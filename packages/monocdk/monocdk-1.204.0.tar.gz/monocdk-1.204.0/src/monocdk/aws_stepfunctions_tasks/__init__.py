'''
# Tasks for AWS Step Functions

[AWS Step Functions](https://docs.aws.amazon.com/step-functions/latest/dg/welcome.html) is a web service that enables you to coordinate the
components of distributed applications and microservices using visual workflows.
You build applications from individual components that each perform a discrete
function, or task, allowing you to scale and change applications quickly.

A [Task](https://docs.aws.amazon.com/step-functions/latest/dg/amazon-states-language-task-state.html) state represents a single unit of work performed by a state machine.
All work in your state machine is performed by tasks.

This module is part of the [AWS Cloud Development Kit](https://github.com/aws/aws-cdk) project.

## Table Of Contents

* [Tasks for AWS Step Functions](#tasks-for-aws-step-functions)

  * [Table Of Contents](#table-of-contents)
  * [Task](#task)
  * [Paths](#paths)

    * [InputPath](#inputpath)
    * [OutputPath](#outputpath)
    * [ResultPath](#resultpath)
  * [Task parameters from the state JSON](#task-parameters-from-the-state-json)
  * [Evaluate Expression](#evaluate-expression)
  * [API Gateway](#api-gateway)

    * [Call REST API Endpoint](#call-rest-api-endpoint)
    * [Call HTTP API Endpoint](#call-http-api-endpoint)
  * [AWS SDK](#aws-sdk)
  * [Athena](#athena)

    * [StartQueryExecution](#startqueryexecution)
    * [GetQueryExecution](#getqueryexecution)
    * [GetQueryResults](#getqueryresults)
    * [StopQueryExecution](#stopqueryexecution)
  * [Batch](#batch)

    * [SubmitJob](#submitjob)
  * [CodeBuild](#codebuild)

    * [StartBuild](#startbuild)
  * [DynamoDB](#dynamodb)

    * [GetItem](#getitem)
    * [PutItem](#putitem)
    * [DeleteItem](#deleteitem)
    * [UpdateItem](#updateitem)
  * [ECS](#ecs)

    * [RunTask](#runtask)

      * [EC2](#ec2)
      * [Fargate](#fargate)
  * [EMR](#emr)

    * [Create Cluster](#create-cluster)
    * [Termination Protection](#termination-protection)
    * [Terminate Cluster](#terminate-cluster)
    * [Add Step](#add-step)
    * [Cancel Step](#cancel-step)
    * [Modify Instance Fleet](#modify-instance-fleet)
    * [Modify Instance Group](#modify-instance-group)
  * [EMR on EKS](#emr-on-eks)

    * [Create Virtual Cluster](#create-virtual-cluster)
    * [Delete Virtual Cluster](#delete-virtual-cluster)
    * [Start Job Run](#start-job-run)
  * [EKS](#eks)

    * [Call](#call)
  * [EventBridge](#eventbridge)

    * [Put Events](#put-events)
  * [Glue](#glue)
  * [Glue DataBrew](#glue-databrew)
  * [Lambda](#lambda)
  * [SageMaker](#sagemaker)

    * [Create Training Job](#create-training-job)
    * [Create Transform Job](#create-transform-job)
    * [Create Endpoint](#create-endpoint)
    * [Create Endpoint Config](#create-endpoint-config)
    * [Create Model](#create-model)
    * [Update Endpoint](#update-endpoint)
  * [SNS](#sns)
  * [Step Functions](#step-functions)

    * [Start Execution](#start-execution)
    * [Invoke Activity](#invoke-activity)
  * [SQS](#sqs)

## Task

A Task state represents a single unit of work performed by a state machine. In the
CDK, the exact work to be done is determined by a class that implements `IStepFunctionsTask`.

AWS Step Functions [integrates](https://docs.aws.amazon.com/step-functions/latest/dg/concepts-service-integrations.html) with some AWS services so that you can call API
actions, and coordinate executions directly from the Amazon States Language in
Step Functions. You can directly call and pass parameters to the APIs of those
services.

## Paths

In the Amazon States Language, a [path](https://docs.aws.amazon.com/step-functions/latest/dg/amazon-states-language-paths.html) is a string beginning with `$` that you
can use to identify components within JSON text.

Learn more about input and output processing in Step Functions [here](https://docs.aws.amazon.com/step-functions/latest/dg/concepts-input-output-filtering.html)

### InputPath

Both `InputPath` and `Parameters` fields provide a way to manipulate JSON as it
moves through your workflow. AWS Step Functions applies the `InputPath` field first,
and then the `Parameters` field. You can first filter your raw input to a selection
you want using InputPath, and then apply Parameters to manipulate that input
further, or add new values. If you don't specify an `InputPath`, a default value
of `$` will be used.

The following example provides the field named `input` as the input to the `Task`
state that runs a Lambda function.

```python
# fn: lambda.Function

submit_job = tasks.LambdaInvoke(self, "Invoke Handler",
    lambda_function=fn,
    input_path="$.input"
)
```

### OutputPath

Tasks also allow you to select a portion of the state output to pass to the next
state. This enables you to filter out unwanted information, and pass only the
portion of the JSON that you care about. If you don't specify an `OutputPath`,
a default value of `$` will be used. This passes the entire JSON node to the next
state.

The [response](https://docs.aws.amazon.com/lambda/latest/dg/API_Invoke.html#API_Invoke_ResponseSyntax) from a Lambda function includes the response from the function
as well as other metadata.

The following example assigns the output from the Task to a field named `result`

```python
# fn: lambda.Function

submit_job = tasks.LambdaInvoke(self, "Invoke Handler",
    lambda_function=fn,
    output_path="$.Payload.result"
)
```

### ResultSelector

You can use [`ResultSelector`](https://docs.aws.amazon.com/step-functions/latest/dg/input-output-inputpath-params.html#input-output-resultselector)
to manipulate the raw result of a Task, Map or Parallel state before it is
passed to [`ResultPath`](###ResultPath). For service integrations, the raw
result contains metadata in addition to the response payload. You can use
ResultSelector to construct a JSON payload that becomes the effective result
using static values or references to the raw result or context object.

The following example extracts the output payload of a Lambda function Task and combines
it with some static values and the state name from the context object.

```python
# fn: lambda.Function

tasks.LambdaInvoke(self, "Invoke Handler",
    lambda_function=fn,
    result_selector={
        "lambda_output": sfn.JsonPath.string_at("$.Payload"),
        "invoke_request_id": sfn.JsonPath.string_at("$.SdkResponseMetadata.RequestId"),
        "static_value": {
            "foo": "bar"
        },
        "state_name": sfn.JsonPath.string_at("$.State.Name")
    }
)
```

### ResultPath

The output of a state can be a copy of its input, the result it produces (for
example, output from a Task state’s Lambda function), or a combination of its
input and result. Use [`ResultPath`](https://docs.aws.amazon.com/step-functions/latest/dg/input-output-resultpath.html) to control which combination of these is
passed to the state output. If you don't specify an `ResultPath`, a default
value of `$` will be used.

The following example adds the item from calling DynamoDB's `getItem` API to the state
input and passes it to the next state.

```python
# my_table: dynamodb.Table

tasks.DynamoPutItem(self, "PutItem",
    item={
        "MessageId": tasks.DynamoAttributeValue.from_string("message-id")
    },
    table=my_table,
    result_path="$.Item"
)
```

⚠️ The `OutputPath` is computed after applying `ResultPath`. All service integrations
return metadata as part of their response. When using `ResultPath`, it's not possible to
merge a subset of the task output to the input.

## Task parameters from the state JSON

Most tasks take parameters. Parameter values can either be static, supplied directly
in the workflow definition (by specifying their values), or a value available at runtime
in the state machine's execution (either as its input or an output of a prior state).
Parameter values available at runtime can be specified via the `JsonPath` class,
using methods such as `JsonPath.stringAt()`.

The following example provides the field named `input` as the input to the Lambda function
and invokes it asynchronously.

```python
# fn: lambda.Function


submit_job = tasks.LambdaInvoke(self, "Invoke Handler",
    lambda_function=fn,
    payload=sfn.TaskInput.from_json_path_at("$.input"),
    invocation_type=tasks.LambdaInvocationType.EVENT
)
```

You can also use [intrinsic functions](https://docs.aws.amazon.com/step-functions/latest/dg/amazon-states-language-intrinsic-functions.html) available on `JsonPath`, for example `JsonPath.format()`.
Here is an example of starting an Athena query that is dynamically created using the task input:

```python
start_query_execution_job = tasks.AthenaStartQueryExecution(self, "Athena Start Query",
    query_string=sfn.JsonPath.format("select contacts where year={};", sfn.JsonPath.string_at("$.year")),
    query_execution_context=dynamodb.aws_stepfunctions_tasks.QueryExecutionContext(
        database_name="interactions"
    ),
    result_configuration=dynamodb.aws_stepfunctions_tasks.ResultConfiguration(
        encryption_configuration=dynamodb.aws_stepfunctions_tasks.EncryptionConfiguration(
            encryption_option=tasks.EncryptionOption.S3_MANAGED
        ),
        output_location=dynamodb.aws_s3.Location(
            bucket_name="mybucket",
            object_key="myprefix"
        )
    ),
    integration_pattern=sfn.IntegrationPattern.RUN_JOB
)
```

Each service integration has its own set of parameters that can be supplied.

## Evaluate Expression

Use the `EvaluateExpression` to perform simple operations referencing state paths. The
`expression` referenced in the task will be evaluated in a Lambda function
(`eval()`). This allows you to not have to write Lambda code for simple operations.

Example: convert a wait time from milliseconds to seconds, concat this in a message and wait:

```python
convert_to_seconds = tasks.EvaluateExpression(self, "Convert to seconds",
    expression="$.waitMilliseconds / 1000",
    result_path="$.waitSeconds"
)

create_message = tasks.EvaluateExpression(self, "Create message",
    # Note: this is a string inside a string.
    expression="`Now waiting ${$.waitSeconds} seconds...`",
    runtime=lambda_.Runtime.NODEJS_14_X,
    result_path="$.message"
)

publish_message = tasks.SnsPublish(self, "Publish message",
    topic=sns.Topic(self, "cool-topic"),
    message=sfn.TaskInput.from_json_path_at("$.message"),
    result_path="$.sns"
)

wait = sfn.Wait(self, "Wait",
    time=sfn.WaitTime.seconds_path("$.waitSeconds")
)

sfn.StateMachine(self, "StateMachine",
    definition=convert_to_seconds.next(create_message).next(publish_message).next(wait)
)
```

The `EvaluateExpression` supports a `runtime` prop to specify the Lambda
runtime to use to evaluate the expression. Currently, only runtimes
of the Node.js family are supported.

## API Gateway

Step Functions supports [API Gateway](https://docs.aws.amazon.com/step-functions/latest/dg/connect-api-gateway.html) through the service integration pattern.

HTTP APIs are designed for low-latency, cost-effective integrations with AWS services, including AWS Lambda, and HTTP endpoints.
HTTP APIs support OIDC and OAuth 2.0 authorization, and come with built-in support for CORS and automatic deployments.
Previous-generation REST APIs currently offer more features. More details can be found [here](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-vs-rest.html).

### Call REST API Endpoint

The `CallApiGatewayRestApiEndpoint` calls the REST API endpoint.

```python
import monocdk as apigateway

rest_api = apigateway.RestApi(self, "MyRestApi")

invoke_task = tasks.CallApiGatewayRestApiEndpoint(self, "Call REST API",
    api=rest_api,
    stage_name="prod",
    method=tasks.HttpMethod.GET
)
```

Be aware that the header values must be arrays. When passing the Task Token
in the headers field `WAIT_FOR_TASK_TOKEN` integration, use
`JsonPath.array()` to wrap the token in an array:

```python
import monocdk as apigateway
# api: apigateway.RestApi


tasks.CallApiGatewayRestApiEndpoint(self, "Endpoint",
    api=api,
    stage_name="Stage",
    method=tasks.HttpMethod.PUT,
    integration_pattern=sfn.IntegrationPattern.WAIT_FOR_TASK_TOKEN,
    headers=sfn.TaskInput.from_object({
        "TaskToken": sfn.JsonPath.array(sfn.JsonPath.task_token)
    })
)
```

### Call HTTP API Endpoint

The `CallApiGatewayHttpApiEndpoint` calls the HTTP API endpoint.

```python
import monocdk as apigatewayv2

http_api = apigatewayv2.HttpApi(self, "MyHttpApi")

invoke_task = tasks.CallApiGatewayHttpApiEndpoint(self, "Call HTTP API",
    api_id=http_api.api_id,
    api_stack=Stack.of(http_api),
    method=tasks.HttpMethod.GET
)
```

### AWS SDK

Step Functions supports calling [AWS service's API actions](https://docs.aws.amazon.com/step-functions/latest/dg/supported-services-awssdk.html)
through the service integration pattern.

You can use Step Functions' AWS SDK integrations to call any of the over two hundred AWS services
directly from your state machine, giving you access to over nine thousand API actions.

```python
# my_bucket: s3.Bucket

get_object = tasks.CallAwsService(self, "GetObject",
    service="s3",
    action="getObject",
    parameters={
        "Bucket": my_bucket.bucket_name,
        "Key": sfn.JsonPath.string_at("$.key")
    },
    iam_resources=[my_bucket.arn_for_objects("*")]
)
```

Use camelCase for actions and PascalCase for parameter names.

The task automatically adds an IAM statement to the state machine role's policy based on the
service and action called. The resources for this statement must be specified in `iamResources`.

Use the `iamAction` prop to manually specify the IAM action name in the case where the IAM
action name does not match with the API service/action name:

```python
list_buckets = tasks.CallAwsService(self, "ListBuckets",
    service="s3",
    action="listBuckets",
    iam_resources=["*"],
    iam_action="s3:ListAllMyBuckets"
)
```

## Athena

Step Functions supports [Athena](https://docs.aws.amazon.com/step-functions/latest/dg/connect-athena.html) through the service integration pattern.

### StartQueryExecution

The [StartQueryExecution](https://docs.aws.amazon.com/athena/latest/APIReference/API_StartQueryExecution.html) API runs the SQL query statement.

```python
start_query_execution_job = tasks.AthenaStartQueryExecution(self, "Start Athena Query",
    query_string=sfn.JsonPath.string_at("$.queryString"),
    query_execution_context=dynamodb.aws_stepfunctions_tasks.QueryExecutionContext(
        database_name="mydatabase"
    ),
    result_configuration=dynamodb.aws_stepfunctions_tasks.ResultConfiguration(
        encryption_configuration=dynamodb.aws_stepfunctions_tasks.EncryptionConfiguration(
            encryption_option=tasks.EncryptionOption.S3_MANAGED
        ),
        output_location=dynamodb.aws_s3.Location(
            bucket_name="query-results-bucket",
            object_key="folder"
        )
    )
)
```

### GetQueryExecution

The [GetQueryExecution](https://docs.aws.amazon.com/athena/latest/APIReference/API_GetQueryExecution.html) API gets information about a single execution of a query.

```python
get_query_execution_job = tasks.AthenaGetQueryExecution(self, "Get Query Execution",
    query_execution_id=sfn.JsonPath.string_at("$.QueryExecutionId")
)
```

### GetQueryResults

The [GetQueryResults](https://docs.aws.amazon.com/athena/latest/APIReference/API_GetQueryResults.html) API that streams the results of a single query execution specified by QueryExecutionId from S3.

```python
get_query_results_job = tasks.AthenaGetQueryResults(self, "Get Query Results",
    query_execution_id=sfn.JsonPath.string_at("$.QueryExecutionId")
)
```

### StopQueryExecution

The [StopQueryExecution](https://docs.aws.amazon.com/athena/latest/APIReference/API_StopQueryExecution.html) API that stops a query execution.

```python
stop_query_execution_job = tasks.AthenaStopQueryExecution(self, "Stop Query Execution",
    query_execution_id=sfn.JsonPath.string_at("$.QueryExecutionId")
)
```

## Batch

Step Functions supports [Batch](https://docs.aws.amazon.com/step-functions/latest/dg/connect-batch.html) through the service integration pattern.

### SubmitJob

The [SubmitJob](https://docs.aws.amazon.com/batch/latest/APIReference/API_SubmitJob.html) API submits an AWS Batch job from a job definition.

```python
import monocdk as batch
# batch_job_definition: batch.JobDefinition
# batch_queue: batch.JobQueue


task = tasks.BatchSubmitJob(self, "Submit Job",
    job_definition_arn=batch_job_definition.job_definition_arn,
    job_name="MyJob",
    job_queue_arn=batch_queue.job_queue_arn
)
```

## CodeBuild

Step Functions supports [CodeBuild](https://docs.aws.amazon.com/step-functions/latest/dg/connect-codebuild.html) through the service integration pattern.

### StartBuild

[StartBuild](https://docs.aws.amazon.com/codebuild/latest/APIReference/API_StartBuild.html) starts a CodeBuild Project by Project Name.

```python
import monocdk as codebuild


codebuild_project = codebuild.Project(self, "Project",
    project_name="MyTestProject",
    build_spec=codebuild.BuildSpec.from_object({
        "version": "0.2",
        "phases": {
            "build": {
                "commands": ["echo \"Hello, CodeBuild!\""
                ]
            }
        }
    })
)

task = tasks.CodeBuildStartBuild(self, "Task",
    project=codebuild_project,
    integration_pattern=sfn.IntegrationPattern.RUN_JOB,
    environment_variables_override={
        "ZONE": codebuild.aws_codebuild.BuildEnvironmentVariable(
            type=codebuild.BuildEnvironmentVariableType.PLAINTEXT,
            value=sfn.JsonPath.string_at("$.envVariables.zone")
        )
    }
)
```

## DynamoDB

You can call DynamoDB APIs from a `Task` state.
Read more about calling DynamoDB APIs [here](https://docs.aws.amazon.com/step-functions/latest/dg/connect-ddb.html)

### GetItem

The [GetItem](https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_GetItem.html) operation returns a set of attributes for the item with the given primary key.

```python
# my_table: dynamodb.Table

tasks.DynamoGetItem(self, "Get Item",
    key={"message_id": tasks.DynamoAttributeValue.from_string("message-007")},
    table=my_table
)
```

### PutItem

The [PutItem](https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_PutItem.html) operation creates a new item, or replaces an old item with a new item.

```python
# my_table: dynamodb.Table

tasks.DynamoPutItem(self, "PutItem",
    item={
        "MessageId": tasks.DynamoAttributeValue.from_string("message-007"),
        "Text": tasks.DynamoAttributeValue.from_string(sfn.JsonPath.string_at("$.bar")),
        "TotalCount": tasks.DynamoAttributeValue.from_number(10)
    },
    table=my_table
)
```

### DeleteItem

The [DeleteItem](https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_DeleteItem.html) operation deletes a single item in a table by primary key.

```python
# my_table: dynamodb.Table

tasks.DynamoDeleteItem(self, "DeleteItem",
    key={"MessageId": tasks.DynamoAttributeValue.from_string("message-007")},
    table=my_table,
    result_path=sfn.JsonPath.DISCARD
)
```

### UpdateItem

The [UpdateItem](https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_UpdateItem.html) operation edits an existing item's attributes, or adds a new item
to the table if it does not already exist.

```python
# my_table: dynamodb.Table

tasks.DynamoUpdateItem(self, "UpdateItem",
    key={
        "MessageId": tasks.DynamoAttributeValue.from_string("message-007")
    },
    table=my_table,
    expression_attribute_values={
        ":val": tasks.DynamoAttributeValue.number_from_string(sfn.JsonPath.string_at("$.Item.TotalCount.N")),
        ":rand": tasks.DynamoAttributeValue.from_number(20)
    },
    update_expression="SET TotalCount = :val + :rand"
)
```

## ECS

Step Functions supports [ECS/Fargate](https://docs.aws.amazon.com/step-functions/latest/dg/connect-ecs.html) through the service integration pattern.

### RunTask

[RunTask](https://docs.aws.amazon.com/step-functions/latest/dg/connect-ecs.html) starts a new task using the specified task definition.

#### EC2

The EC2 launch type allows you to run your containerized applications on a cluster
of Amazon EC2 instances that you manage.

When a task that uses the EC2 launch type is launched, Amazon ECS must determine where
to place the task based on the requirements specified in the task definition, such as
CPU and memory. Similarly, when you scale down the task count, Amazon ECS must determine
which tasks to terminate. You can apply task placement strategies and constraints to
customize how Amazon ECS places and terminates tasks. Learn more about [task placement](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-placement.html)

The latest ACTIVE revision of the passed task definition is used for running the task.

The following example runs a job from a task definition on EC2

```python
vpc = ec2.Vpc.from_lookup(self, "Vpc",
    is_default=True
)

cluster = ecs.Cluster(self, "Ec2Cluster", vpc=vpc)
cluster.add_capacity("DefaultAutoScalingGroup",
    instance_type=ec2.InstanceType("t2.micro"),
    vpc_subnets=dynamodb.aws_ec2.SubnetSelection(subnet_type=ec2.SubnetType.PUBLIC)
)

task_definition = ecs.TaskDefinition(self, "TD",
    compatibility=ecs.Compatibility.EC2
)

task_definition.add_container("TheContainer",
    image=ecs.ContainerImage.from_registry("foo/bar"),
    memory_limit_mi_b=256
)

run_task = tasks.EcsRunTask(self, "Run",
    integration_pattern=sfn.IntegrationPattern.RUN_JOB,
    cluster=cluster,
    task_definition=task_definition,
    launch_target=tasks.EcsEc2LaunchTarget(
        placement_strategies=[
            ecs.PlacementStrategy.spread_across_instances(),
            ecs.PlacementStrategy.packed_by_cpu(),
            ecs.PlacementStrategy.randomly()
        ],
        placement_constraints=[
            ecs.PlacementConstraint.member_of("blieptuut")
        ]
    )
)
```

#### Fargate

AWS Fargate is a serverless compute engine for containers that works with Amazon
Elastic Container Service (ECS). Fargate makes it easy for you to focus on building
your applications. Fargate removes the need to provision and manage servers, lets you
specify and pay for resources per application, and improves security through application
isolation by design. Learn more about [Fargate](https://aws.amazon.com/fargate/)

The Fargate launch type allows you to run your containerized applications without the need
to provision and manage the backend infrastructure. Just register your task definition and
Fargate launches the container for you. The latest ACTIVE revision of the passed
task definition is used for running the task. Learn more about
[Fargate Versioning](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_DescribeTaskDefinition.html)

The following example runs a job from a task definition on Fargate

```python
vpc = ec2.Vpc.from_lookup(self, "Vpc",
    is_default=True
)

cluster = ecs.Cluster(self, "FargateCluster", vpc=vpc)

task_definition = ecs.TaskDefinition(self, "TD",
    memory_mi_b="512",
    cpu="256",
    compatibility=ecs.Compatibility.FARGATE
)

container_definition = task_definition.add_container("TheContainer",
    image=ecs.ContainerImage.from_registry("foo/bar"),
    memory_limit_mi_b=256
)

run_task = tasks.EcsRunTask(self, "RunFargate",
    integration_pattern=sfn.IntegrationPattern.RUN_JOB,
    cluster=cluster,
    task_definition=task_definition,
    assign_public_ip=True,
    container_overrides=[dynamodb.aws_stepfunctions_tasks.ContainerOverride(
        container_definition=container_definition,
        environment=[dynamodb.aws_stepfunctions_tasks.TaskEnvironmentVariable(name="SOME_KEY", value=sfn.JsonPath.string_at("$.SomeKey"))]
    )],
    launch_target=tasks.EcsFargateLaunchTarget()
)
```

## EMR

Step Functions supports Amazon EMR through the service integration pattern.
The service integration APIs correspond to Amazon EMR APIs but differ in the
parameters that are used.

[Read more](https://docs.aws.amazon.com/step-functions/latest/dg/connect-emr.html) about the differences when using these service integrations.

### Create Cluster

Creates and starts running a cluster (job flow).
Corresponds to the [`runJobFlow`](https://docs.aws.amazon.com/emr/latest/APIReference/API_RunJobFlow.html) API in EMR.

```python
cluster_role = iam.Role(self, "ClusterRole",
    assumed_by=iam.ServicePrincipal("ec2.amazonaws.com")
)

service_role = iam.Role(self, "ServiceRole",
    assumed_by=iam.ServicePrincipal("elasticmapreduce.amazonaws.com")
)

auto_scaling_role = iam.Role(self, "AutoScalingRole",
    assumed_by=iam.ServicePrincipal("elasticmapreduce.amazonaws.com")
)

auto_scaling_role.assume_role_policy.add_statements(
    iam.PolicyStatement(
        effect=iam.Effect.ALLOW,
        principals=[
            iam.ServicePrincipal("application-autoscaling.amazonaws.com")
        ],
        actions=["sts:AssumeRole"
        ]
    ))

tasks.EmrCreateCluster(self, "Create Cluster",
    instances=dynamodb.aws_stepfunctions_tasks.EmrCreateCluster.InstancesConfigProperty(),
    cluster_role=cluster_role,
    name=sfn.TaskInput.from_json_path_at("$.ClusterName").value,
    service_role=service_role,
    auto_scaling_role=auto_scaling_role
)
```

If you want to run multiple steps in [parallel](https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-concurrent-steps.html),
you can specify the `stepConcurrencyLevel` property. The concurrency range is between 1
and 256 inclusive, where the default concurrency of 1 means no step concurrency is allowed.
`stepConcurrencyLevel` requires the EMR release label to be 5.28.0 or above.

```python
tasks.EmrCreateCluster(self, "Create Cluster",
    instances=dynamodb.aws_stepfunctions_tasks.EmrCreateCluster.InstancesConfigProperty(),
    name=sfn.TaskInput.from_json_path_at("$.ClusterName").value,
    step_concurrency_level=10
)
```

### Termination Protection

Locks a cluster (job flow) so the EC2 instances in the cluster cannot be
terminated by user intervention, an API call, or a job-flow error.

Corresponds to the [`setTerminationProtection`](https://docs.aws.amazon.com/step-functions/latest/dg/connect-emr.html) API in EMR.

```python
tasks.EmrSetClusterTerminationProtection(self, "Task",
    cluster_id="ClusterId",
    termination_protected=False
)
```

### Terminate Cluster

Shuts down a cluster (job flow).
Corresponds to the [`terminateJobFlows`](https://docs.aws.amazon.com/emr/latest/APIReference/API_TerminateJobFlows.html) API in EMR.

```python
tasks.EmrTerminateCluster(self, "Task",
    cluster_id="ClusterId"
)
```

### Add Step

Adds a new step to a running cluster.
Corresponds to the [`addJobFlowSteps`](https://docs.aws.amazon.com/emr/latest/APIReference/API_AddJobFlowSteps.html) API in EMR.

```python
tasks.EmrAddStep(self, "Task",
    cluster_id="ClusterId",
    name="StepName",
    jar="Jar",
    action_on_failure=tasks.ActionOnFailure.CONTINUE
)
```

### Cancel Step

Cancels a pending step in a running cluster.
Corresponds to the [`cancelSteps`](https://docs.aws.amazon.com/emr/latest/APIReference/API_CancelSteps.html) API in EMR.

```python
tasks.EmrCancelStep(self, "Task",
    cluster_id="ClusterId",
    step_id="StepId"
)
```

### Modify Instance Fleet

Modifies the target On-Demand and target Spot capacities for the instance
fleet with the specified InstanceFleetName.

Corresponds to the [`modifyInstanceFleet`](https://docs.aws.amazon.com/emr/latest/APIReference/API_ModifyInstanceFleet.html) API in EMR.

```python
tasks.EmrModifyInstanceFleetByName(self, "Task",
    cluster_id="ClusterId",
    instance_fleet_name="InstanceFleetName",
    target_on_demand_capacity=2,
    target_spot_capacity=0
)
```

### Modify Instance Group

Modifies the number of nodes and configuration settings of an instance group.

Corresponds to the [`modifyInstanceGroups`](https://docs.aws.amazon.com/emr/latest/APIReference/API_ModifyInstanceGroups.html) API in EMR.

```python
tasks.EmrModifyInstanceGroupByName(self, "Task",
    cluster_id="ClusterId",
    instance_group_name=sfn.JsonPath.string_at("$.InstanceGroupName"),
    instance_group=dynamodb.aws_stepfunctions_tasks.EmrModifyInstanceGroupByName.InstanceGroupModifyConfigProperty(
        instance_count=1
    )
)
```

## EMR on EKS

Step Functions supports Amazon EMR on EKS through the service integration pattern.
The service integration APIs correspond to Amazon EMR on EKS APIs, but differ in the parameters that are used.

[Read more](https://docs.aws.amazon.com/step-functions/latest/dg/connect-emr-eks.html) about the differences when using these service integrations.

[Setting up](https://docs.aws.amazon.com/emr/latest/EMR-on-EKS-DevelopmentGuide/setting-up.html) the EKS cluster is required.

### Create Virtual Cluster

The [CreateVirtualCluster](https://docs.aws.amazon.com/emr-on-eks/latest/APIReference/API_CreateVirtualCluster.html) API creates a single virtual cluster that's mapped to a single Kubernetes namespace.

The EKS cluster containing the Kubernetes namespace where the virtual cluster will be mapped can be passed in from the task input.

```python
tasks.EmrContainersCreateVirtualCluster(self, "Create a Virtual Cluster",
    eks_cluster=tasks.EksClusterInput.from_task_input(sfn.TaskInput.from_text("clusterId"))
)
```

The EKS cluster can also be passed in directly.

```python
import monocdk as eks

# eks_cluster: eks.Cluster


tasks.EmrContainersCreateVirtualCluster(self, "Create a Virtual Cluster",
    eks_cluster=tasks.EksClusterInput.from_cluster(eks_cluster)
)
```

By default, the Kubernetes namespace that a virtual cluster maps to is "default", but a specific namespace within an EKS cluster can be selected.

```python
tasks.EmrContainersCreateVirtualCluster(self, "Create a Virtual Cluster",
    eks_cluster=tasks.EksClusterInput.from_task_input(sfn.TaskInput.from_text("clusterId")),
    eks_namespace="specified-namespace"
)
```

### Delete Virtual Cluster

The [DeleteVirtualCluster](https://docs.aws.amazon.com/emr-on-eks/latest/APIReference/API_DeleteVirtualCluster.html) API deletes a virtual cluster.

```python
tasks.EmrContainersDeleteVirtualCluster(self, "Delete a Virtual Cluster",
    virtual_cluster_id=sfn.TaskInput.from_json_path_at("$.virtualCluster")
)
```

### Start Job Run

The [StartJobRun](https://docs.aws.amazon.com/emr-on-eks/latest/APIReference/API_StartJobRun.html) API starts a job run. A job is a unit of work that you submit to Amazon EMR on EKS for execution. The work performed by the job can be defined by a Spark jar, PySpark script, or SparkSQL query. A job run is an execution of the job on the virtual cluster.

Required setup:

* If not done already, follow the [steps](https://docs.aws.amazon.com/emr/latest/EMR-on-EKS-DevelopmentGuide/setting-up.html) to setup EMR on EKS and [create an EKS Cluster](https://docs.aws.amazon.com/cdk/api/latest/docs/aws-eks-readme.html#quick-start).
* Enable [Cluster access](https://docs.aws.amazon.com/emr/latest/EMR-on-EKS-DevelopmentGuide/setting-up-cluster-access.html)
* Enable [IAM Role access](https://docs.aws.amazon.com/emr/latest/EMR-on-EKS-DevelopmentGuide/setting-up-enable-IAM.html)

The following actions must be performed if the virtual cluster ID is supplied from the task input. Otherwise, if it is supplied statically in the state machine definition, these actions will be done automatically.

* Create an [IAM role](https://docs.aws.amazon.com/cdk/api/latest/docs/@aws-cdk_aws-iam.Role.html)
* Update the [Role Trust Policy](https://docs.aws.amazon.com/emr/latest/EMR-on-EKS-DevelopmentGuide/setting-up-trust-policy.html) of the Job Execution Role.

The job can be configured with spark submit parameters:

```python
tasks.EmrContainersStartJobRun(self, "EMR Containers Start Job Run",
    virtual_cluster=tasks.VirtualClusterInput.from_virtual_cluster_id("de92jdei2910fwedz"),
    release_label=tasks.ReleaseLabel.EMR_6_2_0,
    job_driver=dynamodb.aws_stepfunctions_tasks.JobDriver(
        spark_submit_job_driver=dynamodb.aws_stepfunctions_tasks.SparkSubmitJobDriver(
            entry_point=sfn.TaskInput.from_text("local:///usr/lib/spark/examples/src/main/python/pi.py"),
            spark_submit_parameters="--conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.executor.cores=2 --conf spark.driver.cores=1"
        )
    )
)
```

Configuring the job can also be done via application configuration:

```python
tasks.EmrContainersStartJobRun(self, "EMR Containers Start Job Run",
    virtual_cluster=tasks.VirtualClusterInput.from_virtual_cluster_id("de92jdei2910fwedz"),
    release_label=tasks.ReleaseLabel.EMR_6_2_0,
    job_name="EMR-Containers-Job",
    job_driver=dynamodb.aws_stepfunctions_tasks.JobDriver(
        spark_submit_job_driver=dynamodb.aws_stepfunctions_tasks.SparkSubmitJobDriver(
            entry_point=sfn.TaskInput.from_text("local:///usr/lib/spark/examples/src/main/python/pi.py")
        )
    ),
    application_config=[dynamodb.aws_stepfunctions_tasks.ApplicationConfiguration(
        classification=tasks.Classification.SPARK_DEFAULTS,
        properties={
            "spark.executor.instances": "1",
            "spark.executor.memory": "512M"
        }
    )]
)
```

Job monitoring can be enabled if `monitoring.logging` is set true. This automatically generates an S3 bucket and CloudWatch logs.

```python
tasks.EmrContainersStartJobRun(self, "EMR Containers Start Job Run",
    virtual_cluster=tasks.VirtualClusterInput.from_virtual_cluster_id("de92jdei2910fwedz"),
    release_label=tasks.ReleaseLabel.EMR_6_2_0,
    job_driver=dynamodb.aws_stepfunctions_tasks.JobDriver(
        spark_submit_job_driver=dynamodb.aws_stepfunctions_tasks.SparkSubmitJobDriver(
            entry_point=sfn.TaskInput.from_text("local:///usr/lib/spark/examples/src/main/python/pi.py"),
            spark_submit_parameters="--conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.executor.cores=2 --conf spark.driver.cores=1"
        )
    ),
    monitoring=dynamodb.aws_stepfunctions_tasks.Monitoring(
        logging=True
    )
)
```

Otherwise, providing monitoring for jobs with existing log groups and log buckets is also available.

```python
import monocdk as logs


log_group = logs.LogGroup(self, "Log Group")
log_bucket = s3.Bucket(self, "S3 Bucket")

tasks.EmrContainersStartJobRun(self, "EMR Containers Start Job Run",
    virtual_cluster=tasks.VirtualClusterInput.from_virtual_cluster_id("de92jdei2910fwedz"),
    release_label=tasks.ReleaseLabel.EMR_6_2_0,
    job_driver=logs.aws_stepfunctions_tasks.JobDriver(
        spark_submit_job_driver=logs.aws_stepfunctions_tasks.SparkSubmitJobDriver(
            entry_point=sfn.TaskInput.from_text("local:///usr/lib/spark/examples/src/main/python/pi.py"),
            spark_submit_parameters="--conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.executor.cores=2 --conf spark.driver.cores=1"
        )
    ),
    monitoring=logs.aws_stepfunctions_tasks.Monitoring(
        log_group=log_group,
        log_bucket=log_bucket
    )
)
```

Users can provide their own existing Job Execution Role.

```python
tasks.EmrContainersStartJobRun(self, "EMR Containers Start Job Run",
    virtual_cluster=tasks.VirtualClusterInput.from_task_input(sfn.TaskInput.from_json_path_at("$.VirtualClusterId")),
    release_label=tasks.ReleaseLabel.EMR_6_2_0,
    job_name="EMR-Containers-Job",
    execution_role=iam.Role.from_role_arn(self, "Job-Execution-Role", "arn:aws:iam::xxxxxxxxxxxx:role/JobExecutionRole"),
    job_driver=dynamodb.aws_stepfunctions_tasks.JobDriver(
        spark_submit_job_driver=dynamodb.aws_stepfunctions_tasks.SparkSubmitJobDriver(
            entry_point=sfn.TaskInput.from_text("local:///usr/lib/spark/examples/src/main/python/pi.py"),
            spark_submit_parameters="--conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.executor.cores=2 --conf spark.driver.cores=1"
        )
    )
)
```

## EKS

Step Functions supports Amazon EKS through the service integration pattern.
The service integration APIs correspond to Amazon EKS APIs.

[Read more](https://docs.aws.amazon.com/step-functions/latest/dg/connect-eks.html) about the differences when using these service integrations.

### Call

Read and write Kubernetes resource objects via a Kubernetes API endpoint.
Corresponds to the [`call`](https://docs.aws.amazon.com/step-functions/latest/dg/connect-eks.html) API in Step Functions Connector.

The following code snippet includes a Task state that uses eks:call to list the pods.

```python
import monocdk as eks


my_eks_cluster = eks.Cluster(self, "my sample cluster",
    version=eks.KubernetesVersion.V1_18,
    cluster_name="myEksCluster"
)

tasks.EksCall(self, "Call a EKS Endpoint",
    cluster=my_eks_cluster,
    http_method=tasks.HttpMethods.GET,
    http_path="/api/v1/namespaces/default/pods"
)
```

## EventBridge

Step Functions supports Amazon EventBridge through the service integration pattern.
The service integration APIs correspond to Amazon EventBridge APIs.

[Read more](https://docs.aws.amazon.com/step-functions/latest/dg/connect-eventbridge.html) about the differences when using these service integrations.

### Put Events

Send events to an EventBridge bus.
Corresponds to the [`put-events`](https://docs.aws.amazon.com/step-functions/latest/dg/connect-eventbridge.html) API in Step Functions Connector.

The following code snippet includes a Task state that uses events:putevents to send an event to the default bus.

```python
import monocdk as events


my_event_bus = events.EventBus(self, "EventBus",
    event_bus_name="MyEventBus1"
)

tasks.EventBridgePutEvents(self, "Send an event to EventBridge",
    entries=[events.aws_stepfunctions_tasks.EventBridgePutEventsEntry(
        detail=sfn.TaskInput.from_object({
            "Message": "Hello from Step Functions!"
        }),
        event_bus=my_event_bus,
        detail_type="MessageFromStepFunctions",
        source="step.functions"
    )]
)
```

## Glue

Step Functions supports [AWS Glue](https://docs.aws.amazon.com/step-functions/latest/dg/connect-glue.html) through the service integration pattern.

You can call the [`StartJobRun`](https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-jobs-runs.html#aws-glue-api-jobs-runs-StartJobRun) API from a `Task` state.

```python
tasks.GlueStartJobRun(self, "Task",
    glue_job_name="my-glue-job",
    arguments=sfn.TaskInput.from_object({
        "key": "value"
    }),
    timeout=Duration.minutes(30),
    notify_delay_after=Duration.minutes(5)
)
```

## Glue DataBrew

Step Functions supports [AWS Glue DataBrew](https://docs.aws.amazon.com/step-functions/latest/dg/connect-databrew.html) through the service integration pattern.

You can call the [`StartJobRun`](https://docs.aws.amazon.com/databrew/latest/dg/API_StartJobRun.html) API from a `Task` state.

```python
tasks.GlueDataBrewStartJobRun(self, "Task",
    name="databrew-job"
)
```

## Lambda

[Invoke](https://docs.aws.amazon.com/lambda/latest/dg/API_Invoke.html) a Lambda function.

You can specify the input to your Lambda function through the `payload` attribute.
By default, Step Functions invokes Lambda function with the state input (JSON path '$')
as the input.

The following snippet invokes a Lambda Function with the state input as the payload
by referencing the `$` path.

```python
# fn: lambda.Function

tasks.LambdaInvoke(self, "Invoke with state input",
    lambda_function=fn
)
```

When a function is invoked, the Lambda service sends  [these response
elements](https://docs.aws.amazon.com/lambda/latest/dg/API_Invoke.html#API_Invoke_ResponseElements)
back.

⚠️ The response from the Lambda function is in an attribute called `Payload`

The following snippet invokes a Lambda Function by referencing the `$.Payload` path
to reference the output of a Lambda executed before it.

```python
# fn: lambda.Function

tasks.LambdaInvoke(self, "Invoke with empty object as payload",
    lambda_function=fn,
    payload=sfn.TaskInput.from_object({})
)

# use the output of fn as input
tasks.LambdaInvoke(self, "Invoke with payload field in the state input",
    lambda_function=fn,
    payload=sfn.TaskInput.from_json_path_at("$.Payload")
)
```

The following snippet invokes a Lambda and sets the task output to only include
the Lambda function response.

```python
# fn: lambda.Function

tasks.LambdaInvoke(self, "Invoke and set function response as task output",
    lambda_function=fn,
    output_path="$.Payload"
)
```

If you want to combine the input and the Lambda function response you can use
the `payloadResponseOnly` property and specify the `resultPath`. This will put the
Lambda function ARN directly in the "Resource" string, but it conflicts with the
integrationPattern, invocationType, clientContext, and qualifier properties.

```python
# fn: lambda.Function

tasks.LambdaInvoke(self, "Invoke and combine function response with task input",
    lambda_function=fn,
    payload_response_only=True,
    result_path="$.fn"
)
```

You can have Step Functions pause a task, and wait for an external process to
return a task token. Read more about the [callback pattern](https://docs.aws.amazon.com/step-functions/latest/dg/callback-task-sample-sqs.html#call-back-lambda-example)

To use the callback pattern, set the `token` property on the task. Call the Step
Functions `SendTaskSuccess` or `SendTaskFailure` APIs with the token to
indicate that the task has completed and the state machine should resume execution.

The following snippet invokes a Lambda with the task token as part of the input
to the Lambda.

```python
# fn: lambda.Function

tasks.LambdaInvoke(self, "Invoke with callback",
    lambda_function=fn,
    integration_pattern=sfn.IntegrationPattern.WAIT_FOR_TASK_TOKEN,
    payload=sfn.TaskInput.from_object({
        "token": sfn.JsonPath.task_token,
        "input": sfn.JsonPath.string_at("$.someField")
    })
)
```

⚠️ The task will pause until it receives that task token back with a `SendTaskSuccess` or `SendTaskFailure`
call. Learn more about [Callback with the Task
Token](https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html#connect-wait-token).

AWS Lambda can occasionally experience transient service errors. In this case, invoking Lambda
results in a 500 error, such as `ServiceException`, `AWSLambdaException`, or `SdkClientException`.
As a best practice, the `LambdaInvoke` task will retry on those errors with an interval of 2 seconds,
a back-off rate of 2 and 6 maximum attempts. Set the `retryOnServiceExceptions` prop to `false` to
disable this behavior.

## SageMaker

Step Functions supports [AWS SageMaker](https://docs.aws.amazon.com/step-functions/latest/dg/connect-sagemaker.html) through the service integration pattern.

If your training job or model uses resources from AWS Marketplace,
[network isolation is required](https://docs.aws.amazon.com/sagemaker/latest/dg/mkt-algo-model-internet-free.html).
To do so, set the `enableNetworkIsolation` property to `true` for `SageMakerCreateModel` or `SageMakerCreateTrainingJob`.

To set environment variables for the Docker container use the `environment` property.

### Create Training Job

You can call the [`CreateTrainingJob`](https://docs.aws.amazon.com/sagemaker/latest/dg/API_CreateTrainingJob.html) API from a `Task` state.

```python
tasks.SageMakerCreateTrainingJob(self, "TrainSagemaker",
    training_job_name=sfn.JsonPath.string_at("$.JobName"),
    algorithm_specification=dynamodb.aws_stepfunctions_tasks.AlgorithmSpecification(
        algorithm_name="BlazingText",
        training_input_mode=tasks.InputMode.FILE
    ),
    input_data_config=[dynamodb.aws_stepfunctions_tasks.Channel(
        channel_name="train",
        data_source=dynamodb.aws_stepfunctions_tasks.DataSource(
            s3_data_source=dynamodb.aws_stepfunctions_tasks.S3DataSource(
                s3_data_type=tasks.S3DataType.S3_PREFIX,
                s3_location=tasks.S3Location.from_json_expression("$.S3Bucket")
            )
        )
    )],
    output_data_config=dynamodb.aws_stepfunctions_tasks.OutputDataConfig(
        s3_output_location=tasks.S3Location.from_bucket(s3.Bucket.from_bucket_name(self, "Bucket", "mybucket"), "myoutputpath")
    ),
    resource_config=dynamodb.aws_stepfunctions_tasks.ResourceConfig(
        instance_count=1,
        instance_type=ec2.InstanceType(sfn.JsonPath.string_at("$.InstanceType")),
        volume_size=Size.gibibytes(50)
    ),  # optional: default is 1 instance of EC2 `M4.XLarge` with `10GB` volume
    stopping_condition=dynamodb.aws_stepfunctions_tasks.StoppingCondition(
        max_runtime=Duration.hours(2)
    )
)
```

### Create Transform Job

You can call the [`CreateTransformJob`](https://docs.aws.amazon.com/sagemaker/latest/dg/API_CreateTransformJob.html) API from a `Task` state.

```python
tasks.SageMakerCreateTransformJob(self, "Batch Inference",
    transform_job_name="MyTransformJob",
    model_name="MyModelName",
    model_client_options=dynamodb.aws_stepfunctions_tasks.ModelClientOptions(
        invocations_max_retries=3,  # default is 0
        invocations_timeout=Duration.minutes(5)
    ),
    transform_input=dynamodb.aws_stepfunctions_tasks.TransformInput(
        transform_data_source=dynamodb.aws_stepfunctions_tasks.TransformDataSource(
            s3_data_source=dynamodb.aws_stepfunctions_tasks.TransformS3DataSource(
                s3_uri="s3://inputbucket/train",
                s3_data_type=tasks.S3DataType.S3_PREFIX
            )
        )
    ),
    transform_output=dynamodb.aws_stepfunctions_tasks.TransformOutput(
        s3_output_path="s3://outputbucket/TransformJobOutputPath"
    ),
    transform_resources=dynamodb.aws_stepfunctions_tasks.TransformResources(
        instance_count=1,
        instance_type=ec2.InstanceType.of(ec2.InstanceClass.M4, ec2.InstanceSize.XLARGE)
    )
)
```

### Create Endpoint

You can call the [`CreateEndpoint`](https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_CreateEndpoint.html) API from a `Task` state.

```python
tasks.SageMakerCreateEndpoint(self, "SagemakerEndpoint",
    endpoint_name=sfn.JsonPath.string_at("$.EndpointName"),
    endpoint_config_name=sfn.JsonPath.string_at("$.EndpointConfigName")
)
```

### Create Endpoint Config

You can call the [`CreateEndpointConfig`](https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_CreateEndpointConfig.html) API from a `Task` state.

```python
tasks.SageMakerCreateEndpointConfig(self, "SagemakerEndpointConfig",
    endpoint_config_name="MyEndpointConfig",
    production_variants=[dynamodb.aws_stepfunctions_tasks.ProductionVariant(
        initial_instance_count=2,
        instance_type=ec2.InstanceType.of(ec2.InstanceClass.M5, ec2.InstanceSize.XLARGE),
        model_name="MyModel",
        variant_name="awesome-variant"
    )]
)
```

### Create Model

You can call the [`CreateModel`](https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_CreateModel.html) API from a `Task` state.

```python
tasks.SageMakerCreateModel(self, "Sagemaker",
    model_name="MyModel",
    primary_container=tasks.ContainerDefinition(
        image=tasks.DockerImage.from_json_expression(sfn.JsonPath.string_at("$.Model.imageName")),
        mode=tasks.Mode.SINGLE_MODEL,
        model_s3_location=tasks.S3Location.from_json_expression("$.TrainingJob.ModelArtifacts.S3ModelArtifacts")
    )
)
```

### Update Endpoint

You can call the [`UpdateEndpoint`](https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_UpdateEndpoint.html) API from a `Task` state.

```python
tasks.SageMakerUpdateEndpoint(self, "SagemakerEndpoint",
    endpoint_name=sfn.JsonPath.string_at("$.Endpoint.Name"),
    endpoint_config_name=sfn.JsonPath.string_at("$.Endpoint.EndpointConfig")
)
```

## SNS

Step Functions supports [Amazon SNS](https://docs.aws.amazon.com/step-functions/latest/dg/connect-sns.html) through the service integration pattern.

You can call the [`Publish`](https://docs.aws.amazon.com/sns/latest/api/API_Publish.html) API from a `Task` state to publish to an SNS topic.

```python
topic = sns.Topic(self, "Topic")

# Use a field from the execution data as message.
task1 = tasks.SnsPublish(self, "Publish1",
    topic=topic,
    integration_pattern=sfn.IntegrationPattern.REQUEST_RESPONSE,
    message=sfn.TaskInput.from_data_at("$.state.message"),
    message_attributes={
        "place": dynamodb.aws_stepfunctions_tasks.MessageAttribute(
            value=sfn.JsonPath.string_at("$.place")
        ),
        "pic": dynamodb.aws_stepfunctions_tasks.MessageAttribute(
            # BINARY must be explicitly set
            data_type=tasks.MessageAttributeDataType.BINARY,
            value=sfn.JsonPath.string_at("$.pic")
        ),
        "people": dynamodb.aws_stepfunctions_tasks.MessageAttribute(
            value=4
        ),
        "handles": dynamodb.aws_stepfunctions_tasks.MessageAttribute(
            value=["@kslater", "@jjf", null, "@mfanning"]
        )
    }
)

# Combine a field from the execution data with
# a literal object.
task2 = tasks.SnsPublish(self, "Publish2",
    topic=topic,
    message=sfn.TaskInput.from_object({
        "field1": "somedata",
        "field2": sfn.JsonPath.string_at("$.field2")
    })
)
```

## Step Functions

### Start Execution

You can manage [AWS Step Functions](https://docs.aws.amazon.com/step-functions/latest/dg/connect-stepfunctions.html) executions.

AWS Step Functions supports it's own [`StartExecution`](https://docs.aws.amazon.com/step-functions/latest/apireference/API_StartExecution.html) API as a service integration.

```python
# Define a state machine with one Pass state
child = sfn.StateMachine(self, "ChildStateMachine",
    definition=sfn.Chain.start(sfn.Pass(self, "PassState"))
)

# Include the state machine in a Task state with callback pattern
task = tasks.StepFunctionsStartExecution(self, "ChildTask",
    state_machine=child,
    integration_pattern=sfn.IntegrationPattern.WAIT_FOR_TASK_TOKEN,
    input=sfn.TaskInput.from_object({
        "token": sfn.JsonPath.task_token,
        "foo": "bar"
    }),
    name="MyExecutionName"
)

# Define a second state machine with the Task state above
sfn.StateMachine(self, "ParentStateMachine",
    definition=task
)
```

You can utilize [Associate Workflow Executions](https://docs.aws.amazon.com/step-functions/latest/dg/concepts-nested-workflows.html#nested-execution-startid)
via the `associateWithParent` property. This allows the Step Functions UI to link child
executions from parent executions, making it easier to trace execution flow across state machines.

```python
# child: sfn.StateMachine

task = tasks.StepFunctionsStartExecution(self, "ChildTask",
    state_machine=child,
    associate_with_parent=True
)
```

This will add the payload `AWS_STEP_FUNCTIONS_STARTED_BY_EXECUTION_ID.$: $$.Execution.Id` to the
`input`property for you, which will pass the execution ID from the context object to the
execution input. It requires `input` to be an object or not be set at all.

### Invoke Activity

You can invoke a [Step Functions Activity](https://docs.aws.amazon.com/step-functions/latest/dg/concepts-activities.html) which enables you to have
a task in your state machine where the work is performed by a *worker* that can
be hosted on Amazon EC2, Amazon ECS, AWS Lambda, basically anywhere. Activities
are a way to associate code running somewhere (known as an activity worker) with
a specific task in a state machine.

When Step Functions reaches an activity task state, the workflow waits for an
activity worker to poll for a task. An activity worker polls Step Functions by
using GetActivityTask, and sending the ARN for the related activity.

After the activity worker completes its work, it can provide a report of its
success or failure by using `SendTaskSuccess` or `SendTaskFailure`. These two
calls use the taskToken provided by GetActivityTask to associate the result
with that task.

The following example creates an activity and creates a task that invokes the activity.

```python
submit_job_activity = sfn.Activity(self, "SubmitJob")

tasks.StepFunctionsInvokeActivity(self, "Submit Job",
    activity=submit_job_activity
)
```

## SQS

Step Functions supports [Amazon SQS](https://docs.aws.amazon.com/step-functions/latest/dg/connect-sqs.html)

You can call the [`SendMessage`](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/API_SendMessage.html) API from a `Task` state
to send a message to an SQS queue.

```python
queue = sqs.Queue(self, "Queue")

# Use a field from the execution data as message.
task1 = tasks.SqsSendMessage(self, "Send1",
    queue=queue,
    message_body=sfn.TaskInput.from_json_path_at("$.message")
)

# Combine a field from the execution data with
# a literal object.
task2 = tasks.SqsSendMessage(self, "Send2",
    queue=queue,
    message_body=sfn.TaskInput.from_object({
        "field1": "somedata",
        "field2": sfn.JsonPath.string_at("$.field2")
    })
)
```
'''
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from .._jsii import *

import constructs as _constructs_77d1e7e8
from .. import (
    Duration as _Duration_070aa057,
    IgnoreMode as _IgnoreMode_31d8bf46,
    Size as _Size_7fbd4337,
    Stack as _Stack_9f43e4a3,
    SymlinkFollowMode as _SymlinkFollowMode_abf4527a,
)
from ..assets import FollowMode as _FollowMode_98b05cc5
from ..aws_apigateway import IRestApi as _IRestApi_a27d4788
from ..aws_codebuild import (
    BuildEnvironmentVariable as _BuildEnvironmentVariable_00095c97,
    IProject as _IProject_6da8803e,
)
from ..aws_dynamodb import ITable as _ITable_24826f7e
from ..aws_ec2 import (
    Connections as _Connections_57ccbda9,
    IConnectable as _IConnectable_c1c0e72c,
    ISecurityGroup as _ISecurityGroup_cdbba9d3,
    IVpc as _IVpc_6d1f76c4,
    InstanceSize as _InstanceSize_decfb0b1,
    InstanceType as _InstanceType_072ad323,
    SubnetSelection as _SubnetSelection_1284e62c,
)
from ..aws_ecr import IRepository as _IRepository_8b4d2894
from ..aws_ecr_assets import (
    DockerImageAssetInvalidationOptions as _DockerImageAssetInvalidationOptions_e5375707,
    DockerImageAssetProps as _DockerImageAssetProps_beaa8517,
    NetworkMode as _NetworkMode_2d19607e,
    Platform as _Platform_5ed8dbaf,
)
from ..aws_ecs import (
    ContainerDefinition as _ContainerDefinition_7934d1e1,
    FargatePlatformVersion as _FargatePlatformVersion_8169c79a,
    ICluster as _ICluster_42c4ec1a,
    ITaskDefinition as _ITaskDefinition_ee0d1862,
    PlacementConstraint as _PlacementConstraint_e22ac48c,
    PlacementStrategy as _PlacementStrategy_ea27367e,
    TaskDefinition as _TaskDefinition_c0dacfb4,
)
from ..aws_eks import ICluster as _ICluster_e7e676cf
from ..aws_events import IEventBus as _IEventBus_2ca38c95
from ..aws_iam import (
    IGrantable as _IGrantable_4c5a91d1,
    IPrincipal as _IPrincipal_93b48231,
    IRole as _IRole_59af6f50,
    PolicyStatement as _PolicyStatement_296fe8a3,
)
from ..aws_kms import IKey as _IKey_36930160
from ..aws_lambda import IFunction as _IFunction_6e14f09e, Runtime as _Runtime_932d369a
from ..aws_logs import ILogGroup as _ILogGroup_846e17a0
from ..aws_s3 import IBucket as _IBucket_73486e29, Location as _Location_cce991ca
from ..aws_sns import ITopic as _ITopic_465e36b9
from ..aws_sqs import IQueue as _IQueue_45a01ab4
from ..aws_stepfunctions import (
    IActivity as _IActivity_4524952f,
    IStateMachine as _IStateMachine_269a89c4,
    IStepFunctionsTask as _IStepFunctionsTask_82eb09ab,
    IntegrationPattern as _IntegrationPattern_fbb35786,
    ServiceIntegrationPattern as _ServiceIntegrationPattern_5581ee88,
    StepFunctionsTaskConfig as _StepFunctionsTaskConfig_fa131821,
    Task as _Task_747ca4f2,
    TaskInput as _TaskInput_71ab46f6,
    TaskMetricsConfig as _TaskMetricsConfig_5aaea59e,
    TaskStateBase as _TaskStateBase_c3080646,
    TaskStateBaseProps as _TaskStateBaseProps_b13f6332,
)


class AcceleratorClass(
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.AcceleratorClass",
):
    '''(experimental) The generation of Elastic Inference (EI) instance.

    :see: https://docs.aws.amazon.com/sagemaker/latest/dg/ei.html
    :stability: experimental
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
        
        accelerator_class = stepfunctions_tasks.AcceleratorClass.of("version")
    '''

    @jsii.member(jsii_name="of")
    @builtins.classmethod
    def of(cls, version: builtins.str) -> "AcceleratorClass":
        '''(experimental) Custom AcceleratorType.

        :param version: - Elastic Inference accelerator generation.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__959021e0fa058c9927caef9274414bb711beb5dfed040d9e9101321edf09c83b)
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        return typing.cast("AcceleratorClass", jsii.sinvoke(cls, "of", [version]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="EIA1")
    def EIA1(cls) -> "AcceleratorClass":
        '''(experimental) Elastic Inference accelerator 1st generation.

        :stability: experimental
        '''
        return typing.cast("AcceleratorClass", jsii.sget(cls, "EIA1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="EIA2")
    def EIA2(cls) -> "AcceleratorClass":
        '''(experimental) Elastic Inference accelerator 2nd generation.

        :stability: experimental
        '''
        return typing.cast("AcceleratorClass", jsii.sget(cls, "EIA2"))

    @builtins.property
    @jsii.member(jsii_name="version")
    def version(self) -> builtins.str:
        '''(experimental) - Elastic Inference accelerator generation.

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "version"))


class AcceleratorType(
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.AcceleratorType",
):
    '''(experimental) The size of the Elastic Inference (EI) instance to use for the production variant.

    EI instances provide on-demand GPU computing for inference

    :see: https://docs.aws.amazon.com/sagemaker/latest/dg/ei.html
    :stability: experimental
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
        
        accelerator_type = stepfunctions_tasks.AcceleratorType("instanceTypeIdentifier")
    '''

    def __init__(self, instance_type_identifier: builtins.str) -> None:
        '''
        :param instance_type_identifier: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6a1fbdecafdd35f93690fc078b36cc353e68f467f7b2b0b9fb9ddf045cf984e3)
            check_type(argname="argument instance_type_identifier", value=instance_type_identifier, expected_type=type_hints["instance_type_identifier"])
        jsii.create(self.__class__, self, [instance_type_identifier])

    @jsii.member(jsii_name="of")
    @builtins.classmethod
    def of(
        cls,
        accelerator_class: AcceleratorClass,
        instance_size: _InstanceSize_decfb0b1,
    ) -> "AcceleratorType":
        '''(experimental) AcceleratorType.

        This class takes a combination of a class and size.

        :param accelerator_class: -
        :param instance_size: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__039f775b31e61c74e088a28a14b8b89d2f4aeec6015ec4ab3f34a7e8e2745d80)
            check_type(argname="argument accelerator_class", value=accelerator_class, expected_type=type_hints["accelerator_class"])
            check_type(argname="argument instance_size", value=instance_size, expected_type=type_hints["instance_size"])
        return typing.cast("AcceleratorType", jsii.sinvoke(cls, "of", [accelerator_class, instance_size]))

    @jsii.member(jsii_name="toString")
    def to_string(self) -> builtins.str:
        '''(experimental) Return the accelerator type as a dotted string.

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.invoke(self, "toString", []))


@jsii.enum(jsii_type="monocdk.aws_stepfunctions_tasks.ActionOnFailure")
class ActionOnFailure(enum.Enum):
    '''(experimental) The action to take when the cluster step fails.

    :default: CONTINUE

    :see:

    https://docs.aws.amazon.com/emr/latest/APIReference/API_StepConfig.html

    Here, they are named as TERMINATE_JOB_FLOW, TERMINATE_CLUSTER, CANCEL_AND_WAIT, and CONTINUE respectively.
    :stability: experimental
    :exampleMetadata: infused

    Example::

        tasks.EmrAddStep(self, "Task",
            cluster_id="ClusterId",
            name="StepName",
            jar="Jar",
            action_on_failure=tasks.ActionOnFailure.CONTINUE
        )
    '''

    TERMINATE_CLUSTER = "TERMINATE_CLUSTER"
    '''(experimental) Terminate the Cluster on Step Failure.

    :stability: experimental
    '''
    CANCEL_AND_WAIT = "CANCEL_AND_WAIT"
    '''(experimental) Cancel Step execution and enter WAITING state.

    :stability: experimental
    '''
    CONTINUE = "CONTINUE"
    '''(experimental) Continue to the next Step.

    :stability: experimental
    '''


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.AlgorithmSpecification",
    jsii_struct_bases=[],
    name_mapping={
        "algorithm_name": "algorithmName",
        "metric_definitions": "metricDefinitions",
        "training_image": "trainingImage",
        "training_input_mode": "trainingInputMode",
    },
)
class AlgorithmSpecification:
    def __init__(
        self,
        *,
        algorithm_name: typing.Optional[builtins.str] = None,
        metric_definitions: typing.Optional[typing.Sequence[typing.Union["MetricDefinition", typing.Dict[builtins.str, typing.Any]]]] = None,
        training_image: typing.Optional["DockerImage"] = None,
        training_input_mode: typing.Optional["InputMode"] = None,
    ) -> None:
        '''(experimental) Specify the training algorithm and algorithm-specific metadata.

        :param algorithm_name: (experimental) Name of the algorithm resource to use for the training job. This must be an algorithm resource that you created or subscribe to on AWS Marketplace. If you specify a value for this parameter, you can't specify a value for TrainingImage. Default: - No algorithm is specified
        :param metric_definitions: (experimental) List of metric definition objects. Each object specifies the metric name and regular expressions used to parse algorithm logs. Default: - No metrics
        :param training_image: (experimental) Registry path of the Docker image that contains the training algorithm. Default: - No Docker image is specified
        :param training_input_mode: (experimental) Input mode that the algorithm supports. Default: 'File' mode

        :stability: experimental
        :exampleMetadata: infused

        Example::

            tasks.SageMakerCreateTrainingJob(self, "TrainSagemaker",
                training_job_name=sfn.JsonPath.string_at("$.JobName"),
                algorithm_specification=dynamodb.aws_stepfunctions_tasks.AlgorithmSpecification(
                    algorithm_name="BlazingText",
                    training_input_mode=tasks.InputMode.FILE
                ),
                input_data_config=[dynamodb.aws_stepfunctions_tasks.Channel(
                    channel_name="train",
                    data_source=dynamodb.aws_stepfunctions_tasks.DataSource(
                        s3_data_source=dynamodb.aws_stepfunctions_tasks.S3DataSource(
                            s3_data_type=tasks.S3DataType.S3_PREFIX,
                            s3_location=tasks.S3Location.from_json_expression("$.S3Bucket")
                        )
                    )
                )],
                output_data_config=dynamodb.aws_stepfunctions_tasks.OutputDataConfig(
                    s3_output_location=tasks.S3Location.from_bucket(s3.Bucket.from_bucket_name(self, "Bucket", "mybucket"), "myoutputpath")
                ),
                resource_config=dynamodb.aws_stepfunctions_tasks.ResourceConfig(
                    instance_count=1,
                    instance_type=ec2.InstanceType(sfn.JsonPath.string_at("$.InstanceType")),
                    volume_size=Size.gibibytes(50)
                ),  # optional: default is 1 instance of EC2 `M4.XLarge` with `10GB` volume
                stopping_condition=dynamodb.aws_stepfunctions_tasks.StoppingCondition(
                    max_runtime=Duration.hours(2)
                )
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e3bd3dae22cf03d691dffad872788e09abd3bf303ae0a0cf00614dacf74bcb93)
            check_type(argname="argument algorithm_name", value=algorithm_name, expected_type=type_hints["algorithm_name"])
            check_type(argname="argument metric_definitions", value=metric_definitions, expected_type=type_hints["metric_definitions"])
            check_type(argname="argument training_image", value=training_image, expected_type=type_hints["training_image"])
            check_type(argname="argument training_input_mode", value=training_input_mode, expected_type=type_hints["training_input_mode"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if algorithm_name is not None:
            self._values["algorithm_name"] = algorithm_name
        if metric_definitions is not None:
            self._values["metric_definitions"] = metric_definitions
        if training_image is not None:
            self._values["training_image"] = training_image
        if training_input_mode is not None:
            self._values["training_input_mode"] = training_input_mode

    @builtins.property
    def algorithm_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Name of the algorithm resource to use for the training job.

        This must be an algorithm resource that you created or subscribe to on AWS Marketplace.
        If you specify a value for this parameter, you can't specify a value for TrainingImage.

        :default: - No algorithm is specified

        :stability: experimental
        '''
        result = self._values.get("algorithm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def metric_definitions(self) -> typing.Optional[typing.List["MetricDefinition"]]:
        '''(experimental) List of metric definition objects.

        Each object specifies the metric name and regular expressions used to parse algorithm logs.

        :default: - No metrics

        :stability: experimental
        '''
        result = self._values.get("metric_definitions")
        return typing.cast(typing.Optional[typing.List["MetricDefinition"]], result)

    @builtins.property
    def training_image(self) -> typing.Optional["DockerImage"]:
        '''(experimental) Registry path of the Docker image that contains the training algorithm.

        :default: - No Docker image is specified

        :stability: experimental
        '''
        result = self._values.get("training_image")
        return typing.cast(typing.Optional["DockerImage"], result)

    @builtins.property
    def training_input_mode(self) -> typing.Optional["InputMode"]:
        '''(experimental) Input mode that the algorithm supports.

        :default: 'File' mode

        :stability: experimental
        '''
        result = self._values.get("training_input_mode")
        return typing.cast(typing.Optional["InputMode"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AlgorithmSpecification(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.ApplicationConfiguration",
    jsii_struct_bases=[],
    name_mapping={
        "classification": "classification",
        "nested_config": "nestedConfig",
        "properties": "properties",
    },
)
class ApplicationConfiguration:
    def __init__(
        self,
        *,
        classification: "Classification",
        nested_config: typing.Optional[typing.Sequence[typing.Union["ApplicationConfiguration", typing.Dict[builtins.str, typing.Any]]]] = None,
        properties: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''(experimental) A configuration specification to be used when provisioning virtual clusters, which can include configurations for applications and software bundled with Amazon EMR on EKS.

        A configuration consists of a classification, properties, and optional nested configurations.
        A classification refers to an application-specific configuration file.
        Properties are the settings you want to change in that file.

        :param classification: (experimental) The classification within a configuration. Length Constraints: Minimum length of 1. Maximum length of 1024.
        :param nested_config: (experimental) A list of additional configurations to apply within a configuration object. Array Members: Maximum number of 100 items. Default: - No other configurations
        :param properties: (experimental) A set of properties specified within a configuration classification. Map Entries: Maximum number of 100 items. Default: - No properties

        :see: https://docs.aws.amazon.com/emr/latest/ReleaseGuide/emr-configure-apps.html
        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
            
            # application_configuration_: stepfunctions_tasks.ApplicationConfiguration
            # classification: stepfunctions_tasks.Classification
            
            application_configuration = stepfunctions_tasks.ApplicationConfiguration(
                classification=classification,
            
                # the properties below are optional
                nested_config=[stepfunctions_tasks.ApplicationConfiguration(
                    classification=classification,
            
                    # the properties below are optional
                    nested_config=[application_configuration_],
                    properties={
                        "properties_key": "properties"
                    }
                )],
                properties={
                    "properties_key": "properties"
                }
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2c77854aa4b1d73a50c484db2443d3f56cfd5535e6ac2108db436f3e3aea788c)
            check_type(argname="argument classification", value=classification, expected_type=type_hints["classification"])
            check_type(argname="argument nested_config", value=nested_config, expected_type=type_hints["nested_config"])
            check_type(argname="argument properties", value=properties, expected_type=type_hints["properties"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "classification": classification,
        }
        if nested_config is not None:
            self._values["nested_config"] = nested_config
        if properties is not None:
            self._values["properties"] = properties

    @builtins.property
    def classification(self) -> "Classification":
        '''(experimental) The classification within a configuration.

        Length Constraints: Minimum length of 1. Maximum length of 1024.

        :stability: experimental
        '''
        result = self._values.get("classification")
        assert result is not None, "Required property 'classification' is missing"
        return typing.cast("Classification", result)

    @builtins.property
    def nested_config(self) -> typing.Optional[typing.List["ApplicationConfiguration"]]:
        '''(experimental) A list of additional configurations to apply within a configuration object.

        Array Members: Maximum number of 100 items.

        :default: - No other configurations

        :stability: experimental
        '''
        result = self._values.get("nested_config")
        return typing.cast(typing.Optional[typing.List["ApplicationConfiguration"]], result)

    @builtins.property
    def properties(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''(experimental) A set of properties specified within a configuration classification.

        Map Entries: Maximum number of 100 items.

        :default: - No properties

        :stability: experimental
        '''
        result = self._values.get("properties")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ApplicationConfiguration(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="monocdk.aws_stepfunctions_tasks.AssembleWith")
class AssembleWith(enum.Enum):
    '''(experimental) How to assemble the results of the transform job as a single S3 object.

    :stability: experimental
    '''

    NONE = "NONE"
    '''(experimental) Concatenate the results in binary format.

    :stability: experimental
    '''
    LINE = "LINE"
    '''(experimental) Add a newline character at the end of every transformed record.

    :stability: experimental
    '''


class AthenaGetQueryExecution(
    _TaskStateBase_c3080646,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.AthenaGetQueryExecution",
):
    '''(experimental) Get an Athena Query Execution as a Task.

    :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-athena.html
    :stability: experimental
    :exampleMetadata: infused

    Example::

        get_query_execution_job = tasks.AthenaGetQueryExecution(self, "Get Query Execution",
            query_execution_id=sfn.JsonPath.string_at("$.QueryExecutionId")
        )
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        query_execution_id: builtins.str,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param query_execution_id: (experimental) Query that will be retrieved. Example value: ``adfsaf-23trf23-f23rt23``
        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5524d4a94b8d2be5baa96c623258de8e956391b4b013a16b2907811d75cf3f42)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = AthenaGetQueryExecutionProps(
            query_execution_id=query_execution_id,
            comment=comment,
            heartbeat=heartbeat,
            input_path=input_path,
            integration_pattern=integration_pattern,
            output_path=output_path,
            result_path=result_path,
            result_selector=result_selector,
            timeout=timeout,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="taskMetrics")
    def _task_metrics(self) -> typing.Optional[_TaskMetricsConfig_5aaea59e]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[_TaskMetricsConfig_5aaea59e], jsii.get(self, "taskMetrics"))

    @builtins.property
    @jsii.member(jsii_name="taskPolicies")
    def _task_policies(self) -> typing.Optional[typing.List[_PolicyStatement_296fe8a3]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.List[_PolicyStatement_296fe8a3]], jsii.get(self, "taskPolicies"))


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.AthenaGetQueryExecutionProps",
    jsii_struct_bases=[_TaskStateBaseProps_b13f6332],
    name_mapping={
        "comment": "comment",
        "heartbeat": "heartbeat",
        "input_path": "inputPath",
        "integration_pattern": "integrationPattern",
        "output_path": "outputPath",
        "result_path": "resultPath",
        "result_selector": "resultSelector",
        "timeout": "timeout",
        "query_execution_id": "queryExecutionId",
    },
)
class AthenaGetQueryExecutionProps(_TaskStateBaseProps_b13f6332):
    def __init__(
        self,
        *,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
        query_execution_id: builtins.str,
    ) -> None:
        '''(experimental) Properties for getting a Query Execution.

        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None
        :param query_execution_id: (experimental) Query that will be retrieved. Example value: ``adfsaf-23trf23-f23rt23``

        :stability: experimental
        :exampleMetadata: infused

        Example::

            get_query_execution_job = tasks.AthenaGetQueryExecution(self, "Get Query Execution",
                query_execution_id=sfn.JsonPath.string_at("$.QueryExecutionId")
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__174bf3d04320a38708b32a0e4a83db0ffab60c76536d1bbb77eb97976453c8f0)
            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
            check_type(argname="argument heartbeat", value=heartbeat, expected_type=type_hints["heartbeat"])
            check_type(argname="argument input_path", value=input_path, expected_type=type_hints["input_path"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
            check_type(argname="argument output_path", value=output_path, expected_type=type_hints["output_path"])
            check_type(argname="argument result_path", value=result_path, expected_type=type_hints["result_path"])
            check_type(argname="argument result_selector", value=result_selector, expected_type=type_hints["result_selector"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
            check_type(argname="argument query_execution_id", value=query_execution_id, expected_type=type_hints["query_execution_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "query_execution_id": query_execution_id,
        }
        if comment is not None:
            self._values["comment"] = comment
        if heartbeat is not None:
            self._values["heartbeat"] = heartbeat
        if input_path is not None:
            self._values["input_path"] = input_path
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern
        if output_path is not None:
            self._values["output_path"] = output_path
        if result_path is not None:
            self._values["result_path"] = result_path
        if result_selector is not None:
            self._values["result_selector"] = result_selector
        if timeout is not None:
            self._values["timeout"] = timeout

    @builtins.property
    def comment(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional description for this state.

        :default: - No comment

        :stability: experimental
        '''
        result = self._values.get("comment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def heartbeat(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the heartbeat.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("heartbeat")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def input_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select part of the state to be the input to this state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        input to be the empty object {}.

        :default: - The entire task input (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("input_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def integration_pattern(self) -> typing.Optional[_IntegrationPattern_fbb35786]:
        '''(experimental) AWS Step Functions integrates with services directly in the Amazon States Language.

        You can control these AWS services using service integration patterns

        :default:

        - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks.
        ``IntegrationPattern.RUN_JOB`` for the following exceptions:
        ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html#connect-wait-token
        :stability: experimental
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_IntegrationPattern_fbb35786], result)

    @builtins.property
    def output_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select select a portion of the state output to pass to the next state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        output to be the empty object {}.

        :default:

        - The entire JSON node determined by the state input, the task result,
        and resultPath is passed to the next state (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("output_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to indicate where to inject the state's output.

        May also be the special value JsonPath.DISCARD, which will cause the state's
        input to become its output.

        :default: - Replaces the entire input with the result (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("result_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied.

        You can use ResultSelector to create a payload with values that are static
        or selected from the state's raw result.

        :default: - None

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/input-output-inputpath-params.html#input-output-resultselector
        :stability: experimental
        '''
        result = self._values.get("result_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def timeout(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the state machine.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def query_execution_id(self) -> builtins.str:
        '''(experimental) Query that will be retrieved.

        Example value: ``adfsaf-23trf23-f23rt23``

        :stability: experimental
        '''
        result = self._values.get("query_execution_id")
        assert result is not None, "Required property 'query_execution_id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AthenaGetQueryExecutionProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AthenaGetQueryResults(
    _TaskStateBase_c3080646,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.AthenaGetQueryResults",
):
    '''(experimental) Get an Athena Query Results as a Task.

    :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-athena.html
    :stability: experimental
    :exampleMetadata: infused

    Example::

        get_query_results_job = tasks.AthenaGetQueryResults(self, "Get Query Results",
            query_execution_id=sfn.JsonPath.string_at("$.QueryExecutionId")
        )
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        query_execution_id: builtins.str,
        max_results: typing.Optional[jsii.Number] = None,
        next_token: typing.Optional[builtins.str] = None,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param query_execution_id: (experimental) Query that will be retrieved. Example value: ``adfsaf-23trf23-f23rt23``
        :param max_results: (experimental) Max number of results. Default: 1000
        :param next_token: (experimental) Pagination token. Default: - No next token
        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c0464d6a97ba64391d2c2ee191c965c6c38eebf816d16f74687b3cd090d17f13)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = AthenaGetQueryResultsProps(
            query_execution_id=query_execution_id,
            max_results=max_results,
            next_token=next_token,
            comment=comment,
            heartbeat=heartbeat,
            input_path=input_path,
            integration_pattern=integration_pattern,
            output_path=output_path,
            result_path=result_path,
            result_selector=result_selector,
            timeout=timeout,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="taskMetrics")
    def _task_metrics(self) -> typing.Optional[_TaskMetricsConfig_5aaea59e]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[_TaskMetricsConfig_5aaea59e], jsii.get(self, "taskMetrics"))

    @builtins.property
    @jsii.member(jsii_name="taskPolicies")
    def _task_policies(self) -> typing.Optional[typing.List[_PolicyStatement_296fe8a3]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.List[_PolicyStatement_296fe8a3]], jsii.get(self, "taskPolicies"))


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.AthenaGetQueryResultsProps",
    jsii_struct_bases=[_TaskStateBaseProps_b13f6332],
    name_mapping={
        "comment": "comment",
        "heartbeat": "heartbeat",
        "input_path": "inputPath",
        "integration_pattern": "integrationPattern",
        "output_path": "outputPath",
        "result_path": "resultPath",
        "result_selector": "resultSelector",
        "timeout": "timeout",
        "query_execution_id": "queryExecutionId",
        "max_results": "maxResults",
        "next_token": "nextToken",
    },
)
class AthenaGetQueryResultsProps(_TaskStateBaseProps_b13f6332):
    def __init__(
        self,
        *,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
        query_execution_id: builtins.str,
        max_results: typing.Optional[jsii.Number] = None,
        next_token: typing.Optional[builtins.str] = None,
    ) -> None:
        '''(experimental) Properties for getting a Query Results.

        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None
        :param query_execution_id: (experimental) Query that will be retrieved. Example value: ``adfsaf-23trf23-f23rt23``
        :param max_results: (experimental) Max number of results. Default: 1000
        :param next_token: (experimental) Pagination token. Default: - No next token

        :stability: experimental
        :exampleMetadata: infused

        Example::

            get_query_results_job = tasks.AthenaGetQueryResults(self, "Get Query Results",
                query_execution_id=sfn.JsonPath.string_at("$.QueryExecutionId")
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1145ec793294ac2d2738d9d3cb83de26e7273a081f4a572d7a38ecb00855f65a)
            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
            check_type(argname="argument heartbeat", value=heartbeat, expected_type=type_hints["heartbeat"])
            check_type(argname="argument input_path", value=input_path, expected_type=type_hints["input_path"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
            check_type(argname="argument output_path", value=output_path, expected_type=type_hints["output_path"])
            check_type(argname="argument result_path", value=result_path, expected_type=type_hints["result_path"])
            check_type(argname="argument result_selector", value=result_selector, expected_type=type_hints["result_selector"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
            check_type(argname="argument query_execution_id", value=query_execution_id, expected_type=type_hints["query_execution_id"])
            check_type(argname="argument max_results", value=max_results, expected_type=type_hints["max_results"])
            check_type(argname="argument next_token", value=next_token, expected_type=type_hints["next_token"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "query_execution_id": query_execution_id,
        }
        if comment is not None:
            self._values["comment"] = comment
        if heartbeat is not None:
            self._values["heartbeat"] = heartbeat
        if input_path is not None:
            self._values["input_path"] = input_path
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern
        if output_path is not None:
            self._values["output_path"] = output_path
        if result_path is not None:
            self._values["result_path"] = result_path
        if result_selector is not None:
            self._values["result_selector"] = result_selector
        if timeout is not None:
            self._values["timeout"] = timeout
        if max_results is not None:
            self._values["max_results"] = max_results
        if next_token is not None:
            self._values["next_token"] = next_token

    @builtins.property
    def comment(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional description for this state.

        :default: - No comment

        :stability: experimental
        '''
        result = self._values.get("comment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def heartbeat(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the heartbeat.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("heartbeat")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def input_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select part of the state to be the input to this state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        input to be the empty object {}.

        :default: - The entire task input (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("input_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def integration_pattern(self) -> typing.Optional[_IntegrationPattern_fbb35786]:
        '''(experimental) AWS Step Functions integrates with services directly in the Amazon States Language.

        You can control these AWS services using service integration patterns

        :default:

        - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks.
        ``IntegrationPattern.RUN_JOB`` for the following exceptions:
        ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html#connect-wait-token
        :stability: experimental
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_IntegrationPattern_fbb35786], result)

    @builtins.property
    def output_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select select a portion of the state output to pass to the next state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        output to be the empty object {}.

        :default:

        - The entire JSON node determined by the state input, the task result,
        and resultPath is passed to the next state (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("output_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to indicate where to inject the state's output.

        May also be the special value JsonPath.DISCARD, which will cause the state's
        input to become its output.

        :default: - Replaces the entire input with the result (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("result_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied.

        You can use ResultSelector to create a payload with values that are static
        or selected from the state's raw result.

        :default: - None

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/input-output-inputpath-params.html#input-output-resultselector
        :stability: experimental
        '''
        result = self._values.get("result_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def timeout(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the state machine.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def query_execution_id(self) -> builtins.str:
        '''(experimental) Query that will be retrieved.

        Example value: ``adfsaf-23trf23-f23rt23``

        :stability: experimental
        '''
        result = self._values.get("query_execution_id")
        assert result is not None, "Required property 'query_execution_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def max_results(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Max number of results.

        :default: 1000

        :stability: experimental
        '''
        result = self._values.get("max_results")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def next_token(self) -> typing.Optional[builtins.str]:
        '''(experimental) Pagination token.

        :default: - No next token

        :stability: experimental
        '''
        result = self._values.get("next_token")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AthenaGetQueryResultsProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AthenaStartQueryExecution(
    _TaskStateBase_c3080646,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.AthenaStartQueryExecution",
):
    '''(experimental) Start an Athena Query as a Task.

    :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-athena.html
    :stability: experimental
    :exampleMetadata: infused

    Example::

        start_query_execution_job = tasks.AthenaStartQueryExecution(self, "Athena Start Query",
            query_string=sfn.JsonPath.format("select contacts where year={};", sfn.JsonPath.string_at("$.year")),
            query_execution_context=dynamodb.aws_stepfunctions_tasks.QueryExecutionContext(
                database_name="interactions"
            ),
            result_configuration=dynamodb.aws_stepfunctions_tasks.ResultConfiguration(
                encryption_configuration=dynamodb.aws_stepfunctions_tasks.EncryptionConfiguration(
                    encryption_option=tasks.EncryptionOption.S3_MANAGED
                ),
                output_location=dynamodb.aws_s3.Location(
                    bucket_name="mybucket",
                    object_key="myprefix"
                )
            ),
            integration_pattern=sfn.IntegrationPattern.RUN_JOB
        )
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        query_string: builtins.str,
        client_request_token: typing.Optional[builtins.str] = None,
        query_execution_context: typing.Optional[typing.Union["QueryExecutionContext", typing.Dict[builtins.str, typing.Any]]] = None,
        result_configuration: typing.Optional[typing.Union["ResultConfiguration", typing.Dict[builtins.str, typing.Any]]] = None,
        work_group: typing.Optional[builtins.str] = None,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param query_string: (experimental) Query that will be started.
        :param client_request_token: (experimental) Unique string string to ensure idempotence. Default: - No client request token
        :param query_execution_context: (experimental) Database within which query executes. Default: - No query execution context
        :param result_configuration: (experimental) Configuration on how and where to save query. Default: - No result configuration
        :param work_group: (experimental) Configuration on how and where to save query. Default: - No work group
        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__54bfbda94fa785c270854d8d0d075ceb2272c647614e085bf7a25794c653686d)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = AthenaStartQueryExecutionProps(
            query_string=query_string,
            client_request_token=client_request_token,
            query_execution_context=query_execution_context,
            result_configuration=result_configuration,
            work_group=work_group,
            comment=comment,
            heartbeat=heartbeat,
            input_path=input_path,
            integration_pattern=integration_pattern,
            output_path=output_path,
            result_path=result_path,
            result_selector=result_selector,
            timeout=timeout,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="taskMetrics")
    def _task_metrics(self) -> typing.Optional[_TaskMetricsConfig_5aaea59e]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[_TaskMetricsConfig_5aaea59e], jsii.get(self, "taskMetrics"))

    @builtins.property
    @jsii.member(jsii_name="taskPolicies")
    def _task_policies(self) -> typing.Optional[typing.List[_PolicyStatement_296fe8a3]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.List[_PolicyStatement_296fe8a3]], jsii.get(self, "taskPolicies"))


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.AthenaStartQueryExecutionProps",
    jsii_struct_bases=[_TaskStateBaseProps_b13f6332],
    name_mapping={
        "comment": "comment",
        "heartbeat": "heartbeat",
        "input_path": "inputPath",
        "integration_pattern": "integrationPattern",
        "output_path": "outputPath",
        "result_path": "resultPath",
        "result_selector": "resultSelector",
        "timeout": "timeout",
        "query_string": "queryString",
        "client_request_token": "clientRequestToken",
        "query_execution_context": "queryExecutionContext",
        "result_configuration": "resultConfiguration",
        "work_group": "workGroup",
    },
)
class AthenaStartQueryExecutionProps(_TaskStateBaseProps_b13f6332):
    def __init__(
        self,
        *,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
        query_string: builtins.str,
        client_request_token: typing.Optional[builtins.str] = None,
        query_execution_context: typing.Optional[typing.Union["QueryExecutionContext", typing.Dict[builtins.str, typing.Any]]] = None,
        result_configuration: typing.Optional[typing.Union["ResultConfiguration", typing.Dict[builtins.str, typing.Any]]] = None,
        work_group: typing.Optional[builtins.str] = None,
    ) -> None:
        '''(experimental) Properties for starting a Query Execution.

        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None
        :param query_string: (experimental) Query that will be started.
        :param client_request_token: (experimental) Unique string string to ensure idempotence. Default: - No client request token
        :param query_execution_context: (experimental) Database within which query executes. Default: - No query execution context
        :param result_configuration: (experimental) Configuration on how and where to save query. Default: - No result configuration
        :param work_group: (experimental) Configuration on how and where to save query. Default: - No work group

        :stability: experimental
        :exampleMetadata: infused

        Example::

            start_query_execution_job = tasks.AthenaStartQueryExecution(self, "Athena Start Query",
                query_string=sfn.JsonPath.format("select contacts where year={};", sfn.JsonPath.string_at("$.year")),
                query_execution_context=dynamodb.aws_stepfunctions_tasks.QueryExecutionContext(
                    database_name="interactions"
                ),
                result_configuration=dynamodb.aws_stepfunctions_tasks.ResultConfiguration(
                    encryption_configuration=dynamodb.aws_stepfunctions_tasks.EncryptionConfiguration(
                        encryption_option=tasks.EncryptionOption.S3_MANAGED
                    ),
                    output_location=dynamodb.aws_s3.Location(
                        bucket_name="mybucket",
                        object_key="myprefix"
                    )
                ),
                integration_pattern=sfn.IntegrationPattern.RUN_JOB
            )
        '''
        if isinstance(query_execution_context, dict):
            query_execution_context = QueryExecutionContext(**query_execution_context)
        if isinstance(result_configuration, dict):
            result_configuration = ResultConfiguration(**result_configuration)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8b958e9e9e74b96e2b8caff95ccee2e2c056805db4b0e907dc0ce89fd1dfca8a)
            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
            check_type(argname="argument heartbeat", value=heartbeat, expected_type=type_hints["heartbeat"])
            check_type(argname="argument input_path", value=input_path, expected_type=type_hints["input_path"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
            check_type(argname="argument output_path", value=output_path, expected_type=type_hints["output_path"])
            check_type(argname="argument result_path", value=result_path, expected_type=type_hints["result_path"])
            check_type(argname="argument result_selector", value=result_selector, expected_type=type_hints["result_selector"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
            check_type(argname="argument query_string", value=query_string, expected_type=type_hints["query_string"])
            check_type(argname="argument client_request_token", value=client_request_token, expected_type=type_hints["client_request_token"])
            check_type(argname="argument query_execution_context", value=query_execution_context, expected_type=type_hints["query_execution_context"])
            check_type(argname="argument result_configuration", value=result_configuration, expected_type=type_hints["result_configuration"])
            check_type(argname="argument work_group", value=work_group, expected_type=type_hints["work_group"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "query_string": query_string,
        }
        if comment is not None:
            self._values["comment"] = comment
        if heartbeat is not None:
            self._values["heartbeat"] = heartbeat
        if input_path is not None:
            self._values["input_path"] = input_path
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern
        if output_path is not None:
            self._values["output_path"] = output_path
        if result_path is not None:
            self._values["result_path"] = result_path
        if result_selector is not None:
            self._values["result_selector"] = result_selector
        if timeout is not None:
            self._values["timeout"] = timeout
        if client_request_token is not None:
            self._values["client_request_token"] = client_request_token
        if query_execution_context is not None:
            self._values["query_execution_context"] = query_execution_context
        if result_configuration is not None:
            self._values["result_configuration"] = result_configuration
        if work_group is not None:
            self._values["work_group"] = work_group

    @builtins.property
    def comment(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional description for this state.

        :default: - No comment

        :stability: experimental
        '''
        result = self._values.get("comment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def heartbeat(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the heartbeat.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("heartbeat")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def input_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select part of the state to be the input to this state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        input to be the empty object {}.

        :default: - The entire task input (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("input_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def integration_pattern(self) -> typing.Optional[_IntegrationPattern_fbb35786]:
        '''(experimental) AWS Step Functions integrates with services directly in the Amazon States Language.

        You can control these AWS services using service integration patterns

        :default:

        - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks.
        ``IntegrationPattern.RUN_JOB`` for the following exceptions:
        ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html#connect-wait-token
        :stability: experimental
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_IntegrationPattern_fbb35786], result)

    @builtins.property
    def output_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select select a portion of the state output to pass to the next state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        output to be the empty object {}.

        :default:

        - The entire JSON node determined by the state input, the task result,
        and resultPath is passed to the next state (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("output_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to indicate where to inject the state's output.

        May also be the special value JsonPath.DISCARD, which will cause the state's
        input to become its output.

        :default: - Replaces the entire input with the result (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("result_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied.

        You can use ResultSelector to create a payload with values that are static
        or selected from the state's raw result.

        :default: - None

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/input-output-inputpath-params.html#input-output-resultselector
        :stability: experimental
        '''
        result = self._values.get("result_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def timeout(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the state machine.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def query_string(self) -> builtins.str:
        '''(experimental) Query that will be started.

        :stability: experimental
        '''
        result = self._values.get("query_string")
        assert result is not None, "Required property 'query_string' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def client_request_token(self) -> typing.Optional[builtins.str]:
        '''(experimental) Unique string string to ensure idempotence.

        :default: - No client request token

        :stability: experimental
        '''
        result = self._values.get("client_request_token")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def query_execution_context(self) -> typing.Optional["QueryExecutionContext"]:
        '''(experimental) Database within which query executes.

        :default: - No query execution context

        :stability: experimental
        '''
        result = self._values.get("query_execution_context")
        return typing.cast(typing.Optional["QueryExecutionContext"], result)

    @builtins.property
    def result_configuration(self) -> typing.Optional["ResultConfiguration"]:
        '''(experimental) Configuration on how and where to save query.

        :default: - No result configuration

        :stability: experimental
        '''
        result = self._values.get("result_configuration")
        return typing.cast(typing.Optional["ResultConfiguration"], result)

    @builtins.property
    def work_group(self) -> typing.Optional[builtins.str]:
        '''(experimental) Configuration on how and where to save query.

        :default: - No work group

        :stability: experimental
        '''
        result = self._values.get("work_group")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AthenaStartQueryExecutionProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AthenaStopQueryExecution(
    _TaskStateBase_c3080646,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.AthenaStopQueryExecution",
):
    '''(experimental) Stop an Athena Query Execution as a Task.

    :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-athena.html
    :stability: experimental
    :exampleMetadata: infused

    Example::

        stop_query_execution_job = tasks.AthenaStopQueryExecution(self, "Stop Query Execution",
            query_execution_id=sfn.JsonPath.string_at("$.QueryExecutionId")
        )
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        query_execution_id: builtins.str,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param query_execution_id: (experimental) Query that will be stopped.
        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__27e526f5e76e3c6abd77a248fdb8af805399e01d52c0d563ee848163ca78aded)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = AthenaStopQueryExecutionProps(
            query_execution_id=query_execution_id,
            comment=comment,
            heartbeat=heartbeat,
            input_path=input_path,
            integration_pattern=integration_pattern,
            output_path=output_path,
            result_path=result_path,
            result_selector=result_selector,
            timeout=timeout,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="taskMetrics")
    def _task_metrics(self) -> typing.Optional[_TaskMetricsConfig_5aaea59e]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[_TaskMetricsConfig_5aaea59e], jsii.get(self, "taskMetrics"))

    @builtins.property
    @jsii.member(jsii_name="taskPolicies")
    def _task_policies(self) -> typing.Optional[typing.List[_PolicyStatement_296fe8a3]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.List[_PolicyStatement_296fe8a3]], jsii.get(self, "taskPolicies"))


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.AthenaStopQueryExecutionProps",
    jsii_struct_bases=[_TaskStateBaseProps_b13f6332],
    name_mapping={
        "comment": "comment",
        "heartbeat": "heartbeat",
        "input_path": "inputPath",
        "integration_pattern": "integrationPattern",
        "output_path": "outputPath",
        "result_path": "resultPath",
        "result_selector": "resultSelector",
        "timeout": "timeout",
        "query_execution_id": "queryExecutionId",
    },
)
class AthenaStopQueryExecutionProps(_TaskStateBaseProps_b13f6332):
    def __init__(
        self,
        *,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
        query_execution_id: builtins.str,
    ) -> None:
        '''(experimental) Properties for stoping a Query Execution.

        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None
        :param query_execution_id: (experimental) Query that will be stopped.

        :stability: experimental
        :exampleMetadata: infused

        Example::

            stop_query_execution_job = tasks.AthenaStopQueryExecution(self, "Stop Query Execution",
                query_execution_id=sfn.JsonPath.string_at("$.QueryExecutionId")
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5048d7d7a753b92b87296c2325d425f7547649e375360ec46bbe38641c7f95d2)
            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
            check_type(argname="argument heartbeat", value=heartbeat, expected_type=type_hints["heartbeat"])
            check_type(argname="argument input_path", value=input_path, expected_type=type_hints["input_path"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
            check_type(argname="argument output_path", value=output_path, expected_type=type_hints["output_path"])
            check_type(argname="argument result_path", value=result_path, expected_type=type_hints["result_path"])
            check_type(argname="argument result_selector", value=result_selector, expected_type=type_hints["result_selector"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
            check_type(argname="argument query_execution_id", value=query_execution_id, expected_type=type_hints["query_execution_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "query_execution_id": query_execution_id,
        }
        if comment is not None:
            self._values["comment"] = comment
        if heartbeat is not None:
            self._values["heartbeat"] = heartbeat
        if input_path is not None:
            self._values["input_path"] = input_path
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern
        if output_path is not None:
            self._values["output_path"] = output_path
        if result_path is not None:
            self._values["result_path"] = result_path
        if result_selector is not None:
            self._values["result_selector"] = result_selector
        if timeout is not None:
            self._values["timeout"] = timeout

    @builtins.property
    def comment(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional description for this state.

        :default: - No comment

        :stability: experimental
        '''
        result = self._values.get("comment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def heartbeat(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the heartbeat.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("heartbeat")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def input_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select part of the state to be the input to this state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        input to be the empty object {}.

        :default: - The entire task input (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("input_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def integration_pattern(self) -> typing.Optional[_IntegrationPattern_fbb35786]:
        '''(experimental) AWS Step Functions integrates with services directly in the Amazon States Language.

        You can control these AWS services using service integration patterns

        :default:

        - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks.
        ``IntegrationPattern.RUN_JOB`` for the following exceptions:
        ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html#connect-wait-token
        :stability: experimental
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_IntegrationPattern_fbb35786], result)

    @builtins.property
    def output_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select select a portion of the state output to pass to the next state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        output to be the empty object {}.

        :default:

        - The entire JSON node determined by the state input, the task result,
        and resultPath is passed to the next state (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("output_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to indicate where to inject the state's output.

        May also be the special value JsonPath.DISCARD, which will cause the state's
        input to become its output.

        :default: - Replaces the entire input with the result (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("result_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied.

        You can use ResultSelector to create a payload with values that are static
        or selected from the state's raw result.

        :default: - None

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/input-output-inputpath-params.html#input-output-resultselector
        :stability: experimental
        '''
        result = self._values.get("result_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def timeout(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the state machine.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def query_execution_id(self) -> builtins.str:
        '''(experimental) Query that will be stopped.

        :stability: experimental
        '''
        result = self._values.get("query_execution_id")
        assert result is not None, "Required property 'query_execution_id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AthenaStopQueryExecutionProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="monocdk.aws_stepfunctions_tasks.AuthType")
class AuthType(enum.Enum):
    '''(experimental) The authentication method used to call the endpoint.

    :stability: experimental
    '''

    NO_AUTH = "NO_AUTH"
    '''(experimental) Call the API direclty with no authorization method.

    :stability: experimental
    '''
    IAM_ROLE = "IAM_ROLE"
    '''(experimental) Use the IAM role associated with the current state machine for authorization.

    :stability: experimental
    '''
    RESOURCE_POLICY = "RESOURCE_POLICY"
    '''(experimental) Use the resource policy of the API for authorization.

    :stability: experimental
    '''


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.BatchContainerOverrides",
    jsii_struct_bases=[],
    name_mapping={
        "command": "command",
        "environment": "environment",
        "gpu_count": "gpuCount",
        "instance_type": "instanceType",
        "memory": "memory",
        "vcpus": "vcpus",
    },
)
class BatchContainerOverrides:
    def __init__(
        self,
        *,
        command: typing.Optional[typing.Sequence[builtins.str]] = None,
        environment: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        gpu_count: typing.Optional[jsii.Number] = None,
        instance_type: typing.Optional[_InstanceType_072ad323] = None,
        memory: typing.Optional[_Size_7fbd4337] = None,
        vcpus: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''(experimental) The overrides that should be sent to a container.

        :param command: (experimental) The command to send to the container that overrides the default command from the Docker image or the job definition. Default: - No command overrides
        :param environment: (experimental) The environment variables to send to the container. You can add new environment variables, which are added to the container at launch, or you can override the existing environment variables from the Docker image or the job definition. Default: - No environment overrides
        :param gpu_count: (experimental) The number of physical GPUs to reserve for the container. The number of GPUs reserved for all containers in a job should not exceed the number of available GPUs on the compute resource that the job is launched on. Default: - No GPU reservation
        :param instance_type: (experimental) The instance type to use for a multi-node parallel job. This parameter is not valid for single-node container jobs. Default: - No instance type overrides
        :param memory: (experimental) Memory reserved for the job. Default: - No memory overrides. The memory supplied in the job definition will be used.
        :param vcpus: (experimental) The number of vCPUs to reserve for the container. This value overrides the value set in the job definition. Default: - No vCPUs overrides

        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            import monocdk as monocdk
            from monocdk import aws_ec2 as ec2
            from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
            
            # instance_type: ec2.InstanceType
            # size: monocdk.Size
            
            batch_container_overrides = stepfunctions_tasks.BatchContainerOverrides(
                command=["command"],
                environment={
                    "environment_key": "environment"
                },
                gpu_count=123,
                instance_type=instance_type,
                memory=size,
                vcpus=123
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__01e94d7181aa8e1397c000ceace2adda19dd1b79f94b97696e37d4e8ab796799)
            check_type(argname="argument command", value=command, expected_type=type_hints["command"])
            check_type(argname="argument environment", value=environment, expected_type=type_hints["environment"])
            check_type(argname="argument gpu_count", value=gpu_count, expected_type=type_hints["gpu_count"])
            check_type(argname="argument instance_type", value=instance_type, expected_type=type_hints["instance_type"])
            check_type(argname="argument memory", value=memory, expected_type=type_hints["memory"])
            check_type(argname="argument vcpus", value=vcpus, expected_type=type_hints["vcpus"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if command is not None:
            self._values["command"] = command
        if environment is not None:
            self._values["environment"] = environment
        if gpu_count is not None:
            self._values["gpu_count"] = gpu_count
        if instance_type is not None:
            self._values["instance_type"] = instance_type
        if memory is not None:
            self._values["memory"] = memory
        if vcpus is not None:
            self._values["vcpus"] = vcpus

    @builtins.property
    def command(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) The command to send to the container that overrides the default command from the Docker image or the job definition.

        :default: - No command overrides

        :stability: experimental
        '''
        result = self._values.get("command")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def environment(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''(experimental) The environment variables to send to the container.

        You can add new environment variables, which are added to the container
        at launch, or you can override the existing environment variables from
        the Docker image or the job definition.

        :default: - No environment overrides

        :stability: experimental
        '''
        result = self._values.get("environment")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def gpu_count(self) -> typing.Optional[jsii.Number]:
        '''(experimental) The number of physical GPUs to reserve for the container.

        The number of GPUs reserved for all containers in a job
        should not exceed the number of available GPUs on the compute
        resource that the job is launched on.

        :default: - No GPU reservation

        :stability: experimental
        '''
        result = self._values.get("gpu_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def instance_type(self) -> typing.Optional[_InstanceType_072ad323]:
        '''(experimental) The instance type to use for a multi-node parallel job.

        This parameter is not valid for single-node container jobs.

        :default: - No instance type overrides

        :stability: experimental
        '''
        result = self._values.get("instance_type")
        return typing.cast(typing.Optional[_InstanceType_072ad323], result)

    @builtins.property
    def memory(self) -> typing.Optional[_Size_7fbd4337]:
        '''(experimental) Memory reserved for the job.

        :default: - No memory overrides. The memory supplied in the job definition will be used.

        :stability: experimental
        '''
        result = self._values.get("memory")
        return typing.cast(typing.Optional[_Size_7fbd4337], result)

    @builtins.property
    def vcpus(self) -> typing.Optional[jsii.Number]:
        '''(experimental) The number of vCPUs to reserve for the container.

        This value overrides the value set in the job definition.

        :default: - No vCPUs overrides

        :stability: experimental
        '''
        result = self._values.get("vcpus")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "BatchContainerOverrides(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.BatchJobDependency",
    jsii_struct_bases=[],
    name_mapping={"job_id": "jobId", "type": "type"},
)
class BatchJobDependency:
    def __init__(
        self,
        *,
        job_id: typing.Optional[builtins.str] = None,
        type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''(experimental) An object representing an AWS Batch job dependency.

        :param job_id: (experimental) The job ID of the AWS Batch job associated with this dependency. Default: - No jobId
        :param type: (experimental) The type of the job dependency. Default: - No type

        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
            
            batch_job_dependency = stepfunctions_tasks.BatchJobDependency(
                job_id="jobId",
                type="type"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__32d05e6969be932149d6678f37f0ae479b50855643c7d9f81d032193e1efe367)
            check_type(argname="argument job_id", value=job_id, expected_type=type_hints["job_id"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if job_id is not None:
            self._values["job_id"] = job_id
        if type is not None:
            self._values["type"] = type

    @builtins.property
    def job_id(self) -> typing.Optional[builtins.str]:
        '''(experimental) The job ID of the AWS Batch job associated with this dependency.

        :default: - No jobId

        :stability: experimental
        '''
        result = self._values.get("job_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''(experimental) The type of the job dependency.

        :default: - No type

        :stability: experimental
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "BatchJobDependency(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="monocdk.aws_stepfunctions_tasks.BatchStrategy")
class BatchStrategy(enum.Enum):
    '''(experimental) Specifies the number of records to include in a mini-batch for an HTTP inference request.

    :stability: experimental
    '''

    MULTI_RECORD = "MULTI_RECORD"
    '''(experimental) Fits multiple records in a mini-batch.

    :stability: experimental
    '''
    SINGLE_RECORD = "SINGLE_RECORD"
    '''(experimental) Use a single record when making an invocation request.

    :stability: experimental
    '''


class BatchSubmitJob(
    _TaskStateBase_c3080646,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.BatchSubmitJob",
):
    '''(experimental) Task to submits an AWS Batch job from a job definition.

    :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-batch.html
    :stability: experimental
    :exampleMetadata: infused

    Example::

        import monocdk as batch
        # batch_job_definition: batch.JobDefinition
        # batch_queue: batch.JobQueue
        
        
        task = tasks.BatchSubmitJob(self, "Submit Job",
            job_definition_arn=batch_job_definition.job_definition_arn,
            job_name="MyJob",
            job_queue_arn=batch_queue.job_queue_arn
        )
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        job_definition_arn: builtins.str,
        job_name: builtins.str,
        job_queue_arn: builtins.str,
        array_size: typing.Optional[jsii.Number] = None,
        attempts: typing.Optional[jsii.Number] = None,
        container_overrides: typing.Optional[typing.Union[BatchContainerOverrides, typing.Dict[builtins.str, typing.Any]]] = None,
        depends_on: typing.Optional[typing.Sequence[typing.Union[BatchJobDependency, typing.Dict[builtins.str, typing.Any]]]] = None,
        payload: typing.Optional[_TaskInput_71ab46f6] = None,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param job_definition_arn: (experimental) The arn of the job definition used by this job.
        :param job_name: (experimental) The name of the job. The first character must be alphanumeric, and up to 128 letters (uppercase and lowercase), numbers, hyphens, and underscores are allowed.
        :param job_queue_arn: (experimental) The arn of the job queue into which the job is submitted.
        :param array_size: (experimental) The array size can be between 2 and 10,000. If you specify array properties for a job, it becomes an array job. For more information, see Array Jobs in the AWS Batch User Guide. Default: - No array size
        :param attempts: (experimental) The number of times to move a job to the RUNNABLE status. You may specify between 1 and 10 attempts. If the value of attempts is greater than one, the job is retried on failure the same number of attempts as the value. Default: 1
        :param container_overrides: (experimental) A list of container overrides in JSON format that specify the name of a container in the specified job definition and the overrides it should receive. Default: - No container overrides
        :param depends_on: (experimental) A list of dependencies for the job. A job can depend upon a maximum of 20 jobs. Default: - No dependencies
        :param payload: (experimental) The payload to be passed as parameters to the batch job. Default: - No parameters are passed
        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f34cd63192e3916bd75ab01fa2eddd6c39c257e56436428a659eb9a8272dd07c)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = BatchSubmitJobProps(
            job_definition_arn=job_definition_arn,
            job_name=job_name,
            job_queue_arn=job_queue_arn,
            array_size=array_size,
            attempts=attempts,
            container_overrides=container_overrides,
            depends_on=depends_on,
            payload=payload,
            comment=comment,
            heartbeat=heartbeat,
            input_path=input_path,
            integration_pattern=integration_pattern,
            output_path=output_path,
            result_path=result_path,
            result_selector=result_selector,
            timeout=timeout,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="taskMetrics")
    def _task_metrics(self) -> typing.Optional[_TaskMetricsConfig_5aaea59e]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[_TaskMetricsConfig_5aaea59e], jsii.get(self, "taskMetrics"))

    @builtins.property
    @jsii.member(jsii_name="taskPolicies")
    def _task_policies(self) -> typing.Optional[typing.List[_PolicyStatement_296fe8a3]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.List[_PolicyStatement_296fe8a3]], jsii.get(self, "taskPolicies"))


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.BatchSubmitJobProps",
    jsii_struct_bases=[_TaskStateBaseProps_b13f6332],
    name_mapping={
        "comment": "comment",
        "heartbeat": "heartbeat",
        "input_path": "inputPath",
        "integration_pattern": "integrationPattern",
        "output_path": "outputPath",
        "result_path": "resultPath",
        "result_selector": "resultSelector",
        "timeout": "timeout",
        "job_definition_arn": "jobDefinitionArn",
        "job_name": "jobName",
        "job_queue_arn": "jobQueueArn",
        "array_size": "arraySize",
        "attempts": "attempts",
        "container_overrides": "containerOverrides",
        "depends_on": "dependsOn",
        "payload": "payload",
    },
)
class BatchSubmitJobProps(_TaskStateBaseProps_b13f6332):
    def __init__(
        self,
        *,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
        job_definition_arn: builtins.str,
        job_name: builtins.str,
        job_queue_arn: builtins.str,
        array_size: typing.Optional[jsii.Number] = None,
        attempts: typing.Optional[jsii.Number] = None,
        container_overrides: typing.Optional[typing.Union[BatchContainerOverrides, typing.Dict[builtins.str, typing.Any]]] = None,
        depends_on: typing.Optional[typing.Sequence[typing.Union[BatchJobDependency, typing.Dict[builtins.str, typing.Any]]]] = None,
        payload: typing.Optional[_TaskInput_71ab46f6] = None,
    ) -> None:
        '''(experimental) Properties for RunBatchJob.

        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None
        :param job_definition_arn: (experimental) The arn of the job definition used by this job.
        :param job_name: (experimental) The name of the job. The first character must be alphanumeric, and up to 128 letters (uppercase and lowercase), numbers, hyphens, and underscores are allowed.
        :param job_queue_arn: (experimental) The arn of the job queue into which the job is submitted.
        :param array_size: (experimental) The array size can be between 2 and 10,000. If you specify array properties for a job, it becomes an array job. For more information, see Array Jobs in the AWS Batch User Guide. Default: - No array size
        :param attempts: (experimental) The number of times to move a job to the RUNNABLE status. You may specify between 1 and 10 attempts. If the value of attempts is greater than one, the job is retried on failure the same number of attempts as the value. Default: 1
        :param container_overrides: (experimental) A list of container overrides in JSON format that specify the name of a container in the specified job definition and the overrides it should receive. Default: - No container overrides
        :param depends_on: (experimental) A list of dependencies for the job. A job can depend upon a maximum of 20 jobs. Default: - No dependencies
        :param payload: (experimental) The payload to be passed as parameters to the batch job. Default: - No parameters are passed

        :stability: experimental
        :exampleMetadata: infused

        Example::

            import monocdk as batch
            # batch_job_definition: batch.JobDefinition
            # batch_queue: batch.JobQueue
            
            
            task = tasks.BatchSubmitJob(self, "Submit Job",
                job_definition_arn=batch_job_definition.job_definition_arn,
                job_name="MyJob",
                job_queue_arn=batch_queue.job_queue_arn
            )
        '''
        if isinstance(container_overrides, dict):
            container_overrides = BatchContainerOverrides(**container_overrides)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ca493b1b57c5a51f3b2afe28129defcde9ae649c09611805a05b493ba63b79cc)
            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
            check_type(argname="argument heartbeat", value=heartbeat, expected_type=type_hints["heartbeat"])
            check_type(argname="argument input_path", value=input_path, expected_type=type_hints["input_path"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
            check_type(argname="argument output_path", value=output_path, expected_type=type_hints["output_path"])
            check_type(argname="argument result_path", value=result_path, expected_type=type_hints["result_path"])
            check_type(argname="argument result_selector", value=result_selector, expected_type=type_hints["result_selector"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
            check_type(argname="argument job_definition_arn", value=job_definition_arn, expected_type=type_hints["job_definition_arn"])
            check_type(argname="argument job_name", value=job_name, expected_type=type_hints["job_name"])
            check_type(argname="argument job_queue_arn", value=job_queue_arn, expected_type=type_hints["job_queue_arn"])
            check_type(argname="argument array_size", value=array_size, expected_type=type_hints["array_size"])
            check_type(argname="argument attempts", value=attempts, expected_type=type_hints["attempts"])
            check_type(argname="argument container_overrides", value=container_overrides, expected_type=type_hints["container_overrides"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument payload", value=payload, expected_type=type_hints["payload"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "job_definition_arn": job_definition_arn,
            "job_name": job_name,
            "job_queue_arn": job_queue_arn,
        }
        if comment is not None:
            self._values["comment"] = comment
        if heartbeat is not None:
            self._values["heartbeat"] = heartbeat
        if input_path is not None:
            self._values["input_path"] = input_path
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern
        if output_path is not None:
            self._values["output_path"] = output_path
        if result_path is not None:
            self._values["result_path"] = result_path
        if result_selector is not None:
            self._values["result_selector"] = result_selector
        if timeout is not None:
            self._values["timeout"] = timeout
        if array_size is not None:
            self._values["array_size"] = array_size
        if attempts is not None:
            self._values["attempts"] = attempts
        if container_overrides is not None:
            self._values["container_overrides"] = container_overrides
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if payload is not None:
            self._values["payload"] = payload

    @builtins.property
    def comment(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional description for this state.

        :default: - No comment

        :stability: experimental
        '''
        result = self._values.get("comment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def heartbeat(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the heartbeat.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("heartbeat")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def input_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select part of the state to be the input to this state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        input to be the empty object {}.

        :default: - The entire task input (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("input_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def integration_pattern(self) -> typing.Optional[_IntegrationPattern_fbb35786]:
        '''(experimental) AWS Step Functions integrates with services directly in the Amazon States Language.

        You can control these AWS services using service integration patterns

        :default:

        - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks.
        ``IntegrationPattern.RUN_JOB`` for the following exceptions:
        ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html#connect-wait-token
        :stability: experimental
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_IntegrationPattern_fbb35786], result)

    @builtins.property
    def output_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select select a portion of the state output to pass to the next state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        output to be the empty object {}.

        :default:

        - The entire JSON node determined by the state input, the task result,
        and resultPath is passed to the next state (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("output_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to indicate where to inject the state's output.

        May also be the special value JsonPath.DISCARD, which will cause the state's
        input to become its output.

        :default: - Replaces the entire input with the result (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("result_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied.

        You can use ResultSelector to create a payload with values that are static
        or selected from the state's raw result.

        :default: - None

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/input-output-inputpath-params.html#input-output-resultselector
        :stability: experimental
        '''
        result = self._values.get("result_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def timeout(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the state machine.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def job_definition_arn(self) -> builtins.str:
        '''(experimental) The arn of the job definition used by this job.

        :stability: experimental
        '''
        result = self._values.get("job_definition_arn")
        assert result is not None, "Required property 'job_definition_arn' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def job_name(self) -> builtins.str:
        '''(experimental) The name of the job.

        The first character must be alphanumeric, and up to 128 letters (uppercase and lowercase),
        numbers, hyphens, and underscores are allowed.

        :stability: experimental
        '''
        result = self._values.get("job_name")
        assert result is not None, "Required property 'job_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def job_queue_arn(self) -> builtins.str:
        '''(experimental) The arn of the job queue into which the job is submitted.

        :stability: experimental
        '''
        result = self._values.get("job_queue_arn")
        assert result is not None, "Required property 'job_queue_arn' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def array_size(self) -> typing.Optional[jsii.Number]:
        '''(experimental) The array size can be between 2 and 10,000.

        If you specify array properties for a job, it becomes an array job.
        For more information, see Array Jobs in the AWS Batch User Guide.

        :default: - No array size

        :stability: experimental
        '''
        result = self._values.get("array_size")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def attempts(self) -> typing.Optional[jsii.Number]:
        '''(experimental) The number of times to move a job to the RUNNABLE status.

        You may specify between 1 and 10 attempts.
        If the value of attempts is greater than one,
        the job is retried on failure the same number of attempts as the value.

        :default: 1

        :stability: experimental
        '''
        result = self._values.get("attempts")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def container_overrides(self) -> typing.Optional[BatchContainerOverrides]:
        '''(experimental) A list of container overrides in JSON format that specify the name of a container in the specified job definition and the overrides it should receive.

        :default: - No container overrides

        :see: https://docs.aws.amazon.com/batch/latest/APIReference/API_SubmitJob.html#Batch-SubmitJob-request-containerOverrides
        :stability: experimental
        '''
        result = self._values.get("container_overrides")
        return typing.cast(typing.Optional[BatchContainerOverrides], result)

    @builtins.property
    def depends_on(self) -> typing.Optional[typing.List[BatchJobDependency]]:
        '''(experimental) A list of dependencies for the job.

        A job can depend upon a maximum of 20 jobs.

        :default: - No dependencies

        :see: https://docs.aws.amazon.com/batch/latest/APIReference/API_SubmitJob.html#Batch-SubmitJob-request-dependsOn
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[BatchJobDependency]], result)

    @builtins.property
    def payload(self) -> typing.Optional[_TaskInput_71ab46f6]:
        '''(experimental) The payload to be passed as parameters to the batch job.

        :default: - No parameters are passed

        :stability: experimental
        '''
        result = self._values.get("payload")
        return typing.cast(typing.Optional[_TaskInput_71ab46f6], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "BatchSubmitJobProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.CallApiGatewayEndpointBaseProps",
    jsii_struct_bases=[_TaskStateBaseProps_b13f6332],
    name_mapping={
        "comment": "comment",
        "heartbeat": "heartbeat",
        "input_path": "inputPath",
        "integration_pattern": "integrationPattern",
        "output_path": "outputPath",
        "result_path": "resultPath",
        "result_selector": "resultSelector",
        "timeout": "timeout",
        "method": "method",
        "api_path": "apiPath",
        "auth_type": "authType",
        "headers": "headers",
        "query_parameters": "queryParameters",
        "request_body": "requestBody",
    },
)
class CallApiGatewayEndpointBaseProps(_TaskStateBaseProps_b13f6332):
    def __init__(
        self,
        *,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
        method: "HttpMethod",
        api_path: typing.Optional[builtins.str] = None,
        auth_type: typing.Optional[AuthType] = None,
        headers: typing.Optional[_TaskInput_71ab46f6] = None,
        query_parameters: typing.Optional[_TaskInput_71ab46f6] = None,
        request_body: typing.Optional[_TaskInput_71ab46f6] = None,
    ) -> None:
        '''(experimental) Base CallApiGatewayEdnpoint Task Props.

        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None
        :param method: (experimental) Http method for the API.
        :param api_path: (experimental) Path parameters appended after API endpoint. Default: - No path
        :param auth_type: (experimental) Authentication methods. Default: AuthType.NO_AUTH
        :param headers: (experimental) HTTP request information that does not relate to contents of the request. Default: - No headers
        :param query_parameters: (experimental) Query strings attatched to end of request. Default: - No query parameters
        :param request_body: (experimental) HTTP Request body. Default: - No request body

        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            import monocdk as monocdk
            from monocdk import aws_stepfunctions as stepfunctions
            from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
            
            # duration: monocdk.Duration
            # result_selector: Any
            # task_input: stepfunctions.TaskInput
            
            call_api_gateway_endpoint_base_props = stepfunctions_tasks.CallApiGatewayEndpointBaseProps(
                method=stepfunctions_tasks.HttpMethod.GET,
            
                # the properties below are optional
                api_path="apiPath",
                auth_type=stepfunctions_tasks.AuthType.NO_AUTH,
                comment="comment",
                headers=task_input,
                heartbeat=duration,
                input_path="inputPath",
                integration_pattern=stepfunctions.IntegrationPattern.REQUEST_RESPONSE,
                output_path="outputPath",
                query_parameters=task_input,
                request_body=task_input,
                result_path="resultPath",
                result_selector={
                    "result_selector_key": result_selector
                },
                timeout=duration
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2d6c62a9bdb9d3f037b0d365fe73a3e5112fe3a3009f2600abe385d6b794e70a)
            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
            check_type(argname="argument heartbeat", value=heartbeat, expected_type=type_hints["heartbeat"])
            check_type(argname="argument input_path", value=input_path, expected_type=type_hints["input_path"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
            check_type(argname="argument output_path", value=output_path, expected_type=type_hints["output_path"])
            check_type(argname="argument result_path", value=result_path, expected_type=type_hints["result_path"])
            check_type(argname="argument result_selector", value=result_selector, expected_type=type_hints["result_selector"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
            check_type(argname="argument method", value=method, expected_type=type_hints["method"])
            check_type(argname="argument api_path", value=api_path, expected_type=type_hints["api_path"])
            check_type(argname="argument auth_type", value=auth_type, expected_type=type_hints["auth_type"])
            check_type(argname="argument headers", value=headers, expected_type=type_hints["headers"])
            check_type(argname="argument query_parameters", value=query_parameters, expected_type=type_hints["query_parameters"])
            check_type(argname="argument request_body", value=request_body, expected_type=type_hints["request_body"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "method": method,
        }
        if comment is not None:
            self._values["comment"] = comment
        if heartbeat is not None:
            self._values["heartbeat"] = heartbeat
        if input_path is not None:
            self._values["input_path"] = input_path
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern
        if output_path is not None:
            self._values["output_path"] = output_path
        if result_path is not None:
            self._values["result_path"] = result_path
        if result_selector is not None:
            self._values["result_selector"] = result_selector
        if timeout is not None:
            self._values["timeout"] = timeout
        if api_path is not None:
            self._values["api_path"] = api_path
        if auth_type is not None:
            self._values["auth_type"] = auth_type
        if headers is not None:
            self._values["headers"] = headers
        if query_parameters is not None:
            self._values["query_parameters"] = query_parameters
        if request_body is not None:
            self._values["request_body"] = request_body

    @builtins.property
    def comment(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional description for this state.

        :default: - No comment

        :stability: experimental
        '''
        result = self._values.get("comment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def heartbeat(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the heartbeat.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("heartbeat")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def input_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select part of the state to be the input to this state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        input to be the empty object {}.

        :default: - The entire task input (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("input_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def integration_pattern(self) -> typing.Optional[_IntegrationPattern_fbb35786]:
        '''(experimental) AWS Step Functions integrates with services directly in the Amazon States Language.

        You can control these AWS services using service integration patterns

        :default:

        - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks.
        ``IntegrationPattern.RUN_JOB`` for the following exceptions:
        ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html#connect-wait-token
        :stability: experimental
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_IntegrationPattern_fbb35786], result)

    @builtins.property
    def output_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select select a portion of the state output to pass to the next state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        output to be the empty object {}.

        :default:

        - The entire JSON node determined by the state input, the task result,
        and resultPath is passed to the next state (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("output_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to indicate where to inject the state's output.

        May also be the special value JsonPath.DISCARD, which will cause the state's
        input to become its output.

        :default: - Replaces the entire input with the result (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("result_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied.

        You can use ResultSelector to create a payload with values that are static
        or selected from the state's raw result.

        :default: - None

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/input-output-inputpath-params.html#input-output-resultselector
        :stability: experimental
        '''
        result = self._values.get("result_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def timeout(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the state machine.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def method(self) -> "HttpMethod":
        '''(experimental) Http method for the API.

        :stability: experimental
        '''
        result = self._values.get("method")
        assert result is not None, "Required property 'method' is missing"
        return typing.cast("HttpMethod", result)

    @builtins.property
    def api_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) Path parameters appended after API endpoint.

        :default: - No path

        :stability: experimental
        '''
        result = self._values.get("api_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def auth_type(self) -> typing.Optional[AuthType]:
        '''(experimental) Authentication methods.

        :default: AuthType.NO_AUTH

        :stability: experimental
        '''
        result = self._values.get("auth_type")
        return typing.cast(typing.Optional[AuthType], result)

    @builtins.property
    def headers(self) -> typing.Optional[_TaskInput_71ab46f6]:
        '''(experimental) HTTP request information that does not relate to contents of the request.

        :default: - No headers

        :stability: experimental
        '''
        result = self._values.get("headers")
        return typing.cast(typing.Optional[_TaskInput_71ab46f6], result)

    @builtins.property
    def query_parameters(self) -> typing.Optional[_TaskInput_71ab46f6]:
        '''(experimental) Query strings attatched to end of request.

        :default: - No query parameters

        :stability: experimental
        '''
        result = self._values.get("query_parameters")
        return typing.cast(typing.Optional[_TaskInput_71ab46f6], result)

    @builtins.property
    def request_body(self) -> typing.Optional[_TaskInput_71ab46f6]:
        '''(experimental) HTTP Request body.

        :default: - No request body

        :stability: experimental
        '''
        result = self._values.get("request_body")
        return typing.cast(typing.Optional[_TaskInput_71ab46f6], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CallApiGatewayEndpointBaseProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class CallApiGatewayHttpApiEndpoint(
    _TaskStateBase_c3080646,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.CallApiGatewayHttpApiEndpoint",
):
    '''(experimental) Call HTTP API endpoint as a Task.

    :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-api-gateway.html
    :stability: experimental
    :exampleMetadata: infused

    Example::

        import monocdk as apigatewayv2
        
        http_api = apigatewayv2.HttpApi(self, "MyHttpApi")
        
        invoke_task = tasks.CallApiGatewayHttpApiEndpoint(self, "Call HTTP API",
            api_id=http_api.api_id,
            api_stack=Stack.of(http_api),
            method=tasks.HttpMethod.GET
        )
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        api_id: builtins.str,
        api_stack: _Stack_9f43e4a3,
        stage_name: typing.Optional[builtins.str] = None,
        method: "HttpMethod",
        api_path: typing.Optional[builtins.str] = None,
        auth_type: typing.Optional[AuthType] = None,
        headers: typing.Optional[_TaskInput_71ab46f6] = None,
        query_parameters: typing.Optional[_TaskInput_71ab46f6] = None,
        request_body: typing.Optional[_TaskInput_71ab46f6] = None,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param api_id: (experimental) The Id of the API to call.
        :param api_stack: (experimental) The Stack in which the API is defined.
        :param stage_name: (experimental) Name of the stage where the API is deployed to in API Gateway. Default: '$default'
        :param method: (experimental) Http method for the API.
        :param api_path: (experimental) Path parameters appended after API endpoint. Default: - No path
        :param auth_type: (experimental) Authentication methods. Default: AuthType.NO_AUTH
        :param headers: (experimental) HTTP request information that does not relate to contents of the request. Default: - No headers
        :param query_parameters: (experimental) Query strings attatched to end of request. Default: - No query parameters
        :param request_body: (experimental) HTTP Request body. Default: - No request body
        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b55b003c7982b9b58c9a2b9deca99e8cb3360d30d6b247b7712322bb66b78f10)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = CallApiGatewayHttpApiEndpointProps(
            api_id=api_id,
            api_stack=api_stack,
            stage_name=stage_name,
            method=method,
            api_path=api_path,
            auth_type=auth_type,
            headers=headers,
            query_parameters=query_parameters,
            request_body=request_body,
            comment=comment,
            heartbeat=heartbeat,
            input_path=input_path,
            integration_pattern=integration_pattern,
            output_path=output_path,
            result_path=result_path,
            result_selector=result_selector,
            timeout=timeout,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="createPolicyStatements")
    def _create_policy_statements(self) -> typing.List[_PolicyStatement_296fe8a3]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[_PolicyStatement_296fe8a3], jsii.invoke(self, "createPolicyStatements", []))

    @builtins.property
    @jsii.member(jsii_name="apiEndpoint")
    def _api_endpoint(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "apiEndpoint"))

    @builtins.property
    @jsii.member(jsii_name="arnForExecuteApi")
    def _arn_for_execute_api(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "arnForExecuteApi"))

    @builtins.property
    @jsii.member(jsii_name="stageName")
    def _stage_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "stageName"))

    @builtins.property
    @jsii.member(jsii_name="taskMetrics")
    def _task_metrics(self) -> typing.Optional[_TaskMetricsConfig_5aaea59e]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[_TaskMetricsConfig_5aaea59e], jsii.get(self, "taskMetrics"))

    @builtins.property
    @jsii.member(jsii_name="taskPolicies")
    def _task_policies(self) -> typing.Optional[typing.List[_PolicyStatement_296fe8a3]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.List[_PolicyStatement_296fe8a3]], jsii.get(self, "taskPolicies"))


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.CallApiGatewayHttpApiEndpointProps",
    jsii_struct_bases=[CallApiGatewayEndpointBaseProps],
    name_mapping={
        "comment": "comment",
        "heartbeat": "heartbeat",
        "input_path": "inputPath",
        "integration_pattern": "integrationPattern",
        "output_path": "outputPath",
        "result_path": "resultPath",
        "result_selector": "resultSelector",
        "timeout": "timeout",
        "method": "method",
        "api_path": "apiPath",
        "auth_type": "authType",
        "headers": "headers",
        "query_parameters": "queryParameters",
        "request_body": "requestBody",
        "api_id": "apiId",
        "api_stack": "apiStack",
        "stage_name": "stageName",
    },
)
class CallApiGatewayHttpApiEndpointProps(CallApiGatewayEndpointBaseProps):
    def __init__(
        self,
        *,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
        method: "HttpMethod",
        api_path: typing.Optional[builtins.str] = None,
        auth_type: typing.Optional[AuthType] = None,
        headers: typing.Optional[_TaskInput_71ab46f6] = None,
        query_parameters: typing.Optional[_TaskInput_71ab46f6] = None,
        request_body: typing.Optional[_TaskInput_71ab46f6] = None,
        api_id: builtins.str,
        api_stack: _Stack_9f43e4a3,
        stage_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''(experimental) Properties for calling an HTTP API Endpoint.

        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None
        :param method: (experimental) Http method for the API.
        :param api_path: (experimental) Path parameters appended after API endpoint. Default: - No path
        :param auth_type: (experimental) Authentication methods. Default: AuthType.NO_AUTH
        :param headers: (experimental) HTTP request information that does not relate to contents of the request. Default: - No headers
        :param query_parameters: (experimental) Query strings attatched to end of request. Default: - No query parameters
        :param request_body: (experimental) HTTP Request body. Default: - No request body
        :param api_id: (experimental) The Id of the API to call.
        :param api_stack: (experimental) The Stack in which the API is defined.
        :param stage_name: (experimental) Name of the stage where the API is deployed to in API Gateway. Default: '$default'

        :stability: experimental
        :exampleMetadata: infused

        Example::

            import monocdk as apigatewayv2
            
            http_api = apigatewayv2.HttpApi(self, "MyHttpApi")
            
            invoke_task = tasks.CallApiGatewayHttpApiEndpoint(self, "Call HTTP API",
                api_id=http_api.api_id,
                api_stack=Stack.of(http_api),
                method=tasks.HttpMethod.GET
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6f1e0132f6a5a32af459e8750866c10a1d246d1ed6d3cb4d477e31f5d1e57621)
            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
            check_type(argname="argument heartbeat", value=heartbeat, expected_type=type_hints["heartbeat"])
            check_type(argname="argument input_path", value=input_path, expected_type=type_hints["input_path"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
            check_type(argname="argument output_path", value=output_path, expected_type=type_hints["output_path"])
            check_type(argname="argument result_path", value=result_path, expected_type=type_hints["result_path"])
            check_type(argname="argument result_selector", value=result_selector, expected_type=type_hints["result_selector"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
            check_type(argname="argument method", value=method, expected_type=type_hints["method"])
            check_type(argname="argument api_path", value=api_path, expected_type=type_hints["api_path"])
            check_type(argname="argument auth_type", value=auth_type, expected_type=type_hints["auth_type"])
            check_type(argname="argument headers", value=headers, expected_type=type_hints["headers"])
            check_type(argname="argument query_parameters", value=query_parameters, expected_type=type_hints["query_parameters"])
            check_type(argname="argument request_body", value=request_body, expected_type=type_hints["request_body"])
            check_type(argname="argument api_id", value=api_id, expected_type=type_hints["api_id"])
            check_type(argname="argument api_stack", value=api_stack, expected_type=type_hints["api_stack"])
            check_type(argname="argument stage_name", value=stage_name, expected_type=type_hints["stage_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "method": method,
            "api_id": api_id,
            "api_stack": api_stack,
        }
        if comment is not None:
            self._values["comment"] = comment
        if heartbeat is not None:
            self._values["heartbeat"] = heartbeat
        if input_path is not None:
            self._values["input_path"] = input_path
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern
        if output_path is not None:
            self._values["output_path"] = output_path
        if result_path is not None:
            self._values["result_path"] = result_path
        if result_selector is not None:
            self._values["result_selector"] = result_selector
        if timeout is not None:
            self._values["timeout"] = timeout
        if api_path is not None:
            self._values["api_path"] = api_path
        if auth_type is not None:
            self._values["auth_type"] = auth_type
        if headers is not None:
            self._values["headers"] = headers
        if query_parameters is not None:
            self._values["query_parameters"] = query_parameters
        if request_body is not None:
            self._values["request_body"] = request_body
        if stage_name is not None:
            self._values["stage_name"] = stage_name

    @builtins.property
    def comment(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional description for this state.

        :default: - No comment

        :stability: experimental
        '''
        result = self._values.get("comment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def heartbeat(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the heartbeat.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("heartbeat")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def input_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select part of the state to be the input to this state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        input to be the empty object {}.

        :default: - The entire task input (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("input_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def integration_pattern(self) -> typing.Optional[_IntegrationPattern_fbb35786]:
        '''(experimental) AWS Step Functions integrates with services directly in the Amazon States Language.

        You can control these AWS services using service integration patterns

        :default:

        - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks.
        ``IntegrationPattern.RUN_JOB`` for the following exceptions:
        ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html#connect-wait-token
        :stability: experimental
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_IntegrationPattern_fbb35786], result)

    @builtins.property
    def output_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select select a portion of the state output to pass to the next state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        output to be the empty object {}.

        :default:

        - The entire JSON node determined by the state input, the task result,
        and resultPath is passed to the next state (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("output_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to indicate where to inject the state's output.

        May also be the special value JsonPath.DISCARD, which will cause the state's
        input to become its output.

        :default: - Replaces the entire input with the result (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("result_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied.

        You can use ResultSelector to create a payload with values that are static
        or selected from the state's raw result.

        :default: - None

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/input-output-inputpath-params.html#input-output-resultselector
        :stability: experimental
        '''
        result = self._values.get("result_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def timeout(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the state machine.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def method(self) -> "HttpMethod":
        '''(experimental) Http method for the API.

        :stability: experimental
        '''
        result = self._values.get("method")
        assert result is not None, "Required property 'method' is missing"
        return typing.cast("HttpMethod", result)

    @builtins.property
    def api_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) Path parameters appended after API endpoint.

        :default: - No path

        :stability: experimental
        '''
        result = self._values.get("api_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def auth_type(self) -> typing.Optional[AuthType]:
        '''(experimental) Authentication methods.

        :default: AuthType.NO_AUTH

        :stability: experimental
        '''
        result = self._values.get("auth_type")
        return typing.cast(typing.Optional[AuthType], result)

    @builtins.property
    def headers(self) -> typing.Optional[_TaskInput_71ab46f6]:
        '''(experimental) HTTP request information that does not relate to contents of the request.

        :default: - No headers

        :stability: experimental
        '''
        result = self._values.get("headers")
        return typing.cast(typing.Optional[_TaskInput_71ab46f6], result)

    @builtins.property
    def query_parameters(self) -> typing.Optional[_TaskInput_71ab46f6]:
        '''(experimental) Query strings attatched to end of request.

        :default: - No query parameters

        :stability: experimental
        '''
        result = self._values.get("query_parameters")
        return typing.cast(typing.Optional[_TaskInput_71ab46f6], result)

    @builtins.property
    def request_body(self) -> typing.Optional[_TaskInput_71ab46f6]:
        '''(experimental) HTTP Request body.

        :default: - No request body

        :stability: experimental
        '''
        result = self._values.get("request_body")
        return typing.cast(typing.Optional[_TaskInput_71ab46f6], result)

    @builtins.property
    def api_id(self) -> builtins.str:
        '''(experimental) The Id of the API to call.

        :stability: experimental
        '''
        result = self._values.get("api_id")
        assert result is not None, "Required property 'api_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def api_stack(self) -> _Stack_9f43e4a3:
        '''(experimental) The Stack in which the API is defined.

        :stability: experimental
        '''
        result = self._values.get("api_stack")
        assert result is not None, "Required property 'api_stack' is missing"
        return typing.cast(_Stack_9f43e4a3, result)

    @builtins.property
    def stage_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Name of the stage where the API is deployed to in API Gateway.

        :default: '$default'

        :stability: experimental
        '''
        result = self._values.get("stage_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CallApiGatewayHttpApiEndpointProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class CallApiGatewayRestApiEndpoint(
    _TaskStateBase_c3080646,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.CallApiGatewayRestApiEndpoint",
):
    '''(experimental) Call REST API endpoint as a Task.

    Be aware that the header values must be arrays. When passing the Task Token
    in the headers field ``WAIT_FOR_TASK_TOKEN`` integration, use
    ``JsonPath.array()`` to wrap the token in an array::

       # Example automatically generated from non-compiling source. May contain errors.
       import aws_cdk.aws_apigateway as apigateway
       # api: apigateway.RestApi


       tasks.CallApiGatewayRestApiEndpoint(self, "Endpoint",
           api=api,
           stage_name="Stage",
           method=tasks.HttpMethod.PUT,
           integration_pattern=sfn.IntegrationPattern.WAIT_FOR_TASK_TOKEN,
           headers=sfn.TaskInput.from_object({
               "TaskToken": sfn.JsonPath.array(sfn.JsonPath.task_token)
           })
       )

    :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-api-gateway.html
    :stability: experimental
    :exampleMetadata: infused

    Example::

        import monocdk as apigateway
        # api: apigateway.RestApi
        
        
        tasks.CallApiGatewayRestApiEndpoint(self, "Endpoint",
            api=api,
            stage_name="Stage",
            method=tasks.HttpMethod.PUT,
            integration_pattern=sfn.IntegrationPattern.WAIT_FOR_TASK_TOKEN,
            headers=sfn.TaskInput.from_object({
                "TaskToken": sfn.JsonPath.array(sfn.JsonPath.task_token)
            })
        )
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        api: _IRestApi_a27d4788,
        stage_name: builtins.str,
        method: "HttpMethod",
        api_path: typing.Optional[builtins.str] = None,
        auth_type: typing.Optional[AuthType] = None,
        headers: typing.Optional[_TaskInput_71ab46f6] = None,
        query_parameters: typing.Optional[_TaskInput_71ab46f6] = None,
        request_body: typing.Optional[_TaskInput_71ab46f6] = None,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param api: (experimental) API to call.
        :param stage_name: (experimental) Name of the stage where the API is deployed to in API Gateway.
        :param method: (experimental) Http method for the API.
        :param api_path: (experimental) Path parameters appended after API endpoint. Default: - No path
        :param auth_type: (experimental) Authentication methods. Default: AuthType.NO_AUTH
        :param headers: (experimental) HTTP request information that does not relate to contents of the request. Default: - No headers
        :param query_parameters: (experimental) Query strings attatched to end of request. Default: - No query parameters
        :param request_body: (experimental) HTTP Request body. Default: - No request body
        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__508affe57ea1e2f3119725bcdcd4e1e18ac42ba09c8620cb9993bdad3954625f)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = CallApiGatewayRestApiEndpointProps(
            api=api,
            stage_name=stage_name,
            method=method,
            api_path=api_path,
            auth_type=auth_type,
            headers=headers,
            query_parameters=query_parameters,
            request_body=request_body,
            comment=comment,
            heartbeat=heartbeat,
            input_path=input_path,
            integration_pattern=integration_pattern,
            output_path=output_path,
            result_path=result_path,
            result_selector=result_selector,
            timeout=timeout,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="createPolicyStatements")
    def _create_policy_statements(self) -> typing.List[_PolicyStatement_296fe8a3]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[_PolicyStatement_296fe8a3], jsii.invoke(self, "createPolicyStatements", []))

    @builtins.property
    @jsii.member(jsii_name="apiEndpoint")
    def _api_endpoint(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "apiEndpoint"))

    @builtins.property
    @jsii.member(jsii_name="arnForExecuteApi")
    def _arn_for_execute_api(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "arnForExecuteApi"))

    @builtins.property
    @jsii.member(jsii_name="stageName")
    def _stage_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "stageName"))

    @builtins.property
    @jsii.member(jsii_name="taskMetrics")
    def _task_metrics(self) -> typing.Optional[_TaskMetricsConfig_5aaea59e]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[_TaskMetricsConfig_5aaea59e], jsii.get(self, "taskMetrics"))

    @builtins.property
    @jsii.member(jsii_name="taskPolicies")
    def _task_policies(self) -> typing.Optional[typing.List[_PolicyStatement_296fe8a3]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.List[_PolicyStatement_296fe8a3]], jsii.get(self, "taskPolicies"))


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.CallApiGatewayRestApiEndpointProps",
    jsii_struct_bases=[CallApiGatewayEndpointBaseProps],
    name_mapping={
        "comment": "comment",
        "heartbeat": "heartbeat",
        "input_path": "inputPath",
        "integration_pattern": "integrationPattern",
        "output_path": "outputPath",
        "result_path": "resultPath",
        "result_selector": "resultSelector",
        "timeout": "timeout",
        "method": "method",
        "api_path": "apiPath",
        "auth_type": "authType",
        "headers": "headers",
        "query_parameters": "queryParameters",
        "request_body": "requestBody",
        "api": "api",
        "stage_name": "stageName",
    },
)
class CallApiGatewayRestApiEndpointProps(CallApiGatewayEndpointBaseProps):
    def __init__(
        self,
        *,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
        method: "HttpMethod",
        api_path: typing.Optional[builtins.str] = None,
        auth_type: typing.Optional[AuthType] = None,
        headers: typing.Optional[_TaskInput_71ab46f6] = None,
        query_parameters: typing.Optional[_TaskInput_71ab46f6] = None,
        request_body: typing.Optional[_TaskInput_71ab46f6] = None,
        api: _IRestApi_a27d4788,
        stage_name: builtins.str,
    ) -> None:
        '''(experimental) Properties for calling an REST API Endpoint.

        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None
        :param method: (experimental) Http method for the API.
        :param api_path: (experimental) Path parameters appended after API endpoint. Default: - No path
        :param auth_type: (experimental) Authentication methods. Default: AuthType.NO_AUTH
        :param headers: (experimental) HTTP request information that does not relate to contents of the request. Default: - No headers
        :param query_parameters: (experimental) Query strings attatched to end of request. Default: - No query parameters
        :param request_body: (experimental) HTTP Request body. Default: - No request body
        :param api: (experimental) API to call.
        :param stage_name: (experimental) Name of the stage where the API is deployed to in API Gateway.

        :stability: experimental
        :exampleMetadata: infused

        Example::

            import monocdk as apigateway
            # api: apigateway.RestApi
            
            
            tasks.CallApiGatewayRestApiEndpoint(self, "Endpoint",
                api=api,
                stage_name="Stage",
                method=tasks.HttpMethod.PUT,
                integration_pattern=sfn.IntegrationPattern.WAIT_FOR_TASK_TOKEN,
                headers=sfn.TaskInput.from_object({
                    "TaskToken": sfn.JsonPath.array(sfn.JsonPath.task_token)
                })
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c15645443f1d3723a03a2bfba6ac660ee72db9dc16a31fec99c99b53510e104f)
            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
            check_type(argname="argument heartbeat", value=heartbeat, expected_type=type_hints["heartbeat"])
            check_type(argname="argument input_path", value=input_path, expected_type=type_hints["input_path"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
            check_type(argname="argument output_path", value=output_path, expected_type=type_hints["output_path"])
            check_type(argname="argument result_path", value=result_path, expected_type=type_hints["result_path"])
            check_type(argname="argument result_selector", value=result_selector, expected_type=type_hints["result_selector"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
            check_type(argname="argument method", value=method, expected_type=type_hints["method"])
            check_type(argname="argument api_path", value=api_path, expected_type=type_hints["api_path"])
            check_type(argname="argument auth_type", value=auth_type, expected_type=type_hints["auth_type"])
            check_type(argname="argument headers", value=headers, expected_type=type_hints["headers"])
            check_type(argname="argument query_parameters", value=query_parameters, expected_type=type_hints["query_parameters"])
            check_type(argname="argument request_body", value=request_body, expected_type=type_hints["request_body"])
            check_type(argname="argument api", value=api, expected_type=type_hints["api"])
            check_type(argname="argument stage_name", value=stage_name, expected_type=type_hints["stage_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "method": method,
            "api": api,
            "stage_name": stage_name,
        }
        if comment is not None:
            self._values["comment"] = comment
        if heartbeat is not None:
            self._values["heartbeat"] = heartbeat
        if input_path is not None:
            self._values["input_path"] = input_path
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern
        if output_path is not None:
            self._values["output_path"] = output_path
        if result_path is not None:
            self._values["result_path"] = result_path
        if result_selector is not None:
            self._values["result_selector"] = result_selector
        if timeout is not None:
            self._values["timeout"] = timeout
        if api_path is not None:
            self._values["api_path"] = api_path
        if auth_type is not None:
            self._values["auth_type"] = auth_type
        if headers is not None:
            self._values["headers"] = headers
        if query_parameters is not None:
            self._values["query_parameters"] = query_parameters
        if request_body is not None:
            self._values["request_body"] = request_body

    @builtins.property
    def comment(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional description for this state.

        :default: - No comment

        :stability: experimental
        '''
        result = self._values.get("comment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def heartbeat(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the heartbeat.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("heartbeat")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def input_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select part of the state to be the input to this state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        input to be the empty object {}.

        :default: - The entire task input (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("input_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def integration_pattern(self) -> typing.Optional[_IntegrationPattern_fbb35786]:
        '''(experimental) AWS Step Functions integrates with services directly in the Amazon States Language.

        You can control these AWS services using service integration patterns

        :default:

        - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks.
        ``IntegrationPattern.RUN_JOB`` for the following exceptions:
        ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html#connect-wait-token
        :stability: experimental
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_IntegrationPattern_fbb35786], result)

    @builtins.property
    def output_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select select a portion of the state output to pass to the next state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        output to be the empty object {}.

        :default:

        - The entire JSON node determined by the state input, the task result,
        and resultPath is passed to the next state (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("output_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to indicate where to inject the state's output.

        May also be the special value JsonPath.DISCARD, which will cause the state's
        input to become its output.

        :default: - Replaces the entire input with the result (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("result_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied.

        You can use ResultSelector to create a payload with values that are static
        or selected from the state's raw result.

        :default: - None

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/input-output-inputpath-params.html#input-output-resultselector
        :stability: experimental
        '''
        result = self._values.get("result_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def timeout(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the state machine.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def method(self) -> "HttpMethod":
        '''(experimental) Http method for the API.

        :stability: experimental
        '''
        result = self._values.get("method")
        assert result is not None, "Required property 'method' is missing"
        return typing.cast("HttpMethod", result)

    @builtins.property
    def api_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) Path parameters appended after API endpoint.

        :default: - No path

        :stability: experimental
        '''
        result = self._values.get("api_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def auth_type(self) -> typing.Optional[AuthType]:
        '''(experimental) Authentication methods.

        :default: AuthType.NO_AUTH

        :stability: experimental
        '''
        result = self._values.get("auth_type")
        return typing.cast(typing.Optional[AuthType], result)

    @builtins.property
    def headers(self) -> typing.Optional[_TaskInput_71ab46f6]:
        '''(experimental) HTTP request information that does not relate to contents of the request.

        :default: - No headers

        :stability: experimental
        '''
        result = self._values.get("headers")
        return typing.cast(typing.Optional[_TaskInput_71ab46f6], result)

    @builtins.property
    def query_parameters(self) -> typing.Optional[_TaskInput_71ab46f6]:
        '''(experimental) Query strings attatched to end of request.

        :default: - No query parameters

        :stability: experimental
        '''
        result = self._values.get("query_parameters")
        return typing.cast(typing.Optional[_TaskInput_71ab46f6], result)

    @builtins.property
    def request_body(self) -> typing.Optional[_TaskInput_71ab46f6]:
        '''(experimental) HTTP Request body.

        :default: - No request body

        :stability: experimental
        '''
        result = self._values.get("request_body")
        return typing.cast(typing.Optional[_TaskInput_71ab46f6], result)

    @builtins.property
    def api(self) -> _IRestApi_a27d4788:
        '''(experimental) API to call.

        :stability: experimental
        '''
        result = self._values.get("api")
        assert result is not None, "Required property 'api' is missing"
        return typing.cast(_IRestApi_a27d4788, result)

    @builtins.property
    def stage_name(self) -> builtins.str:
        '''(experimental) Name of the stage where the API is deployed to in API Gateway.

        :stability: experimental
        '''
        result = self._values.get("stage_name")
        assert result is not None, "Required property 'stage_name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CallApiGatewayRestApiEndpointProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class CallAwsService(
    _TaskStateBase_c3080646,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.CallAwsService",
):
    '''(experimental) A StepFunctions task to call an AWS service API.

    :stability: experimental
    :exampleMetadata: infused

    Example::

        # my_bucket: s3.Bucket
        
        get_object = tasks.CallAwsService(self, "GetObject",
            service="s3",
            action="getObject",
            parameters={
                "Bucket": my_bucket.bucket_name,
                "Key": sfn.JsonPath.string_at("$.key")
            },
            iam_resources=[my_bucket.arn_for_objects("*")]
        )
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        action: builtins.str,
        iam_resources: typing.Sequence[builtins.str],
        service: builtins.str,
        iam_action: typing.Optional[builtins.str] = None,
        parameters: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param action: (experimental) The API action to call. Use camelCase.
        :param iam_resources: (experimental) The resources for the IAM statement that will be added to the state machine role's policy to allow the state machine to make the API call. By default the action for this IAM statement will be ``service:action``.
        :param service: (experimental) The AWS service to call.
        :param iam_action: (experimental) The action for the IAM statement that will be added to the state machine role's policy to allow the state machine to make the API call. Use in the case where the IAM action name does not match with the API service/action name, e.g. ``s3:ListBuckets`` requires ``s3:ListAllMyBuckets``. Default: - service:action
        :param parameters: (experimental) Parameters for the API action call. Use PascalCase for the parameter names. Default: - no parameters
        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2b78fcaf67b0f989b1ac54e1c0b74ca22a679df83969389413d6b09a35550e9a)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = CallAwsServiceProps(
            action=action,
            iam_resources=iam_resources,
            service=service,
            iam_action=iam_action,
            parameters=parameters,
            comment=comment,
            heartbeat=heartbeat,
            input_path=input_path,
            integration_pattern=integration_pattern,
            output_path=output_path,
            result_path=result_path,
            result_selector=result_selector,
            timeout=timeout,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="taskMetrics")
    def _task_metrics(self) -> typing.Optional[_TaskMetricsConfig_5aaea59e]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[_TaskMetricsConfig_5aaea59e], jsii.get(self, "taskMetrics"))

    @builtins.property
    @jsii.member(jsii_name="taskPolicies")
    def _task_policies(self) -> typing.Optional[typing.List[_PolicyStatement_296fe8a3]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.List[_PolicyStatement_296fe8a3]], jsii.get(self, "taskPolicies"))


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.CallAwsServiceProps",
    jsii_struct_bases=[_TaskStateBaseProps_b13f6332],
    name_mapping={
        "comment": "comment",
        "heartbeat": "heartbeat",
        "input_path": "inputPath",
        "integration_pattern": "integrationPattern",
        "output_path": "outputPath",
        "result_path": "resultPath",
        "result_selector": "resultSelector",
        "timeout": "timeout",
        "action": "action",
        "iam_resources": "iamResources",
        "service": "service",
        "iam_action": "iamAction",
        "parameters": "parameters",
    },
)
class CallAwsServiceProps(_TaskStateBaseProps_b13f6332):
    def __init__(
        self,
        *,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
        action: builtins.str,
        iam_resources: typing.Sequence[builtins.str],
        service: builtins.str,
        iam_action: typing.Optional[builtins.str] = None,
        parameters: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    ) -> None:
        '''(experimental) Properties for calling an AWS service's API action from your state machine.

        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None
        :param action: (experimental) The API action to call. Use camelCase.
        :param iam_resources: (experimental) The resources for the IAM statement that will be added to the state machine role's policy to allow the state machine to make the API call. By default the action for this IAM statement will be ``service:action``.
        :param service: (experimental) The AWS service to call.
        :param iam_action: (experimental) The action for the IAM statement that will be added to the state machine role's policy to allow the state machine to make the API call. Use in the case where the IAM action name does not match with the API service/action name, e.g. ``s3:ListBuckets`` requires ``s3:ListAllMyBuckets``. Default: - service:action
        :param parameters: (experimental) Parameters for the API action call. Use PascalCase for the parameter names. Default: - no parameters

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/supported-services-awssdk.html
        :stability: experimental
        :exampleMetadata: infused

        Example::

            # my_bucket: s3.Bucket
            
            get_object = tasks.CallAwsService(self, "GetObject",
                service="s3",
                action="getObject",
                parameters={
                    "Bucket": my_bucket.bucket_name,
                    "Key": sfn.JsonPath.string_at("$.key")
                },
                iam_resources=[my_bucket.arn_for_objects("*")]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5803a26cfc1e2247ca0d98af98a9536ee0944e658343f8f6673c91ffd6050954)
            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
            check_type(argname="argument heartbeat", value=heartbeat, expected_type=type_hints["heartbeat"])
            check_type(argname="argument input_path", value=input_path, expected_type=type_hints["input_path"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
            check_type(argname="argument output_path", value=output_path, expected_type=type_hints["output_path"])
            check_type(argname="argument result_path", value=result_path, expected_type=type_hints["result_path"])
            check_type(argname="argument result_selector", value=result_selector, expected_type=type_hints["result_selector"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
            check_type(argname="argument action", value=action, expected_type=type_hints["action"])
            check_type(argname="argument iam_resources", value=iam_resources, expected_type=type_hints["iam_resources"])
            check_type(argname="argument service", value=service, expected_type=type_hints["service"])
            check_type(argname="argument iam_action", value=iam_action, expected_type=type_hints["iam_action"])
            check_type(argname="argument parameters", value=parameters, expected_type=type_hints["parameters"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "action": action,
            "iam_resources": iam_resources,
            "service": service,
        }
        if comment is not None:
            self._values["comment"] = comment
        if heartbeat is not None:
            self._values["heartbeat"] = heartbeat
        if input_path is not None:
            self._values["input_path"] = input_path
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern
        if output_path is not None:
            self._values["output_path"] = output_path
        if result_path is not None:
            self._values["result_path"] = result_path
        if result_selector is not None:
            self._values["result_selector"] = result_selector
        if timeout is not None:
            self._values["timeout"] = timeout
        if iam_action is not None:
            self._values["iam_action"] = iam_action
        if parameters is not None:
            self._values["parameters"] = parameters

    @builtins.property
    def comment(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional description for this state.

        :default: - No comment

        :stability: experimental
        '''
        result = self._values.get("comment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def heartbeat(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the heartbeat.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("heartbeat")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def input_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select part of the state to be the input to this state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        input to be the empty object {}.

        :default: - The entire task input (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("input_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def integration_pattern(self) -> typing.Optional[_IntegrationPattern_fbb35786]:
        '''(experimental) AWS Step Functions integrates with services directly in the Amazon States Language.

        You can control these AWS services using service integration patterns

        :default:

        - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks.
        ``IntegrationPattern.RUN_JOB`` for the following exceptions:
        ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html#connect-wait-token
        :stability: experimental
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_IntegrationPattern_fbb35786], result)

    @builtins.property
    def output_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select select a portion of the state output to pass to the next state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        output to be the empty object {}.

        :default:

        - The entire JSON node determined by the state input, the task result,
        and resultPath is passed to the next state (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("output_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to indicate where to inject the state's output.

        May also be the special value JsonPath.DISCARD, which will cause the state's
        input to become its output.

        :default: - Replaces the entire input with the result (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("result_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied.

        You can use ResultSelector to create a payload with values that are static
        or selected from the state's raw result.

        :default: - None

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/input-output-inputpath-params.html#input-output-resultselector
        :stability: experimental
        '''
        result = self._values.get("result_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def timeout(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the state machine.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def action(self) -> builtins.str:
        '''(experimental) The API action to call.

        Use camelCase.

        :stability: experimental
        '''
        result = self._values.get("action")
        assert result is not None, "Required property 'action' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def iam_resources(self) -> typing.List[builtins.str]:
        '''(experimental) The resources for the IAM statement that will be added to the state machine role's policy to allow the state machine to make the API call.

        By default the action for this IAM statement will be ``service:action``.

        :stability: experimental
        '''
        result = self._values.get("iam_resources")
        assert result is not None, "Required property 'iam_resources' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def service(self) -> builtins.str:
        '''(experimental) The AWS service to call.

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/supported-services-awssdk.html
        :stability: experimental
        '''
        result = self._values.get("service")
        assert result is not None, "Required property 'service' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def iam_action(self) -> typing.Optional[builtins.str]:
        '''(experimental) The action for the IAM statement that will be added to the state machine role's policy to allow the state machine to make the API call.

        Use in the case where the IAM action name does not match with the
        API service/action name, e.g. ``s3:ListBuckets`` requires ``s3:ListAllMyBuckets``.

        :default: - service:action

        :stability: experimental
        '''
        result = self._values.get("iam_action")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def parameters(self) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) Parameters for the API action call.

        Use PascalCase for the parameter names.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("parameters")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CallAwsServiceProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.Channel",
    jsii_struct_bases=[],
    name_mapping={
        "channel_name": "channelName",
        "data_source": "dataSource",
        "compression_type": "compressionType",
        "content_type": "contentType",
        "input_mode": "inputMode",
        "record_wrapper_type": "recordWrapperType",
        "shuffle_config": "shuffleConfig",
    },
)
class Channel:
    def __init__(
        self,
        *,
        channel_name: builtins.str,
        data_source: typing.Union["DataSource", typing.Dict[builtins.str, typing.Any]],
        compression_type: typing.Optional["CompressionType"] = None,
        content_type: typing.Optional[builtins.str] = None,
        input_mode: typing.Optional["InputMode"] = None,
        record_wrapper_type: typing.Optional["RecordWrapperType"] = None,
        shuffle_config: typing.Optional[typing.Union["ShuffleConfig", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''(experimental) Describes the training, validation or test dataset and the Amazon S3 location where it is stored.

        :param channel_name: (experimental) Name of the channel.
        :param data_source: (experimental) Location of the channel data.
        :param compression_type: (experimental) Compression type if training data is compressed. Default: - None
        :param content_type: (experimental) The MIME type of the data. Default: - None
        :param input_mode: (experimental) Input mode to use for the data channel in a training job. Default: - None
        :param record_wrapper_type: (experimental) Specify RecordIO as the value when input data is in raw format but the training algorithm requires the RecordIO format. In this case, Amazon SageMaker wraps each individual S3 object in a RecordIO record. If the input data is already in RecordIO format, you don't need to set this attribute. Default: - None
        :param shuffle_config: (experimental) Shuffle config option for input data in a channel. Default: - None

        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
            
            # s3_location: stepfunctions_tasks.S3Location
            
            channel = stepfunctions_tasks.Channel(
                channel_name="channelName",
                data_source=stepfunctions_tasks.DataSource(
                    s3_data_source=stepfunctions_tasks.S3DataSource(
                        s3_location=s3_location,
            
                        # the properties below are optional
                        attribute_names=["attributeNames"],
                        s3_data_distribution_type=stepfunctions_tasks.S3DataDistributionType.FULLY_REPLICATED,
                        s3_data_type=stepfunctions_tasks.S3DataType.MANIFEST_FILE
                    )
                ),
            
                # the properties below are optional
                compression_type=stepfunctions_tasks.CompressionType.NONE,
                content_type="contentType",
                input_mode=stepfunctions_tasks.InputMode.PIPE,
                record_wrapper_type=stepfunctions_tasks.RecordWrapperType.NONE,
                shuffle_config=stepfunctions_tasks.ShuffleConfig(
                    seed=123
                )
            )
        '''
        if isinstance(data_source, dict):
            data_source = DataSource(**data_source)
        if isinstance(shuffle_config, dict):
            shuffle_config = ShuffleConfig(**shuffle_config)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4f825ae449ecea944d6f37787a6d795fe89fa543e25f930bc0efb5102db4cb94)
            check_type(argname="argument channel_name", value=channel_name, expected_type=type_hints["channel_name"])
            check_type(argname="argument data_source", value=data_source, expected_type=type_hints["data_source"])
            check_type(argname="argument compression_type", value=compression_type, expected_type=type_hints["compression_type"])
            check_type(argname="argument content_type", value=content_type, expected_type=type_hints["content_type"])
            check_type(argname="argument input_mode", value=input_mode, expected_type=type_hints["input_mode"])
            check_type(argname="argument record_wrapper_type", value=record_wrapper_type, expected_type=type_hints["record_wrapper_type"])
            check_type(argname="argument shuffle_config", value=shuffle_config, expected_type=type_hints["shuffle_config"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "channel_name": channel_name,
            "data_source": data_source,
        }
        if compression_type is not None:
            self._values["compression_type"] = compression_type
        if content_type is not None:
            self._values["content_type"] = content_type
        if input_mode is not None:
            self._values["input_mode"] = input_mode
        if record_wrapper_type is not None:
            self._values["record_wrapper_type"] = record_wrapper_type
        if shuffle_config is not None:
            self._values["shuffle_config"] = shuffle_config

    @builtins.property
    def channel_name(self) -> builtins.str:
        '''(experimental) Name of the channel.

        :stability: experimental
        '''
        result = self._values.get("channel_name")
        assert result is not None, "Required property 'channel_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def data_source(self) -> "DataSource":
        '''(experimental) Location of the channel data.

        :stability: experimental
        '''
        result = self._values.get("data_source")
        assert result is not None, "Required property 'data_source' is missing"
        return typing.cast("DataSource", result)

    @builtins.property
    def compression_type(self) -> typing.Optional["CompressionType"]:
        '''(experimental) Compression type if training data is compressed.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("compression_type")
        return typing.cast(typing.Optional["CompressionType"], result)

    @builtins.property
    def content_type(self) -> typing.Optional[builtins.str]:
        '''(experimental) The MIME type of the data.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("content_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def input_mode(self) -> typing.Optional["InputMode"]:
        '''(experimental) Input mode to use for the data channel in a training job.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("input_mode")
        return typing.cast(typing.Optional["InputMode"], result)

    @builtins.property
    def record_wrapper_type(self) -> typing.Optional["RecordWrapperType"]:
        '''(experimental) Specify RecordIO as the value when input data is in raw format but the training algorithm requires the RecordIO format.

        In this case, Amazon SageMaker wraps each individual S3 object in a RecordIO record.
        If the input data is already in RecordIO format, you don't need to set this attribute.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("record_wrapper_type")
        return typing.cast(typing.Optional["RecordWrapperType"], result)

    @builtins.property
    def shuffle_config(self) -> typing.Optional["ShuffleConfig"]:
        '''(experimental) Shuffle config option for input data in a channel.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("shuffle_config")
        return typing.cast(typing.Optional["ShuffleConfig"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "Channel(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class Classification(
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.Classification",
):
    '''(experimental) The classification within a EMR Containers application configuration.

    Class can be extended to add other classifications.
    For example, new Classification('xxx-yyy');

    :stability: experimental
    :exampleMetadata: infused

    Example::

        tasks.EmrContainersStartJobRun(self, "EMR Containers Start Job Run",
            virtual_cluster=tasks.VirtualClusterInput.from_virtual_cluster_id("de92jdei2910fwedz"),
            release_label=tasks.ReleaseLabel.EMR_6_2_0,
            job_name="EMR-Containers-Job",
            job_driver=dynamodb.aws_stepfunctions_tasks.JobDriver(
                spark_submit_job_driver=dynamodb.aws_stepfunctions_tasks.SparkSubmitJobDriver(
                    entry_point=sfn.TaskInput.from_text("local:///usr/lib/spark/examples/src/main/python/pi.py")
                )
            ),
            application_config=[dynamodb.aws_stepfunctions_tasks.ApplicationConfiguration(
                classification=tasks.Classification.SPARK_DEFAULTS,
                properties={
                    "spark.executor.instances": "1",
                    "spark.executor.memory": "512M"
                }
            )]
        )
    '''

    def __init__(self, classification_statement: builtins.str) -> None:
        '''(experimental) Creates a new Classification.

        :param classification_statement: A literal string in case a new EMR classification is released, if not already defined.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0db5ad534c508b5437a3c577eba01046accc6bfb30e8511bbee402133fbec1b2)
            check_type(argname="argument classification_statement", value=classification_statement, expected_type=type_hints["classification_statement"])
        jsii.create(self.__class__, self, [classification_statement])

    @jsii.python.classproperty
    @jsii.member(jsii_name="SPARK")
    def SPARK(cls) -> "Classification":
        '''(experimental) Sets the maximizeResourceAllocation property to true or false.

        When true, Amazon EMR automatically configures spark-defaults properties based on cluster hardware configuration.

        For more info:

        :see: https://docs.aws.amazon.com/emr/latest/ReleaseGuide/emr-spark-configure.html#emr-spark-maximizeresourceallocation
        :stability: experimental
        '''
        return typing.cast("Classification", jsii.sget(cls, "SPARK"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="SPARK_DEFAULTS")
    def SPARK_DEFAULTS(cls) -> "Classification":
        '''(experimental) Sets values in the spark-defaults.conf file.

        For more info:

        :see: https://spark.apache.org/docs/latest/configuration.html
        :stability: experimental
        '''
        return typing.cast("Classification", jsii.sget(cls, "SPARK_DEFAULTS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="SPARK_ENV")
    def SPARK_ENV(cls) -> "Classification":
        '''(experimental) Sets values in the spark-env.sh file.

        For more info:

        :see: https://spark.apache.org/docs/latest/configuration.html#environment-variables
        :stability: experimental
        '''
        return typing.cast("Classification", jsii.sget(cls, "SPARK_ENV"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="SPARK_HIVE_SITE")
    def SPARK_HIVE_SITE(cls) -> "Classification":
        '''(experimental) Sets values in the hive-site.xml for Spark.

        :stability: experimental
        '''
        return typing.cast("Classification", jsii.sget(cls, "SPARK_HIVE_SITE"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="SPARK_LOG4J")
    def SPARK_LOG4_J(cls) -> "Classification":
        '''(experimental) Sets values in the log4j.properties file.

        For more settings and info:

        :see: https://github.com/apache/spark/blob/master/conf/log4j.properties.template
        :stability: experimental
        '''
        return typing.cast("Classification", jsii.sget(cls, "SPARK_LOG4J"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="SPARK_METRICS")
    def SPARK_METRICS(cls) -> "Classification":
        '''(experimental) Sets values in the metrics.properties file.

        For more settings and info:

        :see: https://github.com/apache/spark/blob/master/conf/metrics.properties.template
        :stability: experimental
        '''
        return typing.cast("Classification", jsii.sget(cls, "SPARK_METRICS"))

    @builtins.property
    @jsii.member(jsii_name="classificationStatement")
    def classification_statement(self) -> builtins.str:
        '''(experimental) A literal string in case a new EMR classification is released, if not already defined.

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "classificationStatement"))


class CodeBuildStartBuild(
    _TaskStateBase_c3080646,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.CodeBuildStartBuild",
):
    '''(experimental) Start a CodeBuild Build as a task.

    :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-codebuild.html
    :stability: experimental
    :exampleMetadata: infused

    Example::

        import monocdk as codebuild
        
        
        codebuild_project = codebuild.Project(self, "Project",
            project_name="MyTestProject",
            build_spec=codebuild.BuildSpec.from_object({
                "version": "0.2",
                "phases": {
                    "build": {
                        "commands": ["echo \"Hello, CodeBuild!\""
                        ]
                    }
                }
            })
        )
        
        task = tasks.CodeBuildStartBuild(self, "Task",
            project=codebuild_project,
            integration_pattern=sfn.IntegrationPattern.RUN_JOB,
            environment_variables_override={
                "ZONE": codebuild.aws_codebuild.BuildEnvironmentVariable(
                    type=codebuild.BuildEnvironmentVariableType.PLAINTEXT,
                    value=sfn.JsonPath.string_at("$.envVariables.zone")
                )
            }
        )
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        project: _IProject_6da8803e,
        environment_variables_override: typing.Optional[typing.Mapping[builtins.str, typing.Union[_BuildEnvironmentVariable_00095c97, typing.Dict[builtins.str, typing.Any]]]] = None,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param project: (experimental) CodeBuild project to start.
        :param environment_variables_override: (experimental) A set of environment variables to be used for this build only. Default: - the latest environment variables already defined in the build project.
        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__46a0879ab4a77972f8aef79453df3a294e3bb04c5341ca0a3703c45c28f2079a)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = CodeBuildStartBuildProps(
            project=project,
            environment_variables_override=environment_variables_override,
            comment=comment,
            heartbeat=heartbeat,
            input_path=input_path,
            integration_pattern=integration_pattern,
            output_path=output_path,
            result_path=result_path,
            result_selector=result_selector,
            timeout=timeout,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="taskMetrics")
    def _task_metrics(self) -> typing.Optional[_TaskMetricsConfig_5aaea59e]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[_TaskMetricsConfig_5aaea59e], jsii.get(self, "taskMetrics"))

    @builtins.property
    @jsii.member(jsii_name="taskPolicies")
    def _task_policies(self) -> typing.Optional[typing.List[_PolicyStatement_296fe8a3]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.List[_PolicyStatement_296fe8a3]], jsii.get(self, "taskPolicies"))


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.CodeBuildStartBuildProps",
    jsii_struct_bases=[_TaskStateBaseProps_b13f6332],
    name_mapping={
        "comment": "comment",
        "heartbeat": "heartbeat",
        "input_path": "inputPath",
        "integration_pattern": "integrationPattern",
        "output_path": "outputPath",
        "result_path": "resultPath",
        "result_selector": "resultSelector",
        "timeout": "timeout",
        "project": "project",
        "environment_variables_override": "environmentVariablesOverride",
    },
)
class CodeBuildStartBuildProps(_TaskStateBaseProps_b13f6332):
    def __init__(
        self,
        *,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
        project: _IProject_6da8803e,
        environment_variables_override: typing.Optional[typing.Mapping[builtins.str, typing.Union[_BuildEnvironmentVariable_00095c97, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''(experimental) Properties for CodeBuildStartBuild.

        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None
        :param project: (experimental) CodeBuild project to start.
        :param environment_variables_override: (experimental) A set of environment variables to be used for this build only. Default: - the latest environment variables already defined in the build project.

        :stability: experimental
        :exampleMetadata: infused

        Example::

            import monocdk as codebuild
            
            
            codebuild_project = codebuild.Project(self, "Project",
                project_name="MyTestProject",
                build_spec=codebuild.BuildSpec.from_object({
                    "version": "0.2",
                    "phases": {
                        "build": {
                            "commands": ["echo \"Hello, CodeBuild!\""
                            ]
                        }
                    }
                })
            )
            
            task = tasks.CodeBuildStartBuild(self, "Task",
                project=codebuild_project,
                integration_pattern=sfn.IntegrationPattern.RUN_JOB,
                environment_variables_override={
                    "ZONE": codebuild.aws_codebuild.BuildEnvironmentVariable(
                        type=codebuild.BuildEnvironmentVariableType.PLAINTEXT,
                        value=sfn.JsonPath.string_at("$.envVariables.zone")
                    )
                }
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__512ed52086e9a97c66d11ac149d455e72907de8832bad1a13a78a3e7d6bf198c)
            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
            check_type(argname="argument heartbeat", value=heartbeat, expected_type=type_hints["heartbeat"])
            check_type(argname="argument input_path", value=input_path, expected_type=type_hints["input_path"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
            check_type(argname="argument output_path", value=output_path, expected_type=type_hints["output_path"])
            check_type(argname="argument result_path", value=result_path, expected_type=type_hints["result_path"])
            check_type(argname="argument result_selector", value=result_selector, expected_type=type_hints["result_selector"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
            check_type(argname="argument project", value=project, expected_type=type_hints["project"])
            check_type(argname="argument environment_variables_override", value=environment_variables_override, expected_type=type_hints["environment_variables_override"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "project": project,
        }
        if comment is not None:
            self._values["comment"] = comment
        if heartbeat is not None:
            self._values["heartbeat"] = heartbeat
        if input_path is not None:
            self._values["input_path"] = input_path
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern
        if output_path is not None:
            self._values["output_path"] = output_path
        if result_path is not None:
            self._values["result_path"] = result_path
        if result_selector is not None:
            self._values["result_selector"] = result_selector
        if timeout is not None:
            self._values["timeout"] = timeout
        if environment_variables_override is not None:
            self._values["environment_variables_override"] = environment_variables_override

    @builtins.property
    def comment(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional description for this state.

        :default: - No comment

        :stability: experimental
        '''
        result = self._values.get("comment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def heartbeat(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the heartbeat.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("heartbeat")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def input_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select part of the state to be the input to this state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        input to be the empty object {}.

        :default: - The entire task input (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("input_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def integration_pattern(self) -> typing.Optional[_IntegrationPattern_fbb35786]:
        '''(experimental) AWS Step Functions integrates with services directly in the Amazon States Language.

        You can control these AWS services using service integration patterns

        :default:

        - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks.
        ``IntegrationPattern.RUN_JOB`` for the following exceptions:
        ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html#connect-wait-token
        :stability: experimental
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_IntegrationPattern_fbb35786], result)

    @builtins.property
    def output_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select select a portion of the state output to pass to the next state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        output to be the empty object {}.

        :default:

        - The entire JSON node determined by the state input, the task result,
        and resultPath is passed to the next state (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("output_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to indicate where to inject the state's output.

        May also be the special value JsonPath.DISCARD, which will cause the state's
        input to become its output.

        :default: - Replaces the entire input with the result (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("result_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied.

        You can use ResultSelector to create a payload with values that are static
        or selected from the state's raw result.

        :default: - None

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/input-output-inputpath-params.html#input-output-resultselector
        :stability: experimental
        '''
        result = self._values.get("result_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def timeout(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the state machine.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def project(self) -> _IProject_6da8803e:
        '''(experimental) CodeBuild project to start.

        :stability: experimental
        '''
        result = self._values.get("project")
        assert result is not None, "Required property 'project' is missing"
        return typing.cast(_IProject_6da8803e, result)

    @builtins.property
    def environment_variables_override(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, _BuildEnvironmentVariable_00095c97]]:
        '''(experimental) A set of environment variables to be used for this build only.

        :default: - the latest environment variables already defined in the build project.

        :stability: experimental
        '''
        result = self._values.get("environment_variables_override")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, _BuildEnvironmentVariable_00095c97]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CodeBuildStartBuildProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.CommonEcsRunTaskProps",
    jsii_struct_bases=[],
    name_mapping={
        "cluster": "cluster",
        "task_definition": "taskDefinition",
        "container_overrides": "containerOverrides",
        "integration_pattern": "integrationPattern",
    },
)
class CommonEcsRunTaskProps:
    def __init__(
        self,
        *,
        cluster: _ICluster_42c4ec1a,
        task_definition: _TaskDefinition_c0dacfb4,
        container_overrides: typing.Optional[typing.Sequence[typing.Union["ContainerOverride", typing.Dict[builtins.str, typing.Any]]]] = None,
        integration_pattern: typing.Optional[_ServiceIntegrationPattern_5581ee88] = None,
    ) -> None:
        '''(experimental) Basic properties for ECS Tasks.

        :param cluster: (experimental) The topic to run the task on.
        :param task_definition: (experimental) Task Definition used for running tasks in the service. Note: this must be TaskDefinition, and not ITaskDefinition, as it requires properties that are not known for imported task definitions
        :param container_overrides: (experimental) Container setting overrides. Key is the name of the container to override, value is the values you want to override. Default: - No overrides
        :param integration_pattern: (experimental) The service integration pattern indicates different ways to call RunTask in ECS. The valid value for Lambda is FIRE_AND_FORGET, SYNC and WAIT_FOR_TASK_TOKEN. Default: FIRE_AND_FORGET

        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_ecs as ecs
            from monocdk import aws_stepfunctions as stepfunctions
            from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
            
            # cluster: ecs.Cluster
            # container_definition: ecs.ContainerDefinition
            # task_definition: ecs.TaskDefinition
            
            common_ecs_run_task_props = stepfunctions_tasks.CommonEcsRunTaskProps(
                cluster=cluster,
                task_definition=task_definition,
            
                # the properties below are optional
                container_overrides=[stepfunctions_tasks.ContainerOverride(
                    container_definition=container_definition,
            
                    # the properties below are optional
                    command=["command"],
                    cpu=123,
                    environment=[stepfunctions_tasks.TaskEnvironmentVariable(
                        name="name",
                        value="value"
                    )],
                    memory_limit=123,
                    memory_reservation=123
                )],
                integration_pattern=stepfunctions.ServiceIntegrationPattern.FIRE_AND_FORGET
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1f186f0a4b0ad92412e4de2a554d25c2dd32d3f4ab3344c8e969f53c92e97c08)
            check_type(argname="argument cluster", value=cluster, expected_type=type_hints["cluster"])
            check_type(argname="argument task_definition", value=task_definition, expected_type=type_hints["task_definition"])
            check_type(argname="argument container_overrides", value=container_overrides, expected_type=type_hints["container_overrides"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "cluster": cluster,
            "task_definition": task_definition,
        }
        if container_overrides is not None:
            self._values["container_overrides"] = container_overrides
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern

    @builtins.property
    def cluster(self) -> _ICluster_42c4ec1a:
        '''(experimental) The topic to run the task on.

        :stability: experimental
        '''
        result = self._values.get("cluster")
        assert result is not None, "Required property 'cluster' is missing"
        return typing.cast(_ICluster_42c4ec1a, result)

    @builtins.property
    def task_definition(self) -> _TaskDefinition_c0dacfb4:
        '''(experimental) Task Definition used for running tasks in the service.

        Note: this must be TaskDefinition, and not ITaskDefinition,
        as it requires properties that are not known for imported task definitions

        :stability: experimental
        '''
        result = self._values.get("task_definition")
        assert result is not None, "Required property 'task_definition' is missing"
        return typing.cast(_TaskDefinition_c0dacfb4, result)

    @builtins.property
    def container_overrides(self) -> typing.Optional[typing.List["ContainerOverride"]]:
        '''(experimental) Container setting overrides.

        Key is the name of the container to override, value is the
        values you want to override.

        :default: - No overrides

        :stability: experimental
        '''
        result = self._values.get("container_overrides")
        return typing.cast(typing.Optional[typing.List["ContainerOverride"]], result)

    @builtins.property
    def integration_pattern(
        self,
    ) -> typing.Optional[_ServiceIntegrationPattern_5581ee88]:
        '''(experimental) The service integration pattern indicates different ways to call RunTask in ECS.

        The valid value for Lambda is FIRE_AND_FORGET, SYNC and WAIT_FOR_TASK_TOKEN.

        :default: FIRE_AND_FORGET

        :stability: experimental
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_ServiceIntegrationPattern_5581ee88], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CommonEcsRunTaskProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="monocdk.aws_stepfunctions_tasks.CompressionType")
class CompressionType(enum.Enum):
    '''(experimental) Compression type of the data.

    :stability: experimental
    '''

    NONE = "NONE"
    '''(experimental) None compression type.

    :stability: experimental
    '''
    GZIP = "GZIP"
    '''(experimental) Gzip compression type.

    :stability: experimental
    '''


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.ContainerDefinitionConfig",
    jsii_struct_bases=[],
    name_mapping={"parameters": "parameters"},
)
class ContainerDefinitionConfig:
    def __init__(
        self,
        *,
        parameters: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    ) -> None:
        '''(experimental) Configuration options for the ContainerDefinition.

        :param parameters: (experimental) Additional parameters to pass to the base task. Default: - No additional parameters passed

        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
            
            # parameters: Any
            
            container_definition_config = stepfunctions_tasks.ContainerDefinitionConfig(
                parameters={
                    "parameters_key": parameters
                }
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__383968e7c273fd817450b495f2dddceb1d518bd8349567660d1a594589265f7a)
            check_type(argname="argument parameters", value=parameters, expected_type=type_hints["parameters"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if parameters is not None:
            self._values["parameters"] = parameters

    @builtins.property
    def parameters(self) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) Additional parameters to pass to the base task.

        :default: - No additional parameters passed

        :stability: experimental
        '''
        result = self._values.get("parameters")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerDefinitionConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.ContainerDefinitionOptions",
    jsii_struct_bases=[],
    name_mapping={
        "container_host_name": "containerHostName",
        "environment_variables": "environmentVariables",
        "image": "image",
        "mode": "mode",
        "model_package_name": "modelPackageName",
        "model_s3_location": "modelS3Location",
    },
)
class ContainerDefinitionOptions:
    def __init__(
        self,
        *,
        container_host_name: typing.Optional[builtins.str] = None,
        environment_variables: typing.Optional[_TaskInput_71ab46f6] = None,
        image: typing.Optional["DockerImage"] = None,
        mode: typing.Optional["Mode"] = None,
        model_package_name: typing.Optional[builtins.str] = None,
        model_s3_location: typing.Optional["S3Location"] = None,
    ) -> None:
        '''(experimental) Properties to define a ContainerDefinition.

        :param container_host_name: (experimental) This parameter is ignored for models that contain only a PrimaryContainer. When a ContainerDefinition is part of an inference pipeline, the value of the parameter uniquely identifies the container for the purposes of logging and metrics. Default: - None
        :param environment_variables: (experimental) The environment variables to set in the Docker container. Default: - No variables
        :param image: (experimental) The Amazon EC2 Container Registry (Amazon ECR) path where inference code is stored. Default: - None
        :param mode: (experimental) Defines how many models the container hosts. Default: - Mode.SINGLE_MODEL
        :param model_package_name: (experimental) The name or Amazon Resource Name (ARN) of the model package to use to create the model. Default: - None
        :param model_s3_location: (experimental) The S3 path where the model artifacts, which result from model training, are stored. This path must point to a single gzip compressed tar archive (.tar.gz suffix). The S3 path is required for Amazon SageMaker built-in algorithms, but not if you use your own algorithms. Default: - None

        :see: https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_ContainerDefinition.html
        :stability: experimental
        :exampleMetadata: infused

        Example::

            tasks.SageMakerCreateModel(self, "Sagemaker",
                model_name="MyModel",
                primary_container=tasks.ContainerDefinition(
                    image=tasks.DockerImage.from_json_expression(sfn.JsonPath.string_at("$.Model.imageName")),
                    mode=tasks.Mode.SINGLE_MODEL,
                    model_s3_location=tasks.S3Location.from_json_expression("$.TrainingJob.ModelArtifacts.S3ModelArtifacts")
                )
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__abc88b0def593b1547be3a29aab0de06896ad69a0d5e3c866aa98f4871cecca3)
            check_type(argname="argument container_host_name", value=container_host_name, expected_type=type_hints["container_host_name"])
            check_type(argname="argument environment_variables", value=environment_variables, expected_type=type_hints["environment_variables"])
            check_type(argname="argument image", value=image, expected_type=type_hints["image"])
            check_type(argname="argument mode", value=mode, expected_type=type_hints["mode"])
            check_type(argname="argument model_package_name", value=model_package_name, expected_type=type_hints["model_package_name"])
            check_type(argname="argument model_s3_location", value=model_s3_location, expected_type=type_hints["model_s3_location"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if container_host_name is not None:
            self._values["container_host_name"] = container_host_name
        if environment_variables is not None:
            self._values["environment_variables"] = environment_variables
        if image is not None:
            self._values["image"] = image
        if mode is not None:
            self._values["mode"] = mode
        if model_package_name is not None:
            self._values["model_package_name"] = model_package_name
        if model_s3_location is not None:
            self._values["model_s3_location"] = model_s3_location

    @builtins.property
    def container_host_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) This parameter is ignored for models that contain only a PrimaryContainer.

        When a ContainerDefinition is part of an inference pipeline,
        the value of the parameter uniquely identifies the container for the purposes of logging and metrics.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("container_host_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def environment_variables(self) -> typing.Optional[_TaskInput_71ab46f6]:
        '''(experimental) The environment variables to set in the Docker container.

        :default: - No variables

        :stability: experimental
        '''
        result = self._values.get("environment_variables")
        return typing.cast(typing.Optional[_TaskInput_71ab46f6], result)

    @builtins.property
    def image(self) -> typing.Optional["DockerImage"]:
        '''(experimental) The Amazon EC2 Container Registry (Amazon ECR) path where inference code is stored.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("image")
        return typing.cast(typing.Optional["DockerImage"], result)

    @builtins.property
    def mode(self) -> typing.Optional["Mode"]:
        '''(experimental) Defines how many models the container hosts.

        :default: - Mode.SINGLE_MODEL

        :stability: experimental
        '''
        result = self._values.get("mode")
        return typing.cast(typing.Optional["Mode"], result)

    @builtins.property
    def model_package_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) The name or Amazon Resource Name (ARN) of the model package to use to create the model.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("model_package_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def model_s3_location(self) -> typing.Optional["S3Location"]:
        '''(experimental) The S3 path where the model artifacts, which result from model training, are stored.

        This path must point to a single gzip compressed tar archive (.tar.gz suffix).
        The S3 path is required for Amazon SageMaker built-in algorithms, but not if you use your own algorithms.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("model_s3_location")
        return typing.cast(typing.Optional["S3Location"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerDefinitionOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.ContainerOverride",
    jsii_struct_bases=[],
    name_mapping={
        "container_definition": "containerDefinition",
        "command": "command",
        "cpu": "cpu",
        "environment": "environment",
        "memory_limit": "memoryLimit",
        "memory_reservation": "memoryReservation",
    },
)
class ContainerOverride:
    def __init__(
        self,
        *,
        container_definition: _ContainerDefinition_7934d1e1,
        command: typing.Optional[typing.Sequence[builtins.str]] = None,
        cpu: typing.Optional[jsii.Number] = None,
        environment: typing.Optional[typing.Sequence[typing.Union["TaskEnvironmentVariable", typing.Dict[builtins.str, typing.Any]]]] = None,
        memory_limit: typing.Optional[jsii.Number] = None,
        memory_reservation: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''(experimental) A list of container overrides that specify the name of a container and the overrides it should receive.

        :param container_definition: (experimental) Name of the container inside the task definition.
        :param command: (experimental) Command to run inside the container. Default: - Default command from the Docker image or the task definition
        :param cpu: (experimental) The number of cpu units reserved for the container. Default: - The default value from the task definition.
        :param environment: (experimental) The environment variables to send to the container. You can add new environment variables, which are added to the container at launch, or you can override the existing environment variables from the Docker image or the task definition. Default: - The existing environment variables from the Docker image or the task definition
        :param memory_limit: (experimental) The hard limit (in MiB) of memory to present to the container. Default: - The default value from the task definition.
        :param memory_reservation: (experimental) The soft limit (in MiB) of memory to reserve for the container. Default: - The default value from the task definition.

        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_ecs as ecs
            from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
            
            # container_definition: ecs.ContainerDefinition
            
            container_override = stepfunctions_tasks.ContainerOverride(
                container_definition=container_definition,
            
                # the properties below are optional
                command=["command"],
                cpu=123,
                environment=[stepfunctions_tasks.TaskEnvironmentVariable(
                    name="name",
                    value="value"
                )],
                memory_limit=123,
                memory_reservation=123
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__686adc5122dbcb831fcd730a331141f18e31185ba78eb385fdfdc2f9b86d7aba)
            check_type(argname="argument container_definition", value=container_definition, expected_type=type_hints["container_definition"])
            check_type(argname="argument command", value=command, expected_type=type_hints["command"])
            check_type(argname="argument cpu", value=cpu, expected_type=type_hints["cpu"])
            check_type(argname="argument environment", value=environment, expected_type=type_hints["environment"])
            check_type(argname="argument memory_limit", value=memory_limit, expected_type=type_hints["memory_limit"])
            check_type(argname="argument memory_reservation", value=memory_reservation, expected_type=type_hints["memory_reservation"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "container_definition": container_definition,
        }
        if command is not None:
            self._values["command"] = command
        if cpu is not None:
            self._values["cpu"] = cpu
        if environment is not None:
            self._values["environment"] = environment
        if memory_limit is not None:
            self._values["memory_limit"] = memory_limit
        if memory_reservation is not None:
            self._values["memory_reservation"] = memory_reservation

    @builtins.property
    def container_definition(self) -> _ContainerDefinition_7934d1e1:
        '''(experimental) Name of the container inside the task definition.

        :stability: experimental
        '''
        result = self._values.get("container_definition")
        assert result is not None, "Required property 'container_definition' is missing"
        return typing.cast(_ContainerDefinition_7934d1e1, result)

    @builtins.property
    def command(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) Command to run inside the container.

        :default: - Default command from the Docker image or the task definition

        :stability: experimental
        '''
        result = self._values.get("command")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def cpu(self) -> typing.Optional[jsii.Number]:
        '''(experimental) The number of cpu units reserved for the container.

        :default: - The default value from the task definition.

        :stability: experimental
        '''
        result = self._values.get("cpu")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def environment(self) -> typing.Optional[typing.List["TaskEnvironmentVariable"]]:
        '''(experimental) The environment variables to send to the container.

        You can add new environment variables, which are added to the container at launch,
        or you can override the existing environment variables from the Docker image or the task definition.

        :default: - The existing environment variables from the Docker image or the task definition

        :stability: experimental
        '''
        result = self._values.get("environment")
        return typing.cast(typing.Optional[typing.List["TaskEnvironmentVariable"]], result)

    @builtins.property
    def memory_limit(self) -> typing.Optional[jsii.Number]:
        '''(experimental) The hard limit (in MiB) of memory to present to the container.

        :default: - The default value from the task definition.

        :stability: experimental
        '''
        result = self._values.get("memory_limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def memory_reservation(self) -> typing.Optional[jsii.Number]:
        '''(experimental) The soft limit (in MiB) of memory to reserve for the container.

        :default: - The default value from the task definition.

        :stability: experimental
        '''
        result = self._values.get("memory_reservation")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerOverride(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.ContainerOverrides",
    jsii_struct_bases=[],
    name_mapping={
        "command": "command",
        "environment": "environment",
        "gpu_count": "gpuCount",
        "instance_type": "instanceType",
        "memory": "memory",
        "vcpus": "vcpus",
    },
)
class ContainerOverrides:
    def __init__(
        self,
        *,
        command: typing.Optional[typing.Sequence[builtins.str]] = None,
        environment: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        gpu_count: typing.Optional[jsii.Number] = None,
        instance_type: typing.Optional[_InstanceType_072ad323] = None,
        memory: typing.Optional[jsii.Number] = None,
        vcpus: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''(experimental) The overrides that should be sent to a container.

        :param command: (experimental) The command to send to the container that overrides the default command from the Docker image or the job definition. Default: - No command overrides
        :param environment: (experimental) The environment variables to send to the container. You can add new environment variables, which are added to the container at launch, or you can override the existing environment variables from the Docker image or the job definition. Default: - No environment overrides
        :param gpu_count: (experimental) The number of physical GPUs to reserve for the container. The number of GPUs reserved for all containers in a job should not exceed the number of available GPUs on the compute resource that the job is launched on. Default: - No GPU reservation
        :param instance_type: (experimental) The instance type to use for a multi-node parallel job. This parameter is not valid for single-node container jobs. Default: - No instance type overrides
        :param memory: (experimental) The number of MiB of memory reserved for the job. This value overrides the value set in the job definition. Default: - No memory overrides
        :param vcpus: (experimental) The number of vCPUs to reserve for the container. This value overrides the value set in the job definition. Default: - No vCPUs overrides

        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_ec2 as ec2
            from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
            
            # instance_type: ec2.InstanceType
            
            container_overrides = stepfunctions_tasks.ContainerOverrides(
                command=["command"],
                environment={
                    "environment_key": "environment"
                },
                gpu_count=123,
                instance_type=instance_type,
                memory=123,
                vcpus=123
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__df353834bed53580f81dbf38a41e1228045a40fc4ce60c0d509fadeb7287c654)
            check_type(argname="argument command", value=command, expected_type=type_hints["command"])
            check_type(argname="argument environment", value=environment, expected_type=type_hints["environment"])
            check_type(argname="argument gpu_count", value=gpu_count, expected_type=type_hints["gpu_count"])
            check_type(argname="argument instance_type", value=instance_type, expected_type=type_hints["instance_type"])
            check_type(argname="argument memory", value=memory, expected_type=type_hints["memory"])
            check_type(argname="argument vcpus", value=vcpus, expected_type=type_hints["vcpus"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if command is not None:
            self._values["command"] = command
        if environment is not None:
            self._values["environment"] = environment
        if gpu_count is not None:
            self._values["gpu_count"] = gpu_count
        if instance_type is not None:
            self._values["instance_type"] = instance_type
        if memory is not None:
            self._values["memory"] = memory
        if vcpus is not None:
            self._values["vcpus"] = vcpus

    @builtins.property
    def command(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) The command to send to the container that overrides the default command from the Docker image or the job definition.

        :default: - No command overrides

        :stability: experimental
        '''
        result = self._values.get("command")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def environment(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''(experimental) The environment variables to send to the container.

        You can add new environment variables, which are added to the container
        at launch, or you can override the existing environment variables from
        the Docker image or the job definition.

        :default: - No environment overrides

        :stability: experimental
        '''
        result = self._values.get("environment")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def gpu_count(self) -> typing.Optional[jsii.Number]:
        '''(experimental) The number of physical GPUs to reserve for the container.

        The number of GPUs reserved for all containers in a job
        should not exceed the number of available GPUs on the compute
        resource that the job is launched on.

        :default: - No GPU reservation

        :stability: experimental
        '''
        result = self._values.get("gpu_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def instance_type(self) -> typing.Optional[_InstanceType_072ad323]:
        '''(experimental) The instance type to use for a multi-node parallel job.

        This parameter is not valid for single-node container jobs.

        :default: - No instance type overrides

        :stability: experimental
        '''
        result = self._values.get("instance_type")
        return typing.cast(typing.Optional[_InstanceType_072ad323], result)

    @builtins.property
    def memory(self) -> typing.Optional[jsii.Number]:
        '''(experimental) The number of MiB of memory reserved for the job.

        This value overrides the value set in the job definition.

        :default: - No memory overrides

        :stability: experimental
        '''
        result = self._values.get("memory")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def vcpus(self) -> typing.Optional[jsii.Number]:
        '''(experimental) The number of vCPUs to reserve for the container.

        This value overrides the value set in the job definition.

        :default: - No vCPUs overrides

        :stability: experimental
        '''
        result = self._values.get("vcpus")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerOverrides(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.DataSource",
    jsii_struct_bases=[],
    name_mapping={"s3_data_source": "s3DataSource"},
)
class DataSource:
    def __init__(
        self,
        *,
        s3_data_source: typing.Union["S3DataSource", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''(experimental) Location of the channel data.

        :param s3_data_source: (experimental) S3 location of the data source that is associated with a channel.

        :stability: experimental
        :exampleMetadata: infused

        Example::

            tasks.SageMakerCreateTrainingJob(self, "TrainSagemaker",
                training_job_name=sfn.JsonPath.string_at("$.JobName"),
                algorithm_specification=dynamodb.aws_stepfunctions_tasks.AlgorithmSpecification(
                    algorithm_name="BlazingText",
                    training_input_mode=tasks.InputMode.FILE
                ),
                input_data_config=[dynamodb.aws_stepfunctions_tasks.Channel(
                    channel_name="train",
                    data_source=dynamodb.aws_stepfunctions_tasks.DataSource(
                        s3_data_source=dynamodb.aws_stepfunctions_tasks.S3DataSource(
                            s3_data_type=tasks.S3DataType.S3_PREFIX,
                            s3_location=tasks.S3Location.from_json_expression("$.S3Bucket")
                        )
                    )
                )],
                output_data_config=dynamodb.aws_stepfunctions_tasks.OutputDataConfig(
                    s3_output_location=tasks.S3Location.from_bucket(s3.Bucket.from_bucket_name(self, "Bucket", "mybucket"), "myoutputpath")
                ),
                resource_config=dynamodb.aws_stepfunctions_tasks.ResourceConfig(
                    instance_count=1,
                    instance_type=ec2.InstanceType(sfn.JsonPath.string_at("$.InstanceType")),
                    volume_size=Size.gibibytes(50)
                ),  # optional: default is 1 instance of EC2 `M4.XLarge` with `10GB` volume
                stopping_condition=dynamodb.aws_stepfunctions_tasks.StoppingCondition(
                    max_runtime=Duration.hours(2)
                )
            )
        '''
        if isinstance(s3_data_source, dict):
            s3_data_source = S3DataSource(**s3_data_source)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__69771688b002fd56442cd1803873821bfaad2ca08127473634c63bf68add1f6a)
            check_type(argname="argument s3_data_source", value=s3_data_source, expected_type=type_hints["s3_data_source"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "s3_data_source": s3_data_source,
        }

    @builtins.property
    def s3_data_source(self) -> "S3DataSource":
        '''(experimental) S3 location of the data source that is associated with a channel.

        :stability: experimental
        '''
        result = self._values.get("s3_data_source")
        assert result is not None, "Required property 's3_data_source' is missing"
        return typing.cast("S3DataSource", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DataSource(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DockerImage(
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="monocdk.aws_stepfunctions_tasks.DockerImage",
):
    '''(experimental) Creates ``IDockerImage`` instances.

    :stability: experimental
    :exampleMetadata: infused

    Example::

        tasks.SageMakerCreateModel(self, "Sagemaker",
            model_name="MyModel",
            primary_container=tasks.ContainerDefinition(
                image=tasks.DockerImage.from_json_expression(sfn.JsonPath.string_at("$.Model.imageName")),
                mode=tasks.Mode.SINGLE_MODEL,
                model_s3_location=tasks.S3Location.from_json_expression("$.TrainingJob.ModelArtifacts.S3ModelArtifacts")
            )
        )
    '''

    def __init__(self) -> None:
        '''
        :stability: experimental
        '''
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="fromAsset")
    @builtins.classmethod
    def from_asset(
        cls,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        directory: builtins.str,
        build_args: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        file: typing.Optional[builtins.str] = None,
        invalidation: typing.Optional[typing.Union[_DockerImageAssetInvalidationOptions_e5375707, typing.Dict[builtins.str, typing.Any]]] = None,
        network_mode: typing.Optional[_NetworkMode_2d19607e] = None,
        platform: typing.Optional[_Platform_5ed8dbaf] = None,
        repository_name: typing.Optional[builtins.str] = None,
        target: typing.Optional[builtins.str] = None,
        extra_hash: typing.Optional[builtins.str] = None,
        exclude: typing.Optional[typing.Sequence[builtins.str]] = None,
        follow: typing.Optional[_FollowMode_98b05cc5] = None,
        ignore_mode: typing.Optional[_IgnoreMode_31d8bf46] = None,
        follow_symlinks: typing.Optional[_SymlinkFollowMode_abf4527a] = None,
    ) -> "DockerImage":
        '''(experimental) Reference a Docker image that is provided as an Asset in the current app.

        :param scope: the scope in which to create the Asset.
        :param id: the ID for the asset in the construct tree.
        :param directory: (experimental) The directory where the Dockerfile is stored. Any directory inside with a name that matches the CDK output folder (cdk.out by default) will be excluded from the asset
        :param build_args: (experimental) Build args to pass to the ``docker build`` command. Since Docker build arguments are resolved before deployment, keys and values cannot refer to unresolved tokens (such as ``lambda.functionArn`` or ``queue.queueUrl``). Default: - no build args are passed
        :param file: (experimental) Path to the Dockerfile (relative to the directory). Default: 'Dockerfile'
        :param invalidation: (experimental) Options to control which parameters are used to invalidate the asset hash. Default: - hash all parameters
        :param network_mode: (experimental) Networking mode for the RUN commands during build. Support docker API 1.25+. Default: - no networking mode specified (the default networking mode ``NetworkMode.DEFAULT`` will be used)
        :param platform: (experimental) Platform to build for. *Requires Docker Buildx*. Default: - no platform specified (the current machine architecture will be used)
        :param repository_name: (deprecated) ECR repository name. Specify this property if you need to statically address the image, e.g. from a Kubernetes Pod. Note, this is only the repository name, without the registry and the tag parts. Default: - the default ECR repository for CDK assets
        :param target: (experimental) Docker target to build to. Default: - no target
        :param extra_hash: (deprecated) Extra information to encode into the fingerprint (e.g. build instructions and other inputs). Default: - hash is only based on source content
        :param exclude: (deprecated) Glob patterns to exclude from the copy. Default: nothing is excluded
        :param follow: (deprecated) A strategy for how to handle symlinks. Default: Never
        :param ignore_mode: (deprecated) The ignore behavior to use for exclude patterns. Default: - GLOB for file assets, DOCKER or GLOB for docker assets depending on whether the '
        :param follow_symlinks: (experimental) A strategy for how to handle symlinks. Default: SymlinkFollowMode.NEVER

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__099630af2705e74e3c4180fbd5f5ae3ed64915ed291a581ae6f2b2122dac81d9)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _DockerImageAssetProps_beaa8517(
            directory=directory,
            build_args=build_args,
            file=file,
            invalidation=invalidation,
            network_mode=network_mode,
            platform=platform,
            repository_name=repository_name,
            target=target,
            extra_hash=extra_hash,
            exclude=exclude,
            follow=follow,
            ignore_mode=ignore_mode,
            follow_symlinks=follow_symlinks,
        )

        return typing.cast("DockerImage", jsii.sinvoke(cls, "fromAsset", [scope, id, props]))

    @jsii.member(jsii_name="fromEcrRepository")
    @builtins.classmethod
    def from_ecr_repository(
        cls,
        repository: _IRepository_8b4d2894,
        tag_or_digest: typing.Optional[builtins.str] = None,
    ) -> "DockerImage":
        '''(experimental) Reference a Docker image stored in an ECR repository.

        :param repository: the ECR repository where the image is hosted.
        :param tag_or_digest: an optional tag or digest (digests must start with ``sha256:``).

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b2a0dc1c79098867beb966c8800d37a1d3655d5cc440124678866a1bcc6e6828)
            check_type(argname="argument repository", value=repository, expected_type=type_hints["repository"])
            check_type(argname="argument tag_or_digest", value=tag_or_digest, expected_type=type_hints["tag_or_digest"])
        return typing.cast("DockerImage", jsii.sinvoke(cls, "fromEcrRepository", [repository, tag_or_digest]))

    @jsii.member(jsii_name="fromJsonExpression")
    @builtins.classmethod
    def from_json_expression(
        cls,
        expression: builtins.str,
        allow_any_ecr_image_pull: typing.Optional[builtins.bool] = None,
    ) -> "DockerImage":
        '''(experimental) Reference a Docker image which URI is obtained from the task's input.

        :param expression: the JSON path expression with the task input.
        :param allow_any_ecr_image_pull: whether ECR access should be permitted (set to ``false`` if the image will never be in ECR).

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b06ee298eec94a8601b63b4ca77c8e3ddf45343f2de7e03a85889b67e8bed9fc)
            check_type(argname="argument expression", value=expression, expected_type=type_hints["expression"])
            check_type(argname="argument allow_any_ecr_image_pull", value=allow_any_ecr_image_pull, expected_type=type_hints["allow_any_ecr_image_pull"])
        return typing.cast("DockerImage", jsii.sinvoke(cls, "fromJsonExpression", [expression, allow_any_ecr_image_pull]))

    @jsii.member(jsii_name="fromRegistry")
    @builtins.classmethod
    def from_registry(cls, image_uri: builtins.str) -> "DockerImage":
        '''(experimental) Reference a Docker image by it's URI.

        When referencing ECR images, prefer using ``inEcr``.

        :param image_uri: the URI to the docker image.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c393b1773eb71269e52749d1ffa68f6dd910779301fef716d99766ca0553f48d)
            check_type(argname="argument image_uri", value=image_uri, expected_type=type_hints["image_uri"])
        return typing.cast("DockerImage", jsii.sinvoke(cls, "fromRegistry", [image_uri]))

    @jsii.member(jsii_name="bind")
    @abc.abstractmethod
    def bind(self, task: "ISageMakerTask") -> "DockerImageConfig":
        '''(experimental) Called when the image is used by a SageMaker task.

        :param task: -

        :stability: experimental
        '''
        ...


class _DockerImageProxy(DockerImage):
    @jsii.member(jsii_name="bind")
    def bind(self, task: "ISageMakerTask") -> "DockerImageConfig":
        '''(experimental) Called when the image is used by a SageMaker task.

        :param task: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__607df61fcc915521d92a5ad608280a7e6b92845f15c09954bd98871f861e0600)
            check_type(argname="argument task", value=task, expected_type=type_hints["task"])
        return typing.cast("DockerImageConfig", jsii.invoke(self, "bind", [task]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, DockerImage).__jsii_proxy_class__ = lambda : _DockerImageProxy


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.DockerImageConfig",
    jsii_struct_bases=[],
    name_mapping={"image_uri": "imageUri"},
)
class DockerImageConfig:
    def __init__(self, *, image_uri: builtins.str) -> None:
        '''(experimental) Configuration for a using Docker image.

        :param image_uri: (experimental) The fully qualified URI of the Docker image.

        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
            
            docker_image_config = stepfunctions_tasks.DockerImageConfig(
                image_uri="imageUri"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7e9d16424cdb7ff9f2e0d63bdee7e5ece9ffb4277af2de9c7f12dbe7395e2873)
            check_type(argname="argument image_uri", value=image_uri, expected_type=type_hints["image_uri"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "image_uri": image_uri,
        }

    @builtins.property
    def image_uri(self) -> builtins.str:
        '''(experimental) The fully qualified URI of the Docker image.

        :stability: experimental
        '''
        result = self._values.get("image_uri")
        assert result is not None, "Required property 'image_uri' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DockerImageConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DynamoAttributeValue(
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.DynamoAttributeValue",
):
    '''(experimental) Represents the data for an attribute.

    Each attribute value is described as a name-value pair.
    The name is the data type, and the value is the data itself.

    :see: https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_AttributeValue.html
    :stability: experimental
    :exampleMetadata: infused

    Example::

        # my_table: dynamodb.Table
        
        tasks.DynamoDeleteItem(self, "DeleteItem",
            key={"MessageId": tasks.DynamoAttributeValue.from_string("message-007")},
            table=my_table,
            result_path=sfn.JsonPath.DISCARD
        )
    '''

    @jsii.member(jsii_name="booleanFromJsonPath")
    @builtins.classmethod
    def boolean_from_json_path(cls, value: builtins.str) -> "DynamoAttributeValue":
        '''(experimental) Sets an attribute of type Boolean from state input through Json path.

        For example:  "BOOL": true

        :param value: Json path that specifies state input to be used.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eb770b2bba955477ff060791cdf3df4d172abbc77427fae130ed43e52246a3bc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("DynamoAttributeValue", jsii.sinvoke(cls, "booleanFromJsonPath", [value]))

    @jsii.member(jsii_name="fromBinary")
    @builtins.classmethod
    def from_binary(cls, value: builtins.str) -> "DynamoAttributeValue":
        '''(experimental) Sets an attribute of type Binary.

        For example:  "B": "dGhpcyB0ZXh0IGlzIGJhc2U2NC1lbmNvZGVk"

        :param value: base-64 encoded string.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__17a2eba24d2cfa55c71d47a62a2aa4bfcb8eb01558f8741bd6322456a32af345)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("DynamoAttributeValue", jsii.sinvoke(cls, "fromBinary", [value]))

    @jsii.member(jsii_name="fromBinarySet")
    @builtins.classmethod
    def from_binary_set(
        cls,
        value: typing.Sequence[builtins.str],
    ) -> "DynamoAttributeValue":
        '''(experimental) Sets an attribute of type Binary Set.

        For example:  "BS": ["U3Vubnk=", "UmFpbnk=", "U25vd3k="]

        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5d792c0556d9ef30b55c5807bba9752c6fea4dea6821b3d45af2c5f453ba411c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("DynamoAttributeValue", jsii.sinvoke(cls, "fromBinarySet", [value]))

    @jsii.member(jsii_name="fromBoolean")
    @builtins.classmethod
    def from_boolean(cls, value: builtins.bool) -> "DynamoAttributeValue":
        '''(experimental) Sets an attribute of type Boolean.

        For example:  "BOOL": true

        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b6c30781d30eebf22a891712e819d5cbecaafb581375971485191423f62b5597)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("DynamoAttributeValue", jsii.sinvoke(cls, "fromBoolean", [value]))

    @jsii.member(jsii_name="fromList")
    @builtins.classmethod
    def from_list(
        cls,
        value: typing.Sequence["DynamoAttributeValue"],
    ) -> "DynamoAttributeValue":
        '''(experimental) Sets an attribute of type List.

        For example:  "L": [ {"S": "Cookies"} , {"S": "Coffee"}, {"N", "3.14159"}]

        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__301630a08247dfe2512e30693066bc3613375f3d11f3ebdd489ab4aa15f4b858)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("DynamoAttributeValue", jsii.sinvoke(cls, "fromList", [value]))

    @jsii.member(jsii_name="fromMap")
    @builtins.classmethod
    def from_map(
        cls,
        value: typing.Mapping[builtins.str, "DynamoAttributeValue"],
    ) -> "DynamoAttributeValue":
        '''(experimental) Sets an attribute of type Map.

        For example:  "M": {"Name": {"S": "Joe"}, "Age": {"N": "35"}}

        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0edc34959a9d14105c75b076b843a04762d5f14ca8874d4d786ae55a7b12c972)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("DynamoAttributeValue", jsii.sinvoke(cls, "fromMap", [value]))

    @jsii.member(jsii_name="fromNull")
    @builtins.classmethod
    def from_null(cls, value: builtins.bool) -> "DynamoAttributeValue":
        '''(experimental) Sets an attribute of type Null.

        For example:  "NULL": true

        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__919bdbe2bc361af09b09786a220c7900a135c13f21b9e0182b36ea46e562e57a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("DynamoAttributeValue", jsii.sinvoke(cls, "fromNull", [value]))

    @jsii.member(jsii_name="fromNumber")
    @builtins.classmethod
    def from_number(cls, value: jsii.Number) -> "DynamoAttributeValue":
        '''(experimental) Sets a literal number.

        For example: 1234
        Numbers are sent across the network to DynamoDB as strings,
        to maximize compatibility across languages and libraries.
        However, DynamoDB treats them as number type attributes for mathematical operations.

        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1e3c5348e081b3c76abab63d78243006019c49f14795ef1c14c86d1df2f283c0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("DynamoAttributeValue", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromNumberSet")
    @builtins.classmethod
    def from_number_set(
        cls,
        value: typing.Sequence[jsii.Number],
    ) -> "DynamoAttributeValue":
        '''(experimental) Sets an attribute of type Number Set.

        For example:  "NS": ["42.2", "-19", "7.5", "3.14"]
        Numbers are sent across the network to DynamoDB as strings,
        to maximize compatibility across languages and libraries.
        However, DynamoDB treats them as number type attributes for mathematical operations.

        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__91c9ad98c9a6ef95576c0e09c8e425005bcbf3bc371017157841093787150b68)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("DynamoAttributeValue", jsii.sinvoke(cls, "fromNumberSet", [value]))

    @jsii.member(jsii_name="fromString")
    @builtins.classmethod
    def from_string(cls, value: builtins.str) -> "DynamoAttributeValue":
        '''(experimental) Sets an attribute of type String.

        For example:  "S": "Hello"
        Strings may be literal values or as JsonPath. Example values:

        - ``DynamoAttributeValue.fromString('someValue')``
        - ``DynamoAttributeValue.fromString(JsonPath.stringAt('$.bar'))``

        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4e7d42265baa8f8d9e3bf2abe9cab077bac05ecbc6c210b57e44a64aa263254d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("DynamoAttributeValue", jsii.sinvoke(cls, "fromString", [value]))

    @jsii.member(jsii_name="fromStringSet")
    @builtins.classmethod
    def from_string_set(
        cls,
        value: typing.Sequence[builtins.str],
    ) -> "DynamoAttributeValue":
        '''(experimental) Sets an attribute of type String Set.

        For example:  "SS": ["Giraffe", "Hippo" ,"Zebra"]

        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__246c1d8678c674960ad997104291fd7e95f84f830477ed92de09b26e902b8c12)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("DynamoAttributeValue", jsii.sinvoke(cls, "fromStringSet", [value]))

    @jsii.member(jsii_name="listFromJsonPath")
    @builtins.classmethod
    def list_from_json_path(cls, value: builtins.str) -> "DynamoAttributeValue":
        '''(experimental) Sets an attribute of type List.

        For example:  "L": [ {"S": "Cookies"} , {"S": "Coffee"}, {"S", "Veggies"}]

        :param value: Json path that specifies state input to be used.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6aa2cbf966d499423ad97bf52c406a9ec5706524bab966718e288c08a01cef20)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("DynamoAttributeValue", jsii.sinvoke(cls, "listFromJsonPath", [value]))

    @jsii.member(jsii_name="mapFromJsonPath")
    @builtins.classmethod
    def map_from_json_path(cls, value: builtins.str) -> "DynamoAttributeValue":
        '''(experimental) Sets an attribute of type Map.

        For example:  "M": {"Name": {"S": "Joe"}, "Age": {"N": "35"}}

        :param value: Json path that specifies state input to be used.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e64ca519e98b4d3d03964d5f9d54b88629f3ac5cca3d3f7f295d490f0862669a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("DynamoAttributeValue", jsii.sinvoke(cls, "mapFromJsonPath", [value]))

    @jsii.member(jsii_name="numberFromString")
    @builtins.classmethod
    def number_from_string(cls, value: builtins.str) -> "DynamoAttributeValue":
        '''(experimental) Sets an attribute of type Number.

        For example:  "N": "123.45"
        Numbers are sent across the network to DynamoDB as strings,
        to maximize compatibility across languages and libraries.
        However, DynamoDB treats them as number type attributes for mathematical operations.

        Numbers may be expressed as literal strings or as JsonPath

        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b4b1dac4f24d054ff9621ac3023e3b3c26e77d8774487c91da76f665ba6257e8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("DynamoAttributeValue", jsii.sinvoke(cls, "numberFromString", [value]))

    @jsii.member(jsii_name="numberSetFromStrings")
    @builtins.classmethod
    def number_set_from_strings(
        cls,
        value: typing.Sequence[builtins.str],
    ) -> "DynamoAttributeValue":
        '''(experimental) Sets an attribute of type Number Set.

        For example:  "NS": ["42.2", "-19", "7.5", "3.14"]
        Numbers are sent across the network to DynamoDB as strings,
        to maximize compatibility across languages and libraries.
        However, DynamoDB treats them as number type attributes for mathematical operations.

        Numbers may be expressed as literal strings or as JsonPath

        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__86563431d7adb5a2e8be11163965b252d7632bec663c8c0baf722a1a1fb6b087)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("DynamoAttributeValue", jsii.sinvoke(cls, "numberSetFromStrings", [value]))

    @jsii.member(jsii_name="toObject")
    def to_object(self) -> typing.Any:
        '''(experimental) Returns the DynamoDB attribute value.

        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.invoke(self, "toObject", []))

    @builtins.property
    @jsii.member(jsii_name="attributeValue")
    def attribute_value(self) -> typing.Any:
        '''(experimental) Represents the data for the attribute.

        Data can be
        i.e. "S": "Hello"

        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "attributeValue"))


@jsii.enum(jsii_type="monocdk.aws_stepfunctions_tasks.DynamoConsumedCapacity")
class DynamoConsumedCapacity(enum.Enum):
    '''(experimental) Determines the level of detail about provisioned throughput consumption that is returned.

    :stability: experimental
    '''

    INDEXES = "INDEXES"
    '''(experimental) The response includes the aggregate ConsumedCapacity for the operation, together with ConsumedCapacity for each table and secondary index that was accessed.

    :stability: experimental
    '''
    TOTAL = "TOTAL"
    '''(experimental) The response includes only the aggregate ConsumedCapacity for the operation.

    :stability: experimental
    '''
    NONE = "NONE"
    '''(experimental) No ConsumedCapacity details are included in the response.

    :stability: experimental
    '''


class DynamoDeleteItem(
    _TaskStateBase_c3080646,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.DynamoDeleteItem",
):
    '''(experimental) A StepFunctions task to call DynamoDeleteItem.

    :stability: experimental
    :exampleMetadata: infused

    Example::

        # my_table: dynamodb.Table
        
        tasks.DynamoDeleteItem(self, "DeleteItem",
            key={"MessageId": tasks.DynamoAttributeValue.from_string("message-007")},
            table=my_table,
            result_path=sfn.JsonPath.DISCARD
        )
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        key: typing.Mapping[builtins.str, DynamoAttributeValue],
        table: _ITable_24826f7e,
        condition_expression: typing.Optional[builtins.str] = None,
        expression_attribute_names: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        expression_attribute_values: typing.Optional[typing.Mapping[builtins.str, DynamoAttributeValue]] = None,
        return_consumed_capacity: typing.Optional[DynamoConsumedCapacity] = None,
        return_item_collection_metrics: typing.Optional["DynamoItemCollectionMetrics"] = None,
        return_values: typing.Optional["DynamoReturnValues"] = None,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param key: (experimental) Primary key of the item to retrieve. For the primary key, you must provide all of the attributes. For example, with a simple primary key, you only need to provide a value for the partition key. For a composite primary key, you must provide values for both the partition key and the sort key.
        :param table: (experimental) The name of the table containing the requested item.
        :param condition_expression: (experimental) A condition that must be satisfied in order for a conditional DeleteItem to succeed. Default: - No condition expression
        :param expression_attribute_names: (experimental) One or more substitution tokens for attribute names in an expression. Default: - No expression attribute names
        :param expression_attribute_values: (experimental) One or more values that can be substituted in an expression. Default: - No expression attribute values
        :param return_consumed_capacity: (experimental) Determines the level of detail about provisioned throughput consumption that is returned in the response. Default: DynamoConsumedCapacity.NONE
        :param return_item_collection_metrics: (experimental) Determines whether item collection metrics are returned. If set to SIZE, the response includes statistics about item collections, if any, that were modified during the operation are returned in the response. If set to NONE (the default), no statistics are returned. Default: DynamoItemCollectionMetrics.NONE
        :param return_values: (experimental) Use ReturnValues if you want to get the item attributes as they appeared before they were deleted. Default: DynamoReturnValues.NONE
        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__50c2b778c4c1620aeac0366e32b28097b565e90b0acf30493521474717155ed2)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = DynamoDeleteItemProps(
            key=key,
            table=table,
            condition_expression=condition_expression,
            expression_attribute_names=expression_attribute_names,
            expression_attribute_values=expression_attribute_values,
            return_consumed_capacity=return_consumed_capacity,
            return_item_collection_metrics=return_item_collection_metrics,
            return_values=return_values,
            comment=comment,
            heartbeat=heartbeat,
            input_path=input_path,
            integration_pattern=integration_pattern,
            output_path=output_path,
            result_path=result_path,
            result_selector=result_selector,
            timeout=timeout,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="taskMetrics")
    def _task_metrics(self) -> typing.Optional[_TaskMetricsConfig_5aaea59e]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[_TaskMetricsConfig_5aaea59e], jsii.get(self, "taskMetrics"))

    @builtins.property
    @jsii.member(jsii_name="taskPolicies")
    def _task_policies(self) -> typing.Optional[typing.List[_PolicyStatement_296fe8a3]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.List[_PolicyStatement_296fe8a3]], jsii.get(self, "taskPolicies"))


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.DynamoDeleteItemProps",
    jsii_struct_bases=[_TaskStateBaseProps_b13f6332],
    name_mapping={
        "comment": "comment",
        "heartbeat": "heartbeat",
        "input_path": "inputPath",
        "integration_pattern": "integrationPattern",
        "output_path": "outputPath",
        "result_path": "resultPath",
        "result_selector": "resultSelector",
        "timeout": "timeout",
        "key": "key",
        "table": "table",
        "condition_expression": "conditionExpression",
        "expression_attribute_names": "expressionAttributeNames",
        "expression_attribute_values": "expressionAttributeValues",
        "return_consumed_capacity": "returnConsumedCapacity",
        "return_item_collection_metrics": "returnItemCollectionMetrics",
        "return_values": "returnValues",
    },
)
class DynamoDeleteItemProps(_TaskStateBaseProps_b13f6332):
    def __init__(
        self,
        *,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
        key: typing.Mapping[builtins.str, DynamoAttributeValue],
        table: _ITable_24826f7e,
        condition_expression: typing.Optional[builtins.str] = None,
        expression_attribute_names: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        expression_attribute_values: typing.Optional[typing.Mapping[builtins.str, DynamoAttributeValue]] = None,
        return_consumed_capacity: typing.Optional[DynamoConsumedCapacity] = None,
        return_item_collection_metrics: typing.Optional["DynamoItemCollectionMetrics"] = None,
        return_values: typing.Optional["DynamoReturnValues"] = None,
    ) -> None:
        '''(experimental) Properties for DynamoDeleteItem Task.

        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None
        :param key: (experimental) Primary key of the item to retrieve. For the primary key, you must provide all of the attributes. For example, with a simple primary key, you only need to provide a value for the partition key. For a composite primary key, you must provide values for both the partition key and the sort key.
        :param table: (experimental) The name of the table containing the requested item.
        :param condition_expression: (experimental) A condition that must be satisfied in order for a conditional DeleteItem to succeed. Default: - No condition expression
        :param expression_attribute_names: (experimental) One or more substitution tokens for attribute names in an expression. Default: - No expression attribute names
        :param expression_attribute_values: (experimental) One or more values that can be substituted in an expression. Default: - No expression attribute values
        :param return_consumed_capacity: (experimental) Determines the level of detail about provisioned throughput consumption that is returned in the response. Default: DynamoConsumedCapacity.NONE
        :param return_item_collection_metrics: (experimental) Determines whether item collection metrics are returned. If set to SIZE, the response includes statistics about item collections, if any, that were modified during the operation are returned in the response. If set to NONE (the default), no statistics are returned. Default: DynamoItemCollectionMetrics.NONE
        :param return_values: (experimental) Use ReturnValues if you want to get the item attributes as they appeared before they were deleted. Default: DynamoReturnValues.NONE

        :stability: experimental
        :exampleMetadata: infused

        Example::

            # my_table: dynamodb.Table
            
            tasks.DynamoDeleteItem(self, "DeleteItem",
                key={"MessageId": tasks.DynamoAttributeValue.from_string("message-007")},
                table=my_table,
                result_path=sfn.JsonPath.DISCARD
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5c5b01d167c8c11d094ef327d09567d84cad84aacbcfba36494f6c9ad40503de)
            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
            check_type(argname="argument heartbeat", value=heartbeat, expected_type=type_hints["heartbeat"])
            check_type(argname="argument input_path", value=input_path, expected_type=type_hints["input_path"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
            check_type(argname="argument output_path", value=output_path, expected_type=type_hints["output_path"])
            check_type(argname="argument result_path", value=result_path, expected_type=type_hints["result_path"])
            check_type(argname="argument result_selector", value=result_selector, expected_type=type_hints["result_selector"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument table", value=table, expected_type=type_hints["table"])
            check_type(argname="argument condition_expression", value=condition_expression, expected_type=type_hints["condition_expression"])
            check_type(argname="argument expression_attribute_names", value=expression_attribute_names, expected_type=type_hints["expression_attribute_names"])
            check_type(argname="argument expression_attribute_values", value=expression_attribute_values, expected_type=type_hints["expression_attribute_values"])
            check_type(argname="argument return_consumed_capacity", value=return_consumed_capacity, expected_type=type_hints["return_consumed_capacity"])
            check_type(argname="argument return_item_collection_metrics", value=return_item_collection_metrics, expected_type=type_hints["return_item_collection_metrics"])
            check_type(argname="argument return_values", value=return_values, expected_type=type_hints["return_values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "table": table,
        }
        if comment is not None:
            self._values["comment"] = comment
        if heartbeat is not None:
            self._values["heartbeat"] = heartbeat
        if input_path is not None:
            self._values["input_path"] = input_path
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern
        if output_path is not None:
            self._values["output_path"] = output_path
        if result_path is not None:
            self._values["result_path"] = result_path
        if result_selector is not None:
            self._values["result_selector"] = result_selector
        if timeout is not None:
            self._values["timeout"] = timeout
        if condition_expression is not None:
            self._values["condition_expression"] = condition_expression
        if expression_attribute_names is not None:
            self._values["expression_attribute_names"] = expression_attribute_names
        if expression_attribute_values is not None:
            self._values["expression_attribute_values"] = expression_attribute_values
        if return_consumed_capacity is not None:
            self._values["return_consumed_capacity"] = return_consumed_capacity
        if return_item_collection_metrics is not None:
            self._values["return_item_collection_metrics"] = return_item_collection_metrics
        if return_values is not None:
            self._values["return_values"] = return_values

    @builtins.property
    def comment(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional description for this state.

        :default: - No comment

        :stability: experimental
        '''
        result = self._values.get("comment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def heartbeat(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the heartbeat.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("heartbeat")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def input_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select part of the state to be the input to this state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        input to be the empty object {}.

        :default: - The entire task input (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("input_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def integration_pattern(self) -> typing.Optional[_IntegrationPattern_fbb35786]:
        '''(experimental) AWS Step Functions integrates with services directly in the Amazon States Language.

        You can control these AWS services using service integration patterns

        :default:

        - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks.
        ``IntegrationPattern.RUN_JOB`` for the following exceptions:
        ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html#connect-wait-token
        :stability: experimental
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_IntegrationPattern_fbb35786], result)

    @builtins.property
    def output_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select select a portion of the state output to pass to the next state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        output to be the empty object {}.

        :default:

        - The entire JSON node determined by the state input, the task result,
        and resultPath is passed to the next state (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("output_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to indicate where to inject the state's output.

        May also be the special value JsonPath.DISCARD, which will cause the state's
        input to become its output.

        :default: - Replaces the entire input with the result (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("result_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied.

        You can use ResultSelector to create a payload with values that are static
        or selected from the state's raw result.

        :default: - None

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/input-output-inputpath-params.html#input-output-resultselector
        :stability: experimental
        '''
        result = self._values.get("result_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def timeout(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the state machine.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def key(self) -> typing.Mapping[builtins.str, DynamoAttributeValue]:
        '''(experimental) Primary key of the item to retrieve.

        For the primary key, you must provide all of the attributes.
        For example, with a simple primary key, you only need to provide a value for the partition key.
        For a composite primary key, you must provide values for both the partition key and the sort key.

        :see: https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_GetItem.html#DDB-GetItem-request-Key
        :stability: experimental
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(typing.Mapping[builtins.str, DynamoAttributeValue], result)

    @builtins.property
    def table(self) -> _ITable_24826f7e:
        '''(experimental) The name of the table containing the requested item.

        :stability: experimental
        '''
        result = self._values.get("table")
        assert result is not None, "Required property 'table' is missing"
        return typing.cast(_ITable_24826f7e, result)

    @builtins.property
    def condition_expression(self) -> typing.Optional[builtins.str]:
        '''(experimental) A condition that must be satisfied in order for a conditional DeleteItem to succeed.

        :default: - No condition expression

        :see: https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_DeleteItem.html#DDB-DeleteItem-request-ConditionExpression
        :stability: experimental
        '''
        result = self._values.get("condition_expression")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def expression_attribute_names(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''(experimental) One or more substitution tokens for attribute names in an expression.

        :default: - No expression attribute names

        :see: https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_DeleteItem.html#DDB-DeleteItem-request-ExpressionAttributeNames
        :stability: experimental
        '''
        result = self._values.get("expression_attribute_names")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def expression_attribute_values(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, DynamoAttributeValue]]:
        '''(experimental) One or more values that can be substituted in an expression.

        :default: - No expression attribute values

        :see: https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_DeleteItem.html#DDB-DeleteItem-request-ExpressionAttributeValues
        :stability: experimental
        '''
        result = self._values.get("expression_attribute_values")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, DynamoAttributeValue]], result)

    @builtins.property
    def return_consumed_capacity(self) -> typing.Optional[DynamoConsumedCapacity]:
        '''(experimental) Determines the level of detail about provisioned throughput consumption that is returned in the response.

        :default: DynamoConsumedCapacity.NONE

        :see: https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_DeleteItem.html#DDB-DeleteItem-request-ReturnConsumedCapacity
        :stability: experimental
        '''
        result = self._values.get("return_consumed_capacity")
        return typing.cast(typing.Optional[DynamoConsumedCapacity], result)

    @builtins.property
    def return_item_collection_metrics(
        self,
    ) -> typing.Optional["DynamoItemCollectionMetrics"]:
        '''(experimental) Determines whether item collection metrics are returned.

        If set to SIZE, the response includes statistics about item collections, if any,
        that were modified during the operation are returned in the response.
        If set to NONE (the default), no statistics are returned.

        :default: DynamoItemCollectionMetrics.NONE

        :stability: experimental
        '''
        result = self._values.get("return_item_collection_metrics")
        return typing.cast(typing.Optional["DynamoItemCollectionMetrics"], result)

    @builtins.property
    def return_values(self) -> typing.Optional["DynamoReturnValues"]:
        '''(experimental) Use ReturnValues if you want to get the item attributes as they appeared before they were deleted.

        :default: DynamoReturnValues.NONE

        :see: https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_DeleteItem.html#DDB-DeleteItem-request-ReturnValues
        :stability: experimental
        '''
        result = self._values.get("return_values")
        return typing.cast(typing.Optional["DynamoReturnValues"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DynamoDeleteItemProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DynamoGetItem(
    _TaskStateBase_c3080646,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.DynamoGetItem",
):
    '''(experimental) A StepFunctions task to call DynamoGetItem.

    :stability: experimental
    :exampleMetadata: infused

    Example::

        # my_table: dynamodb.Table
        
        tasks.DynamoGetItem(self, "Get Item",
            key={"message_id": tasks.DynamoAttributeValue.from_string("message-007")},
            table=my_table
        )
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        key: typing.Mapping[builtins.str, DynamoAttributeValue],
        table: _ITable_24826f7e,
        consistent_read: typing.Optional[builtins.bool] = None,
        expression_attribute_names: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        projection_expression: typing.Optional[typing.Sequence["DynamoProjectionExpression"]] = None,
        return_consumed_capacity: typing.Optional[DynamoConsumedCapacity] = None,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param key: (experimental) Primary key of the item to retrieve. For the primary key, you must provide all of the attributes. For example, with a simple primary key, you only need to provide a value for the partition key. For a composite primary key, you must provide values for both the partition key and the sort key.
        :param table: (experimental) The name of the table containing the requested item.
        :param consistent_read: (experimental) Determines the read consistency model: If set to true, then the operation uses strongly consistent reads; otherwise, the operation uses eventually consistent reads. Default: false
        :param expression_attribute_names: (experimental) One or more substitution tokens for attribute names in an expression. Default: - No expression attributes
        :param projection_expression: (experimental) An array of DynamoProjectionExpression that identifies one or more attributes to retrieve from the table. These attributes can include scalars, sets, or elements of a JSON document. Default: - No projection expression
        :param return_consumed_capacity: (experimental) Determines the level of detail about provisioned throughput consumption that is returned in the response. Default: DynamoConsumedCapacity.NONE
        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8276391e436f94a7403556ee7362ed2a4d229575b73a338cd658934e4f63599b)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = DynamoGetItemProps(
            key=key,
            table=table,
            consistent_read=consistent_read,
            expression_attribute_names=expression_attribute_names,
            projection_expression=projection_expression,
            return_consumed_capacity=return_consumed_capacity,
            comment=comment,
            heartbeat=heartbeat,
            input_path=input_path,
            integration_pattern=integration_pattern,
            output_path=output_path,
            result_path=result_path,
            result_selector=result_selector,
            timeout=timeout,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="taskMetrics")
    def _task_metrics(self) -> typing.Optional[_TaskMetricsConfig_5aaea59e]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[_TaskMetricsConfig_5aaea59e], jsii.get(self, "taskMetrics"))

    @builtins.property
    @jsii.member(jsii_name="taskPolicies")
    def _task_policies(self) -> typing.Optional[typing.List[_PolicyStatement_296fe8a3]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.List[_PolicyStatement_296fe8a3]], jsii.get(self, "taskPolicies"))


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.DynamoGetItemProps",
    jsii_struct_bases=[_TaskStateBaseProps_b13f6332],
    name_mapping={
        "comment": "comment",
        "heartbeat": "heartbeat",
        "input_path": "inputPath",
        "integration_pattern": "integrationPattern",
        "output_path": "outputPath",
        "result_path": "resultPath",
        "result_selector": "resultSelector",
        "timeout": "timeout",
        "key": "key",
        "table": "table",
        "consistent_read": "consistentRead",
        "expression_attribute_names": "expressionAttributeNames",
        "projection_expression": "projectionExpression",
        "return_consumed_capacity": "returnConsumedCapacity",
    },
)
class DynamoGetItemProps(_TaskStateBaseProps_b13f6332):
    def __init__(
        self,
        *,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
        key: typing.Mapping[builtins.str, DynamoAttributeValue],
        table: _ITable_24826f7e,
        consistent_read: typing.Optional[builtins.bool] = None,
        expression_attribute_names: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        projection_expression: typing.Optional[typing.Sequence["DynamoProjectionExpression"]] = None,
        return_consumed_capacity: typing.Optional[DynamoConsumedCapacity] = None,
    ) -> None:
        '''(experimental) Properties for DynamoGetItem Task.

        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None
        :param key: (experimental) Primary key of the item to retrieve. For the primary key, you must provide all of the attributes. For example, with a simple primary key, you only need to provide a value for the partition key. For a composite primary key, you must provide values for both the partition key and the sort key.
        :param table: (experimental) The name of the table containing the requested item.
        :param consistent_read: (experimental) Determines the read consistency model: If set to true, then the operation uses strongly consistent reads; otherwise, the operation uses eventually consistent reads. Default: false
        :param expression_attribute_names: (experimental) One or more substitution tokens for attribute names in an expression. Default: - No expression attributes
        :param projection_expression: (experimental) An array of DynamoProjectionExpression that identifies one or more attributes to retrieve from the table. These attributes can include scalars, sets, or elements of a JSON document. Default: - No projection expression
        :param return_consumed_capacity: (experimental) Determines the level of detail about provisioned throughput consumption that is returned in the response. Default: DynamoConsumedCapacity.NONE

        :stability: experimental
        :exampleMetadata: infused

        Example::

            # my_table: dynamodb.Table
            
            tasks.DynamoGetItem(self, "Get Item",
                key={"message_id": tasks.DynamoAttributeValue.from_string("message-007")},
                table=my_table
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__42389f04aefc537dd7a6bf215d2903332790dd058b3000d43e045c6fcf414da1)
            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
            check_type(argname="argument heartbeat", value=heartbeat, expected_type=type_hints["heartbeat"])
            check_type(argname="argument input_path", value=input_path, expected_type=type_hints["input_path"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
            check_type(argname="argument output_path", value=output_path, expected_type=type_hints["output_path"])
            check_type(argname="argument result_path", value=result_path, expected_type=type_hints["result_path"])
            check_type(argname="argument result_selector", value=result_selector, expected_type=type_hints["result_selector"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument table", value=table, expected_type=type_hints["table"])
            check_type(argname="argument consistent_read", value=consistent_read, expected_type=type_hints["consistent_read"])
            check_type(argname="argument expression_attribute_names", value=expression_attribute_names, expected_type=type_hints["expression_attribute_names"])
            check_type(argname="argument projection_expression", value=projection_expression, expected_type=type_hints["projection_expression"])
            check_type(argname="argument return_consumed_capacity", value=return_consumed_capacity, expected_type=type_hints["return_consumed_capacity"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "table": table,
        }
        if comment is not None:
            self._values["comment"] = comment
        if heartbeat is not None:
            self._values["heartbeat"] = heartbeat
        if input_path is not None:
            self._values["input_path"] = input_path
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern
        if output_path is not None:
            self._values["output_path"] = output_path
        if result_path is not None:
            self._values["result_path"] = result_path
        if result_selector is not None:
            self._values["result_selector"] = result_selector
        if timeout is not None:
            self._values["timeout"] = timeout
        if consistent_read is not None:
            self._values["consistent_read"] = consistent_read
        if expression_attribute_names is not None:
            self._values["expression_attribute_names"] = expression_attribute_names
        if projection_expression is not None:
            self._values["projection_expression"] = projection_expression
        if return_consumed_capacity is not None:
            self._values["return_consumed_capacity"] = return_consumed_capacity

    @builtins.property
    def comment(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional description for this state.

        :default: - No comment

        :stability: experimental
        '''
        result = self._values.get("comment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def heartbeat(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the heartbeat.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("heartbeat")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def input_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select part of the state to be the input to this state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        input to be the empty object {}.

        :default: - The entire task input (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("input_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def integration_pattern(self) -> typing.Optional[_IntegrationPattern_fbb35786]:
        '''(experimental) AWS Step Functions integrates with services directly in the Amazon States Language.

        You can control these AWS services using service integration patterns

        :default:

        - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks.
        ``IntegrationPattern.RUN_JOB`` for the following exceptions:
        ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html#connect-wait-token
        :stability: experimental
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_IntegrationPattern_fbb35786], result)

    @builtins.property
    def output_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select select a portion of the state output to pass to the next state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        output to be the empty object {}.

        :default:

        - The entire JSON node determined by the state input, the task result,
        and resultPath is passed to the next state (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("output_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to indicate where to inject the state's output.

        May also be the special value JsonPath.DISCARD, which will cause the state's
        input to become its output.

        :default: - Replaces the entire input with the result (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("result_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied.

        You can use ResultSelector to create a payload with values that are static
        or selected from the state's raw result.

        :default: - None

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/input-output-inputpath-params.html#input-output-resultselector
        :stability: experimental
        '''
        result = self._values.get("result_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def timeout(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the state machine.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def key(self) -> typing.Mapping[builtins.str, DynamoAttributeValue]:
        '''(experimental) Primary key of the item to retrieve.

        For the primary key, you must provide all of the attributes.
        For example, with a simple primary key, you only need to provide a value for the partition key.
        For a composite primary key, you must provide values for both the partition key and the sort key.

        :see: https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_GetItem.html#DDB-GetItem-request-Key
        :stability: experimental
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(typing.Mapping[builtins.str, DynamoAttributeValue], result)

    @builtins.property
    def table(self) -> _ITable_24826f7e:
        '''(experimental) The name of the table containing the requested item.

        :stability: experimental
        '''
        result = self._values.get("table")
        assert result is not None, "Required property 'table' is missing"
        return typing.cast(_ITable_24826f7e, result)

    @builtins.property
    def consistent_read(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Determines the read consistency model: If set to true, then the operation uses strongly consistent reads;

        otherwise, the operation uses eventually consistent reads.

        :default: false

        :stability: experimental
        '''
        result = self._values.get("consistent_read")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def expression_attribute_names(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''(experimental) One or more substitution tokens for attribute names in an expression.

        :default: - No expression attributes

        :see: https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_GetItem.html#DDB-GetItem-request-ExpressionAttributeNames
        :stability: experimental
        '''
        result = self._values.get("expression_attribute_names")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def projection_expression(
        self,
    ) -> typing.Optional[typing.List["DynamoProjectionExpression"]]:
        '''(experimental) An array of DynamoProjectionExpression that identifies one or more attributes to retrieve from the table.

        These attributes can include scalars, sets, or elements of a JSON document.

        :default: - No projection expression

        :see: https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_GetItem.html#DDB-GetItem-request-ProjectionExpression
        :stability: experimental
        '''
        result = self._values.get("projection_expression")
        return typing.cast(typing.Optional[typing.List["DynamoProjectionExpression"]], result)

    @builtins.property
    def return_consumed_capacity(self) -> typing.Optional[DynamoConsumedCapacity]:
        '''(experimental) Determines the level of detail about provisioned throughput consumption that is returned in the response.

        :default: DynamoConsumedCapacity.NONE

        :see: https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_GetItem.html#DDB-GetItem-request-ReturnConsumedCapacity
        :stability: experimental
        '''
        result = self._values.get("return_consumed_capacity")
        return typing.cast(typing.Optional[DynamoConsumedCapacity], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DynamoGetItemProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="monocdk.aws_stepfunctions_tasks.DynamoItemCollectionMetrics")
class DynamoItemCollectionMetrics(enum.Enum):
    '''(experimental) Determines whether item collection metrics are returned.

    :stability: experimental
    '''

    SIZE = "SIZE"
    '''(experimental) If set to SIZE, the response includes statistics about item collections, if any, that were modified during the operation.

    :stability: experimental
    '''
    NONE = "NONE"
    '''(experimental) If set to NONE, no statistics are returned.

    :stability: experimental
    '''


class DynamoProjectionExpression(
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.DynamoProjectionExpression",
):
    '''(experimental) Class to generate projection expression.

    :stability: experimental
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
        
        dynamo_projection_expression = stepfunctions_tasks.DynamoProjectionExpression()
    '''

    def __init__(self) -> None:
        '''
        :stability: experimental
        '''
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="atIndex")
    def at_index(self, index: jsii.Number) -> "DynamoProjectionExpression":
        '''(experimental) Adds the array literal access for passed index.

        :param index: array index.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cb3d5ec055b9dcf5ecc75675f8c6ca06bcedcdf15772560c13df804dd6eeaa5d)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("DynamoProjectionExpression", jsii.invoke(self, "atIndex", [index]))

    @jsii.member(jsii_name="toString")
    def to_string(self) -> builtins.str:
        '''(experimental) converts and return the string expression.

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.invoke(self, "toString", []))

    @jsii.member(jsii_name="withAttribute")
    def with_attribute(self, attr: builtins.str) -> "DynamoProjectionExpression":
        '''(experimental) Adds the passed attribute to the chain.

        :param attr: Attribute name.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a020ab37fae0793b590a90b329b49b0b5313d4a04aeb8a574fdc2b5d258e278a)
            check_type(argname="argument attr", value=attr, expected_type=type_hints["attr"])
        return typing.cast("DynamoProjectionExpression", jsii.invoke(self, "withAttribute", [attr]))


class DynamoPutItem(
    _TaskStateBase_c3080646,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.DynamoPutItem",
):
    '''(experimental) A StepFunctions task to call DynamoPutItem.

    :stability: experimental
    :exampleMetadata: infused

    Example::

        # my_table: dynamodb.Table
        
        tasks.DynamoPutItem(self, "PutItem",
            item={
                "MessageId": tasks.DynamoAttributeValue.from_string("message-id")
            },
            table=my_table,
            result_path="$.Item"
        )
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        item: typing.Mapping[builtins.str, DynamoAttributeValue],
        table: _ITable_24826f7e,
        condition_expression: typing.Optional[builtins.str] = None,
        expression_attribute_names: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        expression_attribute_values: typing.Optional[typing.Mapping[builtins.str, DynamoAttributeValue]] = None,
        return_consumed_capacity: typing.Optional[DynamoConsumedCapacity] = None,
        return_item_collection_metrics: typing.Optional[DynamoItemCollectionMetrics] = None,
        return_values: typing.Optional["DynamoReturnValues"] = None,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param item: (experimental) A map of attribute name/value pairs, one for each attribute. Only the primary key attributes are required; you can optionally provide other attribute name-value pairs for the item.
        :param table: (experimental) The name of the table where the item should be written .
        :param condition_expression: (experimental) A condition that must be satisfied in order for a conditional PutItem operation to succeed. Default: - No condition expression
        :param expression_attribute_names: (experimental) One or more substitution tokens for attribute names in an expression. Default: - No expression attribute names
        :param expression_attribute_values: (experimental) One or more values that can be substituted in an expression. Default: - No expression attribute values
        :param return_consumed_capacity: (experimental) Determines the level of detail about provisioned throughput consumption that is returned in the response. Default: DynamoConsumedCapacity.NONE
        :param return_item_collection_metrics: (experimental) The item collection metrics to returned in the response. Default: DynamoItemCollectionMetrics.NONE
        :param return_values: (experimental) Use ReturnValues if you want to get the item attributes as they appeared before they were updated with the PutItem request. Default: DynamoReturnValues.NONE
        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__db7aea571d3fd842f791f23987396695de8e613650f2ed6c94269e6dd286215f)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = DynamoPutItemProps(
            item=item,
            table=table,
            condition_expression=condition_expression,
            expression_attribute_names=expression_attribute_names,
            expression_attribute_values=expression_attribute_values,
            return_consumed_capacity=return_consumed_capacity,
            return_item_collection_metrics=return_item_collection_metrics,
            return_values=return_values,
            comment=comment,
            heartbeat=heartbeat,
            input_path=input_path,
            integration_pattern=integration_pattern,
            output_path=output_path,
            result_path=result_path,
            result_selector=result_selector,
            timeout=timeout,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="taskMetrics")
    def _task_metrics(self) -> typing.Optional[_TaskMetricsConfig_5aaea59e]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[_TaskMetricsConfig_5aaea59e], jsii.get(self, "taskMetrics"))

    @builtins.property
    @jsii.member(jsii_name="taskPolicies")
    def _task_policies(self) -> typing.Optional[typing.List[_PolicyStatement_296fe8a3]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.List[_PolicyStatement_296fe8a3]], jsii.get(self, "taskPolicies"))


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.DynamoPutItemProps",
    jsii_struct_bases=[_TaskStateBaseProps_b13f6332],
    name_mapping={
        "comment": "comment",
        "heartbeat": "heartbeat",
        "input_path": "inputPath",
        "integration_pattern": "integrationPattern",
        "output_path": "outputPath",
        "result_path": "resultPath",
        "result_selector": "resultSelector",
        "timeout": "timeout",
        "item": "item",
        "table": "table",
        "condition_expression": "conditionExpression",
        "expression_attribute_names": "expressionAttributeNames",
        "expression_attribute_values": "expressionAttributeValues",
        "return_consumed_capacity": "returnConsumedCapacity",
        "return_item_collection_metrics": "returnItemCollectionMetrics",
        "return_values": "returnValues",
    },
)
class DynamoPutItemProps(_TaskStateBaseProps_b13f6332):
    def __init__(
        self,
        *,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
        item: typing.Mapping[builtins.str, DynamoAttributeValue],
        table: _ITable_24826f7e,
        condition_expression: typing.Optional[builtins.str] = None,
        expression_attribute_names: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        expression_attribute_values: typing.Optional[typing.Mapping[builtins.str, DynamoAttributeValue]] = None,
        return_consumed_capacity: typing.Optional[DynamoConsumedCapacity] = None,
        return_item_collection_metrics: typing.Optional[DynamoItemCollectionMetrics] = None,
        return_values: typing.Optional["DynamoReturnValues"] = None,
    ) -> None:
        '''(experimental) Properties for DynamoPutItem Task.

        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None
        :param item: (experimental) A map of attribute name/value pairs, one for each attribute. Only the primary key attributes are required; you can optionally provide other attribute name-value pairs for the item.
        :param table: (experimental) The name of the table where the item should be written .
        :param condition_expression: (experimental) A condition that must be satisfied in order for a conditional PutItem operation to succeed. Default: - No condition expression
        :param expression_attribute_names: (experimental) One or more substitution tokens for attribute names in an expression. Default: - No expression attribute names
        :param expression_attribute_values: (experimental) One or more values that can be substituted in an expression. Default: - No expression attribute values
        :param return_consumed_capacity: (experimental) Determines the level of detail about provisioned throughput consumption that is returned in the response. Default: DynamoConsumedCapacity.NONE
        :param return_item_collection_metrics: (experimental) The item collection metrics to returned in the response. Default: DynamoItemCollectionMetrics.NONE
        :param return_values: (experimental) Use ReturnValues if you want to get the item attributes as they appeared before they were updated with the PutItem request. Default: DynamoReturnValues.NONE

        :stability: experimental
        :exampleMetadata: infused

        Example::

            # my_table: dynamodb.Table
            
            tasks.DynamoPutItem(self, "PutItem",
                item={
                    "MessageId": tasks.DynamoAttributeValue.from_string("message-id")
                },
                table=my_table,
                result_path="$.Item"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5a9776444beb6effaf99c18f81bc32dabbe7912532feae2ef7cf8ae71dcd055b)
            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
            check_type(argname="argument heartbeat", value=heartbeat, expected_type=type_hints["heartbeat"])
            check_type(argname="argument input_path", value=input_path, expected_type=type_hints["input_path"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
            check_type(argname="argument output_path", value=output_path, expected_type=type_hints["output_path"])
            check_type(argname="argument result_path", value=result_path, expected_type=type_hints["result_path"])
            check_type(argname="argument result_selector", value=result_selector, expected_type=type_hints["result_selector"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
            check_type(argname="argument item", value=item, expected_type=type_hints["item"])
            check_type(argname="argument table", value=table, expected_type=type_hints["table"])
            check_type(argname="argument condition_expression", value=condition_expression, expected_type=type_hints["condition_expression"])
            check_type(argname="argument expression_attribute_names", value=expression_attribute_names, expected_type=type_hints["expression_attribute_names"])
            check_type(argname="argument expression_attribute_values", value=expression_attribute_values, expected_type=type_hints["expression_attribute_values"])
            check_type(argname="argument return_consumed_capacity", value=return_consumed_capacity, expected_type=type_hints["return_consumed_capacity"])
            check_type(argname="argument return_item_collection_metrics", value=return_item_collection_metrics, expected_type=type_hints["return_item_collection_metrics"])
            check_type(argname="argument return_values", value=return_values, expected_type=type_hints["return_values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "item": item,
            "table": table,
        }
        if comment is not None:
            self._values["comment"] = comment
        if heartbeat is not None:
            self._values["heartbeat"] = heartbeat
        if input_path is not None:
            self._values["input_path"] = input_path
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern
        if output_path is not None:
            self._values["output_path"] = output_path
        if result_path is not None:
            self._values["result_path"] = result_path
        if result_selector is not None:
            self._values["result_selector"] = result_selector
        if timeout is not None:
            self._values["timeout"] = timeout
        if condition_expression is not None:
            self._values["condition_expression"] = condition_expression
        if expression_attribute_names is not None:
            self._values["expression_attribute_names"] = expression_attribute_names
        if expression_attribute_values is not None:
            self._values["expression_attribute_values"] = expression_attribute_values
        if return_consumed_capacity is not None:
            self._values["return_consumed_capacity"] = return_consumed_capacity
        if return_item_collection_metrics is not None:
            self._values["return_item_collection_metrics"] = return_item_collection_metrics
        if return_values is not None:
            self._values["return_values"] = return_values

    @builtins.property
    def comment(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional description for this state.

        :default: - No comment

        :stability: experimental
        '''
        result = self._values.get("comment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def heartbeat(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the heartbeat.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("heartbeat")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def input_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select part of the state to be the input to this state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        input to be the empty object {}.

        :default: - The entire task input (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("input_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def integration_pattern(self) -> typing.Optional[_IntegrationPattern_fbb35786]:
        '''(experimental) AWS Step Functions integrates with services directly in the Amazon States Language.

        You can control these AWS services using service integration patterns

        :default:

        - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks.
        ``IntegrationPattern.RUN_JOB`` for the following exceptions:
        ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html#connect-wait-token
        :stability: experimental
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_IntegrationPattern_fbb35786], result)

    @builtins.property
    def output_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select select a portion of the state output to pass to the next state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        output to be the empty object {}.

        :default:

        - The entire JSON node determined by the state input, the task result,
        and resultPath is passed to the next state (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("output_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to indicate where to inject the state's output.

        May also be the special value JsonPath.DISCARD, which will cause the state's
        input to become its output.

        :default: - Replaces the entire input with the result (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("result_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied.

        You can use ResultSelector to create a payload with values that are static
        or selected from the state's raw result.

        :default: - None

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/input-output-inputpath-params.html#input-output-resultselector
        :stability: experimental
        '''
        result = self._values.get("result_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def timeout(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the state machine.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def item(self) -> typing.Mapping[builtins.str, DynamoAttributeValue]:
        '''(experimental) A map of attribute name/value pairs, one for each attribute.

        Only the primary key attributes are required;
        you can optionally provide other attribute name-value pairs for the item.

        :see: https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_PutItem.html#DDB-PutItem-request-Item
        :stability: experimental
        '''
        result = self._values.get("item")
        assert result is not None, "Required property 'item' is missing"
        return typing.cast(typing.Mapping[builtins.str, DynamoAttributeValue], result)

    @builtins.property
    def table(self) -> _ITable_24826f7e:
        '''(experimental) The name of the table where the item should be written .

        :stability: experimental
        '''
        result = self._values.get("table")
        assert result is not None, "Required property 'table' is missing"
        return typing.cast(_ITable_24826f7e, result)

    @builtins.property
    def condition_expression(self) -> typing.Optional[builtins.str]:
        '''(experimental) A condition that must be satisfied in order for a conditional PutItem operation to succeed.

        :default: - No condition expression

        :see: https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_PutItem.html#DDB-PutItem-request-ConditionExpression
        :stability: experimental
        '''
        result = self._values.get("condition_expression")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def expression_attribute_names(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''(experimental) One or more substitution tokens for attribute names in an expression.

        :default: - No expression attribute names

        :see: https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_PutItem.html#DDB-PutItem-request-ExpressionAttributeNames
        :stability: experimental
        '''
        result = self._values.get("expression_attribute_names")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def expression_attribute_values(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, DynamoAttributeValue]]:
        '''(experimental) One or more values that can be substituted in an expression.

        :default: - No expression attribute values

        :see: https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_PutItem.html#DDB-PutItem-request-ExpressionAttributeValues
        :stability: experimental
        '''
        result = self._values.get("expression_attribute_values")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, DynamoAttributeValue]], result)

    @builtins.property
    def return_consumed_capacity(self) -> typing.Optional[DynamoConsumedCapacity]:
        '''(experimental) Determines the level of detail about provisioned throughput consumption that is returned in the response.

        :default: DynamoConsumedCapacity.NONE

        :see: https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_PutItem.html#DDB-PutItem-request-ReturnConsumedCapacity
        :stability: experimental
        '''
        result = self._values.get("return_consumed_capacity")
        return typing.cast(typing.Optional[DynamoConsumedCapacity], result)

    @builtins.property
    def return_item_collection_metrics(
        self,
    ) -> typing.Optional[DynamoItemCollectionMetrics]:
        '''(experimental) The item collection metrics to returned in the response.

        :default: DynamoItemCollectionMetrics.NONE

        :see: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LSI.html#LSI.ItemCollections
        :stability: experimental
        '''
        result = self._values.get("return_item_collection_metrics")
        return typing.cast(typing.Optional[DynamoItemCollectionMetrics], result)

    @builtins.property
    def return_values(self) -> typing.Optional["DynamoReturnValues"]:
        '''(experimental) Use ReturnValues if you want to get the item attributes as they appeared before they were updated with the PutItem request.

        :default: DynamoReturnValues.NONE

        :see: https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_PutItem.html#DDB-PutItem-request-ReturnValues
        :stability: experimental
        '''
        result = self._values.get("return_values")
        return typing.cast(typing.Optional["DynamoReturnValues"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DynamoPutItemProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="monocdk.aws_stepfunctions_tasks.DynamoReturnValues")
class DynamoReturnValues(enum.Enum):
    '''(experimental) Use ReturnValues if you want to get the item attributes as they appear before or after they are changed.

    :stability: experimental
    '''

    NONE = "NONE"
    '''(experimental) Nothing is returned.

    :stability: experimental
    '''
    ALL_OLD = "ALL_OLD"
    '''(experimental) Returns all of the attributes of the item.

    :stability: experimental
    '''
    UPDATED_OLD = "UPDATED_OLD"
    '''(experimental) Returns only the updated attributes.

    :stability: experimental
    '''
    ALL_NEW = "ALL_NEW"
    '''(experimental) Returns all of the attributes of the item.

    :stability: experimental
    '''
    UPDATED_NEW = "UPDATED_NEW"
    '''(experimental) Returns only the updated attributes.

    :stability: experimental
    '''


class DynamoUpdateItem(
    _TaskStateBase_c3080646,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.DynamoUpdateItem",
):
    '''(experimental) A StepFunctions task to call DynamoUpdateItem.

    :stability: experimental
    :exampleMetadata: infused

    Example::

        # my_table: dynamodb.Table
        
        tasks.DynamoUpdateItem(self, "UpdateItem",
            key={
                "MessageId": tasks.DynamoAttributeValue.from_string("message-007")
            },
            table=my_table,
            expression_attribute_values={
                ":val": tasks.DynamoAttributeValue.number_from_string(sfn.JsonPath.string_at("$.Item.TotalCount.N")),
                ":rand": tasks.DynamoAttributeValue.from_number(20)
            },
            update_expression="SET TotalCount = :val + :rand"
        )
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        key: typing.Mapping[builtins.str, DynamoAttributeValue],
        table: _ITable_24826f7e,
        condition_expression: typing.Optional[builtins.str] = None,
        expression_attribute_names: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        expression_attribute_values: typing.Optional[typing.Mapping[builtins.str, DynamoAttributeValue]] = None,
        return_consumed_capacity: typing.Optional[DynamoConsumedCapacity] = None,
        return_item_collection_metrics: typing.Optional[DynamoItemCollectionMetrics] = None,
        return_values: typing.Optional[DynamoReturnValues] = None,
        update_expression: typing.Optional[builtins.str] = None,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param key: (experimental) Primary key of the item to retrieve. For the primary key, you must provide all of the attributes. For example, with a simple primary key, you only need to provide a value for the partition key. For a composite primary key, you must provide values for both the partition key and the sort key.
        :param table: (experimental) The name of the table containing the requested item.
        :param condition_expression: (experimental) A condition that must be satisfied in order for a conditional DeleteItem to succeed. Default: - No condition expression
        :param expression_attribute_names: (experimental) One or more substitution tokens for attribute names in an expression. Default: - No expression attribute names
        :param expression_attribute_values: (experimental) One or more values that can be substituted in an expression. Default: - No expression attribute values
        :param return_consumed_capacity: (experimental) Determines the level of detail about provisioned throughput consumption that is returned in the response. Default: DynamoConsumedCapacity.NONE
        :param return_item_collection_metrics: (experimental) Determines whether item collection metrics are returned. If set to SIZE, the response includes statistics about item collections, if any, that were modified during the operation are returned in the response. If set to NONE (the default), no statistics are returned. Default: DynamoItemCollectionMetrics.NONE
        :param return_values: (experimental) Use ReturnValues if you want to get the item attributes as they appeared before they were deleted. Default: DynamoReturnValues.NONE
        :param update_expression: (experimental) An expression that defines one or more attributes to be updated, the action to be performed on them, and new values for them. Default: - No update expression
        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bda2681bd9811640c8e6b7ee098f9e11b3396b79f4fbc85f0b812abd0f9a90f3)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = DynamoUpdateItemProps(
            key=key,
            table=table,
            condition_expression=condition_expression,
            expression_attribute_names=expression_attribute_names,
            expression_attribute_values=expression_attribute_values,
            return_consumed_capacity=return_consumed_capacity,
            return_item_collection_metrics=return_item_collection_metrics,
            return_values=return_values,
            update_expression=update_expression,
            comment=comment,
            heartbeat=heartbeat,
            input_path=input_path,
            integration_pattern=integration_pattern,
            output_path=output_path,
            result_path=result_path,
            result_selector=result_selector,
            timeout=timeout,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="taskMetrics")
    def _task_metrics(self) -> typing.Optional[_TaskMetricsConfig_5aaea59e]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[_TaskMetricsConfig_5aaea59e], jsii.get(self, "taskMetrics"))

    @builtins.property
    @jsii.member(jsii_name="taskPolicies")
    def _task_policies(self) -> typing.Optional[typing.List[_PolicyStatement_296fe8a3]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.List[_PolicyStatement_296fe8a3]], jsii.get(self, "taskPolicies"))


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.DynamoUpdateItemProps",
    jsii_struct_bases=[_TaskStateBaseProps_b13f6332],
    name_mapping={
        "comment": "comment",
        "heartbeat": "heartbeat",
        "input_path": "inputPath",
        "integration_pattern": "integrationPattern",
        "output_path": "outputPath",
        "result_path": "resultPath",
        "result_selector": "resultSelector",
        "timeout": "timeout",
        "key": "key",
        "table": "table",
        "condition_expression": "conditionExpression",
        "expression_attribute_names": "expressionAttributeNames",
        "expression_attribute_values": "expressionAttributeValues",
        "return_consumed_capacity": "returnConsumedCapacity",
        "return_item_collection_metrics": "returnItemCollectionMetrics",
        "return_values": "returnValues",
        "update_expression": "updateExpression",
    },
)
class DynamoUpdateItemProps(_TaskStateBaseProps_b13f6332):
    def __init__(
        self,
        *,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
        key: typing.Mapping[builtins.str, DynamoAttributeValue],
        table: _ITable_24826f7e,
        condition_expression: typing.Optional[builtins.str] = None,
        expression_attribute_names: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        expression_attribute_values: typing.Optional[typing.Mapping[builtins.str, DynamoAttributeValue]] = None,
        return_consumed_capacity: typing.Optional[DynamoConsumedCapacity] = None,
        return_item_collection_metrics: typing.Optional[DynamoItemCollectionMetrics] = None,
        return_values: typing.Optional[DynamoReturnValues] = None,
        update_expression: typing.Optional[builtins.str] = None,
    ) -> None:
        '''(experimental) Properties for DynamoUpdateItem Task.

        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None
        :param key: (experimental) Primary key of the item to retrieve. For the primary key, you must provide all of the attributes. For example, with a simple primary key, you only need to provide a value for the partition key. For a composite primary key, you must provide values for both the partition key and the sort key.
        :param table: (experimental) The name of the table containing the requested item.
        :param condition_expression: (experimental) A condition that must be satisfied in order for a conditional DeleteItem to succeed. Default: - No condition expression
        :param expression_attribute_names: (experimental) One or more substitution tokens for attribute names in an expression. Default: - No expression attribute names
        :param expression_attribute_values: (experimental) One or more values that can be substituted in an expression. Default: - No expression attribute values
        :param return_consumed_capacity: (experimental) Determines the level of detail about provisioned throughput consumption that is returned in the response. Default: DynamoConsumedCapacity.NONE
        :param return_item_collection_metrics: (experimental) Determines whether item collection metrics are returned. If set to SIZE, the response includes statistics about item collections, if any, that were modified during the operation are returned in the response. If set to NONE (the default), no statistics are returned. Default: DynamoItemCollectionMetrics.NONE
        :param return_values: (experimental) Use ReturnValues if you want to get the item attributes as they appeared before they were deleted. Default: DynamoReturnValues.NONE
        :param update_expression: (experimental) An expression that defines one or more attributes to be updated, the action to be performed on them, and new values for them. Default: - No update expression

        :stability: experimental
        :exampleMetadata: infused

        Example::

            # my_table: dynamodb.Table
            
            tasks.DynamoUpdateItem(self, "UpdateItem",
                key={
                    "MessageId": tasks.DynamoAttributeValue.from_string("message-007")
                },
                table=my_table,
                expression_attribute_values={
                    ":val": tasks.DynamoAttributeValue.number_from_string(sfn.JsonPath.string_at("$.Item.TotalCount.N")),
                    ":rand": tasks.DynamoAttributeValue.from_number(20)
                },
                update_expression="SET TotalCount = :val + :rand"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__39adb8dd023e34c3306c4560b60cb064fe46453e0f50ccdd57bcc5effc3cdeee)
            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
            check_type(argname="argument heartbeat", value=heartbeat, expected_type=type_hints["heartbeat"])
            check_type(argname="argument input_path", value=input_path, expected_type=type_hints["input_path"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
            check_type(argname="argument output_path", value=output_path, expected_type=type_hints["output_path"])
            check_type(argname="argument result_path", value=result_path, expected_type=type_hints["result_path"])
            check_type(argname="argument result_selector", value=result_selector, expected_type=type_hints["result_selector"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument table", value=table, expected_type=type_hints["table"])
            check_type(argname="argument condition_expression", value=condition_expression, expected_type=type_hints["condition_expression"])
            check_type(argname="argument expression_attribute_names", value=expression_attribute_names, expected_type=type_hints["expression_attribute_names"])
            check_type(argname="argument expression_attribute_values", value=expression_attribute_values, expected_type=type_hints["expression_attribute_values"])
            check_type(argname="argument return_consumed_capacity", value=return_consumed_capacity, expected_type=type_hints["return_consumed_capacity"])
            check_type(argname="argument return_item_collection_metrics", value=return_item_collection_metrics, expected_type=type_hints["return_item_collection_metrics"])
            check_type(argname="argument return_values", value=return_values, expected_type=type_hints["return_values"])
            check_type(argname="argument update_expression", value=update_expression, expected_type=type_hints["update_expression"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "table": table,
        }
        if comment is not None:
            self._values["comment"] = comment
        if heartbeat is not None:
            self._values["heartbeat"] = heartbeat
        if input_path is not None:
            self._values["input_path"] = input_path
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern
        if output_path is not None:
            self._values["output_path"] = output_path
        if result_path is not None:
            self._values["result_path"] = result_path
        if result_selector is not None:
            self._values["result_selector"] = result_selector
        if timeout is not None:
            self._values["timeout"] = timeout
        if condition_expression is not None:
            self._values["condition_expression"] = condition_expression
        if expression_attribute_names is not None:
            self._values["expression_attribute_names"] = expression_attribute_names
        if expression_attribute_values is not None:
            self._values["expression_attribute_values"] = expression_attribute_values
        if return_consumed_capacity is not None:
            self._values["return_consumed_capacity"] = return_consumed_capacity
        if return_item_collection_metrics is not None:
            self._values["return_item_collection_metrics"] = return_item_collection_metrics
        if return_values is not None:
            self._values["return_values"] = return_values
        if update_expression is not None:
            self._values["update_expression"] = update_expression

    @builtins.property
    def comment(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional description for this state.

        :default: - No comment

        :stability: experimental
        '''
        result = self._values.get("comment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def heartbeat(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the heartbeat.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("heartbeat")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def input_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select part of the state to be the input to this state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        input to be the empty object {}.

        :default: - The entire task input (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("input_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def integration_pattern(self) -> typing.Optional[_IntegrationPattern_fbb35786]:
        '''(experimental) AWS Step Functions integrates with services directly in the Amazon States Language.

        You can control these AWS services using service integration patterns

        :default:

        - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks.
        ``IntegrationPattern.RUN_JOB`` for the following exceptions:
        ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html#connect-wait-token
        :stability: experimental
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_IntegrationPattern_fbb35786], result)

    @builtins.property
    def output_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select select a portion of the state output to pass to the next state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        output to be the empty object {}.

        :default:

        - The entire JSON node determined by the state input, the task result,
        and resultPath is passed to the next state (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("output_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to indicate where to inject the state's output.

        May also be the special value JsonPath.DISCARD, which will cause the state's
        input to become its output.

        :default: - Replaces the entire input with the result (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("result_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied.

        You can use ResultSelector to create a payload with values that are static
        or selected from the state's raw result.

        :default: - None

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/input-output-inputpath-params.html#input-output-resultselector
        :stability: experimental
        '''
        result = self._values.get("result_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def timeout(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the state machine.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def key(self) -> typing.Mapping[builtins.str, DynamoAttributeValue]:
        '''(experimental) Primary key of the item to retrieve.

        For the primary key, you must provide all of the attributes.
        For example, with a simple primary key, you only need to provide a value for the partition key.
        For a composite primary key, you must provide values for both the partition key and the sort key.

        :see: https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_GetItem.html#DDB-GetItem-request-Key
        :stability: experimental
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(typing.Mapping[builtins.str, DynamoAttributeValue], result)

    @builtins.property
    def table(self) -> _ITable_24826f7e:
        '''(experimental) The name of the table containing the requested item.

        :stability: experimental
        '''
        result = self._values.get("table")
        assert result is not None, "Required property 'table' is missing"
        return typing.cast(_ITable_24826f7e, result)

    @builtins.property
    def condition_expression(self) -> typing.Optional[builtins.str]:
        '''(experimental) A condition that must be satisfied in order for a conditional DeleteItem to succeed.

        :default: - No condition expression

        :see: https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_UpdateItem.html#DDB-UpdateItem-request-ConditionExpression
        :stability: experimental
        '''
        result = self._values.get("condition_expression")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def expression_attribute_names(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''(experimental) One or more substitution tokens for attribute names in an expression.

        :default: - No expression attribute names

        :see: https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_UpdateItem.html#DDB-UpdateItem-request-ExpressionAttributeNames
        :stability: experimental
        '''
        result = self._values.get("expression_attribute_names")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def expression_attribute_values(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, DynamoAttributeValue]]:
        '''(experimental) One or more values that can be substituted in an expression.

        :default: - No expression attribute values

        :see: https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_UpdateItem.html#DDB-UpdateItem-request-ExpressionAttributeValues
        :stability: experimental
        '''
        result = self._values.get("expression_attribute_values")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, DynamoAttributeValue]], result)

    @builtins.property
    def return_consumed_capacity(self) -> typing.Optional[DynamoConsumedCapacity]:
        '''(experimental) Determines the level of detail about provisioned throughput consumption that is returned in the response.

        :default: DynamoConsumedCapacity.NONE

        :see: https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_UpdateItem.html#DDB-UpdateItem-request-ReturnConsumedCapacity
        :stability: experimental
        '''
        result = self._values.get("return_consumed_capacity")
        return typing.cast(typing.Optional[DynamoConsumedCapacity], result)

    @builtins.property
    def return_item_collection_metrics(
        self,
    ) -> typing.Optional[DynamoItemCollectionMetrics]:
        '''(experimental) Determines whether item collection metrics are returned.

        If set to SIZE, the response includes statistics about item collections, if any,
        that were modified during the operation are returned in the response.
        If set to NONE (the default), no statistics are returned.

        :default: DynamoItemCollectionMetrics.NONE

        :stability: experimental
        '''
        result = self._values.get("return_item_collection_metrics")
        return typing.cast(typing.Optional[DynamoItemCollectionMetrics], result)

    @builtins.property
    def return_values(self) -> typing.Optional[DynamoReturnValues]:
        '''(experimental) Use ReturnValues if you want to get the item attributes as they appeared before they were deleted.

        :default: DynamoReturnValues.NONE

        :see: https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_UpdateItem.html#DDB-UpdateItem-request-ReturnValues
        :stability: experimental
        '''
        result = self._values.get("return_values")
        return typing.cast(typing.Optional[DynamoReturnValues], result)

    @builtins.property
    def update_expression(self) -> typing.Optional[builtins.str]:
        '''(experimental) An expression that defines one or more attributes to be updated, the action to be performed on them, and new values for them.

        :default: - No update expression

        :see: https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_UpdateItem.html#DDB-UpdateItem-request-UpdateExpression
        :stability: experimental
        '''
        result = self._values.get("update_expression")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DynamoUpdateItemProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.EcsEc2LaunchTargetOptions",
    jsii_struct_bases=[],
    name_mapping={
        "placement_constraints": "placementConstraints",
        "placement_strategies": "placementStrategies",
    },
)
class EcsEc2LaunchTargetOptions:
    def __init__(
        self,
        *,
        placement_constraints: typing.Optional[typing.Sequence[_PlacementConstraint_e22ac48c]] = None,
        placement_strategies: typing.Optional[typing.Sequence[_PlacementStrategy_ea27367e]] = None,
    ) -> None:
        '''(experimental) Options to run an ECS task on EC2 in StepFunctions and ECS.

        :param placement_constraints: (experimental) Placement constraints. Default: - None
        :param placement_strategies: (experimental) Placement strategies. Default: - None

        :stability: experimental
        :exampleMetadata: infused

        Example::

            vpc = ec2.Vpc.from_lookup(self, "Vpc",
                is_default=True
            )
            
            cluster = ecs.Cluster(self, "Ec2Cluster", vpc=vpc)
            cluster.add_capacity("DefaultAutoScalingGroup",
                instance_type=ec2.InstanceType("t2.micro"),
                vpc_subnets=dynamodb.aws_ec2.SubnetSelection(subnet_type=ec2.SubnetType.PUBLIC)
            )
            
            task_definition = ecs.TaskDefinition(self, "TD",
                compatibility=ecs.Compatibility.EC2
            )
            
            task_definition.add_container("TheContainer",
                image=ecs.ContainerImage.from_registry("foo/bar"),
                memory_limit_mi_b=256
            )
            
            run_task = tasks.EcsRunTask(self, "Run",
                integration_pattern=sfn.IntegrationPattern.RUN_JOB,
                cluster=cluster,
                task_definition=task_definition,
                launch_target=tasks.EcsEc2LaunchTarget(
                    placement_strategies=[
                        ecs.PlacementStrategy.spread_across_instances(),
                        ecs.PlacementStrategy.packed_by_cpu(),
                        ecs.PlacementStrategy.randomly()
                    ],
                    placement_constraints=[
                        ecs.PlacementConstraint.member_of("blieptuut")
                    ]
                )
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e324f53d03df7d8acc34db14dbd33526e646a679b3998b58a9e0894894409622)
            check_type(argname="argument placement_constraints", value=placement_constraints, expected_type=type_hints["placement_constraints"])
            check_type(argname="argument placement_strategies", value=placement_strategies, expected_type=type_hints["placement_strategies"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if placement_constraints is not None:
            self._values["placement_constraints"] = placement_constraints
        if placement_strategies is not None:
            self._values["placement_strategies"] = placement_strategies

    @builtins.property
    def placement_constraints(
        self,
    ) -> typing.Optional[typing.List[_PlacementConstraint_e22ac48c]]:
        '''(experimental) Placement constraints.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("placement_constraints")
        return typing.cast(typing.Optional[typing.List[_PlacementConstraint_e22ac48c]], result)

    @builtins.property
    def placement_strategies(
        self,
    ) -> typing.Optional[typing.List[_PlacementStrategy_ea27367e]]:
        '''(experimental) Placement strategies.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("placement_strategies")
        return typing.cast(typing.Optional[typing.List[_PlacementStrategy_ea27367e]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EcsEc2LaunchTargetOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.EcsFargateLaunchTargetOptions",
    jsii_struct_bases=[],
    name_mapping={"platform_version": "platformVersion"},
)
class EcsFargateLaunchTargetOptions:
    def __init__(self, *, platform_version: _FargatePlatformVersion_8169c79a) -> None:
        '''(experimental) Properties to define an ECS service.

        :param platform_version: (experimental) Refers to a specific runtime environment for Fargate task infrastructure. Fargate platform version is a combination of the kernel and container runtime versions.

        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_ecs as ecs
            from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
            
            ecs_fargate_launch_target_options = stepfunctions_tasks.EcsFargateLaunchTargetOptions(
                platform_version=ecs.FargatePlatformVersion.LATEST
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6c5c23e107327d82dac97cbcae0ef541969abf912847a5428a3ae4ab4fd4ca84)
            check_type(argname="argument platform_version", value=platform_version, expected_type=type_hints["platform_version"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "platform_version": platform_version,
        }

    @builtins.property
    def platform_version(self) -> _FargatePlatformVersion_8169c79a:
        '''(experimental) Refers to a specific runtime environment for Fargate task infrastructure.

        Fargate platform version is a combination of the kernel and container runtime versions.

        :see: https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html
        :stability: experimental
        '''
        result = self._values.get("platform_version")
        assert result is not None, "Required property 'platform_version' is missing"
        return typing.cast(_FargatePlatformVersion_8169c79a, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EcsFargateLaunchTargetOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.EcsLaunchTargetConfig",
    jsii_struct_bases=[],
    name_mapping={"parameters": "parameters"},
)
class EcsLaunchTargetConfig:
    def __init__(
        self,
        *,
        parameters: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    ) -> None:
        '''(experimental) Configuration options for the ECS launch type.

        :param parameters: (experimental) Additional parameters to pass to the base task. Default: - No additional parameters passed

        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
            
            # parameters: Any
            
            ecs_launch_target_config = stepfunctions_tasks.EcsLaunchTargetConfig(
                parameters={
                    "parameters_key": parameters
                }
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ef5a4b62cc441b94242ae1ad1b7ec623baac4b0101f3ccf77409f903aeff2e4b)
            check_type(argname="argument parameters", value=parameters, expected_type=type_hints["parameters"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if parameters is not None:
            self._values["parameters"] = parameters

    @builtins.property
    def parameters(self) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) Additional parameters to pass to the base task.

        :default: - No additional parameters passed

        :stability: experimental
        '''
        result = self._values.get("parameters")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EcsLaunchTargetConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IConnectable_c1c0e72c)
class EcsRunTask(
    _TaskStateBase_c3080646,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.EcsRunTask",
):
    '''(experimental) Run a Task on ECS or Fargate.

    :stability: experimental
    :exampleMetadata: infused

    Example::

        vpc = ec2.Vpc.from_lookup(self, "Vpc",
            is_default=True
        )
        
        cluster = ecs.Cluster(self, "Ec2Cluster", vpc=vpc)
        cluster.add_capacity("DefaultAutoScalingGroup",
            instance_type=ec2.InstanceType("t2.micro"),
            vpc_subnets=dynamodb.aws_ec2.SubnetSelection(subnet_type=ec2.SubnetType.PUBLIC)
        )
        
        task_definition = ecs.TaskDefinition(self, "TD",
            compatibility=ecs.Compatibility.EC2
        )
        
        task_definition.add_container("TheContainer",
            image=ecs.ContainerImage.from_registry("foo/bar"),
            memory_limit_mi_b=256
        )
        
        run_task = tasks.EcsRunTask(self, "Run",
            integration_pattern=sfn.IntegrationPattern.RUN_JOB,
            cluster=cluster,
            task_definition=task_definition,
            launch_target=tasks.EcsEc2LaunchTarget(
                placement_strategies=[
                    ecs.PlacementStrategy.spread_across_instances(),
                    ecs.PlacementStrategy.packed_by_cpu(),
                    ecs.PlacementStrategy.randomly()
                ],
                placement_constraints=[
                    ecs.PlacementConstraint.member_of("blieptuut")
                ]
            )
        )
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        cluster: _ICluster_42c4ec1a,
        launch_target: "IEcsLaunchTarget",
        task_definition: _TaskDefinition_c0dacfb4,
        assign_public_ip: typing.Optional[builtins.bool] = None,
        container_overrides: typing.Optional[typing.Sequence[typing.Union[ContainerOverride, typing.Dict[builtins.str, typing.Any]]]] = None,
        security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
        subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param cluster: (experimental) The ECS cluster to run the task on.
        :param launch_target: (experimental) An Amazon ECS launch type determines the type of infrastructure on which your tasks and services are hosted.
        :param task_definition: (experimental) [disable-awslint:ref-via-interface] Task Definition used for running tasks in the service. Note: this must be TaskDefinition, and not ITaskDefinition, as it requires properties that are not known for imported task definitions
        :param assign_public_ip: (experimental) Assign public IP addresses to each task. Default: false
        :param container_overrides: (experimental) Container setting overrides. Specify the container to use and the overrides to apply. Default: - No overrides
        :param security_groups: (experimental) Existing security groups to use for the tasks. Default: - A new security group is created
        :param subnets: (experimental) Subnets to place the task's ENIs. Default: - Public subnets if assignPublicIp is set. Private subnets otherwise.
        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e87e83174e33e1c6a526fa133f7ed43cae78024979076c92e599a33429e55328)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = EcsRunTaskProps(
            cluster=cluster,
            launch_target=launch_target,
            task_definition=task_definition,
            assign_public_ip=assign_public_ip,
            container_overrides=container_overrides,
            security_groups=security_groups,
            subnets=subnets,
            comment=comment,
            heartbeat=heartbeat,
            input_path=input_path,
            integration_pattern=integration_pattern,
            output_path=output_path,
            result_path=result_path,
            result_selector=result_selector,
            timeout=timeout,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="connections")
    def connections(self) -> _Connections_57ccbda9:
        '''(experimental) Manage allowed network traffic for this service.

        :stability: experimental
        '''
        return typing.cast(_Connections_57ccbda9, jsii.get(self, "connections"))

    @builtins.property
    @jsii.member(jsii_name="taskMetrics")
    def _task_metrics(self) -> typing.Optional[_TaskMetricsConfig_5aaea59e]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[_TaskMetricsConfig_5aaea59e], jsii.get(self, "taskMetrics"))

    @builtins.property
    @jsii.member(jsii_name="taskPolicies")
    def _task_policies(self) -> typing.Optional[typing.List[_PolicyStatement_296fe8a3]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.List[_PolicyStatement_296fe8a3]], jsii.get(self, "taskPolicies"))


@jsii.implements(_IConnectable_c1c0e72c, _IStepFunctionsTask_82eb09ab)
class EcsRunTaskBase(
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.EcsRunTaskBase",
):
    '''(deprecated) A StepFunctions Task to run a Task on ECS or Fargate.

    :deprecated: No replacement

    :stability: deprecated
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from monocdk import aws_ecs as ecs
        from monocdk import aws_stepfunctions as stepfunctions
        from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
        
        # cluster: ecs.Cluster
        # container_definition: ecs.ContainerDefinition
        # parameters: Any
        # task_definition: ecs.TaskDefinition
        
        ecs_run_task_base = stepfunctions_tasks.EcsRunTaskBase(
            cluster=cluster,
            task_definition=task_definition,
        
            # the properties below are optional
            container_overrides=[stepfunctions_tasks.ContainerOverride(
                container_definition=container_definition,
        
                # the properties below are optional
                command=["command"],
                cpu=123,
                environment=[stepfunctions_tasks.TaskEnvironmentVariable(
                    name="name",
                    value="value"
                )],
                memory_limit=123,
                memory_reservation=123
            )],
            integration_pattern=stepfunctions.ServiceIntegrationPattern.FIRE_AND_FORGET,
            parameters={
                "parameters_key": parameters
            }
        )
    '''

    def __init__(
        self,
        *,
        parameters: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        cluster: _ICluster_42c4ec1a,
        task_definition: _TaskDefinition_c0dacfb4,
        container_overrides: typing.Optional[typing.Sequence[typing.Union[ContainerOverride, typing.Dict[builtins.str, typing.Any]]]] = None,
        integration_pattern: typing.Optional[_ServiceIntegrationPattern_5581ee88] = None,
    ) -> None:
        '''
        :param parameters: (deprecated) Additional parameters to pass to the base task. Default: - No additional parameters passed
        :param cluster: (experimental) The topic to run the task on.
        :param task_definition: (experimental) Task Definition used for running tasks in the service. Note: this must be TaskDefinition, and not ITaskDefinition, as it requires properties that are not known for imported task definitions
        :param container_overrides: (experimental) Container setting overrides. Key is the name of the container to override, value is the values you want to override. Default: - No overrides
        :param integration_pattern: (experimental) The service integration pattern indicates different ways to call RunTask in ECS. The valid value for Lambda is FIRE_AND_FORGET, SYNC and WAIT_FOR_TASK_TOKEN. Default: FIRE_AND_FORGET

        :stability: deprecated
        '''
        props = EcsRunTaskBaseProps(
            parameters=parameters,
            cluster=cluster,
            task_definition=task_definition,
            container_overrides=container_overrides,
            integration_pattern=integration_pattern,
        )

        jsii.create(self.__class__, self, [props])

    @jsii.member(jsii_name="bind")
    def bind(self, task: _Task_747ca4f2) -> _StepFunctionsTaskConfig_fa131821:
        '''(deprecated) Called when the task object is used in a workflow.

        :param task: -

        :stability: deprecated
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__21ba7eaca3d6186e68c5587fb07fe61f1c30392456a11143676fdfc4f0adcca1)
            check_type(argname="argument task", value=task, expected_type=type_hints["task"])
        return typing.cast(_StepFunctionsTaskConfig_fa131821, jsii.invoke(self, "bind", [task]))

    @jsii.member(jsii_name="configureAwsVpcNetworking")
    def _configure_aws_vpc_networking(
        self,
        vpc: _IVpc_6d1f76c4,
        assign_public_ip: typing.Optional[builtins.bool] = None,
        subnet_selection: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
        security_group: typing.Optional[_ISecurityGroup_cdbba9d3] = None,
    ) -> None:
        '''
        :param vpc: -
        :param assign_public_ip: -
        :param subnet_selection: -
        :param security_group: -

        :stability: deprecated
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e5f14dd1a2e95d8fcaf8e2be6d8ee0c5b9ea268b264868901b9f11abc540bcbe)
            check_type(argname="argument vpc", value=vpc, expected_type=type_hints["vpc"])
            check_type(argname="argument assign_public_ip", value=assign_public_ip, expected_type=type_hints["assign_public_ip"])
            check_type(argname="argument subnet_selection", value=subnet_selection, expected_type=type_hints["subnet_selection"])
            check_type(argname="argument security_group", value=security_group, expected_type=type_hints["security_group"])
        return typing.cast(None, jsii.invoke(self, "configureAwsVpcNetworking", [vpc, assign_public_ip, subnet_selection, security_group]))

    @builtins.property
    @jsii.member(jsii_name="connections")
    def connections(self) -> _Connections_57ccbda9:
        '''(deprecated) Manage allowed network traffic for this service.

        :stability: deprecated
        '''
        return typing.cast(_Connections_57ccbda9, jsii.get(self, "connections"))


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.EcsRunTaskBaseProps",
    jsii_struct_bases=[CommonEcsRunTaskProps],
    name_mapping={
        "cluster": "cluster",
        "task_definition": "taskDefinition",
        "container_overrides": "containerOverrides",
        "integration_pattern": "integrationPattern",
        "parameters": "parameters",
    },
)
class EcsRunTaskBaseProps(CommonEcsRunTaskProps):
    def __init__(
        self,
        *,
        cluster: _ICluster_42c4ec1a,
        task_definition: _TaskDefinition_c0dacfb4,
        container_overrides: typing.Optional[typing.Sequence[typing.Union[ContainerOverride, typing.Dict[builtins.str, typing.Any]]]] = None,
        integration_pattern: typing.Optional[_ServiceIntegrationPattern_5581ee88] = None,
        parameters: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    ) -> None:
        '''(deprecated) Construction properties for the BaseRunTaskProps.

        :param cluster: (experimental) The topic to run the task on.
        :param task_definition: (experimental) Task Definition used for running tasks in the service. Note: this must be TaskDefinition, and not ITaskDefinition, as it requires properties that are not known for imported task definitions
        :param container_overrides: (experimental) Container setting overrides. Key is the name of the container to override, value is the values you want to override. Default: - No overrides
        :param integration_pattern: (experimental) The service integration pattern indicates different ways to call RunTask in ECS. The valid value for Lambda is FIRE_AND_FORGET, SYNC and WAIT_FOR_TASK_TOKEN. Default: FIRE_AND_FORGET
        :param parameters: (deprecated) Additional parameters to pass to the base task. Default: - No additional parameters passed

        :deprecated: No replacement

        :stability: deprecated
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_ecs as ecs
            from monocdk import aws_stepfunctions as stepfunctions
            from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
            
            # cluster: ecs.Cluster
            # container_definition: ecs.ContainerDefinition
            # parameters: Any
            # task_definition: ecs.TaskDefinition
            
            ecs_run_task_base_props = stepfunctions_tasks.EcsRunTaskBaseProps(
                cluster=cluster,
                task_definition=task_definition,
            
                # the properties below are optional
                container_overrides=[stepfunctions_tasks.ContainerOverride(
                    container_definition=container_definition,
            
                    # the properties below are optional
                    command=["command"],
                    cpu=123,
                    environment=[stepfunctions_tasks.TaskEnvironmentVariable(
                        name="name",
                        value="value"
                    )],
                    memory_limit=123,
                    memory_reservation=123
                )],
                integration_pattern=stepfunctions.ServiceIntegrationPattern.FIRE_AND_FORGET,
                parameters={
                    "parameters_key": parameters
                }
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__15b45e87400dff8f9e18d7ec69f4372f8700035c9caa27c520ac54d0dbbd0c6a)
            check_type(argname="argument cluster", value=cluster, expected_type=type_hints["cluster"])
            check_type(argname="argument task_definition", value=task_definition, expected_type=type_hints["task_definition"])
            check_type(argname="argument container_overrides", value=container_overrides, expected_type=type_hints["container_overrides"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
            check_type(argname="argument parameters", value=parameters, expected_type=type_hints["parameters"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "cluster": cluster,
            "task_definition": task_definition,
        }
        if container_overrides is not None:
            self._values["container_overrides"] = container_overrides
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern
        if parameters is not None:
            self._values["parameters"] = parameters

    @builtins.property
    def cluster(self) -> _ICluster_42c4ec1a:
        '''(experimental) The topic to run the task on.

        :stability: experimental
        '''
        result = self._values.get("cluster")
        assert result is not None, "Required property 'cluster' is missing"
        return typing.cast(_ICluster_42c4ec1a, result)

    @builtins.property
    def task_definition(self) -> _TaskDefinition_c0dacfb4:
        '''(experimental) Task Definition used for running tasks in the service.

        Note: this must be TaskDefinition, and not ITaskDefinition,
        as it requires properties that are not known for imported task definitions

        :stability: experimental
        '''
        result = self._values.get("task_definition")
        assert result is not None, "Required property 'task_definition' is missing"
        return typing.cast(_TaskDefinition_c0dacfb4, result)

    @builtins.property
    def container_overrides(self) -> typing.Optional[typing.List[ContainerOverride]]:
        '''(experimental) Container setting overrides.

        Key is the name of the container to override, value is the
        values you want to override.

        :default: - No overrides

        :stability: experimental
        '''
        result = self._values.get("container_overrides")
        return typing.cast(typing.Optional[typing.List[ContainerOverride]], result)

    @builtins.property
    def integration_pattern(
        self,
    ) -> typing.Optional[_ServiceIntegrationPattern_5581ee88]:
        '''(experimental) The service integration pattern indicates different ways to call RunTask in ECS.

        The valid value for Lambda is FIRE_AND_FORGET, SYNC and WAIT_FOR_TASK_TOKEN.

        :default: FIRE_AND_FORGET

        :stability: experimental
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_ServiceIntegrationPattern_5581ee88], result)

    @builtins.property
    def parameters(self) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(deprecated) Additional parameters to pass to the base task.

        :default: - No additional parameters passed

        :stability: deprecated
        '''
        result = self._values.get("parameters")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EcsRunTaskBaseProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.EcsRunTaskProps",
    jsii_struct_bases=[_TaskStateBaseProps_b13f6332],
    name_mapping={
        "comment": "comment",
        "heartbeat": "heartbeat",
        "input_path": "inputPath",
        "integration_pattern": "integrationPattern",
        "output_path": "outputPath",
        "result_path": "resultPath",
        "result_selector": "resultSelector",
        "timeout": "timeout",
        "cluster": "cluster",
        "launch_target": "launchTarget",
        "task_definition": "taskDefinition",
        "assign_public_ip": "assignPublicIp",
        "container_overrides": "containerOverrides",
        "security_groups": "securityGroups",
        "subnets": "subnets",
    },
)
class EcsRunTaskProps(_TaskStateBaseProps_b13f6332):
    def __init__(
        self,
        *,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
        cluster: _ICluster_42c4ec1a,
        launch_target: "IEcsLaunchTarget",
        task_definition: _TaskDefinition_c0dacfb4,
        assign_public_ip: typing.Optional[builtins.bool] = None,
        container_overrides: typing.Optional[typing.Sequence[typing.Union[ContainerOverride, typing.Dict[builtins.str, typing.Any]]]] = None,
        security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
        subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''(experimental) Properties for ECS Tasks.

        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None
        :param cluster: (experimental) The ECS cluster to run the task on.
        :param launch_target: (experimental) An Amazon ECS launch type determines the type of infrastructure on which your tasks and services are hosted.
        :param task_definition: (experimental) [disable-awslint:ref-via-interface] Task Definition used for running tasks in the service. Note: this must be TaskDefinition, and not ITaskDefinition, as it requires properties that are not known for imported task definitions
        :param assign_public_ip: (experimental) Assign public IP addresses to each task. Default: false
        :param container_overrides: (experimental) Container setting overrides. Specify the container to use and the overrides to apply. Default: - No overrides
        :param security_groups: (experimental) Existing security groups to use for the tasks. Default: - A new security group is created
        :param subnets: (experimental) Subnets to place the task's ENIs. Default: - Public subnets if assignPublicIp is set. Private subnets otherwise.

        :stability: experimental
        :exampleMetadata: infused

        Example::

            vpc = ec2.Vpc.from_lookup(self, "Vpc",
                is_default=True
            )
            
            cluster = ecs.Cluster(self, "Ec2Cluster", vpc=vpc)
            cluster.add_capacity("DefaultAutoScalingGroup",
                instance_type=ec2.InstanceType("t2.micro"),
                vpc_subnets=dynamodb.aws_ec2.SubnetSelection(subnet_type=ec2.SubnetType.PUBLIC)
            )
            
            task_definition = ecs.TaskDefinition(self, "TD",
                compatibility=ecs.Compatibility.EC2
            )
            
            task_definition.add_container("TheContainer",
                image=ecs.ContainerImage.from_registry("foo/bar"),
                memory_limit_mi_b=256
            )
            
            run_task = tasks.EcsRunTask(self, "Run",
                integration_pattern=sfn.IntegrationPattern.RUN_JOB,
                cluster=cluster,
                task_definition=task_definition,
                launch_target=tasks.EcsEc2LaunchTarget(
                    placement_strategies=[
                        ecs.PlacementStrategy.spread_across_instances(),
                        ecs.PlacementStrategy.packed_by_cpu(),
                        ecs.PlacementStrategy.randomly()
                    ],
                    placement_constraints=[
                        ecs.PlacementConstraint.member_of("blieptuut")
                    ]
                )
            )
        '''
        if isinstance(subnets, dict):
            subnets = _SubnetSelection_1284e62c(**subnets)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__78ae706f3b0cf3baf3b98884089849b7db43f47a158cf29c575c4a10a485e52e)
            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
            check_type(argname="argument heartbeat", value=heartbeat, expected_type=type_hints["heartbeat"])
            check_type(argname="argument input_path", value=input_path, expected_type=type_hints["input_path"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
            check_type(argname="argument output_path", value=output_path, expected_type=type_hints["output_path"])
            check_type(argname="argument result_path", value=result_path, expected_type=type_hints["result_path"])
            check_type(argname="argument result_selector", value=result_selector, expected_type=type_hints["result_selector"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
            check_type(argname="argument cluster", value=cluster, expected_type=type_hints["cluster"])
            check_type(argname="argument launch_target", value=launch_target, expected_type=type_hints["launch_target"])
            check_type(argname="argument task_definition", value=task_definition, expected_type=type_hints["task_definition"])
            check_type(argname="argument assign_public_ip", value=assign_public_ip, expected_type=type_hints["assign_public_ip"])
            check_type(argname="argument container_overrides", value=container_overrides, expected_type=type_hints["container_overrides"])
            check_type(argname="argument security_groups", value=security_groups, expected_type=type_hints["security_groups"])
            check_type(argname="argument subnets", value=subnets, expected_type=type_hints["subnets"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "cluster": cluster,
            "launch_target": launch_target,
            "task_definition": task_definition,
        }
        if comment is not None:
            self._values["comment"] = comment
        if heartbeat is not None:
            self._values["heartbeat"] = heartbeat
        if input_path is not None:
            self._values["input_path"] = input_path
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern
        if output_path is not None:
            self._values["output_path"] = output_path
        if result_path is not None:
            self._values["result_path"] = result_path
        if result_selector is not None:
            self._values["result_selector"] = result_selector
        if timeout is not None:
            self._values["timeout"] = timeout
        if assign_public_ip is not None:
            self._values["assign_public_ip"] = assign_public_ip
        if container_overrides is not None:
            self._values["container_overrides"] = container_overrides
        if security_groups is not None:
            self._values["security_groups"] = security_groups
        if subnets is not None:
            self._values["subnets"] = subnets

    @builtins.property
    def comment(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional description for this state.

        :default: - No comment

        :stability: experimental
        '''
        result = self._values.get("comment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def heartbeat(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the heartbeat.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("heartbeat")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def input_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select part of the state to be the input to this state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        input to be the empty object {}.

        :default: - The entire task input (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("input_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def integration_pattern(self) -> typing.Optional[_IntegrationPattern_fbb35786]:
        '''(experimental) AWS Step Functions integrates with services directly in the Amazon States Language.

        You can control these AWS services using service integration patterns

        :default:

        - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks.
        ``IntegrationPattern.RUN_JOB`` for the following exceptions:
        ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html#connect-wait-token
        :stability: experimental
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_IntegrationPattern_fbb35786], result)

    @builtins.property
    def output_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select select a portion of the state output to pass to the next state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        output to be the empty object {}.

        :default:

        - The entire JSON node determined by the state input, the task result,
        and resultPath is passed to the next state (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("output_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to indicate where to inject the state's output.

        May also be the special value JsonPath.DISCARD, which will cause the state's
        input to become its output.

        :default: - Replaces the entire input with the result (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("result_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied.

        You can use ResultSelector to create a payload with values that are static
        or selected from the state's raw result.

        :default: - None

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/input-output-inputpath-params.html#input-output-resultselector
        :stability: experimental
        '''
        result = self._values.get("result_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def timeout(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the state machine.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def cluster(self) -> _ICluster_42c4ec1a:
        '''(experimental) The ECS cluster to run the task on.

        :stability: experimental
        '''
        result = self._values.get("cluster")
        assert result is not None, "Required property 'cluster' is missing"
        return typing.cast(_ICluster_42c4ec1a, result)

    @builtins.property
    def launch_target(self) -> "IEcsLaunchTarget":
        '''(experimental) An Amazon ECS launch type determines the type of infrastructure on which your tasks and services are hosted.

        :see: https://docs.aws.amazon.com/AmazonECS/latest/developerguide/launch_types.html
        :stability: experimental
        '''
        result = self._values.get("launch_target")
        assert result is not None, "Required property 'launch_target' is missing"
        return typing.cast("IEcsLaunchTarget", result)

    @builtins.property
    def task_definition(self) -> _TaskDefinition_c0dacfb4:
        '''(experimental) [disable-awslint:ref-via-interface] Task Definition used for running tasks in the service.

        Note: this must be TaskDefinition, and not ITaskDefinition,
        as it requires properties that are not known for imported task definitions

        :stability: experimental
        '''
        result = self._values.get("task_definition")
        assert result is not None, "Required property 'task_definition' is missing"
        return typing.cast(_TaskDefinition_c0dacfb4, result)

    @builtins.property
    def assign_public_ip(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Assign public IP addresses to each task.

        :default: false

        :stability: experimental
        '''
        result = self._values.get("assign_public_ip")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def container_overrides(self) -> typing.Optional[typing.List[ContainerOverride]]:
        '''(experimental) Container setting overrides.

        Specify the container to use and the overrides to apply.

        :default: - No overrides

        :stability: experimental
        '''
        result = self._values.get("container_overrides")
        return typing.cast(typing.Optional[typing.List[ContainerOverride]], result)

    @builtins.property
    def security_groups(self) -> typing.Optional[typing.List[_ISecurityGroup_cdbba9d3]]:
        '''(experimental) Existing security groups to use for the tasks.

        :default: - A new security group is created

        :stability: experimental
        '''
        result = self._values.get("security_groups")
        return typing.cast(typing.Optional[typing.List[_ISecurityGroup_cdbba9d3]], result)

    @builtins.property
    def subnets(self) -> typing.Optional[_SubnetSelection_1284e62c]:
        '''(experimental) Subnets to place the task's ENIs.

        :default: - Public subnets if assignPublicIp is set. Private subnets otherwise.

        :stability: experimental
        '''
        result = self._values.get("subnets")
        return typing.cast(typing.Optional[_SubnetSelection_1284e62c], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EcsRunTaskProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class EksCall(
    _TaskStateBase_c3080646,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.EksCall",
):
    '''(experimental) Call a EKS endpoint as a Task.

    :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-eks.html
    :stability: experimental
    :exampleMetadata: infused

    Example::

        import monocdk as eks
        
        
        my_eks_cluster = eks.Cluster(self, "my sample cluster",
            version=eks.KubernetesVersion.V1_18,
            cluster_name="myEksCluster"
        )
        
        tasks.EksCall(self, "Call a EKS Endpoint",
            cluster=my_eks_cluster,
            http_method=tasks.HttpMethods.GET,
            http_path="/api/v1/namespaces/default/pods"
        )
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        cluster: _ICluster_e7e676cf,
        http_method: "HttpMethods",
        http_path: builtins.str,
        query_parameters: typing.Optional[typing.Mapping[builtins.str, typing.Sequence[builtins.str]]] = None,
        request_body: typing.Optional[_TaskInput_71ab46f6] = None,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param cluster: (experimental) The EKS cluster.
        :param http_method: (experimental) HTTP method ("GET", "POST", "PUT", ...) part of HTTP request.
        :param http_path: (experimental) HTTP path of the Kubernetes REST API operation For example: /api/v1/namespaces/default/pods.
        :param query_parameters: (experimental) Query Parameters part of HTTP request. Default: - no query parameters
        :param request_body: (experimental) Request body part of HTTP request. Default: - No request body
        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e952c65435db52e3e70a5ff0952708975260083434274179be34128c9267f2ef)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = EksCallProps(
            cluster=cluster,
            http_method=http_method,
            http_path=http_path,
            query_parameters=query_parameters,
            request_body=request_body,
            comment=comment,
            heartbeat=heartbeat,
            input_path=input_path,
            integration_pattern=integration_pattern,
            output_path=output_path,
            result_path=result_path,
            result_selector=result_selector,
            timeout=timeout,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="taskMetrics")
    def _task_metrics(self) -> typing.Optional[_TaskMetricsConfig_5aaea59e]:
        '''(experimental) No policies are required due to eks:call is an Http service integration and does not call and EKS API directly.

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-eks.html#connect-eks-permissions
        :stability: experimental
        '''
        return typing.cast(typing.Optional[_TaskMetricsConfig_5aaea59e], jsii.get(self, "taskMetrics"))

    @builtins.property
    @jsii.member(jsii_name="taskPolicies")
    def _task_policies(self) -> typing.Optional[typing.List[_PolicyStatement_296fe8a3]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.List[_PolicyStatement_296fe8a3]], jsii.get(self, "taskPolicies"))


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.EksCallProps",
    jsii_struct_bases=[_TaskStateBaseProps_b13f6332],
    name_mapping={
        "comment": "comment",
        "heartbeat": "heartbeat",
        "input_path": "inputPath",
        "integration_pattern": "integrationPattern",
        "output_path": "outputPath",
        "result_path": "resultPath",
        "result_selector": "resultSelector",
        "timeout": "timeout",
        "cluster": "cluster",
        "http_method": "httpMethod",
        "http_path": "httpPath",
        "query_parameters": "queryParameters",
        "request_body": "requestBody",
    },
)
class EksCallProps(_TaskStateBaseProps_b13f6332):
    def __init__(
        self,
        *,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
        cluster: _ICluster_e7e676cf,
        http_method: "HttpMethods",
        http_path: builtins.str,
        query_parameters: typing.Optional[typing.Mapping[builtins.str, typing.Sequence[builtins.str]]] = None,
        request_body: typing.Optional[_TaskInput_71ab46f6] = None,
    ) -> None:
        '''(experimental) Properties for calling a EKS endpoint with EksCall.

        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None
        :param cluster: (experimental) The EKS cluster.
        :param http_method: (experimental) HTTP method ("GET", "POST", "PUT", ...) part of HTTP request.
        :param http_path: (experimental) HTTP path of the Kubernetes REST API operation For example: /api/v1/namespaces/default/pods.
        :param query_parameters: (experimental) Query Parameters part of HTTP request. Default: - no query parameters
        :param request_body: (experimental) Request body part of HTTP request. Default: - No request body

        :stability: experimental
        :exampleMetadata: infused

        Example::

            import monocdk as eks
            
            
            my_eks_cluster = eks.Cluster(self, "my sample cluster",
                version=eks.KubernetesVersion.V1_18,
                cluster_name="myEksCluster"
            )
            
            tasks.EksCall(self, "Call a EKS Endpoint",
                cluster=my_eks_cluster,
                http_method=tasks.HttpMethods.GET,
                http_path="/api/v1/namespaces/default/pods"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3cfe7a2596f78fdcb3164eeff3590eaad18da457b9f277a880c8bff1eda34f21)
            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
            check_type(argname="argument heartbeat", value=heartbeat, expected_type=type_hints["heartbeat"])
            check_type(argname="argument input_path", value=input_path, expected_type=type_hints["input_path"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
            check_type(argname="argument output_path", value=output_path, expected_type=type_hints["output_path"])
            check_type(argname="argument result_path", value=result_path, expected_type=type_hints["result_path"])
            check_type(argname="argument result_selector", value=result_selector, expected_type=type_hints["result_selector"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
            check_type(argname="argument cluster", value=cluster, expected_type=type_hints["cluster"])
            check_type(argname="argument http_method", value=http_method, expected_type=type_hints["http_method"])
            check_type(argname="argument http_path", value=http_path, expected_type=type_hints["http_path"])
            check_type(argname="argument query_parameters", value=query_parameters, expected_type=type_hints["query_parameters"])
            check_type(argname="argument request_body", value=request_body, expected_type=type_hints["request_body"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "cluster": cluster,
            "http_method": http_method,
            "http_path": http_path,
        }
        if comment is not None:
            self._values["comment"] = comment
        if heartbeat is not None:
            self._values["heartbeat"] = heartbeat
        if input_path is not None:
            self._values["input_path"] = input_path
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern
        if output_path is not None:
            self._values["output_path"] = output_path
        if result_path is not None:
            self._values["result_path"] = result_path
        if result_selector is not None:
            self._values["result_selector"] = result_selector
        if timeout is not None:
            self._values["timeout"] = timeout
        if query_parameters is not None:
            self._values["query_parameters"] = query_parameters
        if request_body is not None:
            self._values["request_body"] = request_body

    @builtins.property
    def comment(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional description for this state.

        :default: - No comment

        :stability: experimental
        '''
        result = self._values.get("comment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def heartbeat(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the heartbeat.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("heartbeat")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def input_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select part of the state to be the input to this state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        input to be the empty object {}.

        :default: - The entire task input (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("input_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def integration_pattern(self) -> typing.Optional[_IntegrationPattern_fbb35786]:
        '''(experimental) AWS Step Functions integrates with services directly in the Amazon States Language.

        You can control these AWS services using service integration patterns

        :default:

        - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks.
        ``IntegrationPattern.RUN_JOB`` for the following exceptions:
        ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html#connect-wait-token
        :stability: experimental
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_IntegrationPattern_fbb35786], result)

    @builtins.property
    def output_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select select a portion of the state output to pass to the next state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        output to be the empty object {}.

        :default:

        - The entire JSON node determined by the state input, the task result,
        and resultPath is passed to the next state (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("output_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to indicate where to inject the state's output.

        May also be the special value JsonPath.DISCARD, which will cause the state's
        input to become its output.

        :default: - Replaces the entire input with the result (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("result_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied.

        You can use ResultSelector to create a payload with values that are static
        or selected from the state's raw result.

        :default: - None

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/input-output-inputpath-params.html#input-output-resultselector
        :stability: experimental
        '''
        result = self._values.get("result_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def timeout(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the state machine.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def cluster(self) -> _ICluster_e7e676cf:
        '''(experimental) The EKS cluster.

        :stability: experimental
        '''
        result = self._values.get("cluster")
        assert result is not None, "Required property 'cluster' is missing"
        return typing.cast(_ICluster_e7e676cf, result)

    @builtins.property
    def http_method(self) -> "HttpMethods":
        '''(experimental) HTTP method ("GET", "POST", "PUT", ...) part of HTTP request.

        :stability: experimental
        '''
        result = self._values.get("http_method")
        assert result is not None, "Required property 'http_method' is missing"
        return typing.cast("HttpMethods", result)

    @builtins.property
    def http_path(self) -> builtins.str:
        '''(experimental) HTTP path of the Kubernetes REST API operation For example: /api/v1/namespaces/default/pods.

        :stability: experimental
        '''
        result = self._values.get("http_path")
        assert result is not None, "Required property 'http_path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def query_parameters(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.List[builtins.str]]]:
        '''(experimental) Query Parameters part of HTTP request.

        :default: - no query parameters

        :stability: experimental
        '''
        result = self._values.get("query_parameters")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.List[builtins.str]]], result)

    @builtins.property
    def request_body(self) -> typing.Optional[_TaskInput_71ab46f6]:
        '''(experimental) Request body part of HTTP request.

        :default: - No request body

        :stability: experimental
        '''
        result = self._values.get("request_body")
        return typing.cast(typing.Optional[_TaskInput_71ab46f6], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EksCallProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class EksClusterInput(
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.EksClusterInput",
):
    '''(experimental) Class that supports methods which return the EKS cluster name depending on input type.

    :stability: experimental
    :exampleMetadata: infused

    Example::

        tasks.EmrContainersCreateVirtualCluster(self, "Create a Virtual Cluster",
            eks_cluster=tasks.EksClusterInput.from_task_input(sfn.TaskInput.from_text("clusterId")),
            eks_namespace="specified-namespace"
        )
    '''

    @jsii.member(jsii_name="fromCluster")
    @builtins.classmethod
    def from_cluster(cls, cluster: _ICluster_e7e676cf) -> "EksClusterInput":
        '''(experimental) Specify an existing EKS Cluster as the name for this Cluster.

        :param cluster: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9b762513b331e394a955c4b80a0b39d8ce380d2c8a002e56224afef1c30f5b4e)
            check_type(argname="argument cluster", value=cluster, expected_type=type_hints["cluster"])
        return typing.cast("EksClusterInput", jsii.sinvoke(cls, "fromCluster", [cluster]))

    @jsii.member(jsii_name="fromTaskInput")
    @builtins.classmethod
    def from_task_input(cls, task_input: _TaskInput_71ab46f6) -> "EksClusterInput":
        '''(experimental) Specify a Task Input as the name for this Cluster.

        :param task_input: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__57beafa94208c3483ddb350ef86642f4e7f2a01a800a3c1225936c3f866d9858)
            check_type(argname="argument task_input", value=task_input, expected_type=type_hints["task_input"])
        return typing.cast("EksClusterInput", jsii.sinvoke(cls, "fromTaskInput", [task_input]))

    @builtins.property
    @jsii.member(jsii_name="clusterName")
    def cluster_name(self) -> builtins.str:
        '''(experimental) The name of the EKS Cluster.

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "clusterName"))


class EmrAddStep(
    _TaskStateBase_c3080646,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.EmrAddStep",
):
    '''(experimental) A Step Functions Task to add a Step to an EMR Cluster.

    The StepConfiguration is defined as Parameters in the state machine definition.

    OUTPUT: the StepId

    :stability: experimental
    :exampleMetadata: infused

    Example::

        tasks.EmrAddStep(self, "Task",
            cluster_id="ClusterId",
            name="StepName",
            jar="Jar",
            action_on_failure=tasks.ActionOnFailure.CONTINUE
        )
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        cluster_id: builtins.str,
        jar: builtins.str,
        name: builtins.str,
        action_on_failure: typing.Optional[ActionOnFailure] = None,
        args: typing.Optional[typing.Sequence[builtins.str]] = None,
        main_class: typing.Optional[builtins.str] = None,
        properties: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param cluster_id: (experimental) The ClusterId to add the Step to.
        :param jar: (experimental) A path to a JAR file run during the step.
        :param name: (experimental) The name of the Step.
        :param action_on_failure: (experimental) The action to take when the cluster step fails. Default: ActionOnFailure.CONTINUE
        :param args: (experimental) A list of command line arguments passed to the JAR file's main function when executed. Default: - No args
        :param main_class: (experimental) The name of the main class in the specified Java file. If not specified, the JAR file should specify a Main-Class in its manifest file. Default: - No mainClass
        :param properties: (experimental) A list of Java properties that are set when the step runs. You can use these properties to pass key value pairs to your main function. Default: - No properties
        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f927b1d063aa72dc51ccf6339fd43cb6313f25265881eed13f3cc2cc14791e49)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = EmrAddStepProps(
            cluster_id=cluster_id,
            jar=jar,
            name=name,
            action_on_failure=action_on_failure,
            args=args,
            main_class=main_class,
            properties=properties,
            comment=comment,
            heartbeat=heartbeat,
            input_path=input_path,
            integration_pattern=integration_pattern,
            output_path=output_path,
            result_path=result_path,
            result_selector=result_selector,
            timeout=timeout,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="taskMetrics")
    def _task_metrics(self) -> typing.Optional[_TaskMetricsConfig_5aaea59e]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[_TaskMetricsConfig_5aaea59e], jsii.get(self, "taskMetrics"))

    @builtins.property
    @jsii.member(jsii_name="taskPolicies")
    def _task_policies(self) -> typing.Optional[typing.List[_PolicyStatement_296fe8a3]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.List[_PolicyStatement_296fe8a3]], jsii.get(self, "taskPolicies"))


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.EmrAddStepProps",
    jsii_struct_bases=[_TaskStateBaseProps_b13f6332],
    name_mapping={
        "comment": "comment",
        "heartbeat": "heartbeat",
        "input_path": "inputPath",
        "integration_pattern": "integrationPattern",
        "output_path": "outputPath",
        "result_path": "resultPath",
        "result_selector": "resultSelector",
        "timeout": "timeout",
        "cluster_id": "clusterId",
        "jar": "jar",
        "name": "name",
        "action_on_failure": "actionOnFailure",
        "args": "args",
        "main_class": "mainClass",
        "properties": "properties",
    },
)
class EmrAddStepProps(_TaskStateBaseProps_b13f6332):
    def __init__(
        self,
        *,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
        cluster_id: builtins.str,
        jar: builtins.str,
        name: builtins.str,
        action_on_failure: typing.Optional[ActionOnFailure] = None,
        args: typing.Optional[typing.Sequence[builtins.str]] = None,
        main_class: typing.Optional[builtins.str] = None,
        properties: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''(experimental) Properties for EmrAddStep.

        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None
        :param cluster_id: (experimental) The ClusterId to add the Step to.
        :param jar: (experimental) A path to a JAR file run during the step.
        :param name: (experimental) The name of the Step.
        :param action_on_failure: (experimental) The action to take when the cluster step fails. Default: ActionOnFailure.CONTINUE
        :param args: (experimental) A list of command line arguments passed to the JAR file's main function when executed. Default: - No args
        :param main_class: (experimental) The name of the main class in the specified Java file. If not specified, the JAR file should specify a Main-Class in its manifest file. Default: - No mainClass
        :param properties: (experimental) A list of Java properties that are set when the step runs. You can use these properties to pass key value pairs to your main function. Default: - No properties

        :stability: experimental
        :exampleMetadata: infused

        Example::

            tasks.EmrAddStep(self, "Task",
                cluster_id="ClusterId",
                name="StepName",
                jar="Jar",
                action_on_failure=tasks.ActionOnFailure.CONTINUE
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3c5db24e8ea456e8a91d9f0b2b1fa6e548b76aa7ad57e3b3f8974a1b9e62c7da)
            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
            check_type(argname="argument heartbeat", value=heartbeat, expected_type=type_hints["heartbeat"])
            check_type(argname="argument input_path", value=input_path, expected_type=type_hints["input_path"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
            check_type(argname="argument output_path", value=output_path, expected_type=type_hints["output_path"])
            check_type(argname="argument result_path", value=result_path, expected_type=type_hints["result_path"])
            check_type(argname="argument result_selector", value=result_selector, expected_type=type_hints["result_selector"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
            check_type(argname="argument cluster_id", value=cluster_id, expected_type=type_hints["cluster_id"])
            check_type(argname="argument jar", value=jar, expected_type=type_hints["jar"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument action_on_failure", value=action_on_failure, expected_type=type_hints["action_on_failure"])
            check_type(argname="argument args", value=args, expected_type=type_hints["args"])
            check_type(argname="argument main_class", value=main_class, expected_type=type_hints["main_class"])
            check_type(argname="argument properties", value=properties, expected_type=type_hints["properties"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "cluster_id": cluster_id,
            "jar": jar,
            "name": name,
        }
        if comment is not None:
            self._values["comment"] = comment
        if heartbeat is not None:
            self._values["heartbeat"] = heartbeat
        if input_path is not None:
            self._values["input_path"] = input_path
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern
        if output_path is not None:
            self._values["output_path"] = output_path
        if result_path is not None:
            self._values["result_path"] = result_path
        if result_selector is not None:
            self._values["result_selector"] = result_selector
        if timeout is not None:
            self._values["timeout"] = timeout
        if action_on_failure is not None:
            self._values["action_on_failure"] = action_on_failure
        if args is not None:
            self._values["args"] = args
        if main_class is not None:
            self._values["main_class"] = main_class
        if properties is not None:
            self._values["properties"] = properties

    @builtins.property
    def comment(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional description for this state.

        :default: - No comment

        :stability: experimental
        '''
        result = self._values.get("comment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def heartbeat(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the heartbeat.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("heartbeat")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def input_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select part of the state to be the input to this state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        input to be the empty object {}.

        :default: - The entire task input (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("input_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def integration_pattern(self) -> typing.Optional[_IntegrationPattern_fbb35786]:
        '''(experimental) AWS Step Functions integrates with services directly in the Amazon States Language.

        You can control these AWS services using service integration patterns

        :default:

        - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks.
        ``IntegrationPattern.RUN_JOB`` for the following exceptions:
        ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html#connect-wait-token
        :stability: experimental
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_IntegrationPattern_fbb35786], result)

    @builtins.property
    def output_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select select a portion of the state output to pass to the next state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        output to be the empty object {}.

        :default:

        - The entire JSON node determined by the state input, the task result,
        and resultPath is passed to the next state (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("output_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to indicate where to inject the state's output.

        May also be the special value JsonPath.DISCARD, which will cause the state's
        input to become its output.

        :default: - Replaces the entire input with the result (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("result_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied.

        You can use ResultSelector to create a payload with values that are static
        or selected from the state's raw result.

        :default: - None

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/input-output-inputpath-params.html#input-output-resultselector
        :stability: experimental
        '''
        result = self._values.get("result_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def timeout(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the state machine.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def cluster_id(self) -> builtins.str:
        '''(experimental) The ClusterId to add the Step to.

        :stability: experimental
        '''
        result = self._values.get("cluster_id")
        assert result is not None, "Required property 'cluster_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def jar(self) -> builtins.str:
        '''(experimental) A path to a JAR file run during the step.

        :see: https://docs.aws.amazon.com/emr/latest/APIReference/API_HadoopJarStepConfig.html
        :stability: experimental
        '''
        result = self._values.get("jar")
        assert result is not None, "Required property 'jar' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> builtins.str:
        '''(experimental) The name of the Step.

        :see: https://docs.aws.amazon.com/emr/latest/APIReference/API_StepConfig.html
        :stability: experimental
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def action_on_failure(self) -> typing.Optional[ActionOnFailure]:
        '''(experimental) The action to take when the cluster step fails.

        :default: ActionOnFailure.CONTINUE

        :see: https://docs.aws.amazon.com/emr/latest/APIReference/API_StepConfig.html
        :stability: experimental
        '''
        result = self._values.get("action_on_failure")
        return typing.cast(typing.Optional[ActionOnFailure], result)

    @builtins.property
    def args(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) A list of command line arguments passed to the JAR file's main function when executed.

        :default: - No args

        :see: https://docs.aws.amazon.com/emr/latest/APIReference/API_HadoopJarStepConfig.html
        :stability: experimental
        '''
        result = self._values.get("args")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def main_class(self) -> typing.Optional[builtins.str]:
        '''(experimental) The name of the main class in the specified Java file.

        If not specified, the JAR file should specify a Main-Class in its manifest file.

        :default: - No mainClass

        :see: https://docs.aws.amazon.com/emr/latest/APIReference/API_HadoopJarStepConfig.html
        :stability: experimental
        '''
        result = self._values.get("main_class")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def properties(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''(experimental) A list of Java properties that are set when the step runs.

        You can use these properties to pass key value pairs to your main function.

        :default: - No properties

        :see: https://docs.aws.amazon.com/emr/latest/APIReference/API_HadoopJarStepConfig.html
        :stability: experimental
        '''
        result = self._values.get("properties")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EmrAddStepProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class EmrCancelStep(
    _TaskStateBase_c3080646,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.EmrCancelStep",
):
    '''(experimental) A Step Functions Task to to cancel a Step on an EMR Cluster.

    :stability: experimental
    :exampleMetadata: infused

    Example::

        tasks.EmrCancelStep(self, "Task",
            cluster_id="ClusterId",
            step_id="StepId"
        )
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        cluster_id: builtins.str,
        step_id: builtins.str,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param cluster_id: (experimental) The ClusterId to update.
        :param step_id: (experimental) The StepId to cancel.
        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__785f802bfae1a766e505bc131de09693420af308a74dcf9d89112d2c5cfe3128)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = EmrCancelStepProps(
            cluster_id=cluster_id,
            step_id=step_id,
            comment=comment,
            heartbeat=heartbeat,
            input_path=input_path,
            integration_pattern=integration_pattern,
            output_path=output_path,
            result_path=result_path,
            result_selector=result_selector,
            timeout=timeout,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="taskMetrics")
    def _task_metrics(self) -> typing.Optional[_TaskMetricsConfig_5aaea59e]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[_TaskMetricsConfig_5aaea59e], jsii.get(self, "taskMetrics"))

    @builtins.property
    @jsii.member(jsii_name="taskPolicies")
    def _task_policies(self) -> typing.Optional[typing.List[_PolicyStatement_296fe8a3]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.List[_PolicyStatement_296fe8a3]], jsii.get(self, "taskPolicies"))


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.EmrCancelStepProps",
    jsii_struct_bases=[_TaskStateBaseProps_b13f6332],
    name_mapping={
        "comment": "comment",
        "heartbeat": "heartbeat",
        "input_path": "inputPath",
        "integration_pattern": "integrationPattern",
        "output_path": "outputPath",
        "result_path": "resultPath",
        "result_selector": "resultSelector",
        "timeout": "timeout",
        "cluster_id": "clusterId",
        "step_id": "stepId",
    },
)
class EmrCancelStepProps(_TaskStateBaseProps_b13f6332):
    def __init__(
        self,
        *,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
        cluster_id: builtins.str,
        step_id: builtins.str,
    ) -> None:
        '''(experimental) Properties for EmrCancelStep.

        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None
        :param cluster_id: (experimental) The ClusterId to update.
        :param step_id: (experimental) The StepId to cancel.

        :stability: experimental
        :exampleMetadata: infused

        Example::

            tasks.EmrCancelStep(self, "Task",
                cluster_id="ClusterId",
                step_id="StepId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eb31d268cb374fca02551f55095d596ae04a6b153f8b53763c03078f3a91d38d)
            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
            check_type(argname="argument heartbeat", value=heartbeat, expected_type=type_hints["heartbeat"])
            check_type(argname="argument input_path", value=input_path, expected_type=type_hints["input_path"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
            check_type(argname="argument output_path", value=output_path, expected_type=type_hints["output_path"])
            check_type(argname="argument result_path", value=result_path, expected_type=type_hints["result_path"])
            check_type(argname="argument result_selector", value=result_selector, expected_type=type_hints["result_selector"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
            check_type(argname="argument cluster_id", value=cluster_id, expected_type=type_hints["cluster_id"])
            check_type(argname="argument step_id", value=step_id, expected_type=type_hints["step_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "cluster_id": cluster_id,
            "step_id": step_id,
        }
        if comment is not None:
            self._values["comment"] = comment
        if heartbeat is not None:
            self._values["heartbeat"] = heartbeat
        if input_path is not None:
            self._values["input_path"] = input_path
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern
        if output_path is not None:
            self._values["output_path"] = output_path
        if result_path is not None:
            self._values["result_path"] = result_path
        if result_selector is not None:
            self._values["result_selector"] = result_selector
        if timeout is not None:
            self._values["timeout"] = timeout

    @builtins.property
    def comment(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional description for this state.

        :default: - No comment

        :stability: experimental
        '''
        result = self._values.get("comment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def heartbeat(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the heartbeat.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("heartbeat")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def input_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select part of the state to be the input to this state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        input to be the empty object {}.

        :default: - The entire task input (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("input_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def integration_pattern(self) -> typing.Optional[_IntegrationPattern_fbb35786]:
        '''(experimental) AWS Step Functions integrates with services directly in the Amazon States Language.

        You can control these AWS services using service integration patterns

        :default:

        - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks.
        ``IntegrationPattern.RUN_JOB`` for the following exceptions:
        ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html#connect-wait-token
        :stability: experimental
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_IntegrationPattern_fbb35786], result)

    @builtins.property
    def output_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select select a portion of the state output to pass to the next state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        output to be the empty object {}.

        :default:

        - The entire JSON node determined by the state input, the task result,
        and resultPath is passed to the next state (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("output_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to indicate where to inject the state's output.

        May also be the special value JsonPath.DISCARD, which will cause the state's
        input to become its output.

        :default: - Replaces the entire input with the result (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("result_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied.

        You can use ResultSelector to create a payload with values that are static
        or selected from the state's raw result.

        :default: - None

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/input-output-inputpath-params.html#input-output-resultselector
        :stability: experimental
        '''
        result = self._values.get("result_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def timeout(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the state machine.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def cluster_id(self) -> builtins.str:
        '''(experimental) The ClusterId to update.

        :stability: experimental
        '''
        result = self._values.get("cluster_id")
        assert result is not None, "Required property 'cluster_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def step_id(self) -> builtins.str:
        '''(experimental) The StepId to cancel.

        :stability: experimental
        '''
        result = self._values.get("step_id")
        assert result is not None, "Required property 'step_id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EmrCancelStepProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class EmrContainersCreateVirtualCluster(
    _TaskStateBase_c3080646,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.EmrContainersCreateVirtualCluster",
):
    '''(experimental) Task that creates an EMR Containers virtual cluster from an EKS cluster.

    :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-emr-eks.html
    :stability: experimental
    :exampleMetadata: infused

    Example::

        tasks.EmrContainersCreateVirtualCluster(self, "Create a Virtual Cluster",
            eks_cluster=tasks.EksClusterInput.from_task_input(sfn.TaskInput.from_text("clusterId")),
            eks_namespace="specified-namespace"
        )
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        eks_cluster: EksClusterInput,
        eks_namespace: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        virtual_cluster_name: typing.Optional[builtins.str] = None,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param eks_cluster: (experimental) EKS Cluster or task input that contains the name of the cluster.
        :param eks_namespace: (experimental) The namespace of an EKS cluster. Default: - 'default'
        :param tags: (experimental) The tags assigned to the virtual cluster. Default: {}
        :param virtual_cluster_name: (experimental) Name of the virtual cluster that will be created. Default: - the name of the state machine execution that runs this task and state name
        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__50ac8afd98d0b18f69b953dfe878c155573b69c5b7f6ed8649c50fb7033283e1)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = EmrContainersCreateVirtualClusterProps(
            eks_cluster=eks_cluster,
            eks_namespace=eks_namespace,
            tags=tags,
            virtual_cluster_name=virtual_cluster_name,
            comment=comment,
            heartbeat=heartbeat,
            input_path=input_path,
            integration_pattern=integration_pattern,
            output_path=output_path,
            result_path=result_path,
            result_selector=result_selector,
            timeout=timeout,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="taskMetrics")
    def _task_metrics(self) -> typing.Optional[_TaskMetricsConfig_5aaea59e]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[_TaskMetricsConfig_5aaea59e], jsii.get(self, "taskMetrics"))

    @builtins.property
    @jsii.member(jsii_name="taskPolicies")
    def _task_policies(self) -> typing.Optional[typing.List[_PolicyStatement_296fe8a3]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.List[_PolicyStatement_296fe8a3]], jsii.get(self, "taskPolicies"))


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.EmrContainersCreateVirtualClusterProps",
    jsii_struct_bases=[_TaskStateBaseProps_b13f6332],
    name_mapping={
        "comment": "comment",
        "heartbeat": "heartbeat",
        "input_path": "inputPath",
        "integration_pattern": "integrationPattern",
        "output_path": "outputPath",
        "result_path": "resultPath",
        "result_selector": "resultSelector",
        "timeout": "timeout",
        "eks_cluster": "eksCluster",
        "eks_namespace": "eksNamespace",
        "tags": "tags",
        "virtual_cluster_name": "virtualClusterName",
    },
)
class EmrContainersCreateVirtualClusterProps(_TaskStateBaseProps_b13f6332):
    def __init__(
        self,
        *,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
        eks_cluster: EksClusterInput,
        eks_namespace: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        virtual_cluster_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''(experimental) Properties to define a EMR Containers CreateVirtualCluster Task on an EKS cluster.

        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None
        :param eks_cluster: (experimental) EKS Cluster or task input that contains the name of the cluster.
        :param eks_namespace: (experimental) The namespace of an EKS cluster. Default: - 'default'
        :param tags: (experimental) The tags assigned to the virtual cluster. Default: {}
        :param virtual_cluster_name: (experimental) Name of the virtual cluster that will be created. Default: - the name of the state machine execution that runs this task and state name

        :stability: experimental
        :exampleMetadata: infused

        Example::

            tasks.EmrContainersCreateVirtualCluster(self, "Create a Virtual Cluster",
                eks_cluster=tasks.EksClusterInput.from_task_input(sfn.TaskInput.from_text("clusterId")),
                eks_namespace="specified-namespace"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__abf1ab32a8d29073fe21e35bccf34024dd0830802b68510fbfd98d480ae41c17)
            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
            check_type(argname="argument heartbeat", value=heartbeat, expected_type=type_hints["heartbeat"])
            check_type(argname="argument input_path", value=input_path, expected_type=type_hints["input_path"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
            check_type(argname="argument output_path", value=output_path, expected_type=type_hints["output_path"])
            check_type(argname="argument result_path", value=result_path, expected_type=type_hints["result_path"])
            check_type(argname="argument result_selector", value=result_selector, expected_type=type_hints["result_selector"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
            check_type(argname="argument eks_cluster", value=eks_cluster, expected_type=type_hints["eks_cluster"])
            check_type(argname="argument eks_namespace", value=eks_namespace, expected_type=type_hints["eks_namespace"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument virtual_cluster_name", value=virtual_cluster_name, expected_type=type_hints["virtual_cluster_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "eks_cluster": eks_cluster,
        }
        if comment is not None:
            self._values["comment"] = comment
        if heartbeat is not None:
            self._values["heartbeat"] = heartbeat
        if input_path is not None:
            self._values["input_path"] = input_path
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern
        if output_path is not None:
            self._values["output_path"] = output_path
        if result_path is not None:
            self._values["result_path"] = result_path
        if result_selector is not None:
            self._values["result_selector"] = result_selector
        if timeout is not None:
            self._values["timeout"] = timeout
        if eks_namespace is not None:
            self._values["eks_namespace"] = eks_namespace
        if tags is not None:
            self._values["tags"] = tags
        if virtual_cluster_name is not None:
            self._values["virtual_cluster_name"] = virtual_cluster_name

    @builtins.property
    def comment(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional description for this state.

        :default: - No comment

        :stability: experimental
        '''
        result = self._values.get("comment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def heartbeat(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the heartbeat.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("heartbeat")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def input_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select part of the state to be the input to this state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        input to be the empty object {}.

        :default: - The entire task input (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("input_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def integration_pattern(self) -> typing.Optional[_IntegrationPattern_fbb35786]:
        '''(experimental) AWS Step Functions integrates with services directly in the Amazon States Language.

        You can control these AWS services using service integration patterns

        :default:

        - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks.
        ``IntegrationPattern.RUN_JOB`` for the following exceptions:
        ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html#connect-wait-token
        :stability: experimental
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_IntegrationPattern_fbb35786], result)

    @builtins.property
    def output_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select select a portion of the state output to pass to the next state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        output to be the empty object {}.

        :default:

        - The entire JSON node determined by the state input, the task result,
        and resultPath is passed to the next state (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("output_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to indicate where to inject the state's output.

        May also be the special value JsonPath.DISCARD, which will cause the state's
        input to become its output.

        :default: - Replaces the entire input with the result (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("result_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied.

        You can use ResultSelector to create a payload with values that are static
        or selected from the state's raw result.

        :default: - None

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/input-output-inputpath-params.html#input-output-resultselector
        :stability: experimental
        '''
        result = self._values.get("result_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def timeout(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the state machine.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def eks_cluster(self) -> EksClusterInput:
        '''(experimental) EKS Cluster or task input that contains the name of the cluster.

        :stability: experimental
        '''
        result = self._values.get("eks_cluster")
        assert result is not None, "Required property 'eks_cluster' is missing"
        return typing.cast(EksClusterInput, result)

    @builtins.property
    def eks_namespace(self) -> typing.Optional[builtins.str]:
        '''(experimental) The namespace of an EKS cluster.

        :default: - 'default'

        :stability: experimental
        '''
        result = self._values.get("eks_namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''(experimental) The tags assigned to the virtual cluster.

        :default: {}

        :stability: experimental
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def virtual_cluster_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Name of the virtual cluster that will be created.

        :default: - the name of the state machine execution that runs this task and state name

        :stability: experimental
        '''
        result = self._values.get("virtual_cluster_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EmrContainersCreateVirtualClusterProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class EmrContainersDeleteVirtualCluster(
    _TaskStateBase_c3080646,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.EmrContainersDeleteVirtualCluster",
):
    '''(experimental) Deletes an EMR Containers virtual cluster as a Task.

    :see: https://docs.amazonaws.cn/en_us/step-functions/latest/dg/connect-emr-eks.html
    :stability: experimental
    :exampleMetadata: infused

    Example::

        tasks.EmrContainersDeleteVirtualCluster(self, "Delete a Virtual Cluster",
            virtual_cluster_id=sfn.TaskInput.from_json_path_at("$.virtualCluster")
        )
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        virtual_cluster_id: _TaskInput_71ab46f6,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param virtual_cluster_id: (experimental) The ID of the virtual cluster that will be deleted.
        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4c2be350ed024a4864230b8c3e097e05964c922f44f55946856112b9853e1534)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = EmrContainersDeleteVirtualClusterProps(
            virtual_cluster_id=virtual_cluster_id,
            comment=comment,
            heartbeat=heartbeat,
            input_path=input_path,
            integration_pattern=integration_pattern,
            output_path=output_path,
            result_path=result_path,
            result_selector=result_selector,
            timeout=timeout,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="taskMetrics")
    def _task_metrics(self) -> typing.Optional[_TaskMetricsConfig_5aaea59e]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[_TaskMetricsConfig_5aaea59e], jsii.get(self, "taskMetrics"))

    @builtins.property
    @jsii.member(jsii_name="taskPolicies")
    def _task_policies(self) -> typing.Optional[typing.List[_PolicyStatement_296fe8a3]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.List[_PolicyStatement_296fe8a3]], jsii.get(self, "taskPolicies"))


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.EmrContainersDeleteVirtualClusterProps",
    jsii_struct_bases=[_TaskStateBaseProps_b13f6332],
    name_mapping={
        "comment": "comment",
        "heartbeat": "heartbeat",
        "input_path": "inputPath",
        "integration_pattern": "integrationPattern",
        "output_path": "outputPath",
        "result_path": "resultPath",
        "result_selector": "resultSelector",
        "timeout": "timeout",
        "virtual_cluster_id": "virtualClusterId",
    },
)
class EmrContainersDeleteVirtualClusterProps(_TaskStateBaseProps_b13f6332):
    def __init__(
        self,
        *,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
        virtual_cluster_id: _TaskInput_71ab46f6,
    ) -> None:
        '''(experimental) Properties to define a EMR Containers DeleteVirtualCluster Task.

        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None
        :param virtual_cluster_id: (experimental) The ID of the virtual cluster that will be deleted.

        :stability: experimental
        :exampleMetadata: infused

        Example::

            tasks.EmrContainersDeleteVirtualCluster(self, "Delete a Virtual Cluster",
                virtual_cluster_id=sfn.TaskInput.from_json_path_at("$.virtualCluster")
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a2b98be7e6895a4c94529af2df5ad7dbd7875558b5c29ad782553277a67c4190)
            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
            check_type(argname="argument heartbeat", value=heartbeat, expected_type=type_hints["heartbeat"])
            check_type(argname="argument input_path", value=input_path, expected_type=type_hints["input_path"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
            check_type(argname="argument output_path", value=output_path, expected_type=type_hints["output_path"])
            check_type(argname="argument result_path", value=result_path, expected_type=type_hints["result_path"])
            check_type(argname="argument result_selector", value=result_selector, expected_type=type_hints["result_selector"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
            check_type(argname="argument virtual_cluster_id", value=virtual_cluster_id, expected_type=type_hints["virtual_cluster_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "virtual_cluster_id": virtual_cluster_id,
        }
        if comment is not None:
            self._values["comment"] = comment
        if heartbeat is not None:
            self._values["heartbeat"] = heartbeat
        if input_path is not None:
            self._values["input_path"] = input_path
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern
        if output_path is not None:
            self._values["output_path"] = output_path
        if result_path is not None:
            self._values["result_path"] = result_path
        if result_selector is not None:
            self._values["result_selector"] = result_selector
        if timeout is not None:
            self._values["timeout"] = timeout

    @builtins.property
    def comment(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional description for this state.

        :default: - No comment

        :stability: experimental
        '''
        result = self._values.get("comment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def heartbeat(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the heartbeat.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("heartbeat")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def input_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select part of the state to be the input to this state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        input to be the empty object {}.

        :default: - The entire task input (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("input_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def integration_pattern(self) -> typing.Optional[_IntegrationPattern_fbb35786]:
        '''(experimental) AWS Step Functions integrates with services directly in the Amazon States Language.

        You can control these AWS services using service integration patterns

        :default:

        - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks.
        ``IntegrationPattern.RUN_JOB`` for the following exceptions:
        ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html#connect-wait-token
        :stability: experimental
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_IntegrationPattern_fbb35786], result)

    @builtins.property
    def output_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select select a portion of the state output to pass to the next state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        output to be the empty object {}.

        :default:

        - The entire JSON node determined by the state input, the task result,
        and resultPath is passed to the next state (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("output_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to indicate where to inject the state's output.

        May also be the special value JsonPath.DISCARD, which will cause the state's
        input to become its output.

        :default: - Replaces the entire input with the result (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("result_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied.

        You can use ResultSelector to create a payload with values that are static
        or selected from the state's raw result.

        :default: - None

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/input-output-inputpath-params.html#input-output-resultselector
        :stability: experimental
        '''
        result = self._values.get("result_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def timeout(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the state machine.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def virtual_cluster_id(self) -> _TaskInput_71ab46f6:
        '''(experimental) The ID of the virtual cluster that will be deleted.

        :stability: experimental
        '''
        result = self._values.get("virtual_cluster_id")
        assert result is not None, "Required property 'virtual_cluster_id' is missing"
        return typing.cast(_TaskInput_71ab46f6, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EmrContainersDeleteVirtualClusterProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IGrantable_4c5a91d1)
class EmrContainersStartJobRun(
    _TaskStateBase_c3080646,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.EmrContainersStartJobRun",
):
    '''(experimental) Starts a job run.

    A job is a unit of work that you submit to Amazon EMR on EKS for execution.
    The work performed by the job can be defined by a Spark jar, PySpark script, or SparkSQL query.
    A job run is an execution of the job on the virtual cluster.

    :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-emr-eks.html
    :stability: experimental
    :exampleMetadata: infused

    Example::

        tasks.EmrContainersStartJobRun(self, "EMR Containers Start Job Run",
            virtual_cluster=tasks.VirtualClusterInput.from_virtual_cluster_id("de92jdei2910fwedz"),
            release_label=tasks.ReleaseLabel.EMR_6_2_0,
            job_name="EMR-Containers-Job",
            job_driver=dynamodb.aws_stepfunctions_tasks.JobDriver(
                spark_submit_job_driver=dynamodb.aws_stepfunctions_tasks.SparkSubmitJobDriver(
                    entry_point=sfn.TaskInput.from_text("local:///usr/lib/spark/examples/src/main/python/pi.py")
                )
            ),
            application_config=[dynamodb.aws_stepfunctions_tasks.ApplicationConfiguration(
                classification=tasks.Classification.SPARK_DEFAULTS,
                properties={
                    "spark.executor.instances": "1",
                    "spark.executor.memory": "512M"
                }
            )]
        )
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        job_driver: typing.Union["JobDriver", typing.Dict[builtins.str, typing.Any]],
        release_label: "ReleaseLabel",
        virtual_cluster: "VirtualClusterInput",
        application_config: typing.Optional[typing.Sequence[typing.Union[ApplicationConfiguration, typing.Dict[builtins.str, typing.Any]]]] = None,
        execution_role: typing.Optional[_IRole_59af6f50] = None,
        job_name: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union["Monitoring", typing.Dict[builtins.str, typing.Any]]] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param job_driver: (experimental) The job driver for the job run.
        :param release_label: (experimental) The Amazon EMR release version to use for the job run.
        :param virtual_cluster: (experimental) The ID of the virtual cluster where the job will be run.
        :param application_config: (experimental) The configurations for the application running in the job run. Maximum of 100 items Default: - No application config
        :param execution_role: (experimental) The execution role for the job run. If ``virtualClusterId`` is from a JSON input path, an execution role must be provided. If an execution role is provided, follow the documentation to update the role trust policy. Default: - Automatically generated only when the provided ``virtualClusterId`` is not an encoded JSON path
        :param job_name: (experimental) The name of the job run. Default: - No job run name
        :param monitoring: (experimental) Configuration for monitoring the job run. Default: - logging enabled and resources automatically generated if ``monitoring.logging`` is set to ``true``
        :param tags: (experimental) The tags assigned to job runs. Default: - None
        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6d0e21e7654207f458a68f87a628a631eb0bb59f2167aa14a1939914622d172c)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = EmrContainersStartJobRunProps(
            job_driver=job_driver,
            release_label=release_label,
            virtual_cluster=virtual_cluster,
            application_config=application_config,
            execution_role=execution_role,
            job_name=job_name,
            monitoring=monitoring,
            tags=tags,
            comment=comment,
            heartbeat=heartbeat,
            input_path=input_path,
            integration_pattern=integration_pattern,
            output_path=output_path,
            result_path=result_path,
            result_selector=result_selector,
            timeout=timeout,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="grantPrincipal")
    def grant_principal(self) -> _IPrincipal_93b48231:
        '''(experimental) The principal to grant permissions to.

        :stability: experimental
        '''
        return typing.cast(_IPrincipal_93b48231, jsii.get(self, "grantPrincipal"))

    @builtins.property
    @jsii.member(jsii_name="taskMetrics")
    def _task_metrics(self) -> typing.Optional[_TaskMetricsConfig_5aaea59e]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[_TaskMetricsConfig_5aaea59e], jsii.get(self, "taskMetrics"))

    @builtins.property
    @jsii.member(jsii_name="taskPolicies")
    def _task_policies(self) -> typing.Optional[typing.List[_PolicyStatement_296fe8a3]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.List[_PolicyStatement_296fe8a3]], jsii.get(self, "taskPolicies"))


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.EmrContainersStartJobRunProps",
    jsii_struct_bases=[_TaskStateBaseProps_b13f6332],
    name_mapping={
        "comment": "comment",
        "heartbeat": "heartbeat",
        "input_path": "inputPath",
        "integration_pattern": "integrationPattern",
        "output_path": "outputPath",
        "result_path": "resultPath",
        "result_selector": "resultSelector",
        "timeout": "timeout",
        "job_driver": "jobDriver",
        "release_label": "releaseLabel",
        "virtual_cluster": "virtualCluster",
        "application_config": "applicationConfig",
        "execution_role": "executionRole",
        "job_name": "jobName",
        "monitoring": "monitoring",
        "tags": "tags",
    },
)
class EmrContainersStartJobRunProps(_TaskStateBaseProps_b13f6332):
    def __init__(
        self,
        *,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
        job_driver: typing.Union["JobDriver", typing.Dict[builtins.str, typing.Any]],
        release_label: "ReleaseLabel",
        virtual_cluster: "VirtualClusterInput",
        application_config: typing.Optional[typing.Sequence[typing.Union[ApplicationConfiguration, typing.Dict[builtins.str, typing.Any]]]] = None,
        execution_role: typing.Optional[_IRole_59af6f50] = None,
        job_name: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union["Monitoring", typing.Dict[builtins.str, typing.Any]]] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''(experimental) The props for a EMR Containers StartJobRun Task.

        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None
        :param job_driver: (experimental) The job driver for the job run.
        :param release_label: (experimental) The Amazon EMR release version to use for the job run.
        :param virtual_cluster: (experimental) The ID of the virtual cluster where the job will be run.
        :param application_config: (experimental) The configurations for the application running in the job run. Maximum of 100 items Default: - No application config
        :param execution_role: (experimental) The execution role for the job run. If ``virtualClusterId`` is from a JSON input path, an execution role must be provided. If an execution role is provided, follow the documentation to update the role trust policy. Default: - Automatically generated only when the provided ``virtualClusterId`` is not an encoded JSON path
        :param job_name: (experimental) The name of the job run. Default: - No job run name
        :param monitoring: (experimental) Configuration for monitoring the job run. Default: - logging enabled and resources automatically generated if ``monitoring.logging`` is set to ``true``
        :param tags: (experimental) The tags assigned to job runs. Default: - None

        :stability: experimental
        :exampleMetadata: infused

        Example::

            tasks.EmrContainersStartJobRun(self, "EMR Containers Start Job Run",
                virtual_cluster=tasks.VirtualClusterInput.from_virtual_cluster_id("de92jdei2910fwedz"),
                release_label=tasks.ReleaseLabel.EMR_6_2_0,
                job_name="EMR-Containers-Job",
                job_driver=dynamodb.aws_stepfunctions_tasks.JobDriver(
                    spark_submit_job_driver=dynamodb.aws_stepfunctions_tasks.SparkSubmitJobDriver(
                        entry_point=sfn.TaskInput.from_text("local:///usr/lib/spark/examples/src/main/python/pi.py")
                    )
                ),
                application_config=[dynamodb.aws_stepfunctions_tasks.ApplicationConfiguration(
                    classification=tasks.Classification.SPARK_DEFAULTS,
                    properties={
                        "spark.executor.instances": "1",
                        "spark.executor.memory": "512M"
                    }
                )]
            )
        '''
        if isinstance(job_driver, dict):
            job_driver = JobDriver(**job_driver)
        if isinstance(monitoring, dict):
            monitoring = Monitoring(**monitoring)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d350350fad378b3b805a1287f452171d3029dc873cc06799d8a400ceb523e700)
            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
            check_type(argname="argument heartbeat", value=heartbeat, expected_type=type_hints["heartbeat"])
            check_type(argname="argument input_path", value=input_path, expected_type=type_hints["input_path"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
            check_type(argname="argument output_path", value=output_path, expected_type=type_hints["output_path"])
            check_type(argname="argument result_path", value=result_path, expected_type=type_hints["result_path"])
            check_type(argname="argument result_selector", value=result_selector, expected_type=type_hints["result_selector"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
            check_type(argname="argument job_driver", value=job_driver, expected_type=type_hints["job_driver"])
            check_type(argname="argument release_label", value=release_label, expected_type=type_hints["release_label"])
            check_type(argname="argument virtual_cluster", value=virtual_cluster, expected_type=type_hints["virtual_cluster"])
            check_type(argname="argument application_config", value=application_config, expected_type=type_hints["application_config"])
            check_type(argname="argument execution_role", value=execution_role, expected_type=type_hints["execution_role"])
            check_type(argname="argument job_name", value=job_name, expected_type=type_hints["job_name"])
            check_type(argname="argument monitoring", value=monitoring, expected_type=type_hints["monitoring"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "job_driver": job_driver,
            "release_label": release_label,
            "virtual_cluster": virtual_cluster,
        }
        if comment is not None:
            self._values["comment"] = comment
        if heartbeat is not None:
            self._values["heartbeat"] = heartbeat
        if input_path is not None:
            self._values["input_path"] = input_path
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern
        if output_path is not None:
            self._values["output_path"] = output_path
        if result_path is not None:
            self._values["result_path"] = result_path
        if result_selector is not None:
            self._values["result_selector"] = result_selector
        if timeout is not None:
            self._values["timeout"] = timeout
        if application_config is not None:
            self._values["application_config"] = application_config
        if execution_role is not None:
            self._values["execution_role"] = execution_role
        if job_name is not None:
            self._values["job_name"] = job_name
        if monitoring is not None:
            self._values["monitoring"] = monitoring
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def comment(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional description for this state.

        :default: - No comment

        :stability: experimental
        '''
        result = self._values.get("comment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def heartbeat(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the heartbeat.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("heartbeat")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def input_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select part of the state to be the input to this state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        input to be the empty object {}.

        :default: - The entire task input (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("input_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def integration_pattern(self) -> typing.Optional[_IntegrationPattern_fbb35786]:
        '''(experimental) AWS Step Functions integrates with services directly in the Amazon States Language.

        You can control these AWS services using service integration patterns

        :default:

        - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks.
        ``IntegrationPattern.RUN_JOB`` for the following exceptions:
        ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html#connect-wait-token
        :stability: experimental
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_IntegrationPattern_fbb35786], result)

    @builtins.property
    def output_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select select a portion of the state output to pass to the next state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        output to be the empty object {}.

        :default:

        - The entire JSON node determined by the state input, the task result,
        and resultPath is passed to the next state (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("output_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to indicate where to inject the state's output.

        May also be the special value JsonPath.DISCARD, which will cause the state's
        input to become its output.

        :default: - Replaces the entire input with the result (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("result_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied.

        You can use ResultSelector to create a payload with values that are static
        or selected from the state's raw result.

        :default: - None

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/input-output-inputpath-params.html#input-output-resultselector
        :stability: experimental
        '''
        result = self._values.get("result_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def timeout(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the state machine.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def job_driver(self) -> "JobDriver":
        '''(experimental) The job driver for the job run.

        :see: https://docs.aws.amazon.com/emr-on-eks/latest/APIReference/API_JobDriver.html
        :stability: experimental
        '''
        result = self._values.get("job_driver")
        assert result is not None, "Required property 'job_driver' is missing"
        return typing.cast("JobDriver", result)

    @builtins.property
    def release_label(self) -> "ReleaseLabel":
        '''(experimental) The Amazon EMR release version to use for the job run.

        :stability: experimental
        '''
        result = self._values.get("release_label")
        assert result is not None, "Required property 'release_label' is missing"
        return typing.cast("ReleaseLabel", result)

    @builtins.property
    def virtual_cluster(self) -> "VirtualClusterInput":
        '''(experimental) The ID of the virtual cluster where the job will be run.

        :stability: experimental
        '''
        result = self._values.get("virtual_cluster")
        assert result is not None, "Required property 'virtual_cluster' is missing"
        return typing.cast("VirtualClusterInput", result)

    @builtins.property
    def application_config(
        self,
    ) -> typing.Optional[typing.List[ApplicationConfiguration]]:
        '''(experimental) The configurations for the application running in the job run.

        Maximum of 100 items

        :default: - No application config

        :see: https://docs.aws.amazon.com/emr-on-eks/latest/APIReference/API_Configuration.html
        :stability: experimental
        '''
        result = self._values.get("application_config")
        return typing.cast(typing.Optional[typing.List[ApplicationConfiguration]], result)

    @builtins.property
    def execution_role(self) -> typing.Optional[_IRole_59af6f50]:
        '''(experimental) The execution role for the job run.

        If ``virtualClusterId`` is from a JSON input path, an execution role must be provided.
        If an execution role is provided, follow the documentation to update the role trust policy.

        :default: - Automatically generated only when the provided ``virtualClusterId`` is not an encoded JSON path

        :see: https://docs.aws.amazon.com/emr/latest/EMR-on-EKS-DevelopmentGuide/setting-up-trust-policy.html
        :stability: experimental
        '''
        result = self._values.get("execution_role")
        return typing.cast(typing.Optional[_IRole_59af6f50], result)

    @builtins.property
    def job_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) The name of the job run.

        :default: - No job run name

        :stability: experimental
        '''
        result = self._values.get("job_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def monitoring(self) -> typing.Optional["Monitoring"]:
        '''(experimental) Configuration for monitoring the job run.

        :default: - logging enabled and resources automatically generated if ``monitoring.logging`` is set to ``true``

        :see: https://docs.aws.amazon.com/emr-on-eks/latest/APIReference/API_MonitoringConfiguration.html
        :stability: experimental
        '''
        result = self._values.get("monitoring")
        return typing.cast(typing.Optional["Monitoring"], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''(experimental) The tags assigned to job runs.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EmrContainersStartJobRunProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class EmrCreateCluster(
    _TaskStateBase_c3080646,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.EmrCreateCluster",
):
    '''(experimental) A Step Functions Task to create an EMR Cluster.

    The ClusterConfiguration is defined as Parameters in the state machine definition.

    OUTPUT: the ClusterId.

    :stability: experimental
    :exampleMetadata: infused

    Example::

        cluster_role = iam.Role(self, "ClusterRole",
            assumed_by=iam.ServicePrincipal("ec2.amazonaws.com")
        )
        
        service_role = iam.Role(self, "ServiceRole",
            assumed_by=iam.ServicePrincipal("elasticmapreduce.amazonaws.com")
        )
        
        auto_scaling_role = iam.Role(self, "AutoScalingRole",
            assumed_by=iam.ServicePrincipal("elasticmapreduce.amazonaws.com")
        )
        
        auto_scaling_role.assume_role_policy.add_statements(
            iam.PolicyStatement(
                effect=iam.Effect.ALLOW,
                principals=[
                    iam.ServicePrincipal("application-autoscaling.amazonaws.com")
                ],
                actions=["sts:AssumeRole"
                ]
            ))
        
        tasks.EmrCreateCluster(self, "Create Cluster",
            instances=dynamodb.aws_stepfunctions_tasks.EmrCreateCluster.InstancesConfigProperty(),
            cluster_role=cluster_role,
            name=sfn.TaskInput.from_json_path_at("$.ClusterName").value,
            service_role=service_role,
            auto_scaling_role=auto_scaling_role
        )
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        instances: typing.Union["EmrCreateCluster.InstancesConfigProperty", typing.Dict[builtins.str, typing.Any]],
        name: builtins.str,
        additional_info: typing.Optional[builtins.str] = None,
        applications: typing.Optional[typing.Sequence[typing.Union["EmrCreateCluster.ApplicationConfigProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        auto_scaling_role: typing.Optional[_IRole_59af6f50] = None,
        bootstrap_actions: typing.Optional[typing.Sequence[typing.Union["EmrCreateCluster.BootstrapActionConfigProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        cluster_role: typing.Optional[_IRole_59af6f50] = None,
        configurations: typing.Optional[typing.Sequence[typing.Union["EmrCreateCluster.ConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        custom_ami_id: typing.Optional[builtins.str] = None,
        ebs_root_volume_size: typing.Optional[_Size_7fbd4337] = None,
        kerberos_attributes: typing.Optional[typing.Union["EmrCreateCluster.KerberosAttributesProperty", typing.Dict[builtins.str, typing.Any]]] = None,
        log_uri: typing.Optional[builtins.str] = None,
        release_label: typing.Optional[builtins.str] = None,
        scale_down_behavior: typing.Optional["EmrCreateCluster.EmrClusterScaleDownBehavior"] = None,
        security_configuration: typing.Optional[builtins.str] = None,
        service_role: typing.Optional[_IRole_59af6f50] = None,
        step_concurrency_level: typing.Optional[jsii.Number] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        visible_to_all_users: typing.Optional[builtins.bool] = None,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param instances: (experimental) A specification of the number and type of Amazon EC2 instances.
        :param name: (experimental) The Name of the Cluster.
        :param additional_info: (experimental) A JSON string for selecting additional features. Default: - None
        :param applications: (experimental) A case-insensitive list of applications for Amazon EMR to install and configure when launching the cluster. Default: - EMR selected default
        :param auto_scaling_role: (experimental) An IAM role for automatic scaling policies. Default: - A role will be created.
        :param bootstrap_actions: (experimental) A list of bootstrap actions to run before Hadoop starts on the cluster nodes. Default: - None
        :param cluster_role: (experimental) Also called instance profile and EC2 role. An IAM role for an EMR cluster. The EC2 instances of the cluster assume this role. This attribute has been renamed from jobFlowRole to clusterRole to align with other ERM/StepFunction integration parameters. Default: - - A Role will be created
        :param configurations: (experimental) The list of configurations supplied for the EMR cluster you are creating. Default: - None
        :param custom_ami_id: (experimental) The ID of a custom Amazon EBS-backed Linux AMI. Default: - None
        :param ebs_root_volume_size: (experimental) The size of the EBS root device volume of the Linux AMI that is used for each EC2 instance. Default: - EMR selected default
        :param kerberos_attributes: (experimental) Attributes for Kerberos configuration when Kerberos authentication is enabled using a security configuration. Default: - None
        :param log_uri: (experimental) The location in Amazon S3 to write the log files of the job flow. Default: - None
        :param release_label: (experimental) The Amazon EMR release label, which determines the version of open-source application packages installed on the cluster. Default: - EMR selected default
        :param scale_down_behavior: (experimental) Specifies the way that individual Amazon EC2 instances terminate when an automatic scale-in activity occurs or an instance group is resized. Default: - EMR selected default
        :param security_configuration: (experimental) The name of a security configuration to apply to the cluster. Default: - None
        :param service_role: (experimental) The IAM role that will be assumed by the Amazon EMR service to access AWS resources on your behalf. Default: - A role will be created that Amazon EMR service can assume.
        :param step_concurrency_level: (experimental) Specifies the step concurrency level to allow multiple steps to run in parallel. Requires EMR release label 5.28.0 or above. Must be in range [1, 256]. Default: 1 - no step concurrency allowed
        :param tags: (experimental) A list of tags to associate with a cluster and propagate to Amazon EC2 instances. Default: - None
        :param visible_to_all_users: (experimental) A value of true indicates that all IAM users in the AWS account can perform cluster actions if they have the proper IAM policy permissions. Default: true
        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d311b70081c11860696da2d7a5ed040392beffc7948a514b206959d42bf767c4)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = EmrCreateClusterProps(
            instances=instances,
            name=name,
            additional_info=additional_info,
            applications=applications,
            auto_scaling_role=auto_scaling_role,
            bootstrap_actions=bootstrap_actions,
            cluster_role=cluster_role,
            configurations=configurations,
            custom_ami_id=custom_ami_id,
            ebs_root_volume_size=ebs_root_volume_size,
            kerberos_attributes=kerberos_attributes,
            log_uri=log_uri,
            release_label=release_label,
            scale_down_behavior=scale_down_behavior,
            security_configuration=security_configuration,
            service_role=service_role,
            step_concurrency_level=step_concurrency_level,
            tags=tags,
            visible_to_all_users=visible_to_all_users,
            comment=comment,
            heartbeat=heartbeat,
            input_path=input_path,
            integration_pattern=integration_pattern,
            output_path=output_path,
            result_path=result_path,
            result_selector=result_selector,
            timeout=timeout,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="autoScalingRole")
    def auto_scaling_role(self) -> _IRole_59af6f50:
        '''(experimental) The autoscaling role for the EMR Cluster.

        Only available after task has been added to a state machine.

        :stability: experimental
        '''
        return typing.cast(_IRole_59af6f50, jsii.get(self, "autoScalingRole"))

    @builtins.property
    @jsii.member(jsii_name="clusterRole")
    def cluster_role(self) -> _IRole_59af6f50:
        '''(experimental) The instance role for the EMR Cluster.

        Only available after task has been added to a state machine.

        :stability: experimental
        '''
        return typing.cast(_IRole_59af6f50, jsii.get(self, "clusterRole"))

    @builtins.property
    @jsii.member(jsii_name="serviceRole")
    def service_role(self) -> _IRole_59af6f50:
        '''(experimental) The service role for the EMR Cluster.

        Only available after task has been added to a state machine.

        :stability: experimental
        '''
        return typing.cast(_IRole_59af6f50, jsii.get(self, "serviceRole"))

    @builtins.property
    @jsii.member(jsii_name="taskMetrics")
    def _task_metrics(self) -> typing.Optional[_TaskMetricsConfig_5aaea59e]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[_TaskMetricsConfig_5aaea59e], jsii.get(self, "taskMetrics"))

    @builtins.property
    @jsii.member(jsii_name="taskPolicies")
    def _task_policies(self) -> typing.Optional[typing.List[_PolicyStatement_296fe8a3]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.List[_PolicyStatement_296fe8a3]], jsii.get(self, "taskPolicies"))

    @jsii.data_type(
        jsii_type="monocdk.aws_stepfunctions_tasks.EmrCreateCluster.ApplicationConfigProperty",
        jsii_struct_bases=[],
        name_mapping={
            "name": "name",
            "additional_info": "additionalInfo",
            "args": "args",
            "version": "version",
        },
    )
    class ApplicationConfigProperty:
        def __init__(
            self,
            *,
            name: builtins.str,
            additional_info: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
            args: typing.Optional[typing.Sequence[builtins.str]] = None,
            version: typing.Optional[builtins.str] = None,
        ) -> None:
            '''(experimental) Properties for the EMR Cluster Applications.

            Applies to Amazon EMR releases 4.0 and later. A case-insensitive list of applications for Amazon EMR to install and configure when launching
            the cluster.

            See the RunJobFlow API for complete documentation on input parameters

            :param name: (experimental) The name of the application.
            :param additional_info: (experimental) This option is for advanced users only. This is meta information about third-party applications that third-party vendors use for testing purposes. Default: No additionalInfo
            :param args: (experimental) Arguments for Amazon EMR to pass to the application. Default: No args
            :param version: (experimental) The version of the application. Default: No version

            :see: https://docs.aws.amazon.com/emr/latest/APIReference/API_Application.html
            :stability: experimental
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
                
                application_config_property = stepfunctions_tasks.EmrCreateCluster.ApplicationConfigProperty(
                    name="name",
                
                    # the properties below are optional
                    additional_info={
                        "additional_info_key": "additionalInfo"
                    },
                    args=["args"],
                    version="version"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__36613d8534c1f85ffdd6947683c01f52b90bc8775624ea62fb5fe8a6add10187)
                check_type(argname="argument name", value=name, expected_type=type_hints["name"])
                check_type(argname="argument additional_info", value=additional_info, expected_type=type_hints["additional_info"])
                check_type(argname="argument args", value=args, expected_type=type_hints["args"])
                check_type(argname="argument version", value=version, expected_type=type_hints["version"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "name": name,
            }
            if additional_info is not None:
                self._values["additional_info"] = additional_info
            if args is not None:
                self._values["args"] = args
            if version is not None:
                self._values["version"] = version

        @builtins.property
        def name(self) -> builtins.str:
            '''(experimental) The name of the application.

            :stability: experimental
            '''
            result = self._values.get("name")
            assert result is not None, "Required property 'name' is missing"
            return typing.cast(builtins.str, result)

        @builtins.property
        def additional_info(
            self,
        ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
            '''(experimental) This option is for advanced users only.

            This is meta information about third-party applications that third-party vendors use
            for testing purposes.

            :default: No additionalInfo

            :stability: experimental
            '''
            result = self._values.get("additional_info")
            return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

        @builtins.property
        def args(self) -> typing.Optional[typing.List[builtins.str]]:
            '''(experimental) Arguments for Amazon EMR to pass to the application.

            :default: No args

            :stability: experimental
            '''
            result = self._values.get("args")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def version(self) -> typing.Optional[builtins.str]:
            '''(experimental) The version of the application.

            :default: No version

            :stability: experimental
            '''
            result = self._values.get("version")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ApplicationConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="monocdk.aws_stepfunctions_tasks.EmrCreateCluster.AutoScalingPolicyProperty",
        jsii_struct_bases=[],
        name_mapping={"constraints": "constraints", "rules": "rules"},
    )
    class AutoScalingPolicyProperty:
        def __init__(
            self,
            *,
            constraints: typing.Union["EmrCreateCluster.ScalingConstraintsProperty", typing.Dict[builtins.str, typing.Any]],
            rules: typing.Sequence[typing.Union["EmrCreateCluster.ScalingRuleProperty", typing.Dict[builtins.str, typing.Any]]],
        ) -> None:
            '''(experimental) An automatic scaling policy for a core instance group or task instance group in an Amazon EMR cluster.

            :param constraints: (experimental) The upper and lower EC2 instance limits for an automatic scaling policy. Automatic scaling activity will not cause an instance group to grow above or below these limits.
            :param rules: (experimental) The scale-in and scale-out rules that comprise the automatic scaling policy.

            :see: https://docs.aws.amazon.com/emr/latest/APIReference/API_AutoScalingPolicy.html
            :stability: experimental
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                import monocdk as monocdk
                from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
                
                # duration: monocdk.Duration
                
                auto_scaling_policy_property = stepfunctions_tasks.EmrCreateCluster.AutoScalingPolicyProperty(
                    constraints=stepfunctions_tasks.EmrCreateCluster.ScalingConstraintsProperty(
                        max_capacity=123,
                        min_capacity=123
                    ),
                    rules=[stepfunctions_tasks.EmrCreateCluster.ScalingRuleProperty(
                        action=stepfunctions_tasks.EmrCreateCluster.ScalingActionProperty(
                            simple_scaling_policy_configuration=stepfunctions_tasks.EmrCreateCluster.SimpleScalingPolicyConfigurationProperty(
                                scaling_adjustment=123,
                
                                # the properties below are optional
                                adjustment_type=stepfunctions_tasks.EmrCreateCluster.ScalingAdjustmentType.CHANGE_IN_CAPACITY,
                                cool_down=123
                            ),
                
                            # the properties below are optional
                            market=stepfunctions_tasks.EmrCreateCluster.InstanceMarket.ON_DEMAND
                        ),
                        name="name",
                        trigger=stepfunctions_tasks.EmrCreateCluster.ScalingTriggerProperty(
                            cloud_watch_alarm_definition=stepfunctions_tasks.EmrCreateCluster.CloudWatchAlarmDefinitionProperty(
                                comparison_operator=stepfunctions_tasks.EmrCreateCluster.CloudWatchAlarmComparisonOperator.GREATER_THAN_OR_EQUAL,
                                metric_name="metricName",
                                period=duration,
                
                                # the properties below are optional
                                dimensions=[stepfunctions_tasks.EmrCreateCluster.MetricDimensionProperty(
                                    key="key",
                                    value="value"
                                )],
                                evaluation_periods=123,
                                namespace="namespace",
                                statistic=stepfunctions_tasks.EmrCreateCluster.CloudWatchAlarmStatistic.SAMPLE_COUNT,
                                threshold=123,
                                unit=stepfunctions_tasks.EmrCreateCluster.CloudWatchAlarmUnit.NONE
                            )
                        ),
                
                        # the properties below are optional
                        description="description"
                    )]
                )
            '''
            if isinstance(constraints, dict):
                constraints = EmrCreateCluster.ScalingConstraintsProperty(**constraints)
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__b6bca5ece65cceca581f95ccb67bac90474b6641b9243c189d1a2bdf40c17e17)
                check_type(argname="argument constraints", value=constraints, expected_type=type_hints["constraints"])
                check_type(argname="argument rules", value=rules, expected_type=type_hints["rules"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "constraints": constraints,
                "rules": rules,
            }

        @builtins.property
        def constraints(self) -> "EmrCreateCluster.ScalingConstraintsProperty":
            '''(experimental) The upper and lower EC2 instance limits for an automatic scaling policy.

            Automatic scaling activity will not cause an instance
            group to grow above or below these limits.

            :stability: experimental
            '''
            result = self._values.get("constraints")
            assert result is not None, "Required property 'constraints' is missing"
            return typing.cast("EmrCreateCluster.ScalingConstraintsProperty", result)

        @builtins.property
        def rules(self) -> typing.List["EmrCreateCluster.ScalingRuleProperty"]:
            '''(experimental) The scale-in and scale-out rules that comprise the automatic scaling policy.

            :stability: experimental
            '''
            result = self._values.get("rules")
            assert result is not None, "Required property 'rules' is missing"
            return typing.cast(typing.List["EmrCreateCluster.ScalingRuleProperty"], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AutoScalingPolicyProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="monocdk.aws_stepfunctions_tasks.EmrCreateCluster.BootstrapActionConfigProperty",
        jsii_struct_bases=[],
        name_mapping={
            "name": "name",
            "script_bootstrap_action": "scriptBootstrapAction",
        },
    )
    class BootstrapActionConfigProperty:
        def __init__(
            self,
            *,
            name: builtins.str,
            script_bootstrap_action: typing.Union["EmrCreateCluster.ScriptBootstrapActionConfigProperty", typing.Dict[builtins.str, typing.Any]],
        ) -> None:
            '''(experimental) Configuration of a bootstrap action.

            See the RunJobFlow API for complete documentation on input parameters

            :param name: (experimental) The name of the bootstrap action.
            :param script_bootstrap_action: (experimental) The script run by the bootstrap action.

            :see: https://docs.aws.amazon.com/emr/latest/APIReference/API_BootstrapActionConfig.html
            :stability: experimental
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
                
                bootstrap_action_config_property = stepfunctions_tasks.EmrCreateCluster.BootstrapActionConfigProperty(
                    name="name",
                    script_bootstrap_action=stepfunctions_tasks.EmrCreateCluster.ScriptBootstrapActionConfigProperty(
                        path="path",
                
                        # the properties below are optional
                        args=["args"]
                    )
                )
            '''
            if isinstance(script_bootstrap_action, dict):
                script_bootstrap_action = EmrCreateCluster.ScriptBootstrapActionConfigProperty(**script_bootstrap_action)
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__6f2af2e590a08520f7954e22f47c00ec46844f002d4d5c987ba5153b0e1d653d)
                check_type(argname="argument name", value=name, expected_type=type_hints["name"])
                check_type(argname="argument script_bootstrap_action", value=script_bootstrap_action, expected_type=type_hints["script_bootstrap_action"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "name": name,
                "script_bootstrap_action": script_bootstrap_action,
            }

        @builtins.property
        def name(self) -> builtins.str:
            '''(experimental) The name of the bootstrap action.

            :stability: experimental
            '''
            result = self._values.get("name")
            assert result is not None, "Required property 'name' is missing"
            return typing.cast(builtins.str, result)

        @builtins.property
        def script_bootstrap_action(
            self,
        ) -> "EmrCreateCluster.ScriptBootstrapActionConfigProperty":
            '''(experimental) The script run by the bootstrap action.

            :stability: experimental
            '''
            result = self._values.get("script_bootstrap_action")
            assert result is not None, "Required property 'script_bootstrap_action' is missing"
            return typing.cast("EmrCreateCluster.ScriptBootstrapActionConfigProperty", result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "BootstrapActionConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.enum(
        jsii_type="monocdk.aws_stepfunctions_tasks.EmrCreateCluster.CloudWatchAlarmComparisonOperator"
    )
    class CloudWatchAlarmComparisonOperator(enum.Enum):
        '''(experimental) CloudWatch Alarm Comparison Operators.

        :stability: experimental
        '''

        GREATER_THAN_OR_EQUAL = "GREATER_THAN_OR_EQUAL"
        '''(experimental) GREATER_THAN_OR_EQUAL.

        :stability: experimental
        '''
        GREATER_THAN = "GREATER_THAN"
        '''(experimental) GREATER_THAN.

        :stability: experimental
        '''
        LESS_THAN = "LESS_THAN"
        '''(experimental) LESS_THAN.

        :stability: experimental
        '''
        LESS_THAN_OR_EQUAL = "LESS_THAN_OR_EQUAL"
        '''(experimental) LESS_THAN_OR_EQUAL.

        :stability: experimental
        '''

    @jsii.data_type(
        jsii_type="monocdk.aws_stepfunctions_tasks.EmrCreateCluster.CloudWatchAlarmDefinitionProperty",
        jsii_struct_bases=[],
        name_mapping={
            "comparison_operator": "comparisonOperator",
            "metric_name": "metricName",
            "period": "period",
            "dimensions": "dimensions",
            "evaluation_periods": "evaluationPeriods",
            "namespace": "namespace",
            "statistic": "statistic",
            "threshold": "threshold",
            "unit": "unit",
        },
    )
    class CloudWatchAlarmDefinitionProperty:
        def __init__(
            self,
            *,
            comparison_operator: "EmrCreateCluster.CloudWatchAlarmComparisonOperator",
            metric_name: builtins.str,
            period: _Duration_070aa057,
            dimensions: typing.Optional[typing.Sequence[typing.Union["EmrCreateCluster.MetricDimensionProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            evaluation_periods: typing.Optional[jsii.Number] = None,
            namespace: typing.Optional[builtins.str] = None,
            statistic: typing.Optional["EmrCreateCluster.CloudWatchAlarmStatistic"] = None,
            threshold: typing.Optional[jsii.Number] = None,
            unit: typing.Optional["EmrCreateCluster.CloudWatchAlarmUnit"] = None,
        ) -> None:
            '''(experimental) The definition of a CloudWatch metric alarm, which determines when an automatic scaling activity is triggered.

            When the defined alarm conditions
            are satisfied, scaling activity begins.

            :param comparison_operator: (experimental) Determines how the metric specified by MetricName is compared to the value specified by Threshold.
            :param metric_name: (experimental) The name of the CloudWatch metric that is watched to determine an alarm condition.
            :param period: (experimental) The period, in seconds, over which the statistic is applied. EMR CloudWatch metrics are emitted every five minutes (300 seconds), so if an EMR CloudWatch metric is specified, specify 300.
            :param dimensions: (experimental) A CloudWatch metric dimension. Default: - No dimensions
            :param evaluation_periods: (experimental) The number of periods, in five-minute increments, during which the alarm condition must exist before the alarm triggers automatic scaling activity. Default: 1
            :param namespace: (experimental) The namespace for the CloudWatch metric. Default: 'AWS/ElasticMapReduce'
            :param statistic: (experimental) The statistic to apply to the metric associated with the alarm. Default: CloudWatchAlarmStatistic.AVERAGE
            :param threshold: (experimental) The value against which the specified statistic is compared. Default: - None
            :param unit: (experimental) The unit of measure associated with the CloudWatch metric being watched. The value specified for Unit must correspond to the units specified in the CloudWatch metric. Default: CloudWatchAlarmUnit.NONE

            :see: https://docs.aws.amazon.com/emr/latest/APIReference/API_CloudWatchAlarmDefinition.html
            :stability: experimental
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                import monocdk as monocdk
                from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
                
                # duration: monocdk.Duration
                
                cloud_watch_alarm_definition_property = stepfunctions_tasks.EmrCreateCluster.CloudWatchAlarmDefinitionProperty(
                    comparison_operator=stepfunctions_tasks.EmrCreateCluster.CloudWatchAlarmComparisonOperator.GREATER_THAN_OR_EQUAL,
                    metric_name="metricName",
                    period=duration,
                
                    # the properties below are optional
                    dimensions=[stepfunctions_tasks.EmrCreateCluster.MetricDimensionProperty(
                        key="key",
                        value="value"
                    )],
                    evaluation_periods=123,
                    namespace="namespace",
                    statistic=stepfunctions_tasks.EmrCreateCluster.CloudWatchAlarmStatistic.SAMPLE_COUNT,
                    threshold=123,
                    unit=stepfunctions_tasks.EmrCreateCluster.CloudWatchAlarmUnit.NONE
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__43258c1172514a96087a56d6b3ae6235b82bd01f5607c944fb5c2ff713c7d087)
                check_type(argname="argument comparison_operator", value=comparison_operator, expected_type=type_hints["comparison_operator"])
                check_type(argname="argument metric_name", value=metric_name, expected_type=type_hints["metric_name"])
                check_type(argname="argument period", value=period, expected_type=type_hints["period"])
                check_type(argname="argument dimensions", value=dimensions, expected_type=type_hints["dimensions"])
                check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
                check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
                check_type(argname="argument statistic", value=statistic, expected_type=type_hints["statistic"])
                check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
                check_type(argname="argument unit", value=unit, expected_type=type_hints["unit"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "comparison_operator": comparison_operator,
                "metric_name": metric_name,
                "period": period,
            }
            if dimensions is not None:
                self._values["dimensions"] = dimensions
            if evaluation_periods is not None:
                self._values["evaluation_periods"] = evaluation_periods
            if namespace is not None:
                self._values["namespace"] = namespace
            if statistic is not None:
                self._values["statistic"] = statistic
            if threshold is not None:
                self._values["threshold"] = threshold
            if unit is not None:
                self._values["unit"] = unit

        @builtins.property
        def comparison_operator(
            self,
        ) -> "EmrCreateCluster.CloudWatchAlarmComparisonOperator":
            '''(experimental) Determines how the metric specified by MetricName is compared to the value specified by Threshold.

            :stability: experimental
            '''
            result = self._values.get("comparison_operator")
            assert result is not None, "Required property 'comparison_operator' is missing"
            return typing.cast("EmrCreateCluster.CloudWatchAlarmComparisonOperator", result)

        @builtins.property
        def metric_name(self) -> builtins.str:
            '''(experimental) The name of the CloudWatch metric that is watched to determine an alarm condition.

            :stability: experimental
            '''
            result = self._values.get("metric_name")
            assert result is not None, "Required property 'metric_name' is missing"
            return typing.cast(builtins.str, result)

        @builtins.property
        def period(self) -> _Duration_070aa057:
            '''(experimental) The period, in seconds, over which the statistic is applied.

            EMR CloudWatch metrics are emitted every five minutes (300 seconds), so if
            an EMR CloudWatch metric is specified, specify 300.

            :stability: experimental
            '''
            result = self._values.get("period")
            assert result is not None, "Required property 'period' is missing"
            return typing.cast(_Duration_070aa057, result)

        @builtins.property
        def dimensions(
            self,
        ) -> typing.Optional[typing.List["EmrCreateCluster.MetricDimensionProperty"]]:
            '''(experimental) A CloudWatch metric dimension.

            :default: - No dimensions

            :stability: experimental
            '''
            result = self._values.get("dimensions")
            return typing.cast(typing.Optional[typing.List["EmrCreateCluster.MetricDimensionProperty"]], result)

        @builtins.property
        def evaluation_periods(self) -> typing.Optional[jsii.Number]:
            '''(experimental) The number of periods, in five-minute increments, during which the alarm condition must exist before the alarm triggers automatic scaling activity.

            :default: 1

            :stability: experimental
            '''
            result = self._values.get("evaluation_periods")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def namespace(self) -> typing.Optional[builtins.str]:
            '''(experimental) The namespace for the CloudWatch metric.

            :default: 'AWS/ElasticMapReduce'

            :stability: experimental
            '''
            result = self._values.get("namespace")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def statistic(
            self,
        ) -> typing.Optional["EmrCreateCluster.CloudWatchAlarmStatistic"]:
            '''(experimental) The statistic to apply to the metric associated with the alarm.

            :default: CloudWatchAlarmStatistic.AVERAGE

            :stability: experimental
            '''
            result = self._values.get("statistic")
            return typing.cast(typing.Optional["EmrCreateCluster.CloudWatchAlarmStatistic"], result)

        @builtins.property
        def threshold(self) -> typing.Optional[jsii.Number]:
            '''(experimental) The value against which the specified statistic is compared.

            :default: - None

            :stability: experimental
            '''
            result = self._values.get("threshold")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def unit(self) -> typing.Optional["EmrCreateCluster.CloudWatchAlarmUnit"]:
            '''(experimental) The unit of measure associated with the CloudWatch metric being watched.

            The value specified for Unit must correspond to the units
            specified in the CloudWatch metric.

            :default: CloudWatchAlarmUnit.NONE

            :stability: experimental
            '''
            result = self._values.get("unit")
            return typing.cast(typing.Optional["EmrCreateCluster.CloudWatchAlarmUnit"], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "CloudWatchAlarmDefinitionProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.enum(
        jsii_type="monocdk.aws_stepfunctions_tasks.EmrCreateCluster.CloudWatchAlarmStatistic"
    )
    class CloudWatchAlarmStatistic(enum.Enum):
        '''(experimental) CloudWatch Alarm Statistics.

        :stability: experimental
        '''

        SAMPLE_COUNT = "SAMPLE_COUNT"
        '''(experimental) SAMPLE_COUNT.

        :stability: experimental
        '''
        AVERAGE = "AVERAGE"
        '''(experimental) AVERAGE.

        :stability: experimental
        '''
        SUM = "SUM"
        '''(experimental) SUM.

        :stability: experimental
        '''
        MINIMUM = "MINIMUM"
        '''(experimental) MINIMUM.

        :stability: experimental
        '''
        MAXIMUM = "MAXIMUM"
        '''(experimental) MAXIMUM.

        :stability: experimental
        '''

    @jsii.enum(
        jsii_type="monocdk.aws_stepfunctions_tasks.EmrCreateCluster.CloudWatchAlarmUnit"
    )
    class CloudWatchAlarmUnit(enum.Enum):
        '''(experimental) CloudWatch Alarm Units.

        :stability: experimental
        '''

        NONE = "NONE"
        '''(experimental) NONE.

        :stability: experimental
        '''
        SECONDS = "SECONDS"
        '''(experimental) SECONDS.

        :stability: experimental
        '''
        MICRO_SECONDS = "MICRO_SECONDS"
        '''(experimental) MICRO_SECONDS.

        :stability: experimental
        '''
        MILLI_SECONDS = "MILLI_SECONDS"
        '''(experimental) MILLI_SECONDS.

        :stability: experimental
        '''
        BYTES = "BYTES"
        '''(experimental) BYTES.

        :stability: experimental
        '''
        KILO_BYTES = "KILO_BYTES"
        '''(experimental) KILO_BYTES.

        :stability: experimental
        '''
        MEGA_BYTES = "MEGA_BYTES"
        '''(experimental) MEGA_BYTES.

        :stability: experimental
        '''
        GIGA_BYTES = "GIGA_BYTES"
        '''(experimental) GIGA_BYTES.

        :stability: experimental
        '''
        TERA_BYTES = "TERA_BYTES"
        '''(experimental) TERA_BYTES.

        :stability: experimental
        '''
        BITS = "BITS"
        '''(experimental) BITS.

        :stability: experimental
        '''
        KILO_BITS = "KILO_BITS"
        '''(experimental) KILO_BITS.

        :stability: experimental
        '''
        MEGA_BITS = "MEGA_BITS"
        '''(experimental) MEGA_BITS.

        :stability: experimental
        '''
        GIGA_BITS = "GIGA_BITS"
        '''(experimental) GIGA_BITS.

        :stability: experimental
        '''
        TERA_BITS = "TERA_BITS"
        '''(experimental) TERA_BITS.

        :stability: experimental
        '''
        PERCENT = "PERCENT"
        '''(experimental) PERCENT.

        :stability: experimental
        '''
        COUNT = "COUNT"
        '''(experimental) COUNT.

        :stability: experimental
        '''
        BYTES_PER_SECOND = "BYTES_PER_SECOND"
        '''(experimental) BYTES_PER_SECOND.

        :stability: experimental
        '''
        KILO_BYTES_PER_SECOND = "KILO_BYTES_PER_SECOND"
        '''(experimental) KILO_BYTES_PER_SECOND.

        :stability: experimental
        '''
        MEGA_BYTES_PER_SECOND = "MEGA_BYTES_PER_SECOND"
        '''(experimental) MEGA_BYTES_PER_SECOND.

        :stability: experimental
        '''
        GIGA_BYTES_PER_SECOND = "GIGA_BYTES_PER_SECOND"
        '''(experimental) GIGA_BYTES_PER_SECOND.

        :stability: experimental
        '''
        TERA_BYTES_PER_SECOND = "TERA_BYTES_PER_SECOND"
        '''(experimental) TERA_BYTES_PER_SECOND.

        :stability: experimental
        '''
        BITS_PER_SECOND = "BITS_PER_SECOND"
        '''(experimental) BITS_PER_SECOND.

        :stability: experimental
        '''
        KILO_BITS_PER_SECOND = "KILO_BITS_PER_SECOND"
        '''(experimental) KILO_BITS_PER_SECOND.

        :stability: experimental
        '''
        MEGA_BITS_PER_SECOND = "MEGA_BITS_PER_SECOND"
        '''(experimental) MEGA_BITS_PER_SECOND.

        :stability: experimental
        '''
        GIGA_BITS_PER_SECOND = "GIGA_BITS_PER_SECOND"
        '''(experimental) GIGA_BITS_PER_SECOND.

        :stability: experimental
        '''
        TERA_BITS_PER_SECOND = "TERA_BITS_PER_SECOND"
        '''(experimental) TERA_BITS_PER_SECOND.

        :stability: experimental
        '''
        COUNT_PER_SECOND = "COUNT_PER_SECOND"
        '''(experimental) COUNT_PER_SECOND.

        :stability: experimental
        '''

    @jsii.data_type(
        jsii_type="monocdk.aws_stepfunctions_tasks.EmrCreateCluster.ConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "classification": "classification",
            "configurations": "configurations",
            "properties": "properties",
        },
    )
    class ConfigurationProperty:
        def __init__(
            self,
            *,
            classification: typing.Optional[builtins.str] = None,
            configurations: typing.Optional[typing.Sequence[typing.Union["EmrCreateCluster.ConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            properties: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        ) -> None:
            '''(experimental) An optional configuration specification to be used when provisioning cluster instances, which can include configurations for applications and software bundled with Amazon EMR.

            See the RunJobFlow API for complete documentation on input parameters

            :param classification: (experimental) The classification within a configuration. Default: No classification
            :param configurations: (experimental) A list of additional configurations to apply within a configuration object. Default: No configurations
            :param properties: (experimental) A set of properties specified within a configuration classification. Default: No properties

            :see: https://docs.aws.amazon.com/emr/latest/APIReference/API_Configuration.html
            :stability: experimental
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
                
                # configuration_property_: stepfunctions_tasks.EmrCreateCluster.ConfigurationProperty
                
                configuration_property = stepfunctions_tasks.EmrCreateCluster.ConfigurationProperty(
                    classification="classification",
                    configurations=[stepfunctions_tasks.EmrCreateCluster.ConfigurationProperty(
                        classification="classification",
                        configurations=[configuration_property_],
                        properties={
                            "properties_key": "properties"
                        }
                    )],
                    properties={
                        "properties_key": "properties"
                    }
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__9ae2ee8097495fd12cd5833887efb282ad1c19fb9f4ae5262a5be0ebcc0f8d63)
                check_type(argname="argument classification", value=classification, expected_type=type_hints["classification"])
                check_type(argname="argument configurations", value=configurations, expected_type=type_hints["configurations"])
                check_type(argname="argument properties", value=properties, expected_type=type_hints["properties"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if classification is not None:
                self._values["classification"] = classification
            if configurations is not None:
                self._values["configurations"] = configurations
            if properties is not None:
                self._values["properties"] = properties

        @builtins.property
        def classification(self) -> typing.Optional[builtins.str]:
            '''(experimental) The classification within a configuration.

            :default: No classification

            :stability: experimental
            '''
            result = self._values.get("classification")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def configurations(
            self,
        ) -> typing.Optional[typing.List["EmrCreateCluster.ConfigurationProperty"]]:
            '''(experimental) A list of additional configurations to apply within a configuration object.

            :default: No configurations

            :stability: experimental
            '''
            result = self._values.get("configurations")
            return typing.cast(typing.Optional[typing.List["EmrCreateCluster.ConfigurationProperty"]], result)

        @builtins.property
        def properties(
            self,
        ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
            '''(experimental) A set of properties specified within a configuration classification.

            :default: No properties

            :stability: experimental
            '''
            result = self._values.get("properties")
            return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="monocdk.aws_stepfunctions_tasks.EmrCreateCluster.EbsBlockDeviceConfigProperty",
        jsii_struct_bases=[],
        name_mapping={
            "volume_specification": "volumeSpecification",
            "volumes_per_instance": "volumesPerInstance",
        },
    )
    class EbsBlockDeviceConfigProperty:
        def __init__(
            self,
            *,
            volume_specification: typing.Union["EmrCreateCluster.VolumeSpecificationProperty", typing.Dict[builtins.str, typing.Any]],
            volumes_per_instance: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''(experimental) Configuration of requested EBS block device associated with the instance group with count of volumes that will be associated to every instance.

            :param volume_specification: (experimental) EBS volume specifications such as volume type, IOPS, and size (GiB) that will be requested for the EBS volume attached to an EC2 instance in the cluster.
            :param volumes_per_instance: (experimental) Number of EBS volumes with a specific volume configuration that will be associated with every instance in the instance group. Default: EMR selected default

            :see: https://docs.aws.amazon.com/emr/latest/APIReference/API_EbsBlockDeviceConfig.html
            :stability: experimental
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                import monocdk as monocdk
                from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
                
                # size: monocdk.Size
                
                ebs_block_device_config_property = stepfunctions_tasks.EmrCreateCluster.EbsBlockDeviceConfigProperty(
                    volume_specification=stepfunctions_tasks.EmrCreateCluster.VolumeSpecificationProperty(
                        volume_size=size,
                        volume_type=stepfunctions_tasks.EmrCreateCluster.EbsBlockDeviceVolumeType.GP2,
                
                        # the properties below are optional
                        iops=123
                    ),
                
                    # the properties below are optional
                    volumes_per_instance=123
                )
            '''
            if isinstance(volume_specification, dict):
                volume_specification = EmrCreateCluster.VolumeSpecificationProperty(**volume_specification)
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__99356cdcd3fbfdb8aec5e85f5d099153c7d84fae3a74f9e4af52992fabd5fb77)
                check_type(argname="argument volume_specification", value=volume_specification, expected_type=type_hints["volume_specification"])
                check_type(argname="argument volumes_per_instance", value=volumes_per_instance, expected_type=type_hints["volumes_per_instance"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "volume_specification": volume_specification,
            }
            if volumes_per_instance is not None:
                self._values["volumes_per_instance"] = volumes_per_instance

        @builtins.property
        def volume_specification(
            self,
        ) -> "EmrCreateCluster.VolumeSpecificationProperty":
            '''(experimental) EBS volume specifications such as volume type, IOPS, and size (GiB) that will be requested for the EBS volume attached to an EC2 instance in the cluster.

            :stability: experimental
            '''
            result = self._values.get("volume_specification")
            assert result is not None, "Required property 'volume_specification' is missing"
            return typing.cast("EmrCreateCluster.VolumeSpecificationProperty", result)

        @builtins.property
        def volumes_per_instance(self) -> typing.Optional[jsii.Number]:
            '''(experimental) Number of EBS volumes with a specific volume configuration that will be associated with every instance in the instance group.

            :default: EMR selected default

            :stability: experimental
            '''
            result = self._values.get("volumes_per_instance")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "EbsBlockDeviceConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.enum(
        jsii_type="monocdk.aws_stepfunctions_tasks.EmrCreateCluster.EbsBlockDeviceVolumeType"
    )
    class EbsBlockDeviceVolumeType(enum.Enum):
        '''(experimental) EBS Volume Types.

        :stability: experimental
        '''

        GP2 = "GP2"
        '''(experimental) gp2 Volume Type.

        :stability: experimental
        '''
        IO1 = "IO1"
        '''(experimental) io1 Volume Type.

        :stability: experimental
        '''
        STANDARD = "STANDARD"
        '''(experimental) Standard Volume Type.

        :stability: experimental
        '''

    @jsii.data_type(
        jsii_type="monocdk.aws_stepfunctions_tasks.EmrCreateCluster.EbsConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "ebs_block_device_configs": "ebsBlockDeviceConfigs",
            "ebs_optimized": "ebsOptimized",
        },
    )
    class EbsConfigurationProperty:
        def __init__(
            self,
            *,
            ebs_block_device_configs: typing.Optional[typing.Sequence[typing.Union["EmrCreateCluster.EbsBlockDeviceConfigProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            ebs_optimized: typing.Optional[builtins.bool] = None,
        ) -> None:
            '''(experimental) The Amazon EBS configuration of a cluster instance.

            :param ebs_block_device_configs: (experimental) An array of Amazon EBS volume specifications attached to a cluster instance. Default: - None
            :param ebs_optimized: (experimental) Indicates whether an Amazon EBS volume is EBS-optimized. Default: - EMR selected default

            :see: https://docs.aws.amazon.com/emr/latest/APIReference/API_EbsConfiguration.html
            :stability: experimental
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                import monocdk as monocdk
                from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
                
                # size: monocdk.Size
                
                ebs_configuration_property = stepfunctions_tasks.EmrCreateCluster.EbsConfigurationProperty(
                    ebs_block_device_configs=[stepfunctions_tasks.EmrCreateCluster.EbsBlockDeviceConfigProperty(
                        volume_specification=stepfunctions_tasks.EmrCreateCluster.VolumeSpecificationProperty(
                            volume_size=size,
                            volume_type=stepfunctions_tasks.EmrCreateCluster.EbsBlockDeviceVolumeType.GP2,
                
                            # the properties below are optional
                            iops=123
                        ),
                
                        # the properties below are optional
                        volumes_per_instance=123
                    )],
                    ebs_optimized=False
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__a7ec60066da51c822fa8df948a576174accc8c6838f6d181f94c9891a42287f6)
                check_type(argname="argument ebs_block_device_configs", value=ebs_block_device_configs, expected_type=type_hints["ebs_block_device_configs"])
                check_type(argname="argument ebs_optimized", value=ebs_optimized, expected_type=type_hints["ebs_optimized"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if ebs_block_device_configs is not None:
                self._values["ebs_block_device_configs"] = ebs_block_device_configs
            if ebs_optimized is not None:
                self._values["ebs_optimized"] = ebs_optimized

        @builtins.property
        def ebs_block_device_configs(
            self,
        ) -> typing.Optional[typing.List["EmrCreateCluster.EbsBlockDeviceConfigProperty"]]:
            '''(experimental) An array of Amazon EBS volume specifications attached to a cluster instance.

            :default: - None

            :stability: experimental
            '''
            result = self._values.get("ebs_block_device_configs")
            return typing.cast(typing.Optional[typing.List["EmrCreateCluster.EbsBlockDeviceConfigProperty"]], result)

        @builtins.property
        def ebs_optimized(self) -> typing.Optional[builtins.bool]:
            '''(experimental) Indicates whether an Amazon EBS volume is EBS-optimized.

            :default: - EMR selected default

            :stability: experimental
            '''
            result = self._values.get("ebs_optimized")
            return typing.cast(typing.Optional[builtins.bool], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "EbsConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.enum(
        jsii_type="monocdk.aws_stepfunctions_tasks.EmrCreateCluster.EmrClusterScaleDownBehavior"
    )
    class EmrClusterScaleDownBehavior(enum.Enum):
        '''(experimental) The Cluster ScaleDownBehavior specifies the way that individual Amazon EC2 instances terminate when an automatic scale-in activity occurs or an instance group is resized.

        :see: https://docs.aws.amazon.com/emr/latest/APIReference/API_RunJobFlow.html#EMR-RunJobFlow-request-ScaleDownBehavior
        :stability: experimental
        '''

        TERMINATE_AT_INSTANCE_HOUR = "TERMINATE_AT_INSTANCE_HOUR"
        '''(experimental) Indicates that Amazon EMR terminates nodes at the instance-hour boundary, regardless of when the request to terminate the instance was submitted.

        This option is only available with Amazon EMR 5.1.0 and later and is the default for clusters created using that version

        :stability: experimental
        '''
        TERMINATE_AT_TASK_COMPLETION = "TERMINATE_AT_TASK_COMPLETION"
        '''(experimental) Indicates that Amazon EMR adds nodes to a deny list and drains tasks from nodes before terminating the Amazon EC2 instances, regardless of the instance-hour boundary.

        :stability: experimental
        '''

    @jsii.data_type(
        jsii_type="monocdk.aws_stepfunctions_tasks.EmrCreateCluster.InstanceFleetConfigProperty",
        jsii_struct_bases=[],
        name_mapping={
            "instance_fleet_type": "instanceFleetType",
            "instance_type_configs": "instanceTypeConfigs",
            "launch_specifications": "launchSpecifications",
            "name": "name",
            "target_on_demand_capacity": "targetOnDemandCapacity",
            "target_spot_capacity": "targetSpotCapacity",
        },
    )
    class InstanceFleetConfigProperty:
        def __init__(
            self,
            *,
            instance_fleet_type: "EmrCreateCluster.InstanceRoleType",
            instance_type_configs: typing.Optional[typing.Sequence[typing.Union["EmrCreateCluster.InstanceTypeConfigProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            launch_specifications: typing.Optional[typing.Union["EmrCreateCluster.InstanceFleetProvisioningSpecificationsProperty", typing.Dict[builtins.str, typing.Any]]] = None,
            name: typing.Optional[builtins.str] = None,
            target_on_demand_capacity: typing.Optional[jsii.Number] = None,
            target_spot_capacity: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''(experimental) The configuration that defines an instance fleet.

            :param instance_fleet_type: (experimental) The node type that the instance fleet hosts. Valid values are MASTER,CORE,and TASK.
            :param instance_type_configs: (experimental) The instance type configurations that define the EC2 instances in the instance fleet. Default: No instanceTpeConfigs
            :param launch_specifications: (experimental) The launch specification for the instance fleet. Default: No launchSpecifications
            :param name: (experimental) The friendly name of the instance fleet. Default: No name
            :param target_on_demand_capacity: (experimental) The target capacity of On-Demand units for the instance fleet, which determines how many On-Demand instances to provision. Default: No targetOnDemandCapacity
            :param target_spot_capacity: (experimental) The target capacity of Spot units for the instance fleet, which determines how many Spot instances to provision. Default: No targetSpotCapacity

            :see: https://docs.aws.amazon.com/emr/latest/APIReference/API_InstanceFleetConfig.html
            :stability: experimental
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                import monocdk as monocdk
                from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
                
                # configuration_property_: stepfunctions_tasks.EmrCreateCluster.ConfigurationProperty
                # size: monocdk.Size
                
                instance_fleet_config_property = stepfunctions_tasks.EmrCreateCluster.InstanceFleetConfigProperty(
                    instance_fleet_type=stepfunctions_tasks.EmrCreateCluster.InstanceRoleType.MASTER,
                
                    # the properties below are optional
                    instance_type_configs=[stepfunctions_tasks.EmrCreateCluster.InstanceTypeConfigProperty(
                        instance_type="instanceType",
                
                        # the properties below are optional
                        bid_price="bidPrice",
                        bid_price_as_percentage_of_on_demand_price=123,
                        configurations=[stepfunctions_tasks.EmrCreateCluster.ConfigurationProperty(
                            classification="classification",
                            configurations=[configuration_property_],
                            properties={
                                "properties_key": "properties"
                            }
                        )],
                        ebs_configuration=stepfunctions_tasks.EmrCreateCluster.EbsConfigurationProperty(
                            ebs_block_device_configs=[stepfunctions_tasks.EmrCreateCluster.EbsBlockDeviceConfigProperty(
                                volume_specification=stepfunctions_tasks.EmrCreateCluster.VolumeSpecificationProperty(
                                    volume_size=size,
                                    volume_type=stepfunctions_tasks.EmrCreateCluster.EbsBlockDeviceVolumeType.GP2,
                
                                    # the properties below are optional
                                    iops=123
                                ),
                
                                # the properties below are optional
                                volumes_per_instance=123
                            )],
                            ebs_optimized=False
                        ),
                        weighted_capacity=123
                    )],
                    launch_specifications=stepfunctions_tasks.EmrCreateCluster.InstanceFleetProvisioningSpecificationsProperty(
                        spot_specification=stepfunctions_tasks.EmrCreateCluster.SpotProvisioningSpecificationProperty(
                            timeout_action=stepfunctions_tasks.EmrCreateCluster.SpotTimeoutAction.SWITCH_TO_ON_DEMAND,
                            timeout_duration_minutes=123,
                
                            # the properties below are optional
                            allocation_strategy=stepfunctions_tasks.EmrCreateCluster.SpotAllocationStrategy.CAPACITY_OPTIMIZED,
                            block_duration_minutes=123
                        )
                    ),
                    name="name",
                    target_on_demand_capacity=123,
                    target_spot_capacity=123
                )
            '''
            if isinstance(launch_specifications, dict):
                launch_specifications = EmrCreateCluster.InstanceFleetProvisioningSpecificationsProperty(**launch_specifications)
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__a61ba1d8f8b1c620b1bc6cdf9818e7a79d53671406d2d7d84b8e558297ab66a1)
                check_type(argname="argument instance_fleet_type", value=instance_fleet_type, expected_type=type_hints["instance_fleet_type"])
                check_type(argname="argument instance_type_configs", value=instance_type_configs, expected_type=type_hints["instance_type_configs"])
                check_type(argname="argument launch_specifications", value=launch_specifications, expected_type=type_hints["launch_specifications"])
                check_type(argname="argument name", value=name, expected_type=type_hints["name"])
                check_type(argname="argument target_on_demand_capacity", value=target_on_demand_capacity, expected_type=type_hints["target_on_demand_capacity"])
                check_type(argname="argument target_spot_capacity", value=target_spot_capacity, expected_type=type_hints["target_spot_capacity"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "instance_fleet_type": instance_fleet_type,
            }
            if instance_type_configs is not None:
                self._values["instance_type_configs"] = instance_type_configs
            if launch_specifications is not None:
                self._values["launch_specifications"] = launch_specifications
            if name is not None:
                self._values["name"] = name
            if target_on_demand_capacity is not None:
                self._values["target_on_demand_capacity"] = target_on_demand_capacity
            if target_spot_capacity is not None:
                self._values["target_spot_capacity"] = target_spot_capacity

        @builtins.property
        def instance_fleet_type(self) -> "EmrCreateCluster.InstanceRoleType":
            '''(experimental) The node type that the instance fleet hosts.

            Valid values are MASTER,CORE,and TASK.

            :stability: experimental
            '''
            result = self._values.get("instance_fleet_type")
            assert result is not None, "Required property 'instance_fleet_type' is missing"
            return typing.cast("EmrCreateCluster.InstanceRoleType", result)

        @builtins.property
        def instance_type_configs(
            self,
        ) -> typing.Optional[typing.List["EmrCreateCluster.InstanceTypeConfigProperty"]]:
            '''(experimental) The instance type configurations that define the EC2 instances in the instance fleet.

            :default: No instanceTpeConfigs

            :stability: experimental
            '''
            result = self._values.get("instance_type_configs")
            return typing.cast(typing.Optional[typing.List["EmrCreateCluster.InstanceTypeConfigProperty"]], result)

        @builtins.property
        def launch_specifications(
            self,
        ) -> typing.Optional["EmrCreateCluster.InstanceFleetProvisioningSpecificationsProperty"]:
            '''(experimental) The launch specification for the instance fleet.

            :default: No launchSpecifications

            :stability: experimental
            '''
            result = self._values.get("launch_specifications")
            return typing.cast(typing.Optional["EmrCreateCluster.InstanceFleetProvisioningSpecificationsProperty"], result)

        @builtins.property
        def name(self) -> typing.Optional[builtins.str]:
            '''(experimental) The friendly name of the instance fleet.

            :default: No name

            :stability: experimental
            '''
            result = self._values.get("name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def target_on_demand_capacity(self) -> typing.Optional[jsii.Number]:
            '''(experimental) The target capacity of On-Demand units for the instance fleet, which determines how many On-Demand instances to provision.

            :default: No targetOnDemandCapacity

            :stability: experimental
            '''
            result = self._values.get("target_on_demand_capacity")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def target_spot_capacity(self) -> typing.Optional[jsii.Number]:
            '''(experimental) The target capacity of Spot units for the instance fleet, which determines how many Spot instances to provision.

            :default: No targetSpotCapacity

            :stability: experimental
            '''
            result = self._values.get("target_spot_capacity")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "InstanceFleetConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="monocdk.aws_stepfunctions_tasks.EmrCreateCluster.InstanceFleetProvisioningSpecificationsProperty",
        jsii_struct_bases=[],
        name_mapping={"spot_specification": "spotSpecification"},
    )
    class InstanceFleetProvisioningSpecificationsProperty:
        def __init__(
            self,
            *,
            spot_specification: typing.Union["EmrCreateCluster.SpotProvisioningSpecificationProperty", typing.Dict[builtins.str, typing.Any]],
        ) -> None:
            '''(experimental) The launch specification for Spot instances in the fleet, which determines the defined duration and provisioning timeout behavior.

            :param spot_specification: (experimental) The launch specification for Spot instances in the fleet, which determines the defined duration and provisioning timeout behavior.

            :see: https://docs.aws.amazon.com/emr/latest/APIReference/API_InstanceFleetProvisioningSpecifications.html
            :stability: experimental
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
                
                instance_fleet_provisioning_specifications_property = stepfunctions_tasks.EmrCreateCluster.InstanceFleetProvisioningSpecificationsProperty(
                    spot_specification=stepfunctions_tasks.EmrCreateCluster.SpotProvisioningSpecificationProperty(
                        timeout_action=stepfunctions_tasks.EmrCreateCluster.SpotTimeoutAction.SWITCH_TO_ON_DEMAND,
                        timeout_duration_minutes=123,
                
                        # the properties below are optional
                        allocation_strategy=stepfunctions_tasks.EmrCreateCluster.SpotAllocationStrategy.CAPACITY_OPTIMIZED,
                        block_duration_minutes=123
                    )
                )
            '''
            if isinstance(spot_specification, dict):
                spot_specification = EmrCreateCluster.SpotProvisioningSpecificationProperty(**spot_specification)
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__113d0cee43e6794ae00544c2880ba879f56bced02264ff7bf12998044b94a0ec)
                check_type(argname="argument spot_specification", value=spot_specification, expected_type=type_hints["spot_specification"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "spot_specification": spot_specification,
            }

        @builtins.property
        def spot_specification(
            self,
        ) -> "EmrCreateCluster.SpotProvisioningSpecificationProperty":
            '''(experimental) The launch specification for Spot instances in the fleet, which determines the defined duration and provisioning timeout behavior.

            :stability: experimental
            '''
            result = self._values.get("spot_specification")
            assert result is not None, "Required property 'spot_specification' is missing"
            return typing.cast("EmrCreateCluster.SpotProvisioningSpecificationProperty", result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "InstanceFleetProvisioningSpecificationsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="monocdk.aws_stepfunctions_tasks.EmrCreateCluster.InstanceGroupConfigProperty",
        jsii_struct_bases=[],
        name_mapping={
            "instance_count": "instanceCount",
            "instance_role": "instanceRole",
            "instance_type": "instanceType",
            "auto_scaling_policy": "autoScalingPolicy",
            "bid_price": "bidPrice",
            "configurations": "configurations",
            "ebs_configuration": "ebsConfiguration",
            "market": "market",
            "name": "name",
        },
    )
    class InstanceGroupConfigProperty:
        def __init__(
            self,
            *,
            instance_count: jsii.Number,
            instance_role: "EmrCreateCluster.InstanceRoleType",
            instance_type: builtins.str,
            auto_scaling_policy: typing.Optional[typing.Union["EmrCreateCluster.AutoScalingPolicyProperty", typing.Dict[builtins.str, typing.Any]]] = None,
            bid_price: typing.Optional[builtins.str] = None,
            configurations: typing.Optional[typing.Sequence[typing.Union["EmrCreateCluster.ConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            ebs_configuration: typing.Optional[typing.Union["EmrCreateCluster.EbsConfigurationProperty", typing.Dict[builtins.str, typing.Any]]] = None,
            market: typing.Optional["EmrCreateCluster.InstanceMarket"] = None,
            name: typing.Optional[builtins.str] = None,
        ) -> None:
            '''(experimental) Configuration defining a new instance group.

            :param instance_count: (experimental) Target number of instances for the instance group.
            :param instance_role: (experimental) The role of the instance group in the cluster.
            :param instance_type: (experimental) The EC2 instance type for all instances in the instance group.
            :param auto_scaling_policy: (experimental) An automatic scaling policy for a core instance group or task instance group in an Amazon EMR cluster. Default: - None
            :param bid_price: (experimental) The bid price for each EC2 Spot instance type as defined by InstanceType. Expressed in USD. Default: - None
            :param configurations: (experimental) The list of configurations supplied for an EMR cluster instance group. Default: - None
            :param ebs_configuration: (experimental) EBS configurations that will be attached to each EC2 instance in the instance group. Default: - None
            :param market: (experimental) Market type of the EC2 instances used to create a cluster node. Default: - EMR selected default
            :param name: (experimental) Friendly name given to the instance group. Default: - None

            :see: https://docs.aws.amazon.com/emr/latest/APIReference/API_InstanceGroupConfig.html
            :stability: experimental
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                import monocdk as monocdk
                from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
                
                # configuration_property_: stepfunctions_tasks.EmrCreateCluster.ConfigurationProperty
                # duration: monocdk.Duration
                # size: monocdk.Size
                
                instance_group_config_property = stepfunctions_tasks.EmrCreateCluster.InstanceGroupConfigProperty(
                    instance_count=123,
                    instance_role=stepfunctions_tasks.EmrCreateCluster.InstanceRoleType.MASTER,
                    instance_type="instanceType",
                
                    # the properties below are optional
                    auto_scaling_policy=stepfunctions_tasks.EmrCreateCluster.AutoScalingPolicyProperty(
                        constraints=stepfunctions_tasks.EmrCreateCluster.ScalingConstraintsProperty(
                            max_capacity=123,
                            min_capacity=123
                        ),
                        rules=[stepfunctions_tasks.EmrCreateCluster.ScalingRuleProperty(
                            action=stepfunctions_tasks.EmrCreateCluster.ScalingActionProperty(
                                simple_scaling_policy_configuration=stepfunctions_tasks.EmrCreateCluster.SimpleScalingPolicyConfigurationProperty(
                                    scaling_adjustment=123,
                
                                    # the properties below are optional
                                    adjustment_type=stepfunctions_tasks.EmrCreateCluster.ScalingAdjustmentType.CHANGE_IN_CAPACITY,
                                    cool_down=123
                                ),
                
                                # the properties below are optional
                                market=stepfunctions_tasks.EmrCreateCluster.InstanceMarket.ON_DEMAND
                            ),
                            name="name",
                            trigger=stepfunctions_tasks.EmrCreateCluster.ScalingTriggerProperty(
                                cloud_watch_alarm_definition=stepfunctions_tasks.EmrCreateCluster.CloudWatchAlarmDefinitionProperty(
                                    comparison_operator=stepfunctions_tasks.EmrCreateCluster.CloudWatchAlarmComparisonOperator.GREATER_THAN_OR_EQUAL,
                                    metric_name="metricName",
                                    period=duration,
                
                                    # the properties below are optional
                                    dimensions=[stepfunctions_tasks.EmrCreateCluster.MetricDimensionProperty(
                                        key="key",
                                        value="value"
                                    )],
                                    evaluation_periods=123,
                                    namespace="namespace",
                                    statistic=stepfunctions_tasks.EmrCreateCluster.CloudWatchAlarmStatistic.SAMPLE_COUNT,
                                    threshold=123,
                                    unit=stepfunctions_tasks.EmrCreateCluster.CloudWatchAlarmUnit.NONE
                                )
                            ),
                
                            # the properties below are optional
                            description="description"
                        )]
                    ),
                    bid_price="bidPrice",
                    configurations=[stepfunctions_tasks.EmrCreateCluster.ConfigurationProperty(
                        classification="classification",
                        configurations=[configuration_property_],
                        properties={
                            "properties_key": "properties"
                        }
                    )],
                    ebs_configuration=stepfunctions_tasks.EmrCreateCluster.EbsConfigurationProperty(
                        ebs_block_device_configs=[stepfunctions_tasks.EmrCreateCluster.EbsBlockDeviceConfigProperty(
                            volume_specification=stepfunctions_tasks.EmrCreateCluster.VolumeSpecificationProperty(
                                volume_size=size,
                                volume_type=stepfunctions_tasks.EmrCreateCluster.EbsBlockDeviceVolumeType.GP2,
                
                                # the properties below are optional
                                iops=123
                            ),
                
                            # the properties below are optional
                            volumes_per_instance=123
                        )],
                        ebs_optimized=False
                    ),
                    market=stepfunctions_tasks.EmrCreateCluster.InstanceMarket.ON_DEMAND,
                    name="name"
                )
            '''
            if isinstance(auto_scaling_policy, dict):
                auto_scaling_policy = EmrCreateCluster.AutoScalingPolicyProperty(**auto_scaling_policy)
            if isinstance(ebs_configuration, dict):
                ebs_configuration = EmrCreateCluster.EbsConfigurationProperty(**ebs_configuration)
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__af293198e70e6c58079357a9498bbcaba7d3a8f7b8d14dd81f77826de6be3d63)
                check_type(argname="argument instance_count", value=instance_count, expected_type=type_hints["instance_count"])
                check_type(argname="argument instance_role", value=instance_role, expected_type=type_hints["instance_role"])
                check_type(argname="argument instance_type", value=instance_type, expected_type=type_hints["instance_type"])
                check_type(argname="argument auto_scaling_policy", value=auto_scaling_policy, expected_type=type_hints["auto_scaling_policy"])
                check_type(argname="argument bid_price", value=bid_price, expected_type=type_hints["bid_price"])
                check_type(argname="argument configurations", value=configurations, expected_type=type_hints["configurations"])
                check_type(argname="argument ebs_configuration", value=ebs_configuration, expected_type=type_hints["ebs_configuration"])
                check_type(argname="argument market", value=market, expected_type=type_hints["market"])
                check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "instance_count": instance_count,
                "instance_role": instance_role,
                "instance_type": instance_type,
            }
            if auto_scaling_policy is not None:
                self._values["auto_scaling_policy"] = auto_scaling_policy
            if bid_price is not None:
                self._values["bid_price"] = bid_price
            if configurations is not None:
                self._values["configurations"] = configurations
            if ebs_configuration is not None:
                self._values["ebs_configuration"] = ebs_configuration
            if market is not None:
                self._values["market"] = market
            if name is not None:
                self._values["name"] = name

        @builtins.property
        def instance_count(self) -> jsii.Number:
            '''(experimental) Target number of instances for the instance group.

            :stability: experimental
            '''
            result = self._values.get("instance_count")
            assert result is not None, "Required property 'instance_count' is missing"
            return typing.cast(jsii.Number, result)

        @builtins.property
        def instance_role(self) -> "EmrCreateCluster.InstanceRoleType":
            '''(experimental) The role of the instance group in the cluster.

            :stability: experimental
            '''
            result = self._values.get("instance_role")
            assert result is not None, "Required property 'instance_role' is missing"
            return typing.cast("EmrCreateCluster.InstanceRoleType", result)

        @builtins.property
        def instance_type(self) -> builtins.str:
            '''(experimental) The EC2 instance type for all instances in the instance group.

            :stability: experimental
            '''
            result = self._values.get("instance_type")
            assert result is not None, "Required property 'instance_type' is missing"
            return typing.cast(builtins.str, result)

        @builtins.property
        def auto_scaling_policy(
            self,
        ) -> typing.Optional["EmrCreateCluster.AutoScalingPolicyProperty"]:
            '''(experimental) An automatic scaling policy for a core instance group or task instance group in an Amazon EMR cluster.

            :default: - None

            :stability: experimental
            '''
            result = self._values.get("auto_scaling_policy")
            return typing.cast(typing.Optional["EmrCreateCluster.AutoScalingPolicyProperty"], result)

        @builtins.property
        def bid_price(self) -> typing.Optional[builtins.str]:
            '''(experimental) The bid price for each EC2 Spot instance type as defined by InstanceType.

            Expressed in USD.

            :default: - None

            :stability: experimental
            '''
            result = self._values.get("bid_price")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def configurations(
            self,
        ) -> typing.Optional[typing.List["EmrCreateCluster.ConfigurationProperty"]]:
            '''(experimental) The list of configurations supplied for an EMR cluster instance group.

            :default: - None

            :stability: experimental
            '''
            result = self._values.get("configurations")
            return typing.cast(typing.Optional[typing.List["EmrCreateCluster.ConfigurationProperty"]], result)

        @builtins.property
        def ebs_configuration(
            self,
        ) -> typing.Optional["EmrCreateCluster.EbsConfigurationProperty"]:
            '''(experimental) EBS configurations that will be attached to each EC2 instance in the instance group.

            :default: - None

            :stability: experimental
            '''
            result = self._values.get("ebs_configuration")
            return typing.cast(typing.Optional["EmrCreateCluster.EbsConfigurationProperty"], result)

        @builtins.property
        def market(self) -> typing.Optional["EmrCreateCluster.InstanceMarket"]:
            '''(experimental) Market type of the EC2 instances used to create a cluster node.

            :default: - EMR selected default

            :stability: experimental
            '''
            result = self._values.get("market")
            return typing.cast(typing.Optional["EmrCreateCluster.InstanceMarket"], result)

        @builtins.property
        def name(self) -> typing.Optional[builtins.str]:
            '''(experimental) Friendly name given to the instance group.

            :default: - None

            :stability: experimental
            '''
            result = self._values.get("name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "InstanceGroupConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.enum(
        jsii_type="monocdk.aws_stepfunctions_tasks.EmrCreateCluster.InstanceMarket"
    )
    class InstanceMarket(enum.Enum):
        '''(experimental) EC2 Instance Market.

        :stability: experimental
        '''

        ON_DEMAND = "ON_DEMAND"
        '''(experimental) On Demand Instance.

        :stability: experimental
        '''
        SPOT = "SPOT"
        '''(experimental) Spot Instance.

        :stability: experimental
        '''

    @jsii.enum(
        jsii_type="monocdk.aws_stepfunctions_tasks.EmrCreateCluster.InstanceRoleType"
    )
    class InstanceRoleType(enum.Enum):
        '''(experimental) Instance Role Types.

        :stability: experimental
        '''

        MASTER = "MASTER"
        '''(experimental) Master Node.

        :stability: experimental
        '''
        CORE = "CORE"
        '''(experimental) Core Node.

        :stability: experimental
        '''
        TASK = "TASK"
        '''(experimental) Task Node.

        :stability: experimental
        '''

    @jsii.data_type(
        jsii_type="monocdk.aws_stepfunctions_tasks.EmrCreateCluster.InstanceTypeConfigProperty",
        jsii_struct_bases=[],
        name_mapping={
            "instance_type": "instanceType",
            "bid_price": "bidPrice",
            "bid_price_as_percentage_of_on_demand_price": "bidPriceAsPercentageOfOnDemandPrice",
            "configurations": "configurations",
            "ebs_configuration": "ebsConfiguration",
            "weighted_capacity": "weightedCapacity",
        },
    )
    class InstanceTypeConfigProperty:
        def __init__(
            self,
            *,
            instance_type: builtins.str,
            bid_price: typing.Optional[builtins.str] = None,
            bid_price_as_percentage_of_on_demand_price: typing.Optional[jsii.Number] = None,
            configurations: typing.Optional[typing.Sequence[typing.Union["EmrCreateCluster.ConfigurationProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            ebs_configuration: typing.Optional[typing.Union["EmrCreateCluster.EbsConfigurationProperty", typing.Dict[builtins.str, typing.Any]]] = None,
            weighted_capacity: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''(experimental) An instance type configuration for each instance type in an instance fleet, which determines the EC2 instances Amazon EMR attempts to provision to fulfill On-Demand and Spot target capacities.

            :param instance_type: (experimental) An EC2 instance type.
            :param bid_price: (experimental) The bid price for each EC2 Spot instance type as defined by InstanceType. Expressed in USD. Default: - None
            :param bid_price_as_percentage_of_on_demand_price: (experimental) The bid price, as a percentage of On-Demand price. Default: - None
            :param configurations: (experimental) A configuration classification that applies when provisioning cluster instances, which can include configurations for applications and software that run on the cluster. Default: - None
            :param ebs_configuration: (experimental) The configuration of Amazon Elastic Block Storage (EBS) attached to each instance as defined by InstanceType. Default: - None
            :param weighted_capacity: (experimental) The number of units that a provisioned instance of this type provides toward fulfilling the target capacities defined in the InstanceFleetConfig. Default: - None

            :see: https://docs.aws.amazon.com/emr/latest/APIReference/API_InstanceTypeConfig.html
            :stability: experimental
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                import monocdk as monocdk
                from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
                
                # configuration_property_: stepfunctions_tasks.EmrCreateCluster.ConfigurationProperty
                # size: monocdk.Size
                
                instance_type_config_property = stepfunctions_tasks.EmrCreateCluster.InstanceTypeConfigProperty(
                    instance_type="instanceType",
                
                    # the properties below are optional
                    bid_price="bidPrice",
                    bid_price_as_percentage_of_on_demand_price=123,
                    configurations=[stepfunctions_tasks.EmrCreateCluster.ConfigurationProperty(
                        classification="classification",
                        configurations=[configuration_property_],
                        properties={
                            "properties_key": "properties"
                        }
                    )],
                    ebs_configuration=stepfunctions_tasks.EmrCreateCluster.EbsConfigurationProperty(
                        ebs_block_device_configs=[stepfunctions_tasks.EmrCreateCluster.EbsBlockDeviceConfigProperty(
                            volume_specification=stepfunctions_tasks.EmrCreateCluster.VolumeSpecificationProperty(
                                volume_size=size,
                                volume_type=stepfunctions_tasks.EmrCreateCluster.EbsBlockDeviceVolumeType.GP2,
                
                                # the properties below are optional
                                iops=123
                            ),
                
                            # the properties below are optional
                            volumes_per_instance=123
                        )],
                        ebs_optimized=False
                    ),
                    weighted_capacity=123
                )
            '''
            if isinstance(ebs_configuration, dict):
                ebs_configuration = EmrCreateCluster.EbsConfigurationProperty(**ebs_configuration)
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__135d6ae68c0159bd67fba8f902f6d26035d64e3cc0c44122cb36fab58a2cda81)
                check_type(argname="argument instance_type", value=instance_type, expected_type=type_hints["instance_type"])
                check_type(argname="argument bid_price", value=bid_price, expected_type=type_hints["bid_price"])
                check_type(argname="argument bid_price_as_percentage_of_on_demand_price", value=bid_price_as_percentage_of_on_demand_price, expected_type=type_hints["bid_price_as_percentage_of_on_demand_price"])
                check_type(argname="argument configurations", value=configurations, expected_type=type_hints["configurations"])
                check_type(argname="argument ebs_configuration", value=ebs_configuration, expected_type=type_hints["ebs_configuration"])
                check_type(argname="argument weighted_capacity", value=weighted_capacity, expected_type=type_hints["weighted_capacity"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "instance_type": instance_type,
            }
            if bid_price is not None:
                self._values["bid_price"] = bid_price
            if bid_price_as_percentage_of_on_demand_price is not None:
                self._values["bid_price_as_percentage_of_on_demand_price"] = bid_price_as_percentage_of_on_demand_price
            if configurations is not None:
                self._values["configurations"] = configurations
            if ebs_configuration is not None:
                self._values["ebs_configuration"] = ebs_configuration
            if weighted_capacity is not None:
                self._values["weighted_capacity"] = weighted_capacity

        @builtins.property
        def instance_type(self) -> builtins.str:
            '''(experimental) An EC2 instance type.

            :stability: experimental
            '''
            result = self._values.get("instance_type")
            assert result is not None, "Required property 'instance_type' is missing"
            return typing.cast(builtins.str, result)

        @builtins.property
        def bid_price(self) -> typing.Optional[builtins.str]:
            '''(experimental) The bid price for each EC2 Spot instance type as defined by InstanceType.

            Expressed in USD.

            :default: - None

            :stability: experimental
            '''
            result = self._values.get("bid_price")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def bid_price_as_percentage_of_on_demand_price(
            self,
        ) -> typing.Optional[jsii.Number]:
            '''(experimental) The bid price, as a percentage of On-Demand price.

            :default: - None

            :stability: experimental
            '''
            result = self._values.get("bid_price_as_percentage_of_on_demand_price")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def configurations(
            self,
        ) -> typing.Optional[typing.List["EmrCreateCluster.ConfigurationProperty"]]:
            '''(experimental) A configuration classification that applies when provisioning cluster instances, which can include configurations for applications and software that run on the cluster.

            :default: - None

            :stability: experimental
            '''
            result = self._values.get("configurations")
            return typing.cast(typing.Optional[typing.List["EmrCreateCluster.ConfigurationProperty"]], result)

        @builtins.property
        def ebs_configuration(
            self,
        ) -> typing.Optional["EmrCreateCluster.EbsConfigurationProperty"]:
            '''(experimental) The configuration of Amazon Elastic Block Storage (EBS) attached to each instance as defined by InstanceType.

            :default: - None

            :stability: experimental
            '''
            result = self._values.get("ebs_configuration")
            return typing.cast(typing.Optional["EmrCreateCluster.EbsConfigurationProperty"], result)

        @builtins.property
        def weighted_capacity(self) -> typing.Optional[jsii.Number]:
            '''(experimental) The number of units that a provisioned instance of this type provides toward fulfilling the target capacities defined in the InstanceFleetConfig.

            :default: - None

            :stability: experimental
            '''
            result = self._values.get("weighted_capacity")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "InstanceTypeConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="monocdk.aws_stepfunctions_tasks.EmrCreateCluster.InstancesConfigProperty",
        jsii_struct_bases=[],
        name_mapping={
            "additional_master_security_groups": "additionalMasterSecurityGroups",
            "additional_slave_security_groups": "additionalSlaveSecurityGroups",
            "ec2_key_name": "ec2KeyName",
            "ec2_subnet_id": "ec2SubnetId",
            "ec2_subnet_ids": "ec2SubnetIds",
            "emr_managed_master_security_group": "emrManagedMasterSecurityGroup",
            "emr_managed_slave_security_group": "emrManagedSlaveSecurityGroup",
            "hadoop_version": "hadoopVersion",
            "instance_count": "instanceCount",
            "instance_fleets": "instanceFleets",
            "instance_groups": "instanceGroups",
            "master_instance_type": "masterInstanceType",
            "placement": "placement",
            "service_access_security_group": "serviceAccessSecurityGroup",
            "slave_instance_type": "slaveInstanceType",
            "termination_protected": "terminationProtected",
        },
    )
    class InstancesConfigProperty:
        def __init__(
            self,
            *,
            additional_master_security_groups: typing.Optional[typing.Sequence[builtins.str]] = None,
            additional_slave_security_groups: typing.Optional[typing.Sequence[builtins.str]] = None,
            ec2_key_name: typing.Optional[builtins.str] = None,
            ec2_subnet_id: typing.Optional[builtins.str] = None,
            ec2_subnet_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
            emr_managed_master_security_group: typing.Optional[builtins.str] = None,
            emr_managed_slave_security_group: typing.Optional[builtins.str] = None,
            hadoop_version: typing.Optional[builtins.str] = None,
            instance_count: typing.Optional[jsii.Number] = None,
            instance_fleets: typing.Optional[typing.Sequence[typing.Union["EmrCreateCluster.InstanceFleetConfigProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            instance_groups: typing.Optional[typing.Sequence[typing.Union["EmrCreateCluster.InstanceGroupConfigProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
            master_instance_type: typing.Optional[builtins.str] = None,
            placement: typing.Optional[typing.Union["EmrCreateCluster.PlacementTypeProperty", typing.Dict[builtins.str, typing.Any]]] = None,
            service_access_security_group: typing.Optional[builtins.str] = None,
            slave_instance_type: typing.Optional[builtins.str] = None,
            termination_protected: typing.Optional[builtins.bool] = None,
        ) -> None:
            '''(experimental) A specification of the number and type of Amazon EC2 instances.

            See the RunJobFlow API for complete documentation on input parameters

            :param additional_master_security_groups: (experimental) A list of additional Amazon EC2 security group IDs for the master node. Default: - None
            :param additional_slave_security_groups: (experimental) A list of additional Amazon EC2 security group IDs for the core and task nodes. Default: - None
            :param ec2_key_name: (experimental) The name of the EC2 key pair that can be used to ssh to the master node as the user called "hadoop.". Default: - None
            :param ec2_subnet_id: (experimental) Applies to clusters that use the uniform instance group configuration. To launch the cluster in Amazon Virtual Private Cloud (Amazon VPC), set this parameter to the identifier of the Amazon VPC subnet where you want the cluster to launch. Default: EMR selected default
            :param ec2_subnet_ids: (experimental) Applies to clusters that use the instance fleet configuration. When multiple EC2 subnet IDs are specified, Amazon EMR evaluates them and launches instances in the optimal subnet. Default: EMR selected default
            :param emr_managed_master_security_group: (experimental) The identifier of the Amazon EC2 security group for the master node. Default: - None
            :param emr_managed_slave_security_group: (experimental) The identifier of the Amazon EC2 security group for the core and task nodes. Default: - None
            :param hadoop_version: (experimental) Applies only to Amazon EMR release versions earlier than 4.0. The Hadoop version for the cluster. Default: - 0.18 if the AmiVersion parameter is not set. If AmiVersion is set, the version of Hadoop for that AMI version is used.
            :param instance_count: (experimental) The number of EC2 instances in the cluster. Default: 0
            :param instance_fleets: (experimental) Describes the EC2 instances and instance configurations for clusters that use the instance fleet configuration. The instance fleet configuration is available only in Amazon EMR versions 4.8.0 and later, excluding 5.0.x versions. Default: - None
            :param instance_groups: (experimental) Configuration for the instance groups in a cluster. Default: - None
            :param master_instance_type: (experimental) The EC2 instance type of the master node. Default: - None
            :param placement: (experimental) The Availability Zone in which the cluster runs. Default: - EMR selected default
            :param service_access_security_group: (experimental) The identifier of the Amazon EC2 security group for the Amazon EMR service to access clusters in VPC private subnets. Default: - None
            :param slave_instance_type: (experimental) The EC2 instance type of the core and task nodes. Default: - None
            :param termination_protected: (experimental) Specifies whether to lock the cluster to prevent the Amazon EC2 instances from being terminated by API call, user intervention, or in the event of a job-flow error. Default: false

            :see: https://docs.aws.amazon.com/emr/latest/APIReference/API_JobFlowInstancesConfig.html
            :stability: experimental
            :exampleMetadata: infused

            Example::

                cluster_role = iam.Role(self, "ClusterRole",
                    assumed_by=iam.ServicePrincipal("ec2.amazonaws.com")
                )
                
                service_role = iam.Role(self, "ServiceRole",
                    assumed_by=iam.ServicePrincipal("elasticmapreduce.amazonaws.com")
                )
                
                auto_scaling_role = iam.Role(self, "AutoScalingRole",
                    assumed_by=iam.ServicePrincipal("elasticmapreduce.amazonaws.com")
                )
                
                auto_scaling_role.assume_role_policy.add_statements(
                    iam.PolicyStatement(
                        effect=iam.Effect.ALLOW,
                        principals=[
                            iam.ServicePrincipal("application-autoscaling.amazonaws.com")
                        ],
                        actions=["sts:AssumeRole"
                        ]
                    ))
                
                tasks.EmrCreateCluster(self, "Create Cluster",
                    instances=dynamodb.aws_stepfunctions_tasks.EmrCreateCluster.InstancesConfigProperty(),
                    cluster_role=cluster_role,
                    name=sfn.TaskInput.from_json_path_at("$.ClusterName").value,
                    service_role=service_role,
                    auto_scaling_role=auto_scaling_role
                )
            '''
            if isinstance(placement, dict):
                placement = EmrCreateCluster.PlacementTypeProperty(**placement)
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__9a82907ccd17b55a3b869119d4e86b9e5ea5c4970a526a743393ced97298f0f3)
                check_type(argname="argument additional_master_security_groups", value=additional_master_security_groups, expected_type=type_hints["additional_master_security_groups"])
                check_type(argname="argument additional_slave_security_groups", value=additional_slave_security_groups, expected_type=type_hints["additional_slave_security_groups"])
                check_type(argname="argument ec2_key_name", value=ec2_key_name, expected_type=type_hints["ec2_key_name"])
                check_type(argname="argument ec2_subnet_id", value=ec2_subnet_id, expected_type=type_hints["ec2_subnet_id"])
                check_type(argname="argument ec2_subnet_ids", value=ec2_subnet_ids, expected_type=type_hints["ec2_subnet_ids"])
                check_type(argname="argument emr_managed_master_security_group", value=emr_managed_master_security_group, expected_type=type_hints["emr_managed_master_security_group"])
                check_type(argname="argument emr_managed_slave_security_group", value=emr_managed_slave_security_group, expected_type=type_hints["emr_managed_slave_security_group"])
                check_type(argname="argument hadoop_version", value=hadoop_version, expected_type=type_hints["hadoop_version"])
                check_type(argname="argument instance_count", value=instance_count, expected_type=type_hints["instance_count"])
                check_type(argname="argument instance_fleets", value=instance_fleets, expected_type=type_hints["instance_fleets"])
                check_type(argname="argument instance_groups", value=instance_groups, expected_type=type_hints["instance_groups"])
                check_type(argname="argument master_instance_type", value=master_instance_type, expected_type=type_hints["master_instance_type"])
                check_type(argname="argument placement", value=placement, expected_type=type_hints["placement"])
                check_type(argname="argument service_access_security_group", value=service_access_security_group, expected_type=type_hints["service_access_security_group"])
                check_type(argname="argument slave_instance_type", value=slave_instance_type, expected_type=type_hints["slave_instance_type"])
                check_type(argname="argument termination_protected", value=termination_protected, expected_type=type_hints["termination_protected"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if additional_master_security_groups is not None:
                self._values["additional_master_security_groups"] = additional_master_security_groups
            if additional_slave_security_groups is not None:
                self._values["additional_slave_security_groups"] = additional_slave_security_groups
            if ec2_key_name is not None:
                self._values["ec2_key_name"] = ec2_key_name
            if ec2_subnet_id is not None:
                self._values["ec2_subnet_id"] = ec2_subnet_id
            if ec2_subnet_ids is not None:
                self._values["ec2_subnet_ids"] = ec2_subnet_ids
            if emr_managed_master_security_group is not None:
                self._values["emr_managed_master_security_group"] = emr_managed_master_security_group
            if emr_managed_slave_security_group is not None:
                self._values["emr_managed_slave_security_group"] = emr_managed_slave_security_group
            if hadoop_version is not None:
                self._values["hadoop_version"] = hadoop_version
            if instance_count is not None:
                self._values["instance_count"] = instance_count
            if instance_fleets is not None:
                self._values["instance_fleets"] = instance_fleets
            if instance_groups is not None:
                self._values["instance_groups"] = instance_groups
            if master_instance_type is not None:
                self._values["master_instance_type"] = master_instance_type
            if placement is not None:
                self._values["placement"] = placement
            if service_access_security_group is not None:
                self._values["service_access_security_group"] = service_access_security_group
            if slave_instance_type is not None:
                self._values["slave_instance_type"] = slave_instance_type
            if termination_protected is not None:
                self._values["termination_protected"] = termination_protected

        @builtins.property
        def additional_master_security_groups(
            self,
        ) -> typing.Optional[typing.List[builtins.str]]:
            '''(experimental) A list of additional Amazon EC2 security group IDs for the master node.

            :default: - None

            :stability: experimental
            '''
            result = self._values.get("additional_master_security_groups")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def additional_slave_security_groups(
            self,
        ) -> typing.Optional[typing.List[builtins.str]]:
            '''(experimental) A list of additional Amazon EC2 security group IDs for the core and task nodes.

            :default: - None

            :stability: experimental
            '''
            result = self._values.get("additional_slave_security_groups")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def ec2_key_name(self) -> typing.Optional[builtins.str]:
            '''(experimental) The name of the EC2 key pair that can be used to ssh to the master node as the user called "hadoop.".

            :default: - None

            :stability: experimental
            '''
            result = self._values.get("ec2_key_name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def ec2_subnet_id(self) -> typing.Optional[builtins.str]:
            '''(experimental) Applies to clusters that use the uniform instance group configuration.

            To launch the cluster in Amazon Virtual Private Cloud (Amazon VPC),
            set this parameter to the identifier of the Amazon VPC subnet where you want the cluster to launch.

            :default: EMR selected default

            :stability: experimental
            '''
            result = self._values.get("ec2_subnet_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def ec2_subnet_ids(self) -> typing.Optional[typing.List[builtins.str]]:
            '''(experimental) Applies to clusters that use the instance fleet configuration.

            When multiple EC2 subnet IDs are specified, Amazon EMR evaluates them and
            launches instances in the optimal subnet.

            :default: EMR selected default

            :stability: experimental
            '''
            result = self._values.get("ec2_subnet_ids")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def emr_managed_master_security_group(self) -> typing.Optional[builtins.str]:
            '''(experimental) The identifier of the Amazon EC2 security group for the master node.

            :default: - None

            :stability: experimental
            '''
            result = self._values.get("emr_managed_master_security_group")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def emr_managed_slave_security_group(self) -> typing.Optional[builtins.str]:
            '''(experimental) The identifier of the Amazon EC2 security group for the core and task nodes.

            :default: - None

            :stability: experimental
            '''
            result = self._values.get("emr_managed_slave_security_group")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def hadoop_version(self) -> typing.Optional[builtins.str]:
            '''(experimental) Applies only to Amazon EMR release versions earlier than 4.0. The Hadoop version for the cluster.

            :default: - 0.18 if the AmiVersion parameter is not set. If AmiVersion is set, the version of Hadoop for that AMI version is used.

            :stability: experimental
            '''
            result = self._values.get("hadoop_version")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def instance_count(self) -> typing.Optional[jsii.Number]:
            '''(experimental) The number of EC2 instances in the cluster.

            :default: 0

            :stability: experimental
            '''
            result = self._values.get("instance_count")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def instance_fleets(
            self,
        ) -> typing.Optional[typing.List["EmrCreateCluster.InstanceFleetConfigProperty"]]:
            '''(experimental) Describes the EC2 instances and instance configurations for clusters that use the instance fleet configuration.

            The instance fleet configuration is available only in Amazon EMR versions 4.8.0 and later, excluding 5.0.x versions.

            :default: - None

            :stability: experimental
            '''
            result = self._values.get("instance_fleets")
            return typing.cast(typing.Optional[typing.List["EmrCreateCluster.InstanceFleetConfigProperty"]], result)

        @builtins.property
        def instance_groups(
            self,
        ) -> typing.Optional[typing.List["EmrCreateCluster.InstanceGroupConfigProperty"]]:
            '''(experimental) Configuration for the instance groups in a cluster.

            :default: - None

            :stability: experimental
            '''
            result = self._values.get("instance_groups")
            return typing.cast(typing.Optional[typing.List["EmrCreateCluster.InstanceGroupConfigProperty"]], result)

        @builtins.property
        def master_instance_type(self) -> typing.Optional[builtins.str]:
            '''(experimental) The EC2 instance type of the master node.

            :default: - None

            :stability: experimental
            '''
            result = self._values.get("master_instance_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def placement(
            self,
        ) -> typing.Optional["EmrCreateCluster.PlacementTypeProperty"]:
            '''(experimental) The Availability Zone in which the cluster runs.

            :default: - EMR selected default

            :stability: experimental
            '''
            result = self._values.get("placement")
            return typing.cast(typing.Optional["EmrCreateCluster.PlacementTypeProperty"], result)

        @builtins.property
        def service_access_security_group(self) -> typing.Optional[builtins.str]:
            '''(experimental) The identifier of the Amazon EC2 security group for the Amazon EMR service to access clusters in VPC private subnets.

            :default: - None

            :stability: experimental
            '''
            result = self._values.get("service_access_security_group")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def slave_instance_type(self) -> typing.Optional[builtins.str]:
            '''(experimental) The EC2 instance type of the core and task nodes.

            :default: - None

            :stability: experimental
            '''
            result = self._values.get("slave_instance_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def termination_protected(self) -> typing.Optional[builtins.bool]:
            '''(experimental) Specifies whether to lock the cluster to prevent the Amazon EC2 instances from being terminated by API call, user intervention, or in the event of a job-flow error.

            :default: false

            :stability: experimental
            '''
            result = self._values.get("termination_protected")
            return typing.cast(typing.Optional[builtins.bool], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "InstancesConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="monocdk.aws_stepfunctions_tasks.EmrCreateCluster.KerberosAttributesProperty",
        jsii_struct_bases=[],
        name_mapping={
            "realm": "realm",
            "ad_domain_join_password": "adDomainJoinPassword",
            "ad_domain_join_user": "adDomainJoinUser",
            "cross_realm_trust_principal_password": "crossRealmTrustPrincipalPassword",
            "kdc_admin_password": "kdcAdminPassword",
        },
    )
    class KerberosAttributesProperty:
        def __init__(
            self,
            *,
            realm: builtins.str,
            ad_domain_join_password: typing.Optional[builtins.str] = None,
            ad_domain_join_user: typing.Optional[builtins.str] = None,
            cross_realm_trust_principal_password: typing.Optional[builtins.str] = None,
            kdc_admin_password: typing.Optional[builtins.str] = None,
        ) -> None:
            '''(experimental) Attributes for Kerberos configuration when Kerberos authentication is enabled using a security configuration.

            See the RunJobFlow API for complete documentation on input parameters

            :param realm: (experimental) The name of the Kerberos realm to which all nodes in a cluster belong. For example, EC2.INTERNAL.
            :param ad_domain_join_password: (experimental) The Active Directory password for ADDomainJoinUser. Default: No adDomainJoinPassword
            :param ad_domain_join_user: (experimental) Required only when establishing a cross-realm trust with an Active Directory domain. A user with sufficient privileges to join resources to the domain. Default: No adDomainJoinUser
            :param cross_realm_trust_principal_password: (experimental) Required only when establishing a cross-realm trust with a KDC in a different realm. The cross-realm principal password, which must be identical across realms. Default: No crossRealmTrustPrincipalPassword
            :param kdc_admin_password: (experimental) The password used within the cluster for the kadmin service on the cluster-dedicated KDC, which maintains Kerberos principals, password policies, and keytabs for the cluster. Default: No kdcAdminPassword

            :see: https://docs.aws.amazon.com/emr/latest/APIReference/API_KerberosAttributes.html
            :stability: experimental
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
                
                kerberos_attributes_property = stepfunctions_tasks.EmrCreateCluster.KerberosAttributesProperty(
                    realm="realm",
                
                    # the properties below are optional
                    ad_domain_join_password="adDomainJoinPassword",
                    ad_domain_join_user="adDomainJoinUser",
                    cross_realm_trust_principal_password="crossRealmTrustPrincipalPassword",
                    kdc_admin_password="kdcAdminPassword"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__bc6ff17025091bfeddd48f2f7ef87320f733e72d4a73f14ad0613304e65b27d5)
                check_type(argname="argument realm", value=realm, expected_type=type_hints["realm"])
                check_type(argname="argument ad_domain_join_password", value=ad_domain_join_password, expected_type=type_hints["ad_domain_join_password"])
                check_type(argname="argument ad_domain_join_user", value=ad_domain_join_user, expected_type=type_hints["ad_domain_join_user"])
                check_type(argname="argument cross_realm_trust_principal_password", value=cross_realm_trust_principal_password, expected_type=type_hints["cross_realm_trust_principal_password"])
                check_type(argname="argument kdc_admin_password", value=kdc_admin_password, expected_type=type_hints["kdc_admin_password"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "realm": realm,
            }
            if ad_domain_join_password is not None:
                self._values["ad_domain_join_password"] = ad_domain_join_password
            if ad_domain_join_user is not None:
                self._values["ad_domain_join_user"] = ad_domain_join_user
            if cross_realm_trust_principal_password is not None:
                self._values["cross_realm_trust_principal_password"] = cross_realm_trust_principal_password
            if kdc_admin_password is not None:
                self._values["kdc_admin_password"] = kdc_admin_password

        @builtins.property
        def realm(self) -> builtins.str:
            '''(experimental) The name of the Kerberos realm to which all nodes in a cluster belong.

            For example, EC2.INTERNAL.

            :stability: experimental
            '''
            result = self._values.get("realm")
            assert result is not None, "Required property 'realm' is missing"
            return typing.cast(builtins.str, result)

        @builtins.property
        def ad_domain_join_password(self) -> typing.Optional[builtins.str]:
            '''(experimental) The Active Directory password for ADDomainJoinUser.

            :default: No adDomainJoinPassword

            :stability: experimental
            '''
            result = self._values.get("ad_domain_join_password")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def ad_domain_join_user(self) -> typing.Optional[builtins.str]:
            '''(experimental) Required only when establishing a cross-realm trust with an Active Directory domain.

            A user with sufficient privileges to join
            resources to the domain.

            :default: No adDomainJoinUser

            :stability: experimental
            '''
            result = self._values.get("ad_domain_join_user")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def cross_realm_trust_principal_password(self) -> typing.Optional[builtins.str]:
            '''(experimental) Required only when establishing a cross-realm trust with a KDC in a different realm.

            The cross-realm principal password, which
            must be identical across realms.

            :default: No crossRealmTrustPrincipalPassword

            :stability: experimental
            '''
            result = self._values.get("cross_realm_trust_principal_password")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def kdc_admin_password(self) -> typing.Optional[builtins.str]:
            '''(experimental) The password used within the cluster for the kadmin service on the cluster-dedicated KDC, which maintains Kerberos principals, password policies, and keytabs for the cluster.

            :default: No kdcAdminPassword

            :stability: experimental
            '''
            result = self._values.get("kdc_admin_password")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "KerberosAttributesProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="monocdk.aws_stepfunctions_tasks.EmrCreateCluster.MetricDimensionProperty",
        jsii_struct_bases=[],
        name_mapping={"key": "key", "value": "value"},
    )
    class MetricDimensionProperty:
        def __init__(self, *, key: builtins.str, value: builtins.str) -> None:
            '''(experimental) A CloudWatch dimension, which is specified using a Key (known as a Name in CloudWatch), Value pair.

            By default, Amazon EMR uses
            one dimension whose Key is JobFlowID and Value is a variable representing the cluster ID, which is ${emr.clusterId}. This enables
            the rule to bootstrap when the cluster ID becomes available

            :param key: (experimental) The dimension name.
            :param value: (experimental) The dimension value.

            :see: https://docs.aws.amazon.com/emr/latest/APIReference/API_MetricDimension.html
            :stability: experimental
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
                
                metric_dimension_property = stepfunctions_tasks.EmrCreateCluster.MetricDimensionProperty(
                    key="key",
                    value="value"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__6080a83b61b630725049800cd02d9e902ca564fb1b6400fbf509a6c211013c95)
                check_type(argname="argument key", value=key, expected_type=type_hints["key"])
                check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "key": key,
                "value": value,
            }

        @builtins.property
        def key(self) -> builtins.str:
            '''(experimental) The dimension name.

            :stability: experimental
            '''
            result = self._values.get("key")
            assert result is not None, "Required property 'key' is missing"
            return typing.cast(builtins.str, result)

        @builtins.property
        def value(self) -> builtins.str:
            '''(experimental) The dimension value.

            :stability: experimental
            '''
            result = self._values.get("value")
            assert result is not None, "Required property 'value' is missing"
            return typing.cast(builtins.str, result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "MetricDimensionProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="monocdk.aws_stepfunctions_tasks.EmrCreateCluster.PlacementTypeProperty",
        jsii_struct_bases=[],
        name_mapping={
            "availability_zone": "availabilityZone",
            "availability_zones": "availabilityZones",
        },
    )
    class PlacementTypeProperty:
        def __init__(
            self,
            *,
            availability_zone: typing.Optional[builtins.str] = None,
            availability_zones: typing.Optional[typing.Sequence[builtins.str]] = None,
        ) -> None:
            '''(experimental) The Amazon EC2 Availability Zone configuration of the cluster (job flow).

            :param availability_zone: (experimental) The Amazon EC2 Availability Zone for the cluster. AvailabilityZone is used for uniform instance groups, while AvailabilityZones (plural) is used for instance fleets. Default: - EMR selected default
            :param availability_zones: (experimental) When multiple Availability Zones are specified, Amazon EMR evaluates them and launches instances in the optimal Availability Zone. AvailabilityZones is used for instance fleets, while AvailabilityZone (singular) is used for uniform instance groups. Default: - EMR selected default

            :see: https://docs.aws.amazon.com/emr/latest/APIReference/API_PlacementType.html
            :stability: experimental
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
                
                placement_type_property = stepfunctions_tasks.EmrCreateCluster.PlacementTypeProperty(
                    availability_zone="availabilityZone",
                    availability_zones=["availabilityZones"]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__8ad08ccbf1f276ef9cd54bc146df7ccaa98c01ff4be42cca061a4b039e9d534f)
                check_type(argname="argument availability_zone", value=availability_zone, expected_type=type_hints["availability_zone"])
                check_type(argname="argument availability_zones", value=availability_zones, expected_type=type_hints["availability_zones"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if availability_zone is not None:
                self._values["availability_zone"] = availability_zone
            if availability_zones is not None:
                self._values["availability_zones"] = availability_zones

        @builtins.property
        def availability_zone(self) -> typing.Optional[builtins.str]:
            '''(experimental) The Amazon EC2 Availability Zone for the cluster.

            AvailabilityZone is used for uniform instance groups, while AvailabilityZones
            (plural) is used for instance fleets.

            :default: - EMR selected default

            :stability: experimental
            '''
            result = self._values.get("availability_zone")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def availability_zones(self) -> typing.Optional[typing.List[builtins.str]]:
            '''(experimental) When multiple Availability Zones are specified, Amazon EMR evaluates them and launches instances in the optimal Availability Zone.

            AvailabilityZones is used for instance fleets, while AvailabilityZone (singular) is used for uniform instance groups.

            :default: - EMR selected default

            :stability: experimental
            '''
            result = self._values.get("availability_zones")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PlacementTypeProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="monocdk.aws_stepfunctions_tasks.EmrCreateCluster.ScalingActionProperty",
        jsii_struct_bases=[],
        name_mapping={
            "simple_scaling_policy_configuration": "simpleScalingPolicyConfiguration",
            "market": "market",
        },
    )
    class ScalingActionProperty:
        def __init__(
            self,
            *,
            simple_scaling_policy_configuration: typing.Union["EmrCreateCluster.SimpleScalingPolicyConfigurationProperty", typing.Dict[builtins.str, typing.Any]],
            market: typing.Optional["EmrCreateCluster.InstanceMarket"] = None,
        ) -> None:
            '''(experimental) The type of adjustment the automatic scaling activity makes when triggered, and the periodicity of the adjustment.

            And an automatic scaling configuration, which describes how the policy adds or removes instances, the cooldown period,
            and the number of EC2 instances that will be added each time the CloudWatch metric alarm condition is satisfied.

            :param simple_scaling_policy_configuration: (experimental) The type of adjustment the automatic scaling activity makes when triggered, and the periodicity of the adjustment.
            :param market: (experimental) Not available for instance groups. Instance groups use the market type specified for the group. Default: - EMR selected default

            :see: https://docs.aws.amazon.com/emr/latest/APIReference/API_ScalingAction.html
            :stability: experimental
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
                
                scaling_action_property = stepfunctions_tasks.EmrCreateCluster.ScalingActionProperty(
                    simple_scaling_policy_configuration=stepfunctions_tasks.EmrCreateCluster.SimpleScalingPolicyConfigurationProperty(
                        scaling_adjustment=123,
                
                        # the properties below are optional
                        adjustment_type=stepfunctions_tasks.EmrCreateCluster.ScalingAdjustmentType.CHANGE_IN_CAPACITY,
                        cool_down=123
                    ),
                
                    # the properties below are optional
                    market=stepfunctions_tasks.EmrCreateCluster.InstanceMarket.ON_DEMAND
                )
            '''
            if isinstance(simple_scaling_policy_configuration, dict):
                simple_scaling_policy_configuration = EmrCreateCluster.SimpleScalingPolicyConfigurationProperty(**simple_scaling_policy_configuration)
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__c337be68f6aecc86b2dff837a3c3d1fd511c4374d27a6967723e2d3861a76874)
                check_type(argname="argument simple_scaling_policy_configuration", value=simple_scaling_policy_configuration, expected_type=type_hints["simple_scaling_policy_configuration"])
                check_type(argname="argument market", value=market, expected_type=type_hints["market"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "simple_scaling_policy_configuration": simple_scaling_policy_configuration,
            }
            if market is not None:
                self._values["market"] = market

        @builtins.property
        def simple_scaling_policy_configuration(
            self,
        ) -> "EmrCreateCluster.SimpleScalingPolicyConfigurationProperty":
            '''(experimental) The type of adjustment the automatic scaling activity makes when triggered, and the periodicity of the adjustment.

            :stability: experimental
            '''
            result = self._values.get("simple_scaling_policy_configuration")
            assert result is not None, "Required property 'simple_scaling_policy_configuration' is missing"
            return typing.cast("EmrCreateCluster.SimpleScalingPolicyConfigurationProperty", result)

        @builtins.property
        def market(self) -> typing.Optional["EmrCreateCluster.InstanceMarket"]:
            '''(experimental) Not available for instance groups.

            Instance groups use the market type specified for the group.

            :default: - EMR selected default

            :stability: experimental
            '''
            result = self._values.get("market")
            return typing.cast(typing.Optional["EmrCreateCluster.InstanceMarket"], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ScalingActionProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.enum(
        jsii_type="monocdk.aws_stepfunctions_tasks.EmrCreateCluster.ScalingAdjustmentType"
    )
    class ScalingAdjustmentType(enum.Enum):
        '''(experimental) AutoScaling Adjustment Type.

        :stability: experimental
        '''

        CHANGE_IN_CAPACITY = "CHANGE_IN_CAPACITY"
        '''(experimental) CHANGE_IN_CAPACITY.

        :stability: experimental
        '''
        PERCENT_CHANGE_IN_CAPACITY = "PERCENT_CHANGE_IN_CAPACITY"
        '''(experimental) PERCENT_CHANGE_IN_CAPACITY.

        :stability: experimental
        '''
        EXACT_CAPACITY = "EXACT_CAPACITY"
        '''(experimental) EXACT_CAPACITY.

        :stability: experimental
        '''

    @jsii.data_type(
        jsii_type="monocdk.aws_stepfunctions_tasks.EmrCreateCluster.ScalingConstraintsProperty",
        jsii_struct_bases=[],
        name_mapping={"max_capacity": "maxCapacity", "min_capacity": "minCapacity"},
    )
    class ScalingConstraintsProperty:
        def __init__(
            self,
            *,
            max_capacity: jsii.Number,
            min_capacity: jsii.Number,
        ) -> None:
            '''(experimental) The upper and lower EC2 instance limits for an automatic scaling policy.

            Automatic scaling activities triggered by automatic scaling
            rules will not cause an instance group to grow above or below these limits.

            :param max_capacity: (experimental) The upper boundary of EC2 instances in an instance group beyond which scaling activities are not allowed to grow. Scale-out activities will not add instances beyond this boundary.
            :param min_capacity: (experimental) The lower boundary of EC2 instances in an instance group below which scaling activities are not allowed to shrink. Scale-in activities will not terminate instances below this boundary.

            :see: https://docs.aws.amazon.com/emr/latest/APIReference/API_ScalingConstraints.html
            :stability: experimental
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
                
                scaling_constraints_property = stepfunctions_tasks.EmrCreateCluster.ScalingConstraintsProperty(
                    max_capacity=123,
                    min_capacity=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__1e1d78376ffd5e8000bf9fa260fed7bbb40930219e861e6718c250534eb5ed90)
                check_type(argname="argument max_capacity", value=max_capacity, expected_type=type_hints["max_capacity"])
                check_type(argname="argument min_capacity", value=min_capacity, expected_type=type_hints["min_capacity"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "max_capacity": max_capacity,
                "min_capacity": min_capacity,
            }

        @builtins.property
        def max_capacity(self) -> jsii.Number:
            '''(experimental) The upper boundary of EC2 instances in an instance group beyond which scaling activities are not allowed to grow.

            Scale-out
            activities will not add instances beyond this boundary.

            :stability: experimental
            '''
            result = self._values.get("max_capacity")
            assert result is not None, "Required property 'max_capacity' is missing"
            return typing.cast(jsii.Number, result)

        @builtins.property
        def min_capacity(self) -> jsii.Number:
            '''(experimental) The lower boundary of EC2 instances in an instance group below which scaling activities are not allowed to shrink.

            Scale-in
            activities will not terminate instances below this boundary.

            :stability: experimental
            '''
            result = self._values.get("min_capacity")
            assert result is not None, "Required property 'min_capacity' is missing"
            return typing.cast(jsii.Number, result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ScalingConstraintsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="monocdk.aws_stepfunctions_tasks.EmrCreateCluster.ScalingRuleProperty",
        jsii_struct_bases=[],
        name_mapping={
            "action": "action",
            "name": "name",
            "trigger": "trigger",
            "description": "description",
        },
    )
    class ScalingRuleProperty:
        def __init__(
            self,
            *,
            action: typing.Union["EmrCreateCluster.ScalingActionProperty", typing.Dict[builtins.str, typing.Any]],
            name: builtins.str,
            trigger: typing.Union["EmrCreateCluster.ScalingTriggerProperty", typing.Dict[builtins.str, typing.Any]],
            description: typing.Optional[builtins.str] = None,
        ) -> None:
            '''(experimental) A scale-in or scale-out rule that defines scaling activity, including the CloudWatch metric alarm that triggers activity, how EC2 instances are added or removed, and the periodicity of adjustments.

            :param action: (experimental) The conditions that trigger an automatic scaling activity.
            :param name: (experimental) The name used to identify an automatic scaling rule. Rule names must be unique within a scaling policy.
            :param trigger: (experimental) The CloudWatch alarm definition that determines when automatic scaling activity is triggered.
            :param description: (experimental) A friendly, more verbose description of the automatic scaling rule. Default: - None

            :see: https://docs.aws.amazon.com/emr/latest/APIReference/API_ScalingRule.html
            :stability: experimental
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                import monocdk as monocdk
                from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
                
                # duration: monocdk.Duration
                
                scaling_rule_property = stepfunctions_tasks.EmrCreateCluster.ScalingRuleProperty(
                    action=stepfunctions_tasks.EmrCreateCluster.ScalingActionProperty(
                        simple_scaling_policy_configuration=stepfunctions_tasks.EmrCreateCluster.SimpleScalingPolicyConfigurationProperty(
                            scaling_adjustment=123,
                
                            # the properties below are optional
                            adjustment_type=stepfunctions_tasks.EmrCreateCluster.ScalingAdjustmentType.CHANGE_IN_CAPACITY,
                            cool_down=123
                        ),
                
                        # the properties below are optional
                        market=stepfunctions_tasks.EmrCreateCluster.InstanceMarket.ON_DEMAND
                    ),
                    name="name",
                    trigger=stepfunctions_tasks.EmrCreateCluster.ScalingTriggerProperty(
                        cloud_watch_alarm_definition=stepfunctions_tasks.EmrCreateCluster.CloudWatchAlarmDefinitionProperty(
                            comparison_operator=stepfunctions_tasks.EmrCreateCluster.CloudWatchAlarmComparisonOperator.GREATER_THAN_OR_EQUAL,
                            metric_name="metricName",
                            period=duration,
                
                            # the properties below are optional
                            dimensions=[stepfunctions_tasks.EmrCreateCluster.MetricDimensionProperty(
                                key="key",
                                value="value"
                            )],
                            evaluation_periods=123,
                            namespace="namespace",
                            statistic=stepfunctions_tasks.EmrCreateCluster.CloudWatchAlarmStatistic.SAMPLE_COUNT,
                            threshold=123,
                            unit=stepfunctions_tasks.EmrCreateCluster.CloudWatchAlarmUnit.NONE
                        )
                    ),
                
                    # the properties below are optional
                    description="description"
                )
            '''
            if isinstance(action, dict):
                action = EmrCreateCluster.ScalingActionProperty(**action)
            if isinstance(trigger, dict):
                trigger = EmrCreateCluster.ScalingTriggerProperty(**trigger)
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__982fff6ea3bf67f59f3007e313e188189d3b19720ca3573cf92e43d53d467ada)
                check_type(argname="argument action", value=action, expected_type=type_hints["action"])
                check_type(argname="argument name", value=name, expected_type=type_hints["name"])
                check_type(argname="argument trigger", value=trigger, expected_type=type_hints["trigger"])
                check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "action": action,
                "name": name,
                "trigger": trigger,
            }
            if description is not None:
                self._values["description"] = description

        @builtins.property
        def action(self) -> "EmrCreateCluster.ScalingActionProperty":
            '''(experimental) The conditions that trigger an automatic scaling activity.

            :stability: experimental
            '''
            result = self._values.get("action")
            assert result is not None, "Required property 'action' is missing"
            return typing.cast("EmrCreateCluster.ScalingActionProperty", result)

        @builtins.property
        def name(self) -> builtins.str:
            '''(experimental) The name used to identify an automatic scaling rule.

            Rule names must be unique within a scaling policy.

            :stability: experimental
            '''
            result = self._values.get("name")
            assert result is not None, "Required property 'name' is missing"
            return typing.cast(builtins.str, result)

        @builtins.property
        def trigger(self) -> "EmrCreateCluster.ScalingTriggerProperty":
            '''(experimental) The CloudWatch alarm definition that determines when automatic scaling activity is triggered.

            :stability: experimental
            '''
            result = self._values.get("trigger")
            assert result is not None, "Required property 'trigger' is missing"
            return typing.cast("EmrCreateCluster.ScalingTriggerProperty", result)

        @builtins.property
        def description(self) -> typing.Optional[builtins.str]:
            '''(experimental) A friendly, more verbose description of the automatic scaling rule.

            :default: - None

            :stability: experimental
            '''
            result = self._values.get("description")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ScalingRuleProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="monocdk.aws_stepfunctions_tasks.EmrCreateCluster.ScalingTriggerProperty",
        jsii_struct_bases=[],
        name_mapping={"cloud_watch_alarm_definition": "cloudWatchAlarmDefinition"},
    )
    class ScalingTriggerProperty:
        def __init__(
            self,
            *,
            cloud_watch_alarm_definition: typing.Union["EmrCreateCluster.CloudWatchAlarmDefinitionProperty", typing.Dict[builtins.str, typing.Any]],
        ) -> None:
            '''(experimental) The conditions that trigger an automatic scaling activity and the definition of a CloudWatch metric alarm.

            When the defined alarm conditions are met along with other trigger parameters, scaling activity begins.

            :param cloud_watch_alarm_definition: (experimental) The definition of a CloudWatch metric alarm. When the defined alarm conditions are met along with other trigger parameters, scaling activity begins.

            :see: https://docs.aws.amazon.com/emr/latest/APIReference/API_ScalingTrigger.html
            :stability: experimental
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                import monocdk as monocdk
                from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
                
                # duration: monocdk.Duration
                
                scaling_trigger_property = stepfunctions_tasks.EmrCreateCluster.ScalingTriggerProperty(
                    cloud_watch_alarm_definition=stepfunctions_tasks.EmrCreateCluster.CloudWatchAlarmDefinitionProperty(
                        comparison_operator=stepfunctions_tasks.EmrCreateCluster.CloudWatchAlarmComparisonOperator.GREATER_THAN_OR_EQUAL,
                        metric_name="metricName",
                        period=duration,
                
                        # the properties below are optional
                        dimensions=[stepfunctions_tasks.EmrCreateCluster.MetricDimensionProperty(
                            key="key",
                            value="value"
                        )],
                        evaluation_periods=123,
                        namespace="namespace",
                        statistic=stepfunctions_tasks.EmrCreateCluster.CloudWatchAlarmStatistic.SAMPLE_COUNT,
                        threshold=123,
                        unit=stepfunctions_tasks.EmrCreateCluster.CloudWatchAlarmUnit.NONE
                    )
                )
            '''
            if isinstance(cloud_watch_alarm_definition, dict):
                cloud_watch_alarm_definition = EmrCreateCluster.CloudWatchAlarmDefinitionProperty(**cloud_watch_alarm_definition)
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__325dd5c947d53a3ecdedf472dee7fcfada4f94b3f52b81cee5c69b352b3d7522)
                check_type(argname="argument cloud_watch_alarm_definition", value=cloud_watch_alarm_definition, expected_type=type_hints["cloud_watch_alarm_definition"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "cloud_watch_alarm_definition": cloud_watch_alarm_definition,
            }

        @builtins.property
        def cloud_watch_alarm_definition(
            self,
        ) -> "EmrCreateCluster.CloudWatchAlarmDefinitionProperty":
            '''(experimental) The definition of a CloudWatch metric alarm.

            When the defined alarm conditions are met along with other trigger parameters,
            scaling activity begins.

            :stability: experimental
            '''
            result = self._values.get("cloud_watch_alarm_definition")
            assert result is not None, "Required property 'cloud_watch_alarm_definition' is missing"
            return typing.cast("EmrCreateCluster.CloudWatchAlarmDefinitionProperty", result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ScalingTriggerProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="monocdk.aws_stepfunctions_tasks.EmrCreateCluster.ScriptBootstrapActionConfigProperty",
        jsii_struct_bases=[],
        name_mapping={"path": "path", "args": "args"},
    )
    class ScriptBootstrapActionConfigProperty:
        def __init__(
            self,
            *,
            path: builtins.str,
            args: typing.Optional[typing.Sequence[builtins.str]] = None,
        ) -> None:
            '''(experimental) Configuration of the script to run during a bootstrap action.

            :param path: (experimental) Location of the script to run during a bootstrap action. Can be either a location in Amazon S3 or on a local file system.
            :param args: (experimental) A list of command line arguments to pass to the bootstrap action script. Default: No args

            :see: https://docs.aws.amazon.com/emr/latest/APIReference/API_ScriptBootstrapActionConfig.html
            :stability: experimental
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
                
                script_bootstrap_action_config_property = stepfunctions_tasks.EmrCreateCluster.ScriptBootstrapActionConfigProperty(
                    path="path",
                
                    # the properties below are optional
                    args=["args"]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__765be7c8263df974c985de7cd6e835131253c4d2e4f96f372805fbf93f11668e)
                check_type(argname="argument path", value=path, expected_type=type_hints["path"])
                check_type(argname="argument args", value=args, expected_type=type_hints["args"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "path": path,
            }
            if args is not None:
                self._values["args"] = args

        @builtins.property
        def path(self) -> builtins.str:
            '''(experimental) Location of the script to run during a bootstrap action.

            Can be either a location in Amazon S3 or on a local file system.

            :stability: experimental
            '''
            result = self._values.get("path")
            assert result is not None, "Required property 'path' is missing"
            return typing.cast(builtins.str, result)

        @builtins.property
        def args(self) -> typing.Optional[typing.List[builtins.str]]:
            '''(experimental) A list of command line arguments to pass to the bootstrap action script.

            :default: No args

            :stability: experimental
            '''
            result = self._values.get("args")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ScriptBootstrapActionConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="monocdk.aws_stepfunctions_tasks.EmrCreateCluster.SimpleScalingPolicyConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "scaling_adjustment": "scalingAdjustment",
            "adjustment_type": "adjustmentType",
            "cool_down": "coolDown",
        },
    )
    class SimpleScalingPolicyConfigurationProperty:
        def __init__(
            self,
            *,
            scaling_adjustment: jsii.Number,
            adjustment_type: typing.Optional["EmrCreateCluster.ScalingAdjustmentType"] = None,
            cool_down: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''(experimental) An automatic scaling configuration, which describes how the policy adds or removes instances, the cooldown period, and the number of EC2 instances that will be added each time the CloudWatch metric alarm condition is satisfied.

            :param scaling_adjustment: (experimental) The amount by which to scale in or scale out, based on the specified AdjustmentType. A positive value adds to the instance group's EC2 instance count while a negative number removes instances. If AdjustmentType is set to EXACT_CAPACITY, the number should only be a positive integer.
            :param adjustment_type: (experimental) The way in which EC2 instances are added (if ScalingAdjustment is a positive number) or terminated (if ScalingAdjustment is a negative number) each time the scaling activity is triggered. Default: - None
            :param cool_down: (experimental) The amount of time, in seconds, after a scaling activity completes before any further trigger-related scaling activities can start. Default: 0

            :see: https://docs.aws.amazon.com/emr/latest/APIReference/API_SimpleScalingPolicyConfiguration.html
            :stability: experimental
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
                
                simple_scaling_policy_configuration_property = stepfunctions_tasks.EmrCreateCluster.SimpleScalingPolicyConfigurationProperty(
                    scaling_adjustment=123,
                
                    # the properties below are optional
                    adjustment_type=stepfunctions_tasks.EmrCreateCluster.ScalingAdjustmentType.CHANGE_IN_CAPACITY,
                    cool_down=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__b75fbe84747859a1da505a0de377d8ee5510bbee584646d687b623a758a4e2bf)
                check_type(argname="argument scaling_adjustment", value=scaling_adjustment, expected_type=type_hints["scaling_adjustment"])
                check_type(argname="argument adjustment_type", value=adjustment_type, expected_type=type_hints["adjustment_type"])
                check_type(argname="argument cool_down", value=cool_down, expected_type=type_hints["cool_down"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "scaling_adjustment": scaling_adjustment,
            }
            if adjustment_type is not None:
                self._values["adjustment_type"] = adjustment_type
            if cool_down is not None:
                self._values["cool_down"] = cool_down

        @builtins.property
        def scaling_adjustment(self) -> jsii.Number:
            '''(experimental) The amount by which to scale in or scale out, based on the specified AdjustmentType.

            A positive value adds to the instance group's
            EC2 instance count while a negative number removes instances. If AdjustmentType is set to EXACT_CAPACITY, the number should only be
            a positive integer.

            :stability: experimental
            '''
            result = self._values.get("scaling_adjustment")
            assert result is not None, "Required property 'scaling_adjustment' is missing"
            return typing.cast(jsii.Number, result)

        @builtins.property
        def adjustment_type(
            self,
        ) -> typing.Optional["EmrCreateCluster.ScalingAdjustmentType"]:
            '''(experimental) The way in which EC2 instances are added (if ScalingAdjustment is a positive number) or terminated (if ScalingAdjustment is a negative number) each time the scaling activity is triggered.

            :default: - None

            :stability: experimental
            '''
            result = self._values.get("adjustment_type")
            return typing.cast(typing.Optional["EmrCreateCluster.ScalingAdjustmentType"], result)

        @builtins.property
        def cool_down(self) -> typing.Optional[jsii.Number]:
            '''(experimental) The amount of time, in seconds, after a scaling activity completes before any further trigger-related scaling activities can start.

            :default: 0

            :stability: experimental
            '''
            result = self._values.get("cool_down")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SimpleScalingPolicyConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.enum(
        jsii_type="monocdk.aws_stepfunctions_tasks.EmrCreateCluster.SpotAllocationStrategy"
    )
    class SpotAllocationStrategy(enum.Enum):
        '''(experimental) Spot Allocation Strategies.

        Specifies the strategy to use in launching Spot Instance fleets. For example, "capacity-optimized" launches instances from Spot Instance pools with optimal capacity for the number of instances that are launching.

        :see: https://docs.aws.amazon.com/emr/latest/APIReference/API_SpotProvisioningSpecification.html
        :stability: experimental
        '''

        CAPACITY_OPTIMIZED = "CAPACITY_OPTIMIZED"
        '''(experimental) Capacity-optimized, which launches instances from Spot Instance pools with optimal capacity for the number of instances that are launching.

        :stability: experimental
        '''

    @jsii.data_type(
        jsii_type="monocdk.aws_stepfunctions_tasks.EmrCreateCluster.SpotProvisioningSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "timeout_action": "timeoutAction",
            "timeout_duration_minutes": "timeoutDurationMinutes",
            "allocation_strategy": "allocationStrategy",
            "block_duration_minutes": "blockDurationMinutes",
        },
    )
    class SpotProvisioningSpecificationProperty:
        def __init__(
            self,
            *,
            timeout_action: "EmrCreateCluster.SpotTimeoutAction",
            timeout_duration_minutes: jsii.Number,
            allocation_strategy: typing.Optional["EmrCreateCluster.SpotAllocationStrategy"] = None,
            block_duration_minutes: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''(experimental) The launch specification for Spot instances in the instance fleet, which determines the defined duration and provisioning timeout behavior.

            :param timeout_action: (experimental) The action to take when TargetSpotCapacity has not been fulfilled when the TimeoutDurationMinutes has expired.
            :param timeout_duration_minutes: (experimental) The spot provisioning timeout period in minutes.
            :param allocation_strategy: (experimental) Specifies the strategy to use in launching Spot Instance fleets. Default: - No allocation strategy, i.e. spot instance type will be chosen based on current price only
            :param block_duration_minutes: (experimental) The defined duration for Spot instances (also known as Spot blocks) in minutes. Default: - No blockDurationMinutes

            :see: https://docs.aws.amazon.com/emr/latest/APIReference/API_SpotProvisioningSpecification.html
            :stability: experimental
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
                
                spot_provisioning_specification_property = stepfunctions_tasks.EmrCreateCluster.SpotProvisioningSpecificationProperty(
                    timeout_action=stepfunctions_tasks.EmrCreateCluster.SpotTimeoutAction.SWITCH_TO_ON_DEMAND,
                    timeout_duration_minutes=123,
                
                    # the properties below are optional
                    allocation_strategy=stepfunctions_tasks.EmrCreateCluster.SpotAllocationStrategy.CAPACITY_OPTIMIZED,
                    block_duration_minutes=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__ddf4a9a2adda278dd6bbf6685d23a9596c5a5c4f79fa572c5d379f1ed7d2e2e6)
                check_type(argname="argument timeout_action", value=timeout_action, expected_type=type_hints["timeout_action"])
                check_type(argname="argument timeout_duration_minutes", value=timeout_duration_minutes, expected_type=type_hints["timeout_duration_minutes"])
                check_type(argname="argument allocation_strategy", value=allocation_strategy, expected_type=type_hints["allocation_strategy"])
                check_type(argname="argument block_duration_minutes", value=block_duration_minutes, expected_type=type_hints["block_duration_minutes"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "timeout_action": timeout_action,
                "timeout_duration_minutes": timeout_duration_minutes,
            }
            if allocation_strategy is not None:
                self._values["allocation_strategy"] = allocation_strategy
            if block_duration_minutes is not None:
                self._values["block_duration_minutes"] = block_duration_minutes

        @builtins.property
        def timeout_action(self) -> "EmrCreateCluster.SpotTimeoutAction":
            '''(experimental) The action to take when TargetSpotCapacity has not been fulfilled when the TimeoutDurationMinutes has expired.

            :stability: experimental
            '''
            result = self._values.get("timeout_action")
            assert result is not None, "Required property 'timeout_action' is missing"
            return typing.cast("EmrCreateCluster.SpotTimeoutAction", result)

        @builtins.property
        def timeout_duration_minutes(self) -> jsii.Number:
            '''(experimental) The spot provisioning timeout period in minutes.

            :stability: experimental
            '''
            result = self._values.get("timeout_duration_minutes")
            assert result is not None, "Required property 'timeout_duration_minutes' is missing"
            return typing.cast(jsii.Number, result)

        @builtins.property
        def allocation_strategy(
            self,
        ) -> typing.Optional["EmrCreateCluster.SpotAllocationStrategy"]:
            '''(experimental) Specifies the strategy to use in launching Spot Instance fleets.

            :default: - No allocation strategy, i.e. spot instance type will be chosen based on current price only

            :stability: experimental
            '''
            result = self._values.get("allocation_strategy")
            return typing.cast(typing.Optional["EmrCreateCluster.SpotAllocationStrategy"], result)

        @builtins.property
        def block_duration_minutes(self) -> typing.Optional[jsii.Number]:
            '''(experimental) The defined duration for Spot instances (also known as Spot blocks) in minutes.

            :default: - No blockDurationMinutes

            :stability: experimental
            '''
            result = self._values.get("block_duration_minutes")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SpotProvisioningSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.enum(
        jsii_type="monocdk.aws_stepfunctions_tasks.EmrCreateCluster.SpotTimeoutAction"
    )
    class SpotTimeoutAction(enum.Enum):
        '''(experimental) Spot Timeout Actions.

        :stability: experimental
        '''

        SWITCH_TO_ON_DEMAND = "SWITCH_TO_ON_DEMAND"
        '''(experimental) SWITCH_TO_ON_DEMAND.

        :stability: experimental
        '''
        TERMINATE_CLUSTER = "TERMINATE_CLUSTER"
        '''(experimental) TERMINATE_CLUSTER.

        :stability: experimental
        '''

    @jsii.data_type(
        jsii_type="monocdk.aws_stepfunctions_tasks.EmrCreateCluster.VolumeSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "volume_size": "volumeSize",
            "volume_type": "volumeType",
            "iops": "iops",
        },
    )
    class VolumeSpecificationProperty:
        def __init__(
            self,
            *,
            volume_size: _Size_7fbd4337,
            volume_type: "EmrCreateCluster.EbsBlockDeviceVolumeType",
            iops: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''(experimental) EBS volume specifications such as volume type, IOPS, and size (GiB) that will be requested for the EBS volume attached to an EC2 instance in the cluster.

            :param volume_size: (experimental) The volume size. If the volume type is EBS-optimized, the minimum value is 10GiB. Maximum size is 1TiB
            :param volume_type: (experimental) The volume type. Volume types supported are gp2, io1, standard.
            :param iops: (experimental) The number of I/O operations per second (IOPS) that the volume supports. Default: - EMR selected default

            :see: https://docs.aws.amazon.com/emr/latest/APIReference/API_VolumeSpecification.html
            :stability: experimental
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                import monocdk as monocdk
                from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
                
                # size: monocdk.Size
                
                volume_specification_property = stepfunctions_tasks.EmrCreateCluster.VolumeSpecificationProperty(
                    volume_size=size,
                    volume_type=stepfunctions_tasks.EmrCreateCluster.EbsBlockDeviceVolumeType.GP2,
                
                    # the properties below are optional
                    iops=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__882ee971e514dfab22a0e25f7b48fd0da754428efa677e83e77ee09f6058a9b8)
                check_type(argname="argument volume_size", value=volume_size, expected_type=type_hints["volume_size"])
                check_type(argname="argument volume_type", value=volume_type, expected_type=type_hints["volume_type"])
                check_type(argname="argument iops", value=iops, expected_type=type_hints["iops"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "volume_size": volume_size,
                "volume_type": volume_type,
            }
            if iops is not None:
                self._values["iops"] = iops

        @builtins.property
        def volume_size(self) -> _Size_7fbd4337:
            '''(experimental) The volume size.

            If the volume type is EBS-optimized, the minimum value is 10GiB.
            Maximum size is 1TiB

            :stability: experimental
            '''
            result = self._values.get("volume_size")
            assert result is not None, "Required property 'volume_size' is missing"
            return typing.cast(_Size_7fbd4337, result)

        @builtins.property
        def volume_type(self) -> "EmrCreateCluster.EbsBlockDeviceVolumeType":
            '''(experimental) The volume type.

            Volume types supported are gp2, io1, standard.

            :stability: experimental
            '''
            result = self._values.get("volume_type")
            assert result is not None, "Required property 'volume_type' is missing"
            return typing.cast("EmrCreateCluster.EbsBlockDeviceVolumeType", result)

        @builtins.property
        def iops(self) -> typing.Optional[jsii.Number]:
            '''(experimental) The number of I/O operations per second (IOPS) that the volume supports.

            :default: - EMR selected default

            :stability: experimental
            '''
            result = self._values.get("iops")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "VolumeSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.EmrCreateClusterProps",
    jsii_struct_bases=[_TaskStateBaseProps_b13f6332],
    name_mapping={
        "comment": "comment",
        "heartbeat": "heartbeat",
        "input_path": "inputPath",
        "integration_pattern": "integrationPattern",
        "output_path": "outputPath",
        "result_path": "resultPath",
        "result_selector": "resultSelector",
        "timeout": "timeout",
        "instances": "instances",
        "name": "name",
        "additional_info": "additionalInfo",
        "applications": "applications",
        "auto_scaling_role": "autoScalingRole",
        "bootstrap_actions": "bootstrapActions",
        "cluster_role": "clusterRole",
        "configurations": "configurations",
        "custom_ami_id": "customAmiId",
        "ebs_root_volume_size": "ebsRootVolumeSize",
        "kerberos_attributes": "kerberosAttributes",
        "log_uri": "logUri",
        "release_label": "releaseLabel",
        "scale_down_behavior": "scaleDownBehavior",
        "security_configuration": "securityConfiguration",
        "service_role": "serviceRole",
        "step_concurrency_level": "stepConcurrencyLevel",
        "tags": "tags",
        "visible_to_all_users": "visibleToAllUsers",
    },
)
class EmrCreateClusterProps(_TaskStateBaseProps_b13f6332):
    def __init__(
        self,
        *,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
        instances: typing.Union[EmrCreateCluster.InstancesConfigProperty, typing.Dict[builtins.str, typing.Any]],
        name: builtins.str,
        additional_info: typing.Optional[builtins.str] = None,
        applications: typing.Optional[typing.Sequence[typing.Union[EmrCreateCluster.ApplicationConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
        auto_scaling_role: typing.Optional[_IRole_59af6f50] = None,
        bootstrap_actions: typing.Optional[typing.Sequence[typing.Union[EmrCreateCluster.BootstrapActionConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
        cluster_role: typing.Optional[_IRole_59af6f50] = None,
        configurations: typing.Optional[typing.Sequence[typing.Union[EmrCreateCluster.ConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
        custom_ami_id: typing.Optional[builtins.str] = None,
        ebs_root_volume_size: typing.Optional[_Size_7fbd4337] = None,
        kerberos_attributes: typing.Optional[typing.Union[EmrCreateCluster.KerberosAttributesProperty, typing.Dict[builtins.str, typing.Any]]] = None,
        log_uri: typing.Optional[builtins.str] = None,
        release_label: typing.Optional[builtins.str] = None,
        scale_down_behavior: typing.Optional[EmrCreateCluster.EmrClusterScaleDownBehavior] = None,
        security_configuration: typing.Optional[builtins.str] = None,
        service_role: typing.Optional[_IRole_59af6f50] = None,
        step_concurrency_level: typing.Optional[jsii.Number] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        visible_to_all_users: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''(experimental) Properties for EmrCreateCluster.

        See the RunJobFlow API for complete documentation on input parameters

        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None
        :param instances: (experimental) A specification of the number and type of Amazon EC2 instances.
        :param name: (experimental) The Name of the Cluster.
        :param additional_info: (experimental) A JSON string for selecting additional features. Default: - None
        :param applications: (experimental) A case-insensitive list of applications for Amazon EMR to install and configure when launching the cluster. Default: - EMR selected default
        :param auto_scaling_role: (experimental) An IAM role for automatic scaling policies. Default: - A role will be created.
        :param bootstrap_actions: (experimental) A list of bootstrap actions to run before Hadoop starts on the cluster nodes. Default: - None
        :param cluster_role: (experimental) Also called instance profile and EC2 role. An IAM role for an EMR cluster. The EC2 instances of the cluster assume this role. This attribute has been renamed from jobFlowRole to clusterRole to align with other ERM/StepFunction integration parameters. Default: - - A Role will be created
        :param configurations: (experimental) The list of configurations supplied for the EMR cluster you are creating. Default: - None
        :param custom_ami_id: (experimental) The ID of a custom Amazon EBS-backed Linux AMI. Default: - None
        :param ebs_root_volume_size: (experimental) The size of the EBS root device volume of the Linux AMI that is used for each EC2 instance. Default: - EMR selected default
        :param kerberos_attributes: (experimental) Attributes for Kerberos configuration when Kerberos authentication is enabled using a security configuration. Default: - None
        :param log_uri: (experimental) The location in Amazon S3 to write the log files of the job flow. Default: - None
        :param release_label: (experimental) The Amazon EMR release label, which determines the version of open-source application packages installed on the cluster. Default: - EMR selected default
        :param scale_down_behavior: (experimental) Specifies the way that individual Amazon EC2 instances terminate when an automatic scale-in activity occurs or an instance group is resized. Default: - EMR selected default
        :param security_configuration: (experimental) The name of a security configuration to apply to the cluster. Default: - None
        :param service_role: (experimental) The IAM role that will be assumed by the Amazon EMR service to access AWS resources on your behalf. Default: - A role will be created that Amazon EMR service can assume.
        :param step_concurrency_level: (experimental) Specifies the step concurrency level to allow multiple steps to run in parallel. Requires EMR release label 5.28.0 or above. Must be in range [1, 256]. Default: 1 - no step concurrency allowed
        :param tags: (experimental) A list of tags to associate with a cluster and propagate to Amazon EC2 instances. Default: - None
        :param visible_to_all_users: (experimental) A value of true indicates that all IAM users in the AWS account can perform cluster actions if they have the proper IAM policy permissions. Default: true

        :see: https://docs.aws.amazon.com/emr/latest/APIReference/API_RunJobFlow.html
        :stability: experimental
        :exampleMetadata: infused

        Example::

            cluster_role = iam.Role(self, "ClusterRole",
                assumed_by=iam.ServicePrincipal("ec2.amazonaws.com")
            )
            
            service_role = iam.Role(self, "ServiceRole",
                assumed_by=iam.ServicePrincipal("elasticmapreduce.amazonaws.com")
            )
            
            auto_scaling_role = iam.Role(self, "AutoScalingRole",
                assumed_by=iam.ServicePrincipal("elasticmapreduce.amazonaws.com")
            )
            
            auto_scaling_role.assume_role_policy.add_statements(
                iam.PolicyStatement(
                    effect=iam.Effect.ALLOW,
                    principals=[
                        iam.ServicePrincipal("application-autoscaling.amazonaws.com")
                    ],
                    actions=["sts:AssumeRole"
                    ]
                ))
            
            tasks.EmrCreateCluster(self, "Create Cluster",
                instances=dynamodb.aws_stepfunctions_tasks.EmrCreateCluster.InstancesConfigProperty(),
                cluster_role=cluster_role,
                name=sfn.TaskInput.from_json_path_at("$.ClusterName").value,
                service_role=service_role,
                auto_scaling_role=auto_scaling_role
            )
        '''
        if isinstance(instances, dict):
            instances = EmrCreateCluster.InstancesConfigProperty(**instances)
        if isinstance(kerberos_attributes, dict):
            kerberos_attributes = EmrCreateCluster.KerberosAttributesProperty(**kerberos_attributes)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__47d2a570fa281111b9865f9f17b142e67e413dbd739cbde770ed607bef4e053f)
            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
            check_type(argname="argument heartbeat", value=heartbeat, expected_type=type_hints["heartbeat"])
            check_type(argname="argument input_path", value=input_path, expected_type=type_hints["input_path"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
            check_type(argname="argument output_path", value=output_path, expected_type=type_hints["output_path"])
            check_type(argname="argument result_path", value=result_path, expected_type=type_hints["result_path"])
            check_type(argname="argument result_selector", value=result_selector, expected_type=type_hints["result_selector"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
            check_type(argname="argument instances", value=instances, expected_type=type_hints["instances"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument additional_info", value=additional_info, expected_type=type_hints["additional_info"])
            check_type(argname="argument applications", value=applications, expected_type=type_hints["applications"])
            check_type(argname="argument auto_scaling_role", value=auto_scaling_role, expected_type=type_hints["auto_scaling_role"])
            check_type(argname="argument bootstrap_actions", value=bootstrap_actions, expected_type=type_hints["bootstrap_actions"])
            check_type(argname="argument cluster_role", value=cluster_role, expected_type=type_hints["cluster_role"])
            check_type(argname="argument configurations", value=configurations, expected_type=type_hints["configurations"])
            check_type(argname="argument custom_ami_id", value=custom_ami_id, expected_type=type_hints["custom_ami_id"])
            check_type(argname="argument ebs_root_volume_size", value=ebs_root_volume_size, expected_type=type_hints["ebs_root_volume_size"])
            check_type(argname="argument kerberos_attributes", value=kerberos_attributes, expected_type=type_hints["kerberos_attributes"])
            check_type(argname="argument log_uri", value=log_uri, expected_type=type_hints["log_uri"])
            check_type(argname="argument release_label", value=release_label, expected_type=type_hints["release_label"])
            check_type(argname="argument scale_down_behavior", value=scale_down_behavior, expected_type=type_hints["scale_down_behavior"])
            check_type(argname="argument security_configuration", value=security_configuration, expected_type=type_hints["security_configuration"])
            check_type(argname="argument service_role", value=service_role, expected_type=type_hints["service_role"])
            check_type(argname="argument step_concurrency_level", value=step_concurrency_level, expected_type=type_hints["step_concurrency_level"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument visible_to_all_users", value=visible_to_all_users, expected_type=type_hints["visible_to_all_users"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "instances": instances,
            "name": name,
        }
        if comment is not None:
            self._values["comment"] = comment
        if heartbeat is not None:
            self._values["heartbeat"] = heartbeat
        if input_path is not None:
            self._values["input_path"] = input_path
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern
        if output_path is not None:
            self._values["output_path"] = output_path
        if result_path is not None:
            self._values["result_path"] = result_path
        if result_selector is not None:
            self._values["result_selector"] = result_selector
        if timeout is not None:
            self._values["timeout"] = timeout
        if additional_info is not None:
            self._values["additional_info"] = additional_info
        if applications is not None:
            self._values["applications"] = applications
        if auto_scaling_role is not None:
            self._values["auto_scaling_role"] = auto_scaling_role
        if bootstrap_actions is not None:
            self._values["bootstrap_actions"] = bootstrap_actions
        if cluster_role is not None:
            self._values["cluster_role"] = cluster_role
        if configurations is not None:
            self._values["configurations"] = configurations
        if custom_ami_id is not None:
            self._values["custom_ami_id"] = custom_ami_id
        if ebs_root_volume_size is not None:
            self._values["ebs_root_volume_size"] = ebs_root_volume_size
        if kerberos_attributes is not None:
            self._values["kerberos_attributes"] = kerberos_attributes
        if log_uri is not None:
            self._values["log_uri"] = log_uri
        if release_label is not None:
            self._values["release_label"] = release_label
        if scale_down_behavior is not None:
            self._values["scale_down_behavior"] = scale_down_behavior
        if security_configuration is not None:
            self._values["security_configuration"] = security_configuration
        if service_role is not None:
            self._values["service_role"] = service_role
        if step_concurrency_level is not None:
            self._values["step_concurrency_level"] = step_concurrency_level
        if tags is not None:
            self._values["tags"] = tags
        if visible_to_all_users is not None:
            self._values["visible_to_all_users"] = visible_to_all_users

    @builtins.property
    def comment(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional description for this state.

        :default: - No comment

        :stability: experimental
        '''
        result = self._values.get("comment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def heartbeat(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the heartbeat.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("heartbeat")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def input_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select part of the state to be the input to this state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        input to be the empty object {}.

        :default: - The entire task input (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("input_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def integration_pattern(self) -> typing.Optional[_IntegrationPattern_fbb35786]:
        '''(experimental) AWS Step Functions integrates with services directly in the Amazon States Language.

        You can control these AWS services using service integration patterns

        :default:

        - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks.
        ``IntegrationPattern.RUN_JOB`` for the following exceptions:
        ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html#connect-wait-token
        :stability: experimental
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_IntegrationPattern_fbb35786], result)

    @builtins.property
    def output_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select select a portion of the state output to pass to the next state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        output to be the empty object {}.

        :default:

        - The entire JSON node determined by the state input, the task result,
        and resultPath is passed to the next state (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("output_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to indicate where to inject the state's output.

        May also be the special value JsonPath.DISCARD, which will cause the state's
        input to become its output.

        :default: - Replaces the entire input with the result (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("result_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied.

        You can use ResultSelector to create a payload with values that are static
        or selected from the state's raw result.

        :default: - None

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/input-output-inputpath-params.html#input-output-resultselector
        :stability: experimental
        '''
        result = self._values.get("result_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def timeout(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the state machine.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def instances(self) -> EmrCreateCluster.InstancesConfigProperty:
        '''(experimental) A specification of the number and type of Amazon EC2 instances.

        :stability: experimental
        '''
        result = self._values.get("instances")
        assert result is not None, "Required property 'instances' is missing"
        return typing.cast(EmrCreateCluster.InstancesConfigProperty, result)

    @builtins.property
    def name(self) -> builtins.str:
        '''(experimental) The Name of the Cluster.

        :stability: experimental
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def additional_info(self) -> typing.Optional[builtins.str]:
        '''(experimental) A JSON string for selecting additional features.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("additional_info")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def applications(
        self,
    ) -> typing.Optional[typing.List[EmrCreateCluster.ApplicationConfigProperty]]:
        '''(experimental) A case-insensitive list of applications for Amazon EMR to install and configure when launching the cluster.

        :default: - EMR selected default

        :stability: experimental
        '''
        result = self._values.get("applications")
        return typing.cast(typing.Optional[typing.List[EmrCreateCluster.ApplicationConfigProperty]], result)

    @builtins.property
    def auto_scaling_role(self) -> typing.Optional[_IRole_59af6f50]:
        '''(experimental) An IAM role for automatic scaling policies.

        :default: - A role will be created.

        :stability: experimental
        '''
        result = self._values.get("auto_scaling_role")
        return typing.cast(typing.Optional[_IRole_59af6f50], result)

    @builtins.property
    def bootstrap_actions(
        self,
    ) -> typing.Optional[typing.List[EmrCreateCluster.BootstrapActionConfigProperty]]:
        '''(experimental) A list of bootstrap actions to run before Hadoop starts on the cluster nodes.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("bootstrap_actions")
        return typing.cast(typing.Optional[typing.List[EmrCreateCluster.BootstrapActionConfigProperty]], result)

    @builtins.property
    def cluster_role(self) -> typing.Optional[_IRole_59af6f50]:
        '''(experimental) Also called instance profile and EC2 role.

        An IAM role for an EMR cluster. The EC2 instances of the cluster assume this role.

        This attribute has been renamed from jobFlowRole to clusterRole to align with other ERM/StepFunction integration parameters.

        :default:

        -
        - A Role will be created

        :stability: experimental
        '''
        result = self._values.get("cluster_role")
        return typing.cast(typing.Optional[_IRole_59af6f50], result)

    @builtins.property
    def configurations(
        self,
    ) -> typing.Optional[typing.List[EmrCreateCluster.ConfigurationProperty]]:
        '''(experimental) The list of configurations supplied for the EMR cluster you are creating.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("configurations")
        return typing.cast(typing.Optional[typing.List[EmrCreateCluster.ConfigurationProperty]], result)

    @builtins.property
    def custom_ami_id(self) -> typing.Optional[builtins.str]:
        '''(experimental) The ID of a custom Amazon EBS-backed Linux AMI.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("custom_ami_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ebs_root_volume_size(self) -> typing.Optional[_Size_7fbd4337]:
        '''(experimental) The size of the EBS root device volume of the Linux AMI that is used for each EC2 instance.

        :default: - EMR selected default

        :stability: experimental
        '''
        result = self._values.get("ebs_root_volume_size")
        return typing.cast(typing.Optional[_Size_7fbd4337], result)

    @builtins.property
    def kerberos_attributes(
        self,
    ) -> typing.Optional[EmrCreateCluster.KerberosAttributesProperty]:
        '''(experimental) Attributes for Kerberos configuration when Kerberos authentication is enabled using a security configuration.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("kerberos_attributes")
        return typing.cast(typing.Optional[EmrCreateCluster.KerberosAttributesProperty], result)

    @builtins.property
    def log_uri(self) -> typing.Optional[builtins.str]:
        '''(experimental) The location in Amazon S3 to write the log files of the job flow.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("log_uri")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def release_label(self) -> typing.Optional[builtins.str]:
        '''(experimental) The Amazon EMR release label, which determines the version of open-source application packages installed on the cluster.

        :default: - EMR selected default

        :stability: experimental
        '''
        result = self._values.get("release_label")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scale_down_behavior(
        self,
    ) -> typing.Optional[EmrCreateCluster.EmrClusterScaleDownBehavior]:
        '''(experimental) Specifies the way that individual Amazon EC2 instances terminate when an automatic scale-in activity occurs or an instance group is resized.

        :default: - EMR selected default

        :stability: experimental
        '''
        result = self._values.get("scale_down_behavior")
        return typing.cast(typing.Optional[EmrCreateCluster.EmrClusterScaleDownBehavior], result)

    @builtins.property
    def security_configuration(self) -> typing.Optional[builtins.str]:
        '''(experimental) The name of a security configuration to apply to the cluster.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("security_configuration")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def service_role(self) -> typing.Optional[_IRole_59af6f50]:
        '''(experimental) The IAM role that will be assumed by the Amazon EMR service to access AWS resources on your behalf.

        :default: - A role will be created that Amazon EMR service can assume.

        :stability: experimental
        '''
        result = self._values.get("service_role")
        return typing.cast(typing.Optional[_IRole_59af6f50], result)

    @builtins.property
    def step_concurrency_level(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies the step concurrency level to allow multiple steps to run in parallel.

        Requires EMR release label 5.28.0 or above.
        Must be in range [1, 256].

        :default: 1 - no step concurrency allowed

        :stability: experimental
        '''
        result = self._values.get("step_concurrency_level")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''(experimental) A list of tags to associate with a cluster and propagate to Amazon EC2 instances.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def visible_to_all_users(self) -> typing.Optional[builtins.bool]:
        '''(experimental) A value of true indicates that all IAM users in the AWS account can perform cluster actions if they have the proper IAM policy permissions.

        :default: true

        :stability: experimental
        '''
        result = self._values.get("visible_to_all_users")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EmrCreateClusterProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class EmrModifyInstanceFleetByName(
    _TaskStateBase_c3080646,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.EmrModifyInstanceFleetByName",
):
    '''(experimental) A Step Functions Task to to modify an InstanceFleet on an EMR Cluster.

    :stability: experimental
    :exampleMetadata: infused

    Example::

        tasks.EmrModifyInstanceFleetByName(self, "Task",
            cluster_id="ClusterId",
            instance_fleet_name="InstanceFleetName",
            target_on_demand_capacity=2,
            target_spot_capacity=0
        )
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        cluster_id: builtins.str,
        instance_fleet_name: builtins.str,
        target_on_demand_capacity: jsii.Number,
        target_spot_capacity: jsii.Number,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param cluster_id: (experimental) The ClusterId to update.
        :param instance_fleet_name: (experimental) The InstanceFleetName to update.
        :param target_on_demand_capacity: (experimental) The target capacity of On-Demand units for the instance fleet. Default: - None
        :param target_spot_capacity: (experimental) The target capacity of Spot units for the instance fleet. Default: - None
        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7c19490a585b5bd6c60eaa3531c62dc463fbf43407480a70f5a523a1652ed523)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = EmrModifyInstanceFleetByNameProps(
            cluster_id=cluster_id,
            instance_fleet_name=instance_fleet_name,
            target_on_demand_capacity=target_on_demand_capacity,
            target_spot_capacity=target_spot_capacity,
            comment=comment,
            heartbeat=heartbeat,
            input_path=input_path,
            integration_pattern=integration_pattern,
            output_path=output_path,
            result_path=result_path,
            result_selector=result_selector,
            timeout=timeout,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="taskMetrics")
    def _task_metrics(self) -> typing.Optional[_TaskMetricsConfig_5aaea59e]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[_TaskMetricsConfig_5aaea59e], jsii.get(self, "taskMetrics"))

    @builtins.property
    @jsii.member(jsii_name="taskPolicies")
    def _task_policies(self) -> typing.Optional[typing.List[_PolicyStatement_296fe8a3]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.List[_PolicyStatement_296fe8a3]], jsii.get(self, "taskPolicies"))


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.EmrModifyInstanceFleetByNameProps",
    jsii_struct_bases=[_TaskStateBaseProps_b13f6332],
    name_mapping={
        "comment": "comment",
        "heartbeat": "heartbeat",
        "input_path": "inputPath",
        "integration_pattern": "integrationPattern",
        "output_path": "outputPath",
        "result_path": "resultPath",
        "result_selector": "resultSelector",
        "timeout": "timeout",
        "cluster_id": "clusterId",
        "instance_fleet_name": "instanceFleetName",
        "target_on_demand_capacity": "targetOnDemandCapacity",
        "target_spot_capacity": "targetSpotCapacity",
    },
)
class EmrModifyInstanceFleetByNameProps(_TaskStateBaseProps_b13f6332):
    def __init__(
        self,
        *,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
        cluster_id: builtins.str,
        instance_fleet_name: builtins.str,
        target_on_demand_capacity: jsii.Number,
        target_spot_capacity: jsii.Number,
    ) -> None:
        '''(experimental) Properties for EmrModifyInstanceFleetByName.

        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None
        :param cluster_id: (experimental) The ClusterId to update.
        :param instance_fleet_name: (experimental) The InstanceFleetName to update.
        :param target_on_demand_capacity: (experimental) The target capacity of On-Demand units for the instance fleet. Default: - None
        :param target_spot_capacity: (experimental) The target capacity of Spot units for the instance fleet. Default: - None

        :stability: experimental
        :exampleMetadata: infused

        Example::

            tasks.EmrModifyInstanceFleetByName(self, "Task",
                cluster_id="ClusterId",
                instance_fleet_name="InstanceFleetName",
                target_on_demand_capacity=2,
                target_spot_capacity=0
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4aa4d71be75f4ce06916577b5289c209591a1254666ba08edaeb593b04f97ef6)
            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
            check_type(argname="argument heartbeat", value=heartbeat, expected_type=type_hints["heartbeat"])
            check_type(argname="argument input_path", value=input_path, expected_type=type_hints["input_path"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
            check_type(argname="argument output_path", value=output_path, expected_type=type_hints["output_path"])
            check_type(argname="argument result_path", value=result_path, expected_type=type_hints["result_path"])
            check_type(argname="argument result_selector", value=result_selector, expected_type=type_hints["result_selector"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
            check_type(argname="argument cluster_id", value=cluster_id, expected_type=type_hints["cluster_id"])
            check_type(argname="argument instance_fleet_name", value=instance_fleet_name, expected_type=type_hints["instance_fleet_name"])
            check_type(argname="argument target_on_demand_capacity", value=target_on_demand_capacity, expected_type=type_hints["target_on_demand_capacity"])
            check_type(argname="argument target_spot_capacity", value=target_spot_capacity, expected_type=type_hints["target_spot_capacity"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "cluster_id": cluster_id,
            "instance_fleet_name": instance_fleet_name,
            "target_on_demand_capacity": target_on_demand_capacity,
            "target_spot_capacity": target_spot_capacity,
        }
        if comment is not None:
            self._values["comment"] = comment
        if heartbeat is not None:
            self._values["heartbeat"] = heartbeat
        if input_path is not None:
            self._values["input_path"] = input_path
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern
        if output_path is not None:
            self._values["output_path"] = output_path
        if result_path is not None:
            self._values["result_path"] = result_path
        if result_selector is not None:
            self._values["result_selector"] = result_selector
        if timeout is not None:
            self._values["timeout"] = timeout

    @builtins.property
    def comment(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional description for this state.

        :default: - No comment

        :stability: experimental
        '''
        result = self._values.get("comment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def heartbeat(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the heartbeat.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("heartbeat")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def input_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select part of the state to be the input to this state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        input to be the empty object {}.

        :default: - The entire task input (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("input_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def integration_pattern(self) -> typing.Optional[_IntegrationPattern_fbb35786]:
        '''(experimental) AWS Step Functions integrates with services directly in the Amazon States Language.

        You can control these AWS services using service integration patterns

        :default:

        - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks.
        ``IntegrationPattern.RUN_JOB`` for the following exceptions:
        ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html#connect-wait-token
        :stability: experimental
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_IntegrationPattern_fbb35786], result)

    @builtins.property
    def output_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select select a portion of the state output to pass to the next state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        output to be the empty object {}.

        :default:

        - The entire JSON node determined by the state input, the task result,
        and resultPath is passed to the next state (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("output_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to indicate where to inject the state's output.

        May also be the special value JsonPath.DISCARD, which will cause the state's
        input to become its output.

        :default: - Replaces the entire input with the result (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("result_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied.

        You can use ResultSelector to create a payload with values that are static
        or selected from the state's raw result.

        :default: - None

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/input-output-inputpath-params.html#input-output-resultselector
        :stability: experimental
        '''
        result = self._values.get("result_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def timeout(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the state machine.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def cluster_id(self) -> builtins.str:
        '''(experimental) The ClusterId to update.

        :stability: experimental
        '''
        result = self._values.get("cluster_id")
        assert result is not None, "Required property 'cluster_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def instance_fleet_name(self) -> builtins.str:
        '''(experimental) The InstanceFleetName to update.

        :stability: experimental
        '''
        result = self._values.get("instance_fleet_name")
        assert result is not None, "Required property 'instance_fleet_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def target_on_demand_capacity(self) -> jsii.Number:
        '''(experimental) The target capacity of On-Demand units for the instance fleet.

        :default: - None

        :see: https://docs.aws.amazon.com/emr/latest/APIReference/API_InstanceFleetModifyConfig.html
        :stability: experimental
        '''
        result = self._values.get("target_on_demand_capacity")
        assert result is not None, "Required property 'target_on_demand_capacity' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def target_spot_capacity(self) -> jsii.Number:
        '''(experimental) The target capacity of Spot units for the instance fleet.

        :default: - None

        :see: https://docs.aws.amazon.com/emr/latest/APIReference/API_InstanceFleetModifyConfig.html
        :stability: experimental
        '''
        result = self._values.get("target_spot_capacity")
        assert result is not None, "Required property 'target_spot_capacity' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EmrModifyInstanceFleetByNameProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class EmrModifyInstanceGroupByName(
    _TaskStateBase_c3080646,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.EmrModifyInstanceGroupByName",
):
    '''(experimental) A Step Functions Task to to modify an InstanceGroup on an EMR Cluster.

    :stability: experimental
    :exampleMetadata: infused

    Example::

        tasks.EmrModifyInstanceGroupByName(self, "Task",
            cluster_id="ClusterId",
            instance_group_name=sfn.JsonPath.string_at("$.InstanceGroupName"),
            instance_group=dynamodb.aws_stepfunctions_tasks.EmrModifyInstanceGroupByName.InstanceGroupModifyConfigProperty(
                instance_count=1
            )
        )
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        cluster_id: builtins.str,
        instance_group: typing.Union["EmrModifyInstanceGroupByName.InstanceGroupModifyConfigProperty", typing.Dict[builtins.str, typing.Any]],
        instance_group_name: builtins.str,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param cluster_id: (experimental) The ClusterId to update.
        :param instance_group: (experimental) The JSON that you want to provide to your ModifyInstanceGroup call as input. This uses the same syntax as the ModifyInstanceGroups API.
        :param instance_group_name: (experimental) The InstanceGroupName to update.
        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d4fa925d38c3a36e7cad8cc214aa3bac12a0116b0f43a5c9325049aa25412acf)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = EmrModifyInstanceGroupByNameProps(
            cluster_id=cluster_id,
            instance_group=instance_group,
            instance_group_name=instance_group_name,
            comment=comment,
            heartbeat=heartbeat,
            input_path=input_path,
            integration_pattern=integration_pattern,
            output_path=output_path,
            result_path=result_path,
            result_selector=result_selector,
            timeout=timeout,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="taskMetrics")
    def _task_metrics(self) -> typing.Optional[_TaskMetricsConfig_5aaea59e]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[_TaskMetricsConfig_5aaea59e], jsii.get(self, "taskMetrics"))

    @builtins.property
    @jsii.member(jsii_name="taskPolicies")
    def _task_policies(self) -> typing.Optional[typing.List[_PolicyStatement_296fe8a3]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.List[_PolicyStatement_296fe8a3]], jsii.get(self, "taskPolicies"))

    @jsii.data_type(
        jsii_type="monocdk.aws_stepfunctions_tasks.EmrModifyInstanceGroupByName.InstanceGroupModifyConfigProperty",
        jsii_struct_bases=[],
        name_mapping={
            "configurations": "configurations",
            "e_c2_instance_ids_to_terminate": "eC2InstanceIdsToTerminate",
            "instance_count": "instanceCount",
            "shrink_policy": "shrinkPolicy",
        },
    )
    class InstanceGroupModifyConfigProperty:
        def __init__(
            self,
            *,
            configurations: typing.Optional[typing.Sequence[typing.Union[EmrCreateCluster.ConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
            e_c2_instance_ids_to_terminate: typing.Optional[typing.Sequence[builtins.str]] = None,
            instance_count: typing.Optional[jsii.Number] = None,
            shrink_policy: typing.Optional[typing.Union["EmrModifyInstanceGroupByName.ShrinkPolicyProperty", typing.Dict[builtins.str, typing.Any]]] = None,
        ) -> None:
            '''(experimental) Modify the size or configurations of an instance group.

            :param configurations: (experimental) A list of new or modified configurations to apply for an instance group. Default: - None
            :param e_c2_instance_ids_to_terminate: (experimental) The EC2 InstanceIds to terminate. After you terminate the instances, the instance group will not return to its original requested size. Default: - None
            :param instance_count: (experimental) Target size for the instance group. Default: - None
            :param shrink_policy: (experimental) Policy for customizing shrink operations. Default: - None

            :see: https://docs.aws.amazon.com/emr/latest/APIReference/API_InstanceGroupModifyConfig.html
            :stability: experimental
            :exampleMetadata: infused

            Example::

                tasks.EmrModifyInstanceGroupByName(self, "Task",
                    cluster_id="ClusterId",
                    instance_group_name=sfn.JsonPath.string_at("$.InstanceGroupName"),
                    instance_group=dynamodb.aws_stepfunctions_tasks.EmrModifyInstanceGroupByName.InstanceGroupModifyConfigProperty(
                        instance_count=1
                    )
                )
            '''
            if isinstance(shrink_policy, dict):
                shrink_policy = EmrModifyInstanceGroupByName.ShrinkPolicyProperty(**shrink_policy)
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__00aac5b2e54eccc7c1203ab57db517bb4650f378508b680c827966ea755027c2)
                check_type(argname="argument configurations", value=configurations, expected_type=type_hints["configurations"])
                check_type(argname="argument e_c2_instance_ids_to_terminate", value=e_c2_instance_ids_to_terminate, expected_type=type_hints["e_c2_instance_ids_to_terminate"])
                check_type(argname="argument instance_count", value=instance_count, expected_type=type_hints["instance_count"])
                check_type(argname="argument shrink_policy", value=shrink_policy, expected_type=type_hints["shrink_policy"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if configurations is not None:
                self._values["configurations"] = configurations
            if e_c2_instance_ids_to_terminate is not None:
                self._values["e_c2_instance_ids_to_terminate"] = e_c2_instance_ids_to_terminate
            if instance_count is not None:
                self._values["instance_count"] = instance_count
            if shrink_policy is not None:
                self._values["shrink_policy"] = shrink_policy

        @builtins.property
        def configurations(
            self,
        ) -> typing.Optional[typing.List[EmrCreateCluster.ConfigurationProperty]]:
            '''(experimental) A list of new or modified configurations to apply for an instance group.

            :default: - None

            :stability: experimental
            '''
            result = self._values.get("configurations")
            return typing.cast(typing.Optional[typing.List[EmrCreateCluster.ConfigurationProperty]], result)

        @builtins.property
        def e_c2_instance_ids_to_terminate(
            self,
        ) -> typing.Optional[typing.List[builtins.str]]:
            '''(experimental) The EC2 InstanceIds to terminate.

            After you terminate the instances, the instance group will not return to its original requested size.

            :default: - None

            :stability: experimental
            '''
            result = self._values.get("e_c2_instance_ids_to_terminate")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def instance_count(self) -> typing.Optional[jsii.Number]:
            '''(experimental) Target size for the instance group.

            :default: - None

            :stability: experimental
            '''
            result = self._values.get("instance_count")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def shrink_policy(
            self,
        ) -> typing.Optional["EmrModifyInstanceGroupByName.ShrinkPolicyProperty"]:
            '''(experimental) Policy for customizing shrink operations.

            :default: - None

            :see: https://docs.aws.amazon.com/emr/latest/APIReference/API_ShrinkPolicy.html
            :stability: experimental
            '''
            result = self._values.get("shrink_policy")
            return typing.cast(typing.Optional["EmrModifyInstanceGroupByName.ShrinkPolicyProperty"], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "InstanceGroupModifyConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="monocdk.aws_stepfunctions_tasks.EmrModifyInstanceGroupByName.InstanceResizePolicyProperty",
        jsii_struct_bases=[],
        name_mapping={
            "instances_to_protect": "instancesToProtect",
            "instances_to_terminate": "instancesToTerminate",
            "instance_termination_timeout": "instanceTerminationTimeout",
        },
    )
    class InstanceResizePolicyProperty:
        def __init__(
            self,
            *,
            instances_to_protect: typing.Optional[typing.Sequence[builtins.str]] = None,
            instances_to_terminate: typing.Optional[typing.Sequence[builtins.str]] = None,
            instance_termination_timeout: typing.Optional[_Duration_070aa057] = None,
        ) -> None:
            '''(experimental) Custom policy for requesting termination protection or termination of specific instances when shrinking an instance group.

            :param instances_to_protect: (experimental) Specific list of instances to be protected when shrinking an instance group. Default: - No instances will be protected when shrinking an instance group
            :param instances_to_terminate: (experimental) Specific list of instances to be terminated when shrinking an instance group. Default: - No instances will be terminated when shrinking an instance group.
            :param instance_termination_timeout: (experimental) Decommissioning timeout override for the specific list of instances to be terminated. Default: cdk.Duration.seconds

            :see: https://docs.aws.amazon.com/emr/latest/APIReference/API_InstanceResizePolicy.html
            :stability: experimental
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                import monocdk as monocdk
                from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
                
                # duration: monocdk.Duration
                
                instance_resize_policy_property = stepfunctions_tasks.EmrModifyInstanceGroupByName.InstanceResizePolicyProperty(
                    instances_to_protect=["instancesToProtect"],
                    instances_to_terminate=["instancesToTerminate"],
                    instance_termination_timeout=duration
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__528a6388a1fb63dcb58017ebf85c190eef9b1860e9efd59a6994028a620bcdd9)
                check_type(argname="argument instances_to_protect", value=instances_to_protect, expected_type=type_hints["instances_to_protect"])
                check_type(argname="argument instances_to_terminate", value=instances_to_terminate, expected_type=type_hints["instances_to_terminate"])
                check_type(argname="argument instance_termination_timeout", value=instance_termination_timeout, expected_type=type_hints["instance_termination_timeout"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if instances_to_protect is not None:
                self._values["instances_to_protect"] = instances_to_protect
            if instances_to_terminate is not None:
                self._values["instances_to_terminate"] = instances_to_terminate
            if instance_termination_timeout is not None:
                self._values["instance_termination_timeout"] = instance_termination_timeout

        @builtins.property
        def instances_to_protect(self) -> typing.Optional[typing.List[builtins.str]]:
            '''(experimental) Specific list of instances to be protected when shrinking an instance group.

            :default: - No instances will be protected when shrinking an instance group

            :stability: experimental
            '''
            result = self._values.get("instances_to_protect")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def instances_to_terminate(self) -> typing.Optional[typing.List[builtins.str]]:
            '''(experimental) Specific list of instances to be terminated when shrinking an instance group.

            :default: - No instances will be terminated when shrinking an instance group.

            :stability: experimental
            '''
            result = self._values.get("instances_to_terminate")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def instance_termination_timeout(self) -> typing.Optional[_Duration_070aa057]:
            '''(experimental) Decommissioning timeout override for the specific list of instances to be terminated.

            :default: cdk.Duration.seconds

            :stability: experimental
            '''
            result = self._values.get("instance_termination_timeout")
            return typing.cast(typing.Optional[_Duration_070aa057], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "InstanceResizePolicyProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="monocdk.aws_stepfunctions_tasks.EmrModifyInstanceGroupByName.ShrinkPolicyProperty",
        jsii_struct_bases=[],
        name_mapping={
            "decommission_timeout": "decommissionTimeout",
            "instance_resize_policy": "instanceResizePolicy",
        },
    )
    class ShrinkPolicyProperty:
        def __init__(
            self,
            *,
            decommission_timeout: typing.Optional[_Duration_070aa057] = None,
            instance_resize_policy: typing.Optional[typing.Union["EmrModifyInstanceGroupByName.InstanceResizePolicyProperty", typing.Dict[builtins.str, typing.Any]]] = None,
        ) -> None:
            '''(experimental) Policy for customizing shrink operations.

            Allows configuration of decommissioning timeout and targeted instance shrinking.

            :param decommission_timeout: (experimental) The desired timeout for decommissioning an instance. Overrides the default YARN decommissioning timeout. Default: - EMR selected default
            :param instance_resize_policy: (experimental) Custom policy for requesting termination protection or termination of specific instances when shrinking an instance group. Default: - None

            :see: https://docs.aws.amazon.com/emr/latest/APIReference/API_ShrinkPolicy.html
            :stability: experimental
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                import monocdk as monocdk
                from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
                
                # duration: monocdk.Duration
                
                shrink_policy_property = stepfunctions_tasks.EmrModifyInstanceGroupByName.ShrinkPolicyProperty(
                    decommission_timeout=duration,
                    instance_resize_policy=stepfunctions_tasks.EmrModifyInstanceGroupByName.InstanceResizePolicyProperty(
                        instances_to_protect=["instancesToProtect"],
                        instances_to_terminate=["instancesToTerminate"],
                        instance_termination_timeout=duration
                    )
                )
            '''
            if isinstance(instance_resize_policy, dict):
                instance_resize_policy = EmrModifyInstanceGroupByName.InstanceResizePolicyProperty(**instance_resize_policy)
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__47047e7e0c8fbb6046fbd53ef5e2767c497fc959a4fd9f467fe6a2847bd3bd8a)
                check_type(argname="argument decommission_timeout", value=decommission_timeout, expected_type=type_hints["decommission_timeout"])
                check_type(argname="argument instance_resize_policy", value=instance_resize_policy, expected_type=type_hints["instance_resize_policy"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if decommission_timeout is not None:
                self._values["decommission_timeout"] = decommission_timeout
            if instance_resize_policy is not None:
                self._values["instance_resize_policy"] = instance_resize_policy

        @builtins.property
        def decommission_timeout(self) -> typing.Optional[_Duration_070aa057]:
            '''(experimental) The desired timeout for decommissioning an instance.

            Overrides the default YARN decommissioning timeout.

            :default: - EMR selected default

            :stability: experimental
            '''
            result = self._values.get("decommission_timeout")
            return typing.cast(typing.Optional[_Duration_070aa057], result)

        @builtins.property
        def instance_resize_policy(
            self,
        ) -> typing.Optional["EmrModifyInstanceGroupByName.InstanceResizePolicyProperty"]:
            '''(experimental) Custom policy for requesting termination protection or termination of specific instances when shrinking an instance group.

            :default: - None

            :stability: experimental
            '''
            result = self._values.get("instance_resize_policy")
            return typing.cast(typing.Optional["EmrModifyInstanceGroupByName.InstanceResizePolicyProperty"], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ShrinkPolicyProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.EmrModifyInstanceGroupByNameProps",
    jsii_struct_bases=[_TaskStateBaseProps_b13f6332],
    name_mapping={
        "comment": "comment",
        "heartbeat": "heartbeat",
        "input_path": "inputPath",
        "integration_pattern": "integrationPattern",
        "output_path": "outputPath",
        "result_path": "resultPath",
        "result_selector": "resultSelector",
        "timeout": "timeout",
        "cluster_id": "clusterId",
        "instance_group": "instanceGroup",
        "instance_group_name": "instanceGroupName",
    },
)
class EmrModifyInstanceGroupByNameProps(_TaskStateBaseProps_b13f6332):
    def __init__(
        self,
        *,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
        cluster_id: builtins.str,
        instance_group: typing.Union[EmrModifyInstanceGroupByName.InstanceGroupModifyConfigProperty, typing.Dict[builtins.str, typing.Any]],
        instance_group_name: builtins.str,
    ) -> None:
        '''(experimental) Properties for EmrModifyInstanceGroupByName.

        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None
        :param cluster_id: (experimental) The ClusterId to update.
        :param instance_group: (experimental) The JSON that you want to provide to your ModifyInstanceGroup call as input. This uses the same syntax as the ModifyInstanceGroups API.
        :param instance_group_name: (experimental) The InstanceGroupName to update.

        :stability: experimental
        :exampleMetadata: infused

        Example::

            tasks.EmrModifyInstanceGroupByName(self, "Task",
                cluster_id="ClusterId",
                instance_group_name=sfn.JsonPath.string_at("$.InstanceGroupName"),
                instance_group=dynamodb.aws_stepfunctions_tasks.EmrModifyInstanceGroupByName.InstanceGroupModifyConfigProperty(
                    instance_count=1
                )
            )
        '''
        if isinstance(instance_group, dict):
            instance_group = EmrModifyInstanceGroupByName.InstanceGroupModifyConfigProperty(**instance_group)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__405350534d121e0eae18960e9cfe1491e6404dcf72eb03f262da62acd14758c4)
            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
            check_type(argname="argument heartbeat", value=heartbeat, expected_type=type_hints["heartbeat"])
            check_type(argname="argument input_path", value=input_path, expected_type=type_hints["input_path"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
            check_type(argname="argument output_path", value=output_path, expected_type=type_hints["output_path"])
            check_type(argname="argument result_path", value=result_path, expected_type=type_hints["result_path"])
            check_type(argname="argument result_selector", value=result_selector, expected_type=type_hints["result_selector"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
            check_type(argname="argument cluster_id", value=cluster_id, expected_type=type_hints["cluster_id"])
            check_type(argname="argument instance_group", value=instance_group, expected_type=type_hints["instance_group"])
            check_type(argname="argument instance_group_name", value=instance_group_name, expected_type=type_hints["instance_group_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "cluster_id": cluster_id,
            "instance_group": instance_group,
            "instance_group_name": instance_group_name,
        }
        if comment is not None:
            self._values["comment"] = comment
        if heartbeat is not None:
            self._values["heartbeat"] = heartbeat
        if input_path is not None:
            self._values["input_path"] = input_path
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern
        if output_path is not None:
            self._values["output_path"] = output_path
        if result_path is not None:
            self._values["result_path"] = result_path
        if result_selector is not None:
            self._values["result_selector"] = result_selector
        if timeout is not None:
            self._values["timeout"] = timeout

    @builtins.property
    def comment(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional description for this state.

        :default: - No comment

        :stability: experimental
        '''
        result = self._values.get("comment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def heartbeat(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the heartbeat.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("heartbeat")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def input_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select part of the state to be the input to this state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        input to be the empty object {}.

        :default: - The entire task input (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("input_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def integration_pattern(self) -> typing.Optional[_IntegrationPattern_fbb35786]:
        '''(experimental) AWS Step Functions integrates with services directly in the Amazon States Language.

        You can control these AWS services using service integration patterns

        :default:

        - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks.
        ``IntegrationPattern.RUN_JOB`` for the following exceptions:
        ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html#connect-wait-token
        :stability: experimental
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_IntegrationPattern_fbb35786], result)

    @builtins.property
    def output_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select select a portion of the state output to pass to the next state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        output to be the empty object {}.

        :default:

        - The entire JSON node determined by the state input, the task result,
        and resultPath is passed to the next state (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("output_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to indicate where to inject the state's output.

        May also be the special value JsonPath.DISCARD, which will cause the state's
        input to become its output.

        :default: - Replaces the entire input with the result (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("result_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied.

        You can use ResultSelector to create a payload with values that are static
        or selected from the state's raw result.

        :default: - None

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/input-output-inputpath-params.html#input-output-resultselector
        :stability: experimental
        '''
        result = self._values.get("result_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def timeout(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the state machine.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def cluster_id(self) -> builtins.str:
        '''(experimental) The ClusterId to update.

        :stability: experimental
        '''
        result = self._values.get("cluster_id")
        assert result is not None, "Required property 'cluster_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def instance_group(
        self,
    ) -> EmrModifyInstanceGroupByName.InstanceGroupModifyConfigProperty:
        '''(experimental) The JSON that you want to provide to your ModifyInstanceGroup call as input.

        This uses the same syntax as the ModifyInstanceGroups API.

        :see: https://docs.aws.amazon.com/emr/latest/APIReference/API_ModifyInstanceGroups.html
        :stability: experimental
        '''
        result = self._values.get("instance_group")
        assert result is not None, "Required property 'instance_group' is missing"
        return typing.cast(EmrModifyInstanceGroupByName.InstanceGroupModifyConfigProperty, result)

    @builtins.property
    def instance_group_name(self) -> builtins.str:
        '''(experimental) The InstanceGroupName to update.

        :stability: experimental
        '''
        result = self._values.get("instance_group_name")
        assert result is not None, "Required property 'instance_group_name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EmrModifyInstanceGroupByNameProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class EmrSetClusterTerminationProtection(
    _TaskStateBase_c3080646,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.EmrSetClusterTerminationProtection",
):
    '''(experimental) A Step Functions Task to to set Termination Protection on an EMR Cluster.

    :stability: experimental
    :exampleMetadata: infused

    Example::

        tasks.EmrSetClusterTerminationProtection(self, "Task",
            cluster_id="ClusterId",
            termination_protected=False
        )
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        cluster_id: builtins.str,
        termination_protected: builtins.bool,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param cluster_id: (experimental) The ClusterId to update.
        :param termination_protected: (experimental) Termination protection indicator.
        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__900464b8236509208ce14dca533abcc549a595d074c251d236d77b669b80d8ad)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = EmrSetClusterTerminationProtectionProps(
            cluster_id=cluster_id,
            termination_protected=termination_protected,
            comment=comment,
            heartbeat=heartbeat,
            input_path=input_path,
            integration_pattern=integration_pattern,
            output_path=output_path,
            result_path=result_path,
            result_selector=result_selector,
            timeout=timeout,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="taskMetrics")
    def _task_metrics(self) -> typing.Optional[_TaskMetricsConfig_5aaea59e]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[_TaskMetricsConfig_5aaea59e], jsii.get(self, "taskMetrics"))

    @builtins.property
    @jsii.member(jsii_name="taskPolicies")
    def _task_policies(self) -> typing.Optional[typing.List[_PolicyStatement_296fe8a3]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.List[_PolicyStatement_296fe8a3]], jsii.get(self, "taskPolicies"))


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.EmrSetClusterTerminationProtectionProps",
    jsii_struct_bases=[_TaskStateBaseProps_b13f6332],
    name_mapping={
        "comment": "comment",
        "heartbeat": "heartbeat",
        "input_path": "inputPath",
        "integration_pattern": "integrationPattern",
        "output_path": "outputPath",
        "result_path": "resultPath",
        "result_selector": "resultSelector",
        "timeout": "timeout",
        "cluster_id": "clusterId",
        "termination_protected": "terminationProtected",
    },
)
class EmrSetClusterTerminationProtectionProps(_TaskStateBaseProps_b13f6332):
    def __init__(
        self,
        *,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
        cluster_id: builtins.str,
        termination_protected: builtins.bool,
    ) -> None:
        '''(experimental) Properties for EmrSetClusterTerminationProtection.

        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None
        :param cluster_id: (experimental) The ClusterId to update.
        :param termination_protected: (experimental) Termination protection indicator.

        :stability: experimental
        :exampleMetadata: infused

        Example::

            tasks.EmrSetClusterTerminationProtection(self, "Task",
                cluster_id="ClusterId",
                termination_protected=False
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__100c18ed35eba6ea676971cdfefb76a3bb6dda0c436e5116064070e17dc7d8e7)
            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
            check_type(argname="argument heartbeat", value=heartbeat, expected_type=type_hints["heartbeat"])
            check_type(argname="argument input_path", value=input_path, expected_type=type_hints["input_path"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
            check_type(argname="argument output_path", value=output_path, expected_type=type_hints["output_path"])
            check_type(argname="argument result_path", value=result_path, expected_type=type_hints["result_path"])
            check_type(argname="argument result_selector", value=result_selector, expected_type=type_hints["result_selector"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
            check_type(argname="argument cluster_id", value=cluster_id, expected_type=type_hints["cluster_id"])
            check_type(argname="argument termination_protected", value=termination_protected, expected_type=type_hints["termination_protected"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "cluster_id": cluster_id,
            "termination_protected": termination_protected,
        }
        if comment is not None:
            self._values["comment"] = comment
        if heartbeat is not None:
            self._values["heartbeat"] = heartbeat
        if input_path is not None:
            self._values["input_path"] = input_path
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern
        if output_path is not None:
            self._values["output_path"] = output_path
        if result_path is not None:
            self._values["result_path"] = result_path
        if result_selector is not None:
            self._values["result_selector"] = result_selector
        if timeout is not None:
            self._values["timeout"] = timeout

    @builtins.property
    def comment(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional description for this state.

        :default: - No comment

        :stability: experimental
        '''
        result = self._values.get("comment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def heartbeat(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the heartbeat.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("heartbeat")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def input_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select part of the state to be the input to this state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        input to be the empty object {}.

        :default: - The entire task input (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("input_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def integration_pattern(self) -> typing.Optional[_IntegrationPattern_fbb35786]:
        '''(experimental) AWS Step Functions integrates with services directly in the Amazon States Language.

        You can control these AWS services using service integration patterns

        :default:

        - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks.
        ``IntegrationPattern.RUN_JOB`` for the following exceptions:
        ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html#connect-wait-token
        :stability: experimental
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_IntegrationPattern_fbb35786], result)

    @builtins.property
    def output_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select select a portion of the state output to pass to the next state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        output to be the empty object {}.

        :default:

        - The entire JSON node determined by the state input, the task result,
        and resultPath is passed to the next state (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("output_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to indicate where to inject the state's output.

        May also be the special value JsonPath.DISCARD, which will cause the state's
        input to become its output.

        :default: - Replaces the entire input with the result (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("result_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied.

        You can use ResultSelector to create a payload with values that are static
        or selected from the state's raw result.

        :default: - None

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/input-output-inputpath-params.html#input-output-resultselector
        :stability: experimental
        '''
        result = self._values.get("result_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def timeout(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the state machine.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def cluster_id(self) -> builtins.str:
        '''(experimental) The ClusterId to update.

        :stability: experimental
        '''
        result = self._values.get("cluster_id")
        assert result is not None, "Required property 'cluster_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def termination_protected(self) -> builtins.bool:
        '''(experimental) Termination protection indicator.

        :stability: experimental
        '''
        result = self._values.get("termination_protected")
        assert result is not None, "Required property 'termination_protected' is missing"
        return typing.cast(builtins.bool, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EmrSetClusterTerminationProtectionProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class EmrTerminateCluster(
    _TaskStateBase_c3080646,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.EmrTerminateCluster",
):
    '''(experimental) A Step Functions Task to terminate an EMR Cluster.

    :stability: experimental
    :exampleMetadata: infused

    Example::

        tasks.EmrTerminateCluster(self, "Task",
            cluster_id="ClusterId"
        )
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        cluster_id: builtins.str,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param cluster_id: (experimental) The ClusterId to terminate.
        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3be0548636ce7b8bd9e5c2dc3b21144e6321c6614eb15befed54aec40a3fced5)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = EmrTerminateClusterProps(
            cluster_id=cluster_id,
            comment=comment,
            heartbeat=heartbeat,
            input_path=input_path,
            integration_pattern=integration_pattern,
            output_path=output_path,
            result_path=result_path,
            result_selector=result_selector,
            timeout=timeout,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="taskMetrics")
    def _task_metrics(self) -> typing.Optional[_TaskMetricsConfig_5aaea59e]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[_TaskMetricsConfig_5aaea59e], jsii.get(self, "taskMetrics"))

    @builtins.property
    @jsii.member(jsii_name="taskPolicies")
    def _task_policies(self) -> typing.Optional[typing.List[_PolicyStatement_296fe8a3]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.List[_PolicyStatement_296fe8a3]], jsii.get(self, "taskPolicies"))


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.EmrTerminateClusterProps",
    jsii_struct_bases=[_TaskStateBaseProps_b13f6332],
    name_mapping={
        "comment": "comment",
        "heartbeat": "heartbeat",
        "input_path": "inputPath",
        "integration_pattern": "integrationPattern",
        "output_path": "outputPath",
        "result_path": "resultPath",
        "result_selector": "resultSelector",
        "timeout": "timeout",
        "cluster_id": "clusterId",
    },
)
class EmrTerminateClusterProps(_TaskStateBaseProps_b13f6332):
    def __init__(
        self,
        *,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
        cluster_id: builtins.str,
    ) -> None:
        '''(experimental) Properties for EmrTerminateCluster.

        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None
        :param cluster_id: (experimental) The ClusterId to terminate.

        :stability: experimental
        :exampleMetadata: infused

        Example::

            tasks.EmrTerminateCluster(self, "Task",
                cluster_id="ClusterId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__365a067d98e75c911084d2d82d2d1e7aca007e823e80e9e0652c389f433e7492)
            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
            check_type(argname="argument heartbeat", value=heartbeat, expected_type=type_hints["heartbeat"])
            check_type(argname="argument input_path", value=input_path, expected_type=type_hints["input_path"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
            check_type(argname="argument output_path", value=output_path, expected_type=type_hints["output_path"])
            check_type(argname="argument result_path", value=result_path, expected_type=type_hints["result_path"])
            check_type(argname="argument result_selector", value=result_selector, expected_type=type_hints["result_selector"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
            check_type(argname="argument cluster_id", value=cluster_id, expected_type=type_hints["cluster_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "cluster_id": cluster_id,
        }
        if comment is not None:
            self._values["comment"] = comment
        if heartbeat is not None:
            self._values["heartbeat"] = heartbeat
        if input_path is not None:
            self._values["input_path"] = input_path
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern
        if output_path is not None:
            self._values["output_path"] = output_path
        if result_path is not None:
            self._values["result_path"] = result_path
        if result_selector is not None:
            self._values["result_selector"] = result_selector
        if timeout is not None:
            self._values["timeout"] = timeout

    @builtins.property
    def comment(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional description for this state.

        :default: - No comment

        :stability: experimental
        '''
        result = self._values.get("comment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def heartbeat(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the heartbeat.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("heartbeat")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def input_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select part of the state to be the input to this state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        input to be the empty object {}.

        :default: - The entire task input (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("input_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def integration_pattern(self) -> typing.Optional[_IntegrationPattern_fbb35786]:
        '''(experimental) AWS Step Functions integrates with services directly in the Amazon States Language.

        You can control these AWS services using service integration patterns

        :default:

        - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks.
        ``IntegrationPattern.RUN_JOB`` for the following exceptions:
        ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html#connect-wait-token
        :stability: experimental
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_IntegrationPattern_fbb35786], result)

    @builtins.property
    def output_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select select a portion of the state output to pass to the next state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        output to be the empty object {}.

        :default:

        - The entire JSON node determined by the state input, the task result,
        and resultPath is passed to the next state (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("output_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to indicate where to inject the state's output.

        May also be the special value JsonPath.DISCARD, which will cause the state's
        input to become its output.

        :default: - Replaces the entire input with the result (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("result_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied.

        You can use ResultSelector to create a payload with values that are static
        or selected from the state's raw result.

        :default: - None

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/input-output-inputpath-params.html#input-output-resultselector
        :stability: experimental
        '''
        result = self._values.get("result_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def timeout(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the state machine.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def cluster_id(self) -> builtins.str:
        '''(experimental) The ClusterId to terminate.

        :stability: experimental
        '''
        result = self._values.get("cluster_id")
        assert result is not None, "Required property 'cluster_id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EmrTerminateClusterProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.EncryptionConfiguration",
    jsii_struct_bases=[],
    name_mapping={
        "encryption_option": "encryptionOption",
        "encryption_key": "encryptionKey",
    },
)
class EncryptionConfiguration:
    def __init__(
        self,
        *,
        encryption_option: "EncryptionOption",
        encryption_key: typing.Optional[_IKey_36930160] = None,
    ) -> None:
        '''(experimental) Encryption Configuration of the S3 bucket.

        :param encryption_option: (experimental) Type of S3 server-side encryption enabled. Default: EncryptionOption.S3_MANAGED
        :param encryption_key: (experimental) KMS key ARN or ID. Default: - No KMS key for Encryption Option SSE_S3 and default master key for Encryption Option SSE_KMS and CSE_KMS

        :see: https://docs.aws.amazon.com/athena/latest/APIReference/API_EncryptionConfiguration.html
        :stability: experimental
        :exampleMetadata: infused

        Example::

            start_query_execution_job = tasks.AthenaStartQueryExecution(self, "Athena Start Query",
                query_string=sfn.JsonPath.format("select contacts where year={};", sfn.JsonPath.string_at("$.year")),
                query_execution_context=dynamodb.aws_stepfunctions_tasks.QueryExecutionContext(
                    database_name="interactions"
                ),
                result_configuration=dynamodb.aws_stepfunctions_tasks.ResultConfiguration(
                    encryption_configuration=dynamodb.aws_stepfunctions_tasks.EncryptionConfiguration(
                        encryption_option=tasks.EncryptionOption.S3_MANAGED
                    ),
                    output_location=dynamodb.aws_s3.Location(
                        bucket_name="mybucket",
                        object_key="myprefix"
                    )
                ),
                integration_pattern=sfn.IntegrationPattern.RUN_JOB
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4f88042f1cde743480b78a496056d71c52ff349a10a858db3ffabedfa508936c)
            check_type(argname="argument encryption_option", value=encryption_option, expected_type=type_hints["encryption_option"])
            check_type(argname="argument encryption_key", value=encryption_key, expected_type=type_hints["encryption_key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "encryption_option": encryption_option,
        }
        if encryption_key is not None:
            self._values["encryption_key"] = encryption_key

    @builtins.property
    def encryption_option(self) -> "EncryptionOption":
        '''(experimental) Type of S3 server-side encryption enabled.

        :default: EncryptionOption.S3_MANAGED

        :stability: experimental
        '''
        result = self._values.get("encryption_option")
        assert result is not None, "Required property 'encryption_option' is missing"
        return typing.cast("EncryptionOption", result)

    @builtins.property
    def encryption_key(self) -> typing.Optional[_IKey_36930160]:
        '''(experimental) KMS key ARN or ID.

        :default: - No KMS key for Encryption Option SSE_S3 and default master key for Encryption Option SSE_KMS and CSE_KMS

        :stability: experimental
        '''
        result = self._values.get("encryption_key")
        return typing.cast(typing.Optional[_IKey_36930160], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EncryptionConfiguration(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="monocdk.aws_stepfunctions_tasks.EncryptionOption")
class EncryptionOption(enum.Enum):
    '''(experimental) Encryption Options of the S3 bucket.

    :see: https://docs.aws.amazon.com/athena/latest/APIReference/API_EncryptionConfiguration.html#athena-Type-EncryptionConfiguration-EncryptionOption
    :stability: experimental
    :exampleMetadata: infused

    Example::

        start_query_execution_job = tasks.AthenaStartQueryExecution(self, "Athena Start Query",
            query_string=sfn.JsonPath.format("select contacts where year={};", sfn.JsonPath.string_at("$.year")),
            query_execution_context=dynamodb.aws_stepfunctions_tasks.QueryExecutionContext(
                database_name="interactions"
            ),
            result_configuration=dynamodb.aws_stepfunctions_tasks.ResultConfiguration(
                encryption_configuration=dynamodb.aws_stepfunctions_tasks.EncryptionConfiguration(
                    encryption_option=tasks.EncryptionOption.S3_MANAGED
                ),
                output_location=dynamodb.aws_s3.Location(
                    bucket_name="mybucket",
                    object_key="myprefix"
                )
            ),
            integration_pattern=sfn.IntegrationPattern.RUN_JOB
        )
    '''

    S3_MANAGED = "S3_MANAGED"
    '''(experimental) Server side encryption (SSE) with an Amazon S3-managed key.

    :see: https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingServerSideEncryption.html
    :stability: experimental
    '''
    KMS = "KMS"
    '''(experimental) Server-side encryption (SSE) with an AWS KMS key managed by the account owner.

    :see: https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingKMSEncryption.html
    :stability: experimental
    '''
    CLIENT_SIDE_KMS = "CLIENT_SIDE_KMS"
    '''(experimental) Client-side encryption (CSE) with an AWS KMS key managed by the account owner.

    :see: https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingClientSideEncryption.html
    :stability: experimental
    '''


class EvaluateExpression(
    _TaskStateBase_c3080646,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.EvaluateExpression",
):
    '''(experimental) A Step Functions Task to evaluate an expression.

    OUTPUT: the output of this task is the evaluated expression.

    :stability: experimental
    :exampleMetadata: infused

    Example::

        convert_to_seconds = tasks.EvaluateExpression(self, "Convert to seconds",
            expression="$.waitMilliseconds / 1000",
            result_path="$.waitSeconds"
        )
        
        create_message = tasks.EvaluateExpression(self, "Create message",
            # Note: this is a string inside a string.
            expression="`Now waiting ${$.waitSeconds} seconds...`",
            runtime=lambda_.Runtime.NODEJS_14_X,
            result_path="$.message"
        )
        
        publish_message = tasks.SnsPublish(self, "Publish message",
            topic=sns.Topic(self, "cool-topic"),
            message=sfn.TaskInput.from_json_path_at("$.message"),
            result_path="$.sns"
        )
        
        wait = sfn.Wait(self, "Wait",
            time=sfn.WaitTime.seconds_path("$.waitSeconds")
        )
        
        sfn.StateMachine(self, "StateMachine",
            definition=convert_to_seconds.next(create_message).next(publish_message).next(wait)
        )
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        expression: builtins.str,
        runtime: typing.Optional[_Runtime_932d369a] = None,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param expression: (experimental) The expression to evaluate. The expression may contain state paths. Example value: ``'$.a + $.b'``
        :param runtime: (experimental) The runtime language to use to evaluate the expression. Default: lambda.Runtime.NODEJS_14_X
        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0e0f38b85436d20d4eb2d3de9b592d48384442852329444058c8aba26c5065c3)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = EvaluateExpressionProps(
            expression=expression,
            runtime=runtime,
            comment=comment,
            heartbeat=heartbeat,
            input_path=input_path,
            integration_pattern=integration_pattern,
            output_path=output_path,
            result_path=result_path,
            result_selector=result_selector,
            timeout=timeout,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="taskMetrics")
    def _task_metrics(self) -> typing.Optional[_TaskMetricsConfig_5aaea59e]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[_TaskMetricsConfig_5aaea59e], jsii.get(self, "taskMetrics"))

    @builtins.property
    @jsii.member(jsii_name="taskPolicies")
    def _task_policies(self) -> typing.Optional[typing.List[_PolicyStatement_296fe8a3]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.List[_PolicyStatement_296fe8a3]], jsii.get(self, "taskPolicies"))


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.EvaluateExpressionProps",
    jsii_struct_bases=[_TaskStateBaseProps_b13f6332],
    name_mapping={
        "comment": "comment",
        "heartbeat": "heartbeat",
        "input_path": "inputPath",
        "integration_pattern": "integrationPattern",
        "output_path": "outputPath",
        "result_path": "resultPath",
        "result_selector": "resultSelector",
        "timeout": "timeout",
        "expression": "expression",
        "runtime": "runtime",
    },
)
class EvaluateExpressionProps(_TaskStateBaseProps_b13f6332):
    def __init__(
        self,
        *,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
        expression: builtins.str,
        runtime: typing.Optional[_Runtime_932d369a] = None,
    ) -> None:
        '''(experimental) Properties for EvaluateExpression.

        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None
        :param expression: (experimental) The expression to evaluate. The expression may contain state paths. Example value: ``'$.a + $.b'``
        :param runtime: (experimental) The runtime language to use to evaluate the expression. Default: lambda.Runtime.NODEJS_14_X

        :stability: experimental
        :exampleMetadata: infused

        Example::

            convert_to_seconds = tasks.EvaluateExpression(self, "Convert to seconds",
                expression="$.waitMilliseconds / 1000",
                result_path="$.waitSeconds"
            )
            
            create_message = tasks.EvaluateExpression(self, "Create message",
                # Note: this is a string inside a string.
                expression="`Now waiting ${$.waitSeconds} seconds...`",
                runtime=lambda_.Runtime.NODEJS_14_X,
                result_path="$.message"
            )
            
            publish_message = tasks.SnsPublish(self, "Publish message",
                topic=sns.Topic(self, "cool-topic"),
                message=sfn.TaskInput.from_json_path_at("$.message"),
                result_path="$.sns"
            )
            
            wait = sfn.Wait(self, "Wait",
                time=sfn.WaitTime.seconds_path("$.waitSeconds")
            )
            
            sfn.StateMachine(self, "StateMachine",
                definition=convert_to_seconds.next(create_message).next(publish_message).next(wait)
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1432e39948365e95528d48263d3cc007e597a9bf6ea213e75663e8bca1ead323)
            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
            check_type(argname="argument heartbeat", value=heartbeat, expected_type=type_hints["heartbeat"])
            check_type(argname="argument input_path", value=input_path, expected_type=type_hints["input_path"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
            check_type(argname="argument output_path", value=output_path, expected_type=type_hints["output_path"])
            check_type(argname="argument result_path", value=result_path, expected_type=type_hints["result_path"])
            check_type(argname="argument result_selector", value=result_selector, expected_type=type_hints["result_selector"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
            check_type(argname="argument expression", value=expression, expected_type=type_hints["expression"])
            check_type(argname="argument runtime", value=runtime, expected_type=type_hints["runtime"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "expression": expression,
        }
        if comment is not None:
            self._values["comment"] = comment
        if heartbeat is not None:
            self._values["heartbeat"] = heartbeat
        if input_path is not None:
            self._values["input_path"] = input_path
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern
        if output_path is not None:
            self._values["output_path"] = output_path
        if result_path is not None:
            self._values["result_path"] = result_path
        if result_selector is not None:
            self._values["result_selector"] = result_selector
        if timeout is not None:
            self._values["timeout"] = timeout
        if runtime is not None:
            self._values["runtime"] = runtime

    @builtins.property
    def comment(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional description for this state.

        :default: - No comment

        :stability: experimental
        '''
        result = self._values.get("comment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def heartbeat(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the heartbeat.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("heartbeat")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def input_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select part of the state to be the input to this state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        input to be the empty object {}.

        :default: - The entire task input (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("input_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def integration_pattern(self) -> typing.Optional[_IntegrationPattern_fbb35786]:
        '''(experimental) AWS Step Functions integrates with services directly in the Amazon States Language.

        You can control these AWS services using service integration patterns

        :default:

        - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks.
        ``IntegrationPattern.RUN_JOB`` for the following exceptions:
        ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html#connect-wait-token
        :stability: experimental
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_IntegrationPattern_fbb35786], result)

    @builtins.property
    def output_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select select a portion of the state output to pass to the next state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        output to be the empty object {}.

        :default:

        - The entire JSON node determined by the state input, the task result,
        and resultPath is passed to the next state (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("output_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to indicate where to inject the state's output.

        May also be the special value JsonPath.DISCARD, which will cause the state's
        input to become its output.

        :default: - Replaces the entire input with the result (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("result_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied.

        You can use ResultSelector to create a payload with values that are static
        or selected from the state's raw result.

        :default: - None

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/input-output-inputpath-params.html#input-output-resultselector
        :stability: experimental
        '''
        result = self._values.get("result_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def timeout(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the state machine.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def expression(self) -> builtins.str:
        '''(experimental) The expression to evaluate. The expression may contain state paths.

        Example value: ``'$.a + $.b'``

        :stability: experimental
        '''
        result = self._values.get("expression")
        assert result is not None, "Required property 'expression' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def runtime(self) -> typing.Optional[_Runtime_932d369a]:
        '''(experimental) The runtime language to use to evaluate the expression.

        :default: lambda.Runtime.NODEJS_14_X

        :stability: experimental
        '''
        result = self._values.get("runtime")
        return typing.cast(typing.Optional[_Runtime_932d369a], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EvaluateExpressionProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class EventBridgePutEvents(
    _TaskStateBase_c3080646,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.EventBridgePutEvents",
):
    '''(experimental) A StepFunctions Task to send events to an EventBridge event bus.

    :stability: experimental
    :exampleMetadata: infused

    Example::

        import monocdk as events
        
        
        my_event_bus = events.EventBus(self, "EventBus",
            event_bus_name="MyEventBus1"
        )
        
        tasks.EventBridgePutEvents(self, "Send an event to EventBridge",
            entries=[events.aws_stepfunctions_tasks.EventBridgePutEventsEntry(
                detail=sfn.TaskInput.from_object({
                    "Message": "Hello from Step Functions!"
                }),
                event_bus=my_event_bus,
                detail_type="MessageFromStepFunctions",
                source="step.functions"
            )]
        )
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        entries: typing.Sequence[typing.Union["EventBridgePutEventsEntry", typing.Dict[builtins.str, typing.Any]]],
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param entries: (experimental) The entries that will be sent (must be at least 1).
        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__95e8b397d75d8eb0c06e9dd578f8f8eb0ce04a391b884ce7de4dfbe40bf0139d)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = EventBridgePutEventsProps(
            entries=entries,
            comment=comment,
            heartbeat=heartbeat,
            input_path=input_path,
            integration_pattern=integration_pattern,
            output_path=output_path,
            result_path=result_path,
            result_selector=result_selector,
            timeout=timeout,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="taskMetrics")
    def _task_metrics(self) -> typing.Optional[_TaskMetricsConfig_5aaea59e]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[_TaskMetricsConfig_5aaea59e], jsii.get(self, "taskMetrics"))

    @builtins.property
    @jsii.member(jsii_name="taskPolicies")
    def _task_policies(self) -> typing.Optional[typing.List[_PolicyStatement_296fe8a3]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.List[_PolicyStatement_296fe8a3]], jsii.get(self, "taskPolicies"))


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.EventBridgePutEventsEntry",
    jsii_struct_bases=[],
    name_mapping={
        "detail": "detail",
        "detail_type": "detailType",
        "source": "source",
        "event_bus": "eventBus",
    },
)
class EventBridgePutEventsEntry:
    def __init__(
        self,
        *,
        detail: _TaskInput_71ab46f6,
        detail_type: builtins.str,
        source: builtins.str,
        event_bus: typing.Optional[_IEventBus_2ca38c95] = None,
    ) -> None:
        '''(experimental) An entry to be sent to EventBridge.

        :param detail: (experimental) The event body. Can either be provided as an object or as a JSON-serialized string
        :param detail_type: (experimental) Used along with the source field to help identify the fields and values expected in the detail field. For example, events by CloudTrail have detail type "AWS API Call via CloudTrail"
        :param source: (experimental) The service or application that caused this event to be generated. Example value: ``com.example.service``
        :param event_bus: (experimental) The event bus the entry will be sent to. Default: - event is sent to account's default event bus

        :see: https://docs.aws.amazon.com/eventbridge/latest/APIReference/API_PutEventsRequestEntry.html
        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_events as events
            from monocdk import aws_stepfunctions as stepfunctions
            from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
            
            # event_bus: events.EventBus
            # task_input: stepfunctions.TaskInput
            
            event_bridge_put_events_entry = stepfunctions_tasks.EventBridgePutEventsEntry(
                detail=task_input,
                detail_type="detailType",
                source="source",
            
                # the properties below are optional
                event_bus=event_bus
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6bfb2fcd60ebc7366cf36ab20393a70593e841c272d834c8a81476cd3ce8e103)
            check_type(argname="argument detail", value=detail, expected_type=type_hints["detail"])
            check_type(argname="argument detail_type", value=detail_type, expected_type=type_hints["detail_type"])
            check_type(argname="argument source", value=source, expected_type=type_hints["source"])
            check_type(argname="argument event_bus", value=event_bus, expected_type=type_hints["event_bus"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "detail": detail,
            "detail_type": detail_type,
            "source": source,
        }
        if event_bus is not None:
            self._values["event_bus"] = event_bus

    @builtins.property
    def detail(self) -> _TaskInput_71ab46f6:
        '''(experimental) The event body.

        Can either be provided as an object or as a JSON-serialized string

        :stability: experimental

        Example::

            sfn.TaskInput.from_text("{\"instance-id\": \"i-1234567890abcdef0\", \"state\": \"terminated\"}")
            sfn.TaskInput.from_object({"Message": "Hello from Step Functions"})
            sfn.TaskInput.from_json_path_at("$.EventDetail")
        '''
        result = self._values.get("detail")
        assert result is not None, "Required property 'detail' is missing"
        return typing.cast(_TaskInput_71ab46f6, result)

    @builtins.property
    def detail_type(self) -> builtins.str:
        '''(experimental) Used along with the source field to help identify the fields and values expected in the detail field.

        For example, events by CloudTrail have detail type "AWS API Call via CloudTrail"

        :see: https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-events.html
        :stability: experimental
        '''
        result = self._values.get("detail_type")
        assert result is not None, "Required property 'detail_type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def source(self) -> builtins.str:
        '''(experimental) The service or application that caused this event to be generated.

        Example value: ``com.example.service``

        :see: https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-events.html
        :stability: experimental
        '''
        result = self._values.get("source")
        assert result is not None, "Required property 'source' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def event_bus(self) -> typing.Optional[_IEventBus_2ca38c95]:
        '''(experimental) The event bus the entry will be sent to.

        :default: - event is sent to account's default event bus

        :stability: experimental
        '''
        result = self._values.get("event_bus")
        return typing.cast(typing.Optional[_IEventBus_2ca38c95], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EventBridgePutEventsEntry(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.EventBridgePutEventsProps",
    jsii_struct_bases=[_TaskStateBaseProps_b13f6332],
    name_mapping={
        "comment": "comment",
        "heartbeat": "heartbeat",
        "input_path": "inputPath",
        "integration_pattern": "integrationPattern",
        "output_path": "outputPath",
        "result_path": "resultPath",
        "result_selector": "resultSelector",
        "timeout": "timeout",
        "entries": "entries",
    },
)
class EventBridgePutEventsProps(_TaskStateBaseProps_b13f6332):
    def __init__(
        self,
        *,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
        entries: typing.Sequence[typing.Union[EventBridgePutEventsEntry, typing.Dict[builtins.str, typing.Any]]],
    ) -> None:
        '''(experimental) Properties for sending events with PutEvents.

        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None
        :param entries: (experimental) The entries that will be sent (must be at least 1).

        :stability: experimental
        :exampleMetadata: infused

        Example::

            import monocdk as events
            
            
            my_event_bus = events.EventBus(self, "EventBus",
                event_bus_name="MyEventBus1"
            )
            
            tasks.EventBridgePutEvents(self, "Send an event to EventBridge",
                entries=[events.aws_stepfunctions_tasks.EventBridgePutEventsEntry(
                    detail=sfn.TaskInput.from_object({
                        "Message": "Hello from Step Functions!"
                    }),
                    event_bus=my_event_bus,
                    detail_type="MessageFromStepFunctions",
                    source="step.functions"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__69129595995787769e468fbfdea5494d101b4ee54e3c954504ad5dbb78eea1a6)
            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
            check_type(argname="argument heartbeat", value=heartbeat, expected_type=type_hints["heartbeat"])
            check_type(argname="argument input_path", value=input_path, expected_type=type_hints["input_path"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
            check_type(argname="argument output_path", value=output_path, expected_type=type_hints["output_path"])
            check_type(argname="argument result_path", value=result_path, expected_type=type_hints["result_path"])
            check_type(argname="argument result_selector", value=result_selector, expected_type=type_hints["result_selector"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
            check_type(argname="argument entries", value=entries, expected_type=type_hints["entries"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "entries": entries,
        }
        if comment is not None:
            self._values["comment"] = comment
        if heartbeat is not None:
            self._values["heartbeat"] = heartbeat
        if input_path is not None:
            self._values["input_path"] = input_path
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern
        if output_path is not None:
            self._values["output_path"] = output_path
        if result_path is not None:
            self._values["result_path"] = result_path
        if result_selector is not None:
            self._values["result_selector"] = result_selector
        if timeout is not None:
            self._values["timeout"] = timeout

    @builtins.property
    def comment(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional description for this state.

        :default: - No comment

        :stability: experimental
        '''
        result = self._values.get("comment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def heartbeat(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the heartbeat.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("heartbeat")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def input_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select part of the state to be the input to this state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        input to be the empty object {}.

        :default: - The entire task input (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("input_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def integration_pattern(self) -> typing.Optional[_IntegrationPattern_fbb35786]:
        '''(experimental) AWS Step Functions integrates with services directly in the Amazon States Language.

        You can control these AWS services using service integration patterns

        :default:

        - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks.
        ``IntegrationPattern.RUN_JOB`` for the following exceptions:
        ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html#connect-wait-token
        :stability: experimental
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_IntegrationPattern_fbb35786], result)

    @builtins.property
    def output_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select select a portion of the state output to pass to the next state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        output to be the empty object {}.

        :default:

        - The entire JSON node determined by the state input, the task result,
        and resultPath is passed to the next state (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("output_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to indicate where to inject the state's output.

        May also be the special value JsonPath.DISCARD, which will cause the state's
        input to become its output.

        :default: - Replaces the entire input with the result (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("result_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied.

        You can use ResultSelector to create a payload with values that are static
        or selected from the state's raw result.

        :default: - None

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/input-output-inputpath-params.html#input-output-resultselector
        :stability: experimental
        '''
        result = self._values.get("result_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def timeout(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the state machine.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def entries(self) -> typing.List[EventBridgePutEventsEntry]:
        '''(experimental) The entries that will be sent (must be at least 1).

        :stability: experimental
        '''
        result = self._values.get("entries")
        assert result is not None, "Required property 'entries' is missing"
        return typing.cast(typing.List[EventBridgePutEventsEntry], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EventBridgePutEventsProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class GlueDataBrewStartJobRun(
    _TaskStateBase_c3080646,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.GlueDataBrewStartJobRun",
):
    '''(experimental) Start a Job run as a Task.

    :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-databrew.html
    :stability: experimental
    :exampleMetadata: infused

    Example::

        tasks.GlueDataBrewStartJobRun(self, "Task",
            name="databrew-job"
        )
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        name: builtins.str,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param name: (experimental) Glue DataBrew Job to run.
        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8a115da6edd50c0d9d6c9a1bd6c6faf814e955de4fa3db108773866d781b0f7f)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = GlueDataBrewStartJobRunProps(
            name=name,
            comment=comment,
            heartbeat=heartbeat,
            input_path=input_path,
            integration_pattern=integration_pattern,
            output_path=output_path,
            result_path=result_path,
            result_selector=result_selector,
            timeout=timeout,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="taskMetrics")
    def _task_metrics(self) -> typing.Optional[_TaskMetricsConfig_5aaea59e]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[_TaskMetricsConfig_5aaea59e], jsii.get(self, "taskMetrics"))

    @builtins.property
    @jsii.member(jsii_name="taskPolicies")
    def _task_policies(self) -> typing.Optional[typing.List[_PolicyStatement_296fe8a3]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.List[_PolicyStatement_296fe8a3]], jsii.get(self, "taskPolicies"))


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.GlueDataBrewStartJobRunProps",
    jsii_struct_bases=[_TaskStateBaseProps_b13f6332],
    name_mapping={
        "comment": "comment",
        "heartbeat": "heartbeat",
        "input_path": "inputPath",
        "integration_pattern": "integrationPattern",
        "output_path": "outputPath",
        "result_path": "resultPath",
        "result_selector": "resultSelector",
        "timeout": "timeout",
        "name": "name",
    },
)
class GlueDataBrewStartJobRunProps(_TaskStateBaseProps_b13f6332):
    def __init__(
        self,
        *,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
        name: builtins.str,
    ) -> None:
        '''(experimental) Properties for starting a job run with StartJobRun.

        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None
        :param name: (experimental) Glue DataBrew Job to run.

        :stability: experimental
        :exampleMetadata: infused

        Example::

            tasks.GlueDataBrewStartJobRun(self, "Task",
                name="databrew-job"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dc107df28802e5844a992ad0f860e9f7385386c0ef765aee96bb7c06b60d9efd)
            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
            check_type(argname="argument heartbeat", value=heartbeat, expected_type=type_hints["heartbeat"])
            check_type(argname="argument input_path", value=input_path, expected_type=type_hints["input_path"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
            check_type(argname="argument output_path", value=output_path, expected_type=type_hints["output_path"])
            check_type(argname="argument result_path", value=result_path, expected_type=type_hints["result_path"])
            check_type(argname="argument result_selector", value=result_selector, expected_type=type_hints["result_selector"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if comment is not None:
            self._values["comment"] = comment
        if heartbeat is not None:
            self._values["heartbeat"] = heartbeat
        if input_path is not None:
            self._values["input_path"] = input_path
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern
        if output_path is not None:
            self._values["output_path"] = output_path
        if result_path is not None:
            self._values["result_path"] = result_path
        if result_selector is not None:
            self._values["result_selector"] = result_selector
        if timeout is not None:
            self._values["timeout"] = timeout

    @builtins.property
    def comment(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional description for this state.

        :default: - No comment

        :stability: experimental
        '''
        result = self._values.get("comment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def heartbeat(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the heartbeat.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("heartbeat")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def input_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select part of the state to be the input to this state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        input to be the empty object {}.

        :default: - The entire task input (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("input_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def integration_pattern(self) -> typing.Optional[_IntegrationPattern_fbb35786]:
        '''(experimental) AWS Step Functions integrates with services directly in the Amazon States Language.

        You can control these AWS services using service integration patterns

        :default:

        - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks.
        ``IntegrationPattern.RUN_JOB`` for the following exceptions:
        ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html#connect-wait-token
        :stability: experimental
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_IntegrationPattern_fbb35786], result)

    @builtins.property
    def output_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select select a portion of the state output to pass to the next state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        output to be the empty object {}.

        :default:

        - The entire JSON node determined by the state input, the task result,
        and resultPath is passed to the next state (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("output_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to indicate where to inject the state's output.

        May also be the special value JsonPath.DISCARD, which will cause the state's
        input to become its output.

        :default: - Replaces the entire input with the result (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("result_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied.

        You can use ResultSelector to create a payload with values that are static
        or selected from the state's raw result.

        :default: - None

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/input-output-inputpath-params.html#input-output-resultselector
        :stability: experimental
        '''
        result = self._values.get("result_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def timeout(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the state machine.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def name(self) -> builtins.str:
        '''(experimental) Glue DataBrew Job to run.

        :stability: experimental
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "GlueDataBrewStartJobRunProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class GlueStartJobRun(
    _TaskStateBase_c3080646,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.GlueStartJobRun",
):
    '''(experimental) Starts an AWS Glue job in a Task state.

    OUTPUT: the output of this task is a JobRun structure, for details consult
    https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-jobs-runs.html#aws-glue-api-jobs-runs-JobRun

    :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-glue.html
    :stability: experimental
    :exampleMetadata: infused

    Example::

        tasks.GlueStartJobRun(self, "Task",
            glue_job_name="my-glue-job",
            arguments=sfn.TaskInput.from_object({
                "key": "value"
            }),
            timeout=Duration.minutes(30),
            notify_delay_after=Duration.minutes(5)
        )
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        glue_job_name: builtins.str,
        arguments: typing.Optional[_TaskInput_71ab46f6] = None,
        notify_delay_after: typing.Optional[_Duration_070aa057] = None,
        security_configuration: typing.Optional[builtins.str] = None,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param glue_job_name: (experimental) Glue job name.
        :param arguments: (experimental) The job arguments specifically for this run. For this job run, they replace the default arguments set in the job definition itself. Default: - Default arguments set in the job definition
        :param notify_delay_after: (experimental) After a job run starts, the number of minutes to wait before sending a job run delay notification. Must be at least 1 minute. Default: - Default delay set in the job definition
        :param security_configuration: (experimental) The name of the SecurityConfiguration structure to be used with this job run. This must match the Glue API Default: - Default configuration set in the job definition
        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c27f7438792488798490ece09425a1eec1038a71d90df7d92314ff9e1062d525)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = GlueStartJobRunProps(
            glue_job_name=glue_job_name,
            arguments=arguments,
            notify_delay_after=notify_delay_after,
            security_configuration=security_configuration,
            comment=comment,
            heartbeat=heartbeat,
            input_path=input_path,
            integration_pattern=integration_pattern,
            output_path=output_path,
            result_path=result_path,
            result_selector=result_selector,
            timeout=timeout,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="taskMetrics")
    def _task_metrics(self) -> typing.Optional[_TaskMetricsConfig_5aaea59e]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[_TaskMetricsConfig_5aaea59e], jsii.get(self, "taskMetrics"))

    @builtins.property
    @jsii.member(jsii_name="taskPolicies")
    def _task_policies(self) -> typing.Optional[typing.List[_PolicyStatement_296fe8a3]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.List[_PolicyStatement_296fe8a3]], jsii.get(self, "taskPolicies"))


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.GlueStartJobRunProps",
    jsii_struct_bases=[_TaskStateBaseProps_b13f6332],
    name_mapping={
        "comment": "comment",
        "heartbeat": "heartbeat",
        "input_path": "inputPath",
        "integration_pattern": "integrationPattern",
        "output_path": "outputPath",
        "result_path": "resultPath",
        "result_selector": "resultSelector",
        "timeout": "timeout",
        "glue_job_name": "glueJobName",
        "arguments": "arguments",
        "notify_delay_after": "notifyDelayAfter",
        "security_configuration": "securityConfiguration",
    },
)
class GlueStartJobRunProps(_TaskStateBaseProps_b13f6332):
    def __init__(
        self,
        *,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
        glue_job_name: builtins.str,
        arguments: typing.Optional[_TaskInput_71ab46f6] = None,
        notify_delay_after: typing.Optional[_Duration_070aa057] = None,
        security_configuration: typing.Optional[builtins.str] = None,
    ) -> None:
        '''(experimental) Properties for starting an AWS Glue job as a task.

        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None
        :param glue_job_name: (experimental) Glue job name.
        :param arguments: (experimental) The job arguments specifically for this run. For this job run, they replace the default arguments set in the job definition itself. Default: - Default arguments set in the job definition
        :param notify_delay_after: (experimental) After a job run starts, the number of minutes to wait before sending a job run delay notification. Must be at least 1 minute. Default: - Default delay set in the job definition
        :param security_configuration: (experimental) The name of the SecurityConfiguration structure to be used with this job run. This must match the Glue API Default: - Default configuration set in the job definition

        :stability: experimental
        :exampleMetadata: infused

        Example::

            tasks.GlueStartJobRun(self, "Task",
                glue_job_name="my-glue-job",
                arguments=sfn.TaskInput.from_object({
                    "key": "value"
                }),
                timeout=Duration.minutes(30),
                notify_delay_after=Duration.minutes(5)
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1d070e025ef86245d2bab0e382e188b228c5ea242241faedb3fd8b0a2aba3dd6)
            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
            check_type(argname="argument heartbeat", value=heartbeat, expected_type=type_hints["heartbeat"])
            check_type(argname="argument input_path", value=input_path, expected_type=type_hints["input_path"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
            check_type(argname="argument output_path", value=output_path, expected_type=type_hints["output_path"])
            check_type(argname="argument result_path", value=result_path, expected_type=type_hints["result_path"])
            check_type(argname="argument result_selector", value=result_selector, expected_type=type_hints["result_selector"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
            check_type(argname="argument glue_job_name", value=glue_job_name, expected_type=type_hints["glue_job_name"])
            check_type(argname="argument arguments", value=arguments, expected_type=type_hints["arguments"])
            check_type(argname="argument notify_delay_after", value=notify_delay_after, expected_type=type_hints["notify_delay_after"])
            check_type(argname="argument security_configuration", value=security_configuration, expected_type=type_hints["security_configuration"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "glue_job_name": glue_job_name,
        }
        if comment is not None:
            self._values["comment"] = comment
        if heartbeat is not None:
            self._values["heartbeat"] = heartbeat
        if input_path is not None:
            self._values["input_path"] = input_path
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern
        if output_path is not None:
            self._values["output_path"] = output_path
        if result_path is not None:
            self._values["result_path"] = result_path
        if result_selector is not None:
            self._values["result_selector"] = result_selector
        if timeout is not None:
            self._values["timeout"] = timeout
        if arguments is not None:
            self._values["arguments"] = arguments
        if notify_delay_after is not None:
            self._values["notify_delay_after"] = notify_delay_after
        if security_configuration is not None:
            self._values["security_configuration"] = security_configuration

    @builtins.property
    def comment(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional description for this state.

        :default: - No comment

        :stability: experimental
        '''
        result = self._values.get("comment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def heartbeat(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the heartbeat.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("heartbeat")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def input_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select part of the state to be the input to this state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        input to be the empty object {}.

        :default: - The entire task input (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("input_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def integration_pattern(self) -> typing.Optional[_IntegrationPattern_fbb35786]:
        '''(experimental) AWS Step Functions integrates with services directly in the Amazon States Language.

        You can control these AWS services using service integration patterns

        :default:

        - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks.
        ``IntegrationPattern.RUN_JOB`` for the following exceptions:
        ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html#connect-wait-token
        :stability: experimental
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_IntegrationPattern_fbb35786], result)

    @builtins.property
    def output_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select select a portion of the state output to pass to the next state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        output to be the empty object {}.

        :default:

        - The entire JSON node determined by the state input, the task result,
        and resultPath is passed to the next state (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("output_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to indicate where to inject the state's output.

        May also be the special value JsonPath.DISCARD, which will cause the state's
        input to become its output.

        :default: - Replaces the entire input with the result (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("result_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied.

        You can use ResultSelector to create a payload with values that are static
        or selected from the state's raw result.

        :default: - None

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/input-output-inputpath-params.html#input-output-resultselector
        :stability: experimental
        '''
        result = self._values.get("result_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def timeout(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the state machine.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def glue_job_name(self) -> builtins.str:
        '''(experimental) Glue job name.

        :stability: experimental
        '''
        result = self._values.get("glue_job_name")
        assert result is not None, "Required property 'glue_job_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def arguments(self) -> typing.Optional[_TaskInput_71ab46f6]:
        '''(experimental) The job arguments specifically for this run.

        For this job run, they replace the default arguments set in the job
        definition itself.

        :default: - Default arguments set in the job definition

        :stability: experimental
        '''
        result = self._values.get("arguments")
        return typing.cast(typing.Optional[_TaskInput_71ab46f6], result)

    @builtins.property
    def notify_delay_after(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) After a job run starts, the number of minutes to wait before sending a job run delay notification.

        Must be at least 1 minute.

        :default: - Default delay set in the job definition

        :stability: experimental
        '''
        result = self._values.get("notify_delay_after")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def security_configuration(self) -> typing.Optional[builtins.str]:
        '''(experimental) The name of the SecurityConfiguration structure to be used with this job run.

        This must match the Glue API

        :default: - Default configuration set in the job definition

        :see: https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-common.html#aws-glue-api-regex-oneLine
        :stability: experimental
        '''
        result = self._values.get("security_configuration")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "GlueStartJobRunProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="monocdk.aws_stepfunctions_tasks.HttpMethod")
class HttpMethod(enum.Enum):
    '''(experimental) Http Methods that API Gateway supports.

    :stability: experimental
    :exampleMetadata: infused

    Example::

        import monocdk as apigatewayv2
        
        http_api = apigatewayv2.HttpApi(self, "MyHttpApi")
        
        invoke_task = tasks.CallApiGatewayHttpApiEndpoint(self, "Call HTTP API",
            api_id=http_api.api_id,
            api_stack=Stack.of(http_api),
            method=tasks.HttpMethod.GET
        )
    '''

    GET = "GET"
    '''(experimental) Retreive data from a server at the specified resource.

    :stability: experimental
    '''
    POST = "POST"
    '''(experimental) Send data to the API endpoint to create or udpate a resource.

    :stability: experimental
    '''
    PUT = "PUT"
    '''(experimental) Send data to the API endpoint to update or create a resource.

    :stability: experimental
    '''
    DELETE = "DELETE"
    '''(experimental) Delete the resource at the specified endpoint.

    :stability: experimental
    '''
    PATCH = "PATCH"
    '''(experimental) Apply partial modifications to the resource.

    :stability: experimental
    '''
    HEAD = "HEAD"
    '''(experimental) Retreive data from a server at the specified resource without the response body.

    :stability: experimental
    '''
    OPTIONS = "OPTIONS"
    '''(experimental) Return data describing what other methods and operations the server supports.

    :stability: experimental
    '''


@jsii.enum(jsii_type="monocdk.aws_stepfunctions_tasks.HttpMethods")
class HttpMethods(enum.Enum):
    '''(experimental) Method type of a EKS call.

    :stability: experimental
    :exampleMetadata: infused

    Example::

        import monocdk as eks
        
        
        my_eks_cluster = eks.Cluster(self, "my sample cluster",
            version=eks.KubernetesVersion.V1_18,
            cluster_name="myEksCluster"
        )
        
        tasks.EksCall(self, "Call a EKS Endpoint",
            cluster=my_eks_cluster,
            http_method=tasks.HttpMethods.GET,
            http_path="/api/v1/namespaces/default/pods"
        )
    '''

    GET = "GET"
    '''(experimental) Retrieve data from a server at the specified resource.

    :stability: experimental
    '''
    POST = "POST"
    '''(experimental) Send data to the API endpoint to create or update a resource.

    :stability: experimental
    '''
    PUT = "PUT"
    '''(experimental) Send data to the API endpoint to update or create a resource.

    :stability: experimental
    '''
    DELETE = "DELETE"
    '''(experimental) Delete the resource at the specified endpoint.

    :stability: experimental
    '''
    PATCH = "PATCH"
    '''(experimental) Apply partial modifications to the resource.

    :stability: experimental
    '''
    HEAD = "HEAD"
    '''(experimental) Retrieve data from a server at the specified resource without the response body.

    :stability: experimental
    '''


@jsii.interface(jsii_type="monocdk.aws_stepfunctions_tasks.IContainerDefinition")
class IContainerDefinition(typing_extensions.Protocol):
    '''(experimental) Configuration of the container used to host the model.

    :see: https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_ContainerDefinition.html
    :stability: experimental
    '''

    @jsii.member(jsii_name="bind")
    def bind(self, task: "ISageMakerTask") -> ContainerDefinitionConfig:
        '''(experimental) Called when the ContainerDefinition is used by a SageMaker task.

        :param task: -

        :stability: experimental
        '''
        ...


class _IContainerDefinitionProxy:
    '''(experimental) Configuration of the container used to host the model.

    :see: https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_ContainerDefinition.html
    :stability: experimental
    '''

    __jsii_type__: typing.ClassVar[str] = "monocdk.aws_stepfunctions_tasks.IContainerDefinition"

    @jsii.member(jsii_name="bind")
    def bind(self, task: "ISageMakerTask") -> ContainerDefinitionConfig:
        '''(experimental) Called when the ContainerDefinition is used by a SageMaker task.

        :param task: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__69adf3a722b2a8ec0dea54b76fa143d8d024f0fe5239f8044532df991e91f9ba)
            check_type(argname="argument task", value=task, expected_type=type_hints["task"])
        return typing.cast(ContainerDefinitionConfig, jsii.invoke(self, "bind", [task]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IContainerDefinition).__jsii_proxy_class__ = lambda : _IContainerDefinitionProxy


@jsii.interface(jsii_type="monocdk.aws_stepfunctions_tasks.IEcsLaunchTarget")
class IEcsLaunchTarget(typing_extensions.Protocol):
    '''(experimental) An Amazon ECS launch type determines the type of infrastructure on which your tasks and services are hosted.

    :see: https://docs.aws.amazon.com/AmazonECS/latest/developerguide/launch_types.html
    :stability: experimental
    '''

    @jsii.member(jsii_name="bind")
    def bind(
        self,
        task: EcsRunTask,
        *,
        task_definition: _ITaskDefinition_ee0d1862,
        cluster: typing.Optional[_ICluster_42c4ec1a] = None,
    ) -> EcsLaunchTargetConfig:
        '''(experimental) called when the ECS launch target is configured on RunTask.

        :param task: -
        :param task_definition: (experimental) Task definition to run Docker containers in Amazon ECS.
        :param cluster: (experimental) A regional grouping of one or more container instances on which you can run tasks and services. Default: - No cluster

        :stability: experimental
        '''
        ...


class _IEcsLaunchTargetProxy:
    '''(experimental) An Amazon ECS launch type determines the type of infrastructure on which your tasks and services are hosted.

    :see: https://docs.aws.amazon.com/AmazonECS/latest/developerguide/launch_types.html
    :stability: experimental
    '''

    __jsii_type__: typing.ClassVar[str] = "monocdk.aws_stepfunctions_tasks.IEcsLaunchTarget"

    @jsii.member(jsii_name="bind")
    def bind(
        self,
        task: EcsRunTask,
        *,
        task_definition: _ITaskDefinition_ee0d1862,
        cluster: typing.Optional[_ICluster_42c4ec1a] = None,
    ) -> EcsLaunchTargetConfig:
        '''(experimental) called when the ECS launch target is configured on RunTask.

        :param task: -
        :param task_definition: (experimental) Task definition to run Docker containers in Amazon ECS.
        :param cluster: (experimental) A regional grouping of one or more container instances on which you can run tasks and services. Default: - No cluster

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__11f001e0bddae5d5c1e66870283f786d1e5170b415910310c0501875ad64d87a)
            check_type(argname="argument task", value=task, expected_type=type_hints["task"])
        launch_target_options = LaunchTargetBindOptions(
            task_definition=task_definition, cluster=cluster
        )

        return typing.cast(EcsLaunchTargetConfig, jsii.invoke(self, "bind", [task, launch_target_options]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IEcsLaunchTarget).__jsii_proxy_class__ = lambda : _IEcsLaunchTargetProxy


@jsii.interface(jsii_type="monocdk.aws_stepfunctions_tasks.ISageMakerTask")
class ISageMakerTask(_IGrantable_4c5a91d1, typing_extensions.Protocol):
    '''(experimental) Task to train a machine learning model using Amazon SageMaker.

    :stability: experimental
    '''

    pass


class _ISageMakerTaskProxy(
    jsii.proxy_for(_IGrantable_4c5a91d1), # type: ignore[misc]
):
    '''(experimental) Task to train a machine learning model using Amazon SageMaker.

    :stability: experimental
    '''

    __jsii_type__: typing.ClassVar[str] = "monocdk.aws_stepfunctions_tasks.ISageMakerTask"
    pass

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, ISageMakerTask).__jsii_proxy_class__ = lambda : _ISageMakerTaskProxy


@jsii.enum(jsii_type="monocdk.aws_stepfunctions_tasks.InputMode")
class InputMode(enum.Enum):
    '''(experimental) Input mode that the algorithm supports.

    :stability: experimental
    :exampleMetadata: infused

    Example::

        tasks.SageMakerCreateTrainingJob(self, "TrainSagemaker",
            training_job_name=sfn.JsonPath.string_at("$.JobName"),
            algorithm_specification=dynamodb.aws_stepfunctions_tasks.AlgorithmSpecification(
                algorithm_name="BlazingText",
                training_input_mode=tasks.InputMode.FILE
            ),
            input_data_config=[dynamodb.aws_stepfunctions_tasks.Channel(
                channel_name="train",
                data_source=dynamodb.aws_stepfunctions_tasks.DataSource(
                    s3_data_source=dynamodb.aws_stepfunctions_tasks.S3DataSource(
                        s3_data_type=tasks.S3DataType.S3_PREFIX,
                        s3_location=tasks.S3Location.from_json_expression("$.S3Bucket")
                    )
                )
            )],
            output_data_config=dynamodb.aws_stepfunctions_tasks.OutputDataConfig(
                s3_output_location=tasks.S3Location.from_bucket(s3.Bucket.from_bucket_name(self, "Bucket", "mybucket"), "myoutputpath")
            ),
            resource_config=dynamodb.aws_stepfunctions_tasks.ResourceConfig(
                instance_count=1,
                instance_type=ec2.InstanceType(sfn.JsonPath.string_at("$.InstanceType")),
                volume_size=Size.gibibytes(50)
            ),  # optional: default is 1 instance of EC2 `M4.XLarge` with `10GB` volume
            stopping_condition=dynamodb.aws_stepfunctions_tasks.StoppingCondition(
                max_runtime=Duration.hours(2)
            )
        )
    '''

    PIPE = "PIPE"
    '''(experimental) Pipe mode.

    :stability: experimental
    '''
    FILE = "FILE"
    '''(experimental) File mode.

    :stability: experimental
    '''


@jsii.enum(jsii_type="monocdk.aws_stepfunctions_tasks.InvocationType")
class InvocationType(enum.Enum):
    '''(deprecated) Invocation type of a Lambda.

    :deprecated: use ``LambdaInvocationType``

    :stability: deprecated
    '''

    REQUEST_RESPONSE = "REQUEST_RESPONSE"
    '''(deprecated) Invoke synchronously.

    The API response includes the function response and additional data.

    :stability: deprecated
    '''
    EVENT = "EVENT"
    '''(deprecated) Invoke asynchronously.

    Send events that fail multiple times to the function's dead-letter queue (if it's configured).
    The API response only includes a status code.

    :stability: deprecated
    '''
    DRY_RUN = "DRY_RUN"
    '''(deprecated) TValidate parameter values and verify that the user or role has permission to invoke the function.

    :stability: deprecated
    '''


@jsii.implements(_IStepFunctionsTask_82eb09ab)
class InvokeActivity(
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.InvokeActivity",
):
    '''(deprecated) A Step Functions Task to invoke an Activity worker.

    An Activity can be used directly as a Resource.

    :deprecated: use ``StepFunctionsInvokeActivity``

    :stability: deprecated
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        import monocdk as monocdk
        from monocdk import aws_stepfunctions as stepfunctions
        from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
        
        # activity: stepfunctions.Activity
        # duration: monocdk.Duration
        
        invoke_activity = stepfunctions_tasks.InvokeActivity(activity,
            heartbeat=duration
        )
    '''

    def __init__(
        self,
        activity: _IActivity_4524952f,
        *,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
    ) -> None:
        '''
        :param activity: -
        :param heartbeat: (deprecated) Maximum time between heart beats. If the time between heart beats takes longer than this, a 'Timeout' error is raised. Default: No heart beat timeout

        :stability: deprecated
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__af53cd8c5c34c216808cdd97d2f1de9c92704a7d5613f0f5587b6fa63410a4a4)
            check_type(argname="argument activity", value=activity, expected_type=type_hints["activity"])
        props = InvokeActivityProps(heartbeat=heartbeat)

        jsii.create(self.__class__, self, [activity, props])

    @jsii.member(jsii_name="bind")
    def bind(self, _task: _Task_747ca4f2) -> _StepFunctionsTaskConfig_fa131821:
        '''(deprecated) Called when the task object is used in a workflow.

        :param _task: -

        :stability: deprecated
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1d9faf3eee50026bf2616f77ba1832aef1e7e5031f1a041cf5c3c4d40fa80740)
            check_type(argname="argument _task", value=_task, expected_type=type_hints["_task"])
        return typing.cast(_StepFunctionsTaskConfig_fa131821, jsii.invoke(self, "bind", [_task]))


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.InvokeActivityProps",
    jsii_struct_bases=[],
    name_mapping={"heartbeat": "heartbeat"},
)
class InvokeActivityProps:
    def __init__(
        self,
        *,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
    ) -> None:
        '''(deprecated) Properties for FunctionTask.

        :param heartbeat: (deprecated) Maximum time between heart beats. If the time between heart beats takes longer than this, a 'Timeout' error is raised. Default: No heart beat timeout

        :deprecated: use ``StepFunctionsInvokeActivity`` and ``StepFunctionsInvokeActivityProps``.

        :stability: deprecated
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            import monocdk as monocdk
            from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
            
            # duration: monocdk.Duration
            
            invoke_activity_props = stepfunctions_tasks.InvokeActivityProps(
                heartbeat=duration
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9e36fa17794305764f9d0b5aae88008ac8e9cdcc20902bd4e5b1fe4e00865ed6)
            check_type(argname="argument heartbeat", value=heartbeat, expected_type=type_hints["heartbeat"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if heartbeat is not None:
            self._values["heartbeat"] = heartbeat

    @builtins.property
    def heartbeat(self) -> typing.Optional[_Duration_070aa057]:
        '''(deprecated) Maximum time between heart beats.

        If the time between heart beats takes longer than this, a 'Timeout' error is raised.

        :default: No heart beat timeout

        :stability: deprecated
        '''
        result = self._values.get("heartbeat")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "InvokeActivityProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IStepFunctionsTask_82eb09ab)
class InvokeFunction(
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.InvokeFunction",
):
    '''(deprecated) A Step Functions Task to invoke a Lambda function.

    The Lambda function Arn is defined as Resource in the state machine definition.

    OUTPUT: the output of this task is the return value of the Lambda Function.

    :deprecated: Use ``LambdaInvoke``

    :stability: deprecated
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from monocdk import aws_lambda as lambda_
        from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
        
        # function_: lambda.Function
        # payload: Any
        
        invoke_function = stepfunctions_tasks.InvokeFunction(function_,
            payload={
                "payload_key": payload
            }
        )
    '''

    def __init__(
        self,
        lambda_function: _IFunction_6e14f09e,
        *,
        payload: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    ) -> None:
        '''
        :param lambda_function: -
        :param payload: (deprecated) The JSON that you want to provide to your Lambda function as input. This parameter is named as payload to keep consistent with RunLambdaTask class. Default: - The JSON data indicated by the task's InputPath is used as payload

        :stability: deprecated
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__05648f1c06eee80dc9730e0fac2030a0177c18c649abba6711349fd6aabaff91)
            check_type(argname="argument lambda_function", value=lambda_function, expected_type=type_hints["lambda_function"])
        props = InvokeFunctionProps(payload=payload)

        jsii.create(self.__class__, self, [lambda_function, props])

    @jsii.member(jsii_name="bind")
    def bind(self, _task: _Task_747ca4f2) -> _StepFunctionsTaskConfig_fa131821:
        '''(deprecated) Called when the task object is used in a workflow.

        :param _task: -

        :stability: deprecated
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b6309970979b53bba42a0bd3164727193d778901e0629d8dfa8d226a6cc50371)
            check_type(argname="argument _task", value=_task, expected_type=type_hints["_task"])
        return typing.cast(_StepFunctionsTaskConfig_fa131821, jsii.invoke(self, "bind", [_task]))


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.InvokeFunctionProps",
    jsii_struct_bases=[],
    name_mapping={"payload": "payload"},
)
class InvokeFunctionProps:
    def __init__(
        self,
        *,
        payload: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    ) -> None:
        '''(deprecated) Properties for InvokeFunction.

        :param payload: (deprecated) The JSON that you want to provide to your Lambda function as input. This parameter is named as payload to keep consistent with RunLambdaTask class. Default: - The JSON data indicated by the task's InputPath is used as payload

        :deprecated: use ``LambdaInvoke``

        :stability: deprecated
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
            
            # payload: Any
            
            invoke_function_props = stepfunctions_tasks.InvokeFunctionProps(
                payload={
                    "payload_key": payload
                }
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1434d05684e9f5ba95c534058cecba56f1bf1b0cdc597969db4a29dea1542f5b)
            check_type(argname="argument payload", value=payload, expected_type=type_hints["payload"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if payload is not None:
            self._values["payload"] = payload

    @builtins.property
    def payload(self) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(deprecated) The JSON that you want to provide to your Lambda function as input.

        This parameter is named as payload to keep consistent with RunLambdaTask class.

        :default: - The JSON data indicated by the task's InputPath is used as payload

        :stability: deprecated
        '''
        result = self._values.get("payload")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "InvokeFunctionProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.JobDependency",
    jsii_struct_bases=[],
    name_mapping={"job_id": "jobId", "type": "type"},
)
class JobDependency:
    def __init__(
        self,
        *,
        job_id: typing.Optional[builtins.str] = None,
        type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''(experimental) An object representing an AWS Batch job dependency.

        :param job_id: (experimental) The job ID of the AWS Batch job associated with this dependency. Default: - No jobId
        :param type: (experimental) The type of the job dependency. Default: - No type

        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
            
            job_dependency = stepfunctions_tasks.JobDependency(
                job_id="jobId",
                type="type"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__afcf8bb3736a14739da99cc56dad750c52607c57e8bf79ade4520e4393259be5)
            check_type(argname="argument job_id", value=job_id, expected_type=type_hints["job_id"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if job_id is not None:
            self._values["job_id"] = job_id
        if type is not None:
            self._values["type"] = type

    @builtins.property
    def job_id(self) -> typing.Optional[builtins.str]:
        '''(experimental) The job ID of the AWS Batch job associated with this dependency.

        :default: - No jobId

        :stability: experimental
        '''
        result = self._values.get("job_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''(experimental) The type of the job dependency.

        :default: - No type

        :stability: experimental
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "JobDependency(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.JobDriver",
    jsii_struct_bases=[],
    name_mapping={"spark_submit_job_driver": "sparkSubmitJobDriver"},
)
class JobDriver:
    def __init__(
        self,
        *,
        spark_submit_job_driver: typing.Union["SparkSubmitJobDriver", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''(experimental) Specify the driver that the EMR Containers job runs on.

        The job driver is used to provide an input for the job that will be run.

        :param spark_submit_job_driver: (experimental) The job driver parameters specified for spark submit.

        :stability: experimental
        :exampleMetadata: infused

        Example::

            tasks.EmrContainersStartJobRun(self, "EMR Containers Start Job Run",
                virtual_cluster=tasks.VirtualClusterInput.from_virtual_cluster_id("de92jdei2910fwedz"),
                release_label=tasks.ReleaseLabel.EMR_6_2_0,
                job_name="EMR-Containers-Job",
                job_driver=dynamodb.aws_stepfunctions_tasks.JobDriver(
                    spark_submit_job_driver=dynamodb.aws_stepfunctions_tasks.SparkSubmitJobDriver(
                        entry_point=sfn.TaskInput.from_text("local:///usr/lib/spark/examples/src/main/python/pi.py")
                    )
                ),
                application_config=[dynamodb.aws_stepfunctions_tasks.ApplicationConfiguration(
                    classification=tasks.Classification.SPARK_DEFAULTS,
                    properties={
                        "spark.executor.instances": "1",
                        "spark.executor.memory": "512M"
                    }
                )]
            )
        '''
        if isinstance(spark_submit_job_driver, dict):
            spark_submit_job_driver = SparkSubmitJobDriver(**spark_submit_job_driver)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__27b63bf75f018407d586bbf4a22d2d81f55bd8baca7ee05c13d12db86440d333)
            check_type(argname="argument spark_submit_job_driver", value=spark_submit_job_driver, expected_type=type_hints["spark_submit_job_driver"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "spark_submit_job_driver": spark_submit_job_driver,
        }

    @builtins.property
    def spark_submit_job_driver(self) -> "SparkSubmitJobDriver":
        '''(experimental) The job driver parameters specified for spark submit.

        :see: https://docs.aws.amazon.com/emr-on-eks/latest/APIReference/API_SparkSubmitJobDriver.html
        :stability: experimental
        '''
        result = self._values.get("spark_submit_job_driver")
        assert result is not None, "Required property 'spark_submit_job_driver' is missing"
        return typing.cast("SparkSubmitJobDriver", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "JobDriver(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="monocdk.aws_stepfunctions_tasks.LambdaInvocationType")
class LambdaInvocationType(enum.Enum):
    '''(experimental) Invocation type of a Lambda.

    :stability: experimental
    :exampleMetadata: infused

    Example::

        # fn: lambda.Function
        
        
        submit_job = tasks.LambdaInvoke(self, "Invoke Handler",
            lambda_function=fn,
            payload=sfn.TaskInput.from_json_path_at("$.input"),
            invocation_type=tasks.LambdaInvocationType.EVENT
        )
    '''

    REQUEST_RESPONSE = "REQUEST_RESPONSE"
    '''(experimental) Invoke the function synchronously.

    Keep the connection open until the function returns a response or times out.
    The API response includes the function response and additional data.

    :stability: experimental
    '''
    EVENT = "EVENT"
    '''(experimental) Invoke the function asynchronously.

    Send events that fail multiple times to the function's dead-letter queue (if it's configured).
    The API response only includes a status code.

    :stability: experimental
    '''
    DRY_RUN = "DRY_RUN"
    '''(experimental) Validate parameter values and verify that the user or role has permission to invoke the function.

    :stability: experimental
    '''


class LambdaInvoke(
    _TaskStateBase_c3080646,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.LambdaInvoke",
):
    '''(experimental) Invoke a Lambda function as a Task.

    :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-lambda.html
    :stability: experimental
    :exampleMetadata: infused

    Example::

        import monocdk as lambda_
        
        # order_fn: lambda.Function
        
        
        submit_job = tasks.LambdaInvoke(self, "InvokeOrderProcessor",
            lambda_function=order_fn,
            payload=sfn.TaskInput.from_object({
                "OrderId": sfn.JsonPath.string_at("$.OrderId")
            })
        )
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        lambda_function: _IFunction_6e14f09e,
        client_context: typing.Optional[builtins.str] = None,
        invocation_type: typing.Optional[LambdaInvocationType] = None,
        payload: typing.Optional[_TaskInput_71ab46f6] = None,
        payload_response_only: typing.Optional[builtins.bool] = None,
        qualifier: typing.Optional[builtins.str] = None,
        retry_on_service_exceptions: typing.Optional[builtins.bool] = None,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param lambda_function: (experimental) Lambda function to invoke.
        :param client_context: (experimental) Up to 3583 bytes of base64-encoded data about the invoking client to pass to the function. Default: - No context
        :param invocation_type: (experimental) Invocation type of the Lambda function. Default: InvocationType.REQUEST_RESPONSE
        :param payload: (experimental) The JSON that will be supplied as input to the Lambda function. Default: - The state input (JSON path '$')
        :param payload_response_only: (experimental) Invoke the Lambda in a way that only returns the payload response without additional metadata. The ``payloadResponseOnly`` property cannot be used if ``integrationPattern``, ``invocationType``, ``clientContext``, or ``qualifier`` are specified. It always uses the REQUEST_RESPONSE behavior. Default: false
        :param qualifier: (deprecated) Version or alias to invoke a published version of the function. You only need to supply this if you want the version of the Lambda Function to depend on data in the state machine state. If not, you can pass the appropriate Alias or Version object directly as the ``lambdaFunction`` argument. Default: - Version or alias inherent to the ``lambdaFunction`` object.
        :param retry_on_service_exceptions: (experimental) Whether to retry on Lambda service exceptions. This handles ``Lambda.ServiceException``, ``Lambda.AWSLambdaException`` and ``Lambda.SdkClientException`` with an interval of 2 seconds, a back-off rate of 2 and 6 maximum attempts. Default: true
        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e46d794f3aa056d13dc307e1d2c9cd9cbf2ca41a1e42fb826b46cd9f31d8ac85)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = LambdaInvokeProps(
            lambda_function=lambda_function,
            client_context=client_context,
            invocation_type=invocation_type,
            payload=payload,
            payload_response_only=payload_response_only,
            qualifier=qualifier,
            retry_on_service_exceptions=retry_on_service_exceptions,
            comment=comment,
            heartbeat=heartbeat,
            input_path=input_path,
            integration_pattern=integration_pattern,
            output_path=output_path,
            result_path=result_path,
            result_selector=result_selector,
            timeout=timeout,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="taskMetrics")
    def _task_metrics(self) -> typing.Optional[_TaskMetricsConfig_5aaea59e]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[_TaskMetricsConfig_5aaea59e], jsii.get(self, "taskMetrics"))

    @builtins.property
    @jsii.member(jsii_name="taskPolicies")
    def _task_policies(self) -> typing.Optional[typing.List[_PolicyStatement_296fe8a3]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.List[_PolicyStatement_296fe8a3]], jsii.get(self, "taskPolicies"))


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.LambdaInvokeProps",
    jsii_struct_bases=[_TaskStateBaseProps_b13f6332],
    name_mapping={
        "comment": "comment",
        "heartbeat": "heartbeat",
        "input_path": "inputPath",
        "integration_pattern": "integrationPattern",
        "output_path": "outputPath",
        "result_path": "resultPath",
        "result_selector": "resultSelector",
        "timeout": "timeout",
        "lambda_function": "lambdaFunction",
        "client_context": "clientContext",
        "invocation_type": "invocationType",
        "payload": "payload",
        "payload_response_only": "payloadResponseOnly",
        "qualifier": "qualifier",
        "retry_on_service_exceptions": "retryOnServiceExceptions",
    },
)
class LambdaInvokeProps(_TaskStateBaseProps_b13f6332):
    def __init__(
        self,
        *,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
        lambda_function: _IFunction_6e14f09e,
        client_context: typing.Optional[builtins.str] = None,
        invocation_type: typing.Optional[LambdaInvocationType] = None,
        payload: typing.Optional[_TaskInput_71ab46f6] = None,
        payload_response_only: typing.Optional[builtins.bool] = None,
        qualifier: typing.Optional[builtins.str] = None,
        retry_on_service_exceptions: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''(experimental) Properties for invoking a Lambda function with LambdaInvoke.

        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None
        :param lambda_function: (experimental) Lambda function to invoke.
        :param client_context: (experimental) Up to 3583 bytes of base64-encoded data about the invoking client to pass to the function. Default: - No context
        :param invocation_type: (experimental) Invocation type of the Lambda function. Default: InvocationType.REQUEST_RESPONSE
        :param payload: (experimental) The JSON that will be supplied as input to the Lambda function. Default: - The state input (JSON path '$')
        :param payload_response_only: (experimental) Invoke the Lambda in a way that only returns the payload response without additional metadata. The ``payloadResponseOnly`` property cannot be used if ``integrationPattern``, ``invocationType``, ``clientContext``, or ``qualifier`` are specified. It always uses the REQUEST_RESPONSE behavior. Default: false
        :param qualifier: (deprecated) Version or alias to invoke a published version of the function. You only need to supply this if you want the version of the Lambda Function to depend on data in the state machine state. If not, you can pass the appropriate Alias or Version object directly as the ``lambdaFunction`` argument. Default: - Version or alias inherent to the ``lambdaFunction`` object.
        :param retry_on_service_exceptions: (experimental) Whether to retry on Lambda service exceptions. This handles ``Lambda.ServiceException``, ``Lambda.AWSLambdaException`` and ``Lambda.SdkClientException`` with an interval of 2 seconds, a back-off rate of 2 and 6 maximum attempts. Default: true

        :stability: experimental
        :exampleMetadata: infused

        Example::

            import monocdk as lambda_
            
            # order_fn: lambda.Function
            
            
            submit_job = tasks.LambdaInvoke(self, "InvokeOrderProcessor",
                lambda_function=order_fn,
                payload=sfn.TaskInput.from_object({
                    "OrderId": sfn.JsonPath.string_at("$.OrderId")
                })
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dd2bdfb3e4319c9c6bacf133aaa8034c4393055c5108cc5c21c8344590f94238)
            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
            check_type(argname="argument heartbeat", value=heartbeat, expected_type=type_hints["heartbeat"])
            check_type(argname="argument input_path", value=input_path, expected_type=type_hints["input_path"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
            check_type(argname="argument output_path", value=output_path, expected_type=type_hints["output_path"])
            check_type(argname="argument result_path", value=result_path, expected_type=type_hints["result_path"])
            check_type(argname="argument result_selector", value=result_selector, expected_type=type_hints["result_selector"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
            check_type(argname="argument lambda_function", value=lambda_function, expected_type=type_hints["lambda_function"])
            check_type(argname="argument client_context", value=client_context, expected_type=type_hints["client_context"])
            check_type(argname="argument invocation_type", value=invocation_type, expected_type=type_hints["invocation_type"])
            check_type(argname="argument payload", value=payload, expected_type=type_hints["payload"])
            check_type(argname="argument payload_response_only", value=payload_response_only, expected_type=type_hints["payload_response_only"])
            check_type(argname="argument qualifier", value=qualifier, expected_type=type_hints["qualifier"])
            check_type(argname="argument retry_on_service_exceptions", value=retry_on_service_exceptions, expected_type=type_hints["retry_on_service_exceptions"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "lambda_function": lambda_function,
        }
        if comment is not None:
            self._values["comment"] = comment
        if heartbeat is not None:
            self._values["heartbeat"] = heartbeat
        if input_path is not None:
            self._values["input_path"] = input_path
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern
        if output_path is not None:
            self._values["output_path"] = output_path
        if result_path is not None:
            self._values["result_path"] = result_path
        if result_selector is not None:
            self._values["result_selector"] = result_selector
        if timeout is not None:
            self._values["timeout"] = timeout
        if client_context is not None:
            self._values["client_context"] = client_context
        if invocation_type is not None:
            self._values["invocation_type"] = invocation_type
        if payload is not None:
            self._values["payload"] = payload
        if payload_response_only is not None:
            self._values["payload_response_only"] = payload_response_only
        if qualifier is not None:
            self._values["qualifier"] = qualifier
        if retry_on_service_exceptions is not None:
            self._values["retry_on_service_exceptions"] = retry_on_service_exceptions

    @builtins.property
    def comment(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional description for this state.

        :default: - No comment

        :stability: experimental
        '''
        result = self._values.get("comment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def heartbeat(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the heartbeat.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("heartbeat")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def input_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select part of the state to be the input to this state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        input to be the empty object {}.

        :default: - The entire task input (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("input_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def integration_pattern(self) -> typing.Optional[_IntegrationPattern_fbb35786]:
        '''(experimental) AWS Step Functions integrates with services directly in the Amazon States Language.

        You can control these AWS services using service integration patterns

        :default:

        - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks.
        ``IntegrationPattern.RUN_JOB`` for the following exceptions:
        ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html#connect-wait-token
        :stability: experimental
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_IntegrationPattern_fbb35786], result)

    @builtins.property
    def output_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select select a portion of the state output to pass to the next state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        output to be the empty object {}.

        :default:

        - The entire JSON node determined by the state input, the task result,
        and resultPath is passed to the next state (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("output_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to indicate where to inject the state's output.

        May also be the special value JsonPath.DISCARD, which will cause the state's
        input to become its output.

        :default: - Replaces the entire input with the result (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("result_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied.

        You can use ResultSelector to create a payload with values that are static
        or selected from the state's raw result.

        :default: - None

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/input-output-inputpath-params.html#input-output-resultselector
        :stability: experimental
        '''
        result = self._values.get("result_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def timeout(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the state machine.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def lambda_function(self) -> _IFunction_6e14f09e:
        '''(experimental) Lambda function to invoke.

        :stability: experimental
        '''
        result = self._values.get("lambda_function")
        assert result is not None, "Required property 'lambda_function' is missing"
        return typing.cast(_IFunction_6e14f09e, result)

    @builtins.property
    def client_context(self) -> typing.Optional[builtins.str]:
        '''(experimental) Up to 3583 bytes of base64-encoded data about the invoking client to pass to the function.

        :default: - No context

        :stability: experimental
        '''
        result = self._values.get("client_context")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def invocation_type(self) -> typing.Optional[LambdaInvocationType]:
        '''(experimental) Invocation type of the Lambda function.

        :default: InvocationType.REQUEST_RESPONSE

        :stability: experimental
        '''
        result = self._values.get("invocation_type")
        return typing.cast(typing.Optional[LambdaInvocationType], result)

    @builtins.property
    def payload(self) -> typing.Optional[_TaskInput_71ab46f6]:
        '''(experimental) The JSON that will be supplied as input to the Lambda function.

        :default: - The state input (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("payload")
        return typing.cast(typing.Optional[_TaskInput_71ab46f6], result)

    @builtins.property
    def payload_response_only(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Invoke the Lambda in a way that only returns the payload response without additional metadata.

        The ``payloadResponseOnly`` property cannot be used if ``integrationPattern``, ``invocationType``,
        ``clientContext``, or ``qualifier`` are specified.
        It always uses the REQUEST_RESPONSE behavior.

        :default: false

        :stability: experimental
        '''
        result = self._values.get("payload_response_only")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def qualifier(self) -> typing.Optional[builtins.str]:
        '''(deprecated) Version or alias to invoke a published version of the function.

        You only need to supply this if you want the version of the Lambda Function to depend
        on data in the state machine state. If not, you can pass the appropriate Alias or Version object
        directly as the ``lambdaFunction`` argument.

        :default: - Version or alias inherent to the ``lambdaFunction`` object.

        :deprecated: pass a Version or Alias object as lambdaFunction instead

        :stability: deprecated
        '''
        result = self._values.get("qualifier")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def retry_on_service_exceptions(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Whether to retry on Lambda service exceptions.

        This handles ``Lambda.ServiceException``, ``Lambda.AWSLambdaException`` and
        ``Lambda.SdkClientException`` with an interval of 2 seconds, a back-off rate
        of 2 and 6 maximum attempts.

        :default: true

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/bp-lambda-serviceexception.html
        :stability: experimental
        '''
        result = self._values.get("retry_on_service_exceptions")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LambdaInvokeProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.LaunchTargetBindOptions",
    jsii_struct_bases=[],
    name_mapping={"task_definition": "taskDefinition", "cluster": "cluster"},
)
class LaunchTargetBindOptions:
    def __init__(
        self,
        *,
        task_definition: _ITaskDefinition_ee0d1862,
        cluster: typing.Optional[_ICluster_42c4ec1a] = None,
    ) -> None:
        '''(experimental) Options for binding a launch target to an ECS run job task.

        :param task_definition: (experimental) Task definition to run Docker containers in Amazon ECS.
        :param cluster: (experimental) A regional grouping of one or more container instances on which you can run tasks and services. Default: - No cluster

        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_ecs as ecs
            from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
            
            # cluster: ecs.Cluster
            # task_definition: ecs.TaskDefinition
            
            launch_target_bind_options = stepfunctions_tasks.LaunchTargetBindOptions(
                task_definition=task_definition,
            
                # the properties below are optional
                cluster=cluster
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__660c84d4bc50145e150d416b117c8fbcd77fc5f42c348d92f236700c2742356c)
            check_type(argname="argument task_definition", value=task_definition, expected_type=type_hints["task_definition"])
            check_type(argname="argument cluster", value=cluster, expected_type=type_hints["cluster"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "task_definition": task_definition,
        }
        if cluster is not None:
            self._values["cluster"] = cluster

    @builtins.property
    def task_definition(self) -> _ITaskDefinition_ee0d1862:
        '''(experimental) Task definition to run Docker containers in Amazon ECS.

        :stability: experimental
        '''
        result = self._values.get("task_definition")
        assert result is not None, "Required property 'task_definition' is missing"
        return typing.cast(_ITaskDefinition_ee0d1862, result)

    @builtins.property
    def cluster(self) -> typing.Optional[_ICluster_42c4ec1a]:
        '''(experimental) A regional grouping of one or more container instances on which you can run tasks and services.

        :default: - No cluster

        :stability: experimental
        '''
        result = self._values.get("cluster")
        return typing.cast(typing.Optional[_ICluster_42c4ec1a], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LaunchTargetBindOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.MessageAttribute",
    jsii_struct_bases=[],
    name_mapping={"value": "value", "data_type": "dataType"},
)
class MessageAttribute:
    def __init__(
        self,
        *,
        value: typing.Any,
        data_type: typing.Optional["MessageAttributeDataType"] = None,
    ) -> None:
        '''(experimental) A message attribute to add to the SNS message.

        :param value: (experimental) The value of the attribute.
        :param data_type: (experimental) The data type for the attribute. Default: determined by type inspection if possible, fallback is String

        :see: https://docs.aws.amazon.com/sns/latest/dg/sns-message-attributes.html
        :stability: experimental
        :exampleMetadata: infused

        Example::

            topic = sns.Topic(self, "Topic")
            
            # Use a field from the execution data as message.
            task1 = tasks.SnsPublish(self, "Publish1",
                topic=topic,
                integration_pattern=sfn.IntegrationPattern.REQUEST_RESPONSE,
                message=sfn.TaskInput.from_data_at("$.state.message"),
                message_attributes={
                    "place": dynamodb.aws_stepfunctions_tasks.MessageAttribute(
                        value=sfn.JsonPath.string_at("$.place")
                    ),
                    "pic": dynamodb.aws_stepfunctions_tasks.MessageAttribute(
                        # BINARY must be explicitly set
                        data_type=tasks.MessageAttributeDataType.BINARY,
                        value=sfn.JsonPath.string_at("$.pic")
                    ),
                    "people": dynamodb.aws_stepfunctions_tasks.MessageAttribute(
                        value=4
                    ),
                    "handles": dynamodb.aws_stepfunctions_tasks.MessageAttribute(
                        value=["@kslater", "@jjf", null, "@mfanning"]
                    )
                }
            )
            
            # Combine a field from the execution data with
            # a literal object.
            task2 = tasks.SnsPublish(self, "Publish2",
                topic=topic,
                message=sfn.TaskInput.from_object({
                    "field1": "somedata",
                    "field2": sfn.JsonPath.string_at("$.field2")
                })
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fb5fc4b80d4033a1fa69f1e9d0a1cd8230ce2f5c6a70d43a751a671cb7401df2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            check_type(argname="argument data_type", value=data_type, expected_type=type_hints["data_type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "value": value,
        }
        if data_type is not None:
            self._values["data_type"] = data_type

    @builtins.property
    def value(self) -> typing.Any:
        '''(experimental) The value of the attribute.

        :stability: experimental
        '''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(typing.Any, result)

    @builtins.property
    def data_type(self) -> typing.Optional["MessageAttributeDataType"]:
        '''(experimental) The data type for the attribute.

        :default: determined by type inspection if possible, fallback is String

        :see: https://docs.aws.amazon.com/sns/latest/dg/sns-message-attributes.html#SNSMessageAttributes.DataTypes
        :stability: experimental
        '''
        result = self._values.get("data_type")
        return typing.cast(typing.Optional["MessageAttributeDataType"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "MessageAttribute(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="monocdk.aws_stepfunctions_tasks.MessageAttributeDataType")
class MessageAttributeDataType(enum.Enum):
    '''(experimental) The data type set for the SNS message attributes.

    :see: https://docs.aws.amazon.com/sns/latest/dg/sns-message-attributes.html#SNSMessageAttributes.DataTypes
    :stability: experimental
    :exampleMetadata: infused

    Example::

        topic = sns.Topic(self, "Topic")
        
        # Use a field from the execution data as message.
        task1 = tasks.SnsPublish(self, "Publish1",
            topic=topic,
            integration_pattern=sfn.IntegrationPattern.REQUEST_RESPONSE,
            message=sfn.TaskInput.from_data_at("$.state.message"),
            message_attributes={
                "place": dynamodb.aws_stepfunctions_tasks.MessageAttribute(
                    value=sfn.JsonPath.string_at("$.place")
                ),
                "pic": dynamodb.aws_stepfunctions_tasks.MessageAttribute(
                    # BINARY must be explicitly set
                    data_type=tasks.MessageAttributeDataType.BINARY,
                    value=sfn.JsonPath.string_at("$.pic")
                ),
                "people": dynamodb.aws_stepfunctions_tasks.MessageAttribute(
                    value=4
                ),
                "handles": dynamodb.aws_stepfunctions_tasks.MessageAttribute(
                    value=["@kslater", "@jjf", null, "@mfanning"]
                )
            }
        )
        
        # Combine a field from the execution data with
        # a literal object.
        task2 = tasks.SnsPublish(self, "Publish2",
            topic=topic,
            message=sfn.TaskInput.from_object({
                "field1": "somedata",
                "field2": sfn.JsonPath.string_at("$.field2")
            })
        )
    '''

    STRING = "STRING"
    '''(experimental) Strings are Unicode with UTF-8 binary encoding.

    :stability: experimental
    '''
    STRING_ARRAY = "STRING_ARRAY"
    '''(experimental) An array, formatted as a string.

    :see: https://docs.aws.amazon.com/sns/latest/dg/sns-message-attributes.html#SNSMessageAttributes.DataTypes
    :stability: experimental
    '''
    NUMBER = "NUMBER"
    '''(experimental) Numbers are positive or negative integers or floating-point numbers.

    :see: https://docs.aws.amazon.com/sns/latest/dg/sns-message-attributes.html#SNSMessageAttributes.DataTypes
    :stability: experimental
    '''
    BINARY = "BINARY"
    '''(experimental) Binary type attributes can store any binary data.

    :see: https://docs.aws.amazon.com/sns/latest/dg/sns-message-attributes.html#SNSMessageAttributes.DataTypes
    :stability: experimental
    '''


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.MetricDefinition",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "regex": "regex"},
)
class MetricDefinition:
    def __init__(self, *, name: builtins.str, regex: builtins.str) -> None:
        '''(experimental) Specifies the metric name and regular expressions used to parse algorithm logs.

        :param name: (experimental) Name of the metric.
        :param regex: (experimental) Regular expression that searches the output of a training job and gets the value of the metric.

        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
            
            metric_definition = stepfunctions_tasks.MetricDefinition(
                name="name",
                regex="regex"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c58e2cf8cf19ebcd227d250131280ae233f594b977bec71973cfc6c15adb21db)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument regex", value=regex, expected_type=type_hints["regex"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
            "regex": regex,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''(experimental) Name of the metric.

        :stability: experimental
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def regex(self) -> builtins.str:
        '''(experimental) Regular expression that searches the output of a training job and gets the value of the metric.

        :stability: experimental
        '''
        result = self._values.get("regex")
        assert result is not None, "Required property 'regex' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "MetricDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="monocdk.aws_stepfunctions_tasks.Mode")
class Mode(enum.Enum):
    '''(experimental) Specifies how many models the container hosts.

    :stability: experimental
    :exampleMetadata: infused

    Example::

        tasks.SageMakerCreateModel(self, "Sagemaker",
            model_name="MyModel",
            primary_container=tasks.ContainerDefinition(
                image=tasks.DockerImage.from_json_expression(sfn.JsonPath.string_at("$.Model.imageName")),
                mode=tasks.Mode.SINGLE_MODEL,
                model_s3_location=tasks.S3Location.from_json_expression("$.TrainingJob.ModelArtifacts.S3ModelArtifacts")
            )
        )
    '''

    SINGLE_MODEL = "SINGLE_MODEL"
    '''(experimental) Container hosts a single model.

    :stability: experimental
    '''
    MULTI_MODEL = "MULTI_MODEL"
    '''(experimental) Container hosts multiple models.

    :see: https://docs.aws.amazon.com/sagemaker/latest/dg/multi-model-endpoints.html
    :stability: experimental
    '''


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.ModelClientOptions",
    jsii_struct_bases=[],
    name_mapping={
        "invocations_max_retries": "invocationsMaxRetries",
        "invocations_timeout": "invocationsTimeout",
    },
)
class ModelClientOptions:
    def __init__(
        self,
        *,
        invocations_max_retries: typing.Optional[jsii.Number] = None,
        invocations_timeout: typing.Optional[_Duration_070aa057] = None,
    ) -> None:
        '''(experimental) Configures the timeout and maximum number of retries for processing a transform job invocation.

        :param invocations_max_retries: (experimental) The maximum number of retries when invocation requests are failing. Default: 0
        :param invocations_timeout: (experimental) The timeout duration for an invocation request. Default: Duration.minutes(1)

        :stability: experimental
        :exampleMetadata: infused

        Example::

            tasks.SageMakerCreateTransformJob(self, "Batch Inference",
                transform_job_name="MyTransformJob",
                model_name="MyModelName",
                model_client_options=dynamodb.aws_stepfunctions_tasks.ModelClientOptions(
                    invocations_max_retries=3,  # default is 0
                    invocations_timeout=Duration.minutes(5)
                ),
                transform_input=dynamodb.aws_stepfunctions_tasks.TransformInput(
                    transform_data_source=dynamodb.aws_stepfunctions_tasks.TransformDataSource(
                        s3_data_source=dynamodb.aws_stepfunctions_tasks.TransformS3DataSource(
                            s3_uri="s3://inputbucket/train",
                            s3_data_type=tasks.S3DataType.S3_PREFIX
                        )
                    )
                ),
                transform_output=dynamodb.aws_stepfunctions_tasks.TransformOutput(
                    s3_output_path="s3://outputbucket/TransformJobOutputPath"
                ),
                transform_resources=dynamodb.aws_stepfunctions_tasks.TransformResources(
                    instance_count=1,
                    instance_type=ec2.InstanceType.of(ec2.InstanceClass.M4, ec2.InstanceSize.XLARGE)
                )
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b8ce32a56d555f0339f7f894455b01e67956e8f73b2a5ac506094938b516cce2)
            check_type(argname="argument invocations_max_retries", value=invocations_max_retries, expected_type=type_hints["invocations_max_retries"])
            check_type(argname="argument invocations_timeout", value=invocations_timeout, expected_type=type_hints["invocations_timeout"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if invocations_max_retries is not None:
            self._values["invocations_max_retries"] = invocations_max_retries
        if invocations_timeout is not None:
            self._values["invocations_timeout"] = invocations_timeout

    @builtins.property
    def invocations_max_retries(self) -> typing.Optional[jsii.Number]:
        '''(experimental) The maximum number of retries when invocation requests are failing.

        :default: 0

        :stability: experimental
        '''
        result = self._values.get("invocations_max_retries")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def invocations_timeout(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) The timeout duration for an invocation request.

        :default: Duration.minutes(1)

        :stability: experimental
        '''
        result = self._values.get("invocations_timeout")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ModelClientOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.Monitoring",
    jsii_struct_bases=[],
    name_mapping={
        "log_bucket": "logBucket",
        "logging": "logging",
        "log_group": "logGroup",
        "log_stream_name_prefix": "logStreamNamePrefix",
        "persistent_app_ui": "persistentAppUI",
    },
)
class Monitoring:
    def __init__(
        self,
        *,
        log_bucket: typing.Optional[_IBucket_73486e29] = None,
        logging: typing.Optional[builtins.bool] = None,
        log_group: typing.Optional[_ILogGroup_846e17a0] = None,
        log_stream_name_prefix: typing.Optional[builtins.str] = None,
        persistent_app_ui: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''(experimental) Configuration setting for monitoring.

        :param log_bucket: (experimental) Amazon S3 Bucket for monitoring log publishing. You can configure your jobs to send log information to Amazon S3. Default: - if ``logging`` is manually set to ``true`` and a ``logBucket`` is not provided, a ``logBucket`` will be automatically generated`.
        :param logging: (experimental) Enable logging for this job. If set to true, will automatically create a Cloudwatch Log Group and S3 bucket. This will be set to ``true`` implicitly if values are provided for ``logGroup`` or ``logBucket``. Default: true - true if values are provided for ``logGroup`` or ``logBucket``, false otherwise
        :param log_group: (experimental) A log group for CloudWatch monitoring. You can configure your jobs to send log information to CloudWatch Logs. Default: - if ``logging`` is manually set to ``true`` and a ``logGroup`` is not provided, a ``logGroup`` will be automatically generated`.
        :param log_stream_name_prefix: (experimental) A log stream name prefix for Cloudwatch monitoring. Default: - Log streams created in this log group have no default prefix
        :param persistent_app_ui: (experimental) Monitoring configurations for the persistent application UI. Default: true

        :stability: experimental
        :exampleMetadata: infused

        Example::

            tasks.EmrContainersStartJobRun(self, "EMR Containers Start Job Run",
                virtual_cluster=tasks.VirtualClusterInput.from_virtual_cluster_id("de92jdei2910fwedz"),
                release_label=tasks.ReleaseLabel.EMR_6_2_0,
                job_driver=dynamodb.aws_stepfunctions_tasks.JobDriver(
                    spark_submit_job_driver=dynamodb.aws_stepfunctions_tasks.SparkSubmitJobDriver(
                        entry_point=sfn.TaskInput.from_text("local:///usr/lib/spark/examples/src/main/python/pi.py"),
                        spark_submit_parameters="--conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.executor.cores=2 --conf spark.driver.cores=1"
                    )
                ),
                monitoring=dynamodb.aws_stepfunctions_tasks.Monitoring(
                    logging=True
                )
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9ad4a7297283a4b1be860a18eb37087129871f99f9710c01d141cf6d55813512)
            check_type(argname="argument log_bucket", value=log_bucket, expected_type=type_hints["log_bucket"])
            check_type(argname="argument logging", value=logging, expected_type=type_hints["logging"])
            check_type(argname="argument log_group", value=log_group, expected_type=type_hints["log_group"])
            check_type(argname="argument log_stream_name_prefix", value=log_stream_name_prefix, expected_type=type_hints["log_stream_name_prefix"])
            check_type(argname="argument persistent_app_ui", value=persistent_app_ui, expected_type=type_hints["persistent_app_ui"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if log_bucket is not None:
            self._values["log_bucket"] = log_bucket
        if logging is not None:
            self._values["logging"] = logging
        if log_group is not None:
            self._values["log_group"] = log_group
        if log_stream_name_prefix is not None:
            self._values["log_stream_name_prefix"] = log_stream_name_prefix
        if persistent_app_ui is not None:
            self._values["persistent_app_ui"] = persistent_app_ui

    @builtins.property
    def log_bucket(self) -> typing.Optional[_IBucket_73486e29]:
        '''(experimental) Amazon S3 Bucket for monitoring log publishing.

        You can configure your jobs to send log information to Amazon S3.

        :default: - if ``logging`` is manually set to ``true`` and a ``logBucket`` is not provided, a ``logBucket`` will be automatically generated`.

        :stability: experimental
        '''
        result = self._values.get("log_bucket")
        return typing.cast(typing.Optional[_IBucket_73486e29], result)

    @builtins.property
    def logging(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enable logging for this job.

        If set to true, will automatically create a Cloudwatch Log Group and S3 bucket.
        This will be set to ``true`` implicitly if values are provided for ``logGroup`` or ``logBucket``.

        :default: true - true if values are provided for ``logGroup`` or ``logBucket``, false otherwise

        :stability: experimental
        '''
        result = self._values.get("logging")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def log_group(self) -> typing.Optional[_ILogGroup_846e17a0]:
        '''(experimental) A log group for CloudWatch monitoring.

        You can configure your jobs to send log information to CloudWatch Logs.

        :default: - if ``logging`` is manually set to ``true`` and a ``logGroup`` is not provided, a ``logGroup`` will be automatically generated`.

        :stability: experimental
        '''
        result = self._values.get("log_group")
        return typing.cast(typing.Optional[_ILogGroup_846e17a0], result)

    @builtins.property
    def log_stream_name_prefix(self) -> typing.Optional[builtins.str]:
        '''(experimental) A log stream name prefix for Cloudwatch monitoring.

        :default: - Log streams created in this log group have no default prefix

        :stability: experimental
        '''
        result = self._values.get("log_stream_name_prefix")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def persistent_app_ui(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Monitoring configurations for the persistent application UI.

        :default: true

        :stability: experimental
        '''
        result = self._values.get("persistent_app_ui")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "Monitoring(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.OutputDataConfig",
    jsii_struct_bases=[],
    name_mapping={
        "s3_output_location": "s3OutputLocation",
        "encryption_key": "encryptionKey",
    },
)
class OutputDataConfig:
    def __init__(
        self,
        *,
        s3_output_location: "S3Location",
        encryption_key: typing.Optional[_IKey_36930160] = None,
    ) -> None:
        '''(experimental) Configures the S3 bucket where SageMaker will save the result of model training.

        :param s3_output_location: (experimental) Identifies the S3 path where you want Amazon SageMaker to store the model artifacts.
        :param encryption_key: (experimental) Optional KMS encryption key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption. Default: - Amazon SageMaker uses the default KMS key for Amazon S3 for your role's account

        :stability: experimental
        :exampleMetadata: infused

        Example::

            tasks.SageMakerCreateTrainingJob(self, "TrainSagemaker",
                training_job_name=sfn.JsonPath.string_at("$.JobName"),
                algorithm_specification=dynamodb.aws_stepfunctions_tasks.AlgorithmSpecification(
                    algorithm_name="BlazingText",
                    training_input_mode=tasks.InputMode.FILE
                ),
                input_data_config=[dynamodb.aws_stepfunctions_tasks.Channel(
                    channel_name="train",
                    data_source=dynamodb.aws_stepfunctions_tasks.DataSource(
                        s3_data_source=dynamodb.aws_stepfunctions_tasks.S3DataSource(
                            s3_data_type=tasks.S3DataType.S3_PREFIX,
                            s3_location=tasks.S3Location.from_json_expression("$.S3Bucket")
                        )
                    )
                )],
                output_data_config=dynamodb.aws_stepfunctions_tasks.OutputDataConfig(
                    s3_output_location=tasks.S3Location.from_bucket(s3.Bucket.from_bucket_name(self, "Bucket", "mybucket"), "myoutputpath")
                ),
                resource_config=dynamodb.aws_stepfunctions_tasks.ResourceConfig(
                    instance_count=1,
                    instance_type=ec2.InstanceType(sfn.JsonPath.string_at("$.InstanceType")),
                    volume_size=Size.gibibytes(50)
                ),  # optional: default is 1 instance of EC2 `M4.XLarge` with `10GB` volume
                stopping_condition=dynamodb.aws_stepfunctions_tasks.StoppingCondition(
                    max_runtime=Duration.hours(2)
                )
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__32bb8b4ecebc36c2c73f97899442cbac4197d571bffc9fcc4346e5ab5a5e456e)
            check_type(argname="argument s3_output_location", value=s3_output_location, expected_type=type_hints["s3_output_location"])
            check_type(argname="argument encryption_key", value=encryption_key, expected_type=type_hints["encryption_key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "s3_output_location": s3_output_location,
        }
        if encryption_key is not None:
            self._values["encryption_key"] = encryption_key

    @builtins.property
    def s3_output_location(self) -> "S3Location":
        '''(experimental) Identifies the S3 path where you want Amazon SageMaker to store the model artifacts.

        :stability: experimental
        '''
        result = self._values.get("s3_output_location")
        assert result is not None, "Required property 's3_output_location' is missing"
        return typing.cast("S3Location", result)

    @builtins.property
    def encryption_key(self) -> typing.Optional[_IKey_36930160]:
        '''(experimental) Optional KMS encryption key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption.

        :default: - Amazon SageMaker uses the default KMS key for Amazon S3 for your role's account

        :stability: experimental
        '''
        result = self._values.get("encryption_key")
        return typing.cast(typing.Optional[_IKey_36930160], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "OutputDataConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.ProductionVariant",
    jsii_struct_bases=[],
    name_mapping={
        "instance_type": "instanceType",
        "model_name": "modelName",
        "variant_name": "variantName",
        "accelerator_type": "acceleratorType",
        "initial_instance_count": "initialInstanceCount",
        "initial_variant_weight": "initialVariantWeight",
    },
)
class ProductionVariant:
    def __init__(
        self,
        *,
        instance_type: _InstanceType_072ad323,
        model_name: builtins.str,
        variant_name: builtins.str,
        accelerator_type: typing.Optional[AcceleratorType] = None,
        initial_instance_count: typing.Optional[jsii.Number] = None,
        initial_variant_weight: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''(experimental) Identifies a model that you want to host and the resources to deploy for hosting it.

        :param instance_type: (experimental) The ML compute instance type.
        :param model_name: (experimental) The name of the model that you want to host. This is the name that you specified when creating the model.
        :param variant_name: (experimental) The name of the production variant.
        :param accelerator_type: (experimental) The size of the Elastic Inference (EI) instance to use for the production variant. Default: - None
        :param initial_instance_count: (experimental) Number of instances to launch initially. Default: - 1
        :param initial_variant_weight: (experimental) Determines initial traffic distribution among all of the models that you specify in the endpoint configuration. Default: - 1.0

        :see: https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_ProductionVariant.html
        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_ec2 as ec2
            from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
            
            # accelerator_type: stepfunctions_tasks.AcceleratorType
            # instance_type: ec2.InstanceType
            
            production_variant = stepfunctions_tasks.ProductionVariant(
                instance_type=instance_type,
                model_name="modelName",
                variant_name="variantName",
            
                # the properties below are optional
                accelerator_type=accelerator_type,
                initial_instance_count=123,
                initial_variant_weight=123
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__459d279ec601800dd458d9d18f56450aa57f340add9a31d1bd1ce1dcc7b02dbd)
            check_type(argname="argument instance_type", value=instance_type, expected_type=type_hints["instance_type"])
            check_type(argname="argument model_name", value=model_name, expected_type=type_hints["model_name"])
            check_type(argname="argument variant_name", value=variant_name, expected_type=type_hints["variant_name"])
            check_type(argname="argument accelerator_type", value=accelerator_type, expected_type=type_hints["accelerator_type"])
            check_type(argname="argument initial_instance_count", value=initial_instance_count, expected_type=type_hints["initial_instance_count"])
            check_type(argname="argument initial_variant_weight", value=initial_variant_weight, expected_type=type_hints["initial_variant_weight"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "instance_type": instance_type,
            "model_name": model_name,
            "variant_name": variant_name,
        }
        if accelerator_type is not None:
            self._values["accelerator_type"] = accelerator_type
        if initial_instance_count is not None:
            self._values["initial_instance_count"] = initial_instance_count
        if initial_variant_weight is not None:
            self._values["initial_variant_weight"] = initial_variant_weight

    @builtins.property
    def instance_type(self) -> _InstanceType_072ad323:
        '''(experimental) The ML compute instance type.

        :stability: experimental
        '''
        result = self._values.get("instance_type")
        assert result is not None, "Required property 'instance_type' is missing"
        return typing.cast(_InstanceType_072ad323, result)

    @builtins.property
    def model_name(self) -> builtins.str:
        '''(experimental) The name of the model that you want to host.

        This is the name that you specified when creating the model.

        :stability: experimental
        '''
        result = self._values.get("model_name")
        assert result is not None, "Required property 'model_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def variant_name(self) -> builtins.str:
        '''(experimental) The name of the production variant.

        :stability: experimental
        '''
        result = self._values.get("variant_name")
        assert result is not None, "Required property 'variant_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def accelerator_type(self) -> typing.Optional[AcceleratorType]:
        '''(experimental) The size of the Elastic Inference (EI) instance to use for the production variant.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("accelerator_type")
        return typing.cast(typing.Optional[AcceleratorType], result)

    @builtins.property
    def initial_instance_count(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of instances to launch initially.

        :default: - 1

        :stability: experimental
        '''
        result = self._values.get("initial_instance_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def initial_variant_weight(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Determines initial traffic distribution among all of the models that you specify in the endpoint configuration.

        :default: - 1.0

        :stability: experimental
        '''
        result = self._values.get("initial_variant_weight")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ProductionVariant(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IStepFunctionsTask_82eb09ab)
class PublishToTopic(
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.PublishToTopic",
):
    '''(deprecated) A Step Functions Task to publish messages to SNS topic.

    A Function can be used directly as a Resource, but this class mirrors
    integration with other AWS services via a specific class instance.

    :deprecated: Use ``SnsPublish``

    :stability: deprecated
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from monocdk import aws_sns as sns
        from monocdk import aws_stepfunctions as stepfunctions
        from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
        
        # task_input: stepfunctions.TaskInput
        # topic: sns.Topic
        
        publish_to_topic = stepfunctions_tasks.PublishToTopic(topic,
            message=task_input,
        
            # the properties below are optional
            integration_pattern=stepfunctions.ServiceIntegrationPattern.FIRE_AND_FORGET,
            message_per_subscription_type=False,
            subject="subject"
        )
    '''

    def __init__(
        self,
        topic: _ITopic_465e36b9,
        *,
        message: _TaskInput_71ab46f6,
        integration_pattern: typing.Optional[_ServiceIntegrationPattern_5581ee88] = None,
        message_per_subscription_type: typing.Optional[builtins.bool] = None,
        subject: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param topic: -
        :param message: (deprecated) The text message to send to the topic.
        :param integration_pattern: (deprecated) The service integration pattern indicates different ways to call Publish to SNS. The valid value is either FIRE_AND_FORGET or WAIT_FOR_TASK_TOKEN. Default: FIRE_AND_FORGET
        :param message_per_subscription_type: (deprecated) If true, send a different message to every subscription type. If this is set to true, message must be a JSON object with a "default" key and a key for every subscription type (such as "sqs", "email", etc.) The values are strings representing the messages being sent to every subscription type. Default: false
        :param subject: (deprecated) Used as the "Subject" line when the message is delivered to email endpoints. Also included, if present, in the standard JSON messages delivered to other endpoints. Default: - No subject

        :stability: deprecated
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c77e58c3914b6c4d0cccd4c0f15d9635ea0705d6302f47a08175ede1a3127f73)
            check_type(argname="argument topic", value=topic, expected_type=type_hints["topic"])
        props = PublishToTopicProps(
            message=message,
            integration_pattern=integration_pattern,
            message_per_subscription_type=message_per_subscription_type,
            subject=subject,
        )

        jsii.create(self.__class__, self, [topic, props])

    @jsii.member(jsii_name="bind")
    def bind(self, _task: _Task_747ca4f2) -> _StepFunctionsTaskConfig_fa131821:
        '''(deprecated) Called when the task object is used in a workflow.

        :param _task: -

        :stability: deprecated
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d100c57e2b0f752ce95681cd9e49cef1b7f567fc07c551afc443707a093017b0)
            check_type(argname="argument _task", value=_task, expected_type=type_hints["_task"])
        return typing.cast(_StepFunctionsTaskConfig_fa131821, jsii.invoke(self, "bind", [_task]))


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.PublishToTopicProps",
    jsii_struct_bases=[],
    name_mapping={
        "message": "message",
        "integration_pattern": "integrationPattern",
        "message_per_subscription_type": "messagePerSubscriptionType",
        "subject": "subject",
    },
)
class PublishToTopicProps:
    def __init__(
        self,
        *,
        message: _TaskInput_71ab46f6,
        integration_pattern: typing.Optional[_ServiceIntegrationPattern_5581ee88] = None,
        message_per_subscription_type: typing.Optional[builtins.bool] = None,
        subject: typing.Optional[builtins.str] = None,
    ) -> None:
        '''(deprecated) Properties for PublishTask.

        :param message: (deprecated) The text message to send to the topic.
        :param integration_pattern: (deprecated) The service integration pattern indicates different ways to call Publish to SNS. The valid value is either FIRE_AND_FORGET or WAIT_FOR_TASK_TOKEN. Default: FIRE_AND_FORGET
        :param message_per_subscription_type: (deprecated) If true, send a different message to every subscription type. If this is set to true, message must be a JSON object with a "default" key and a key for every subscription type (such as "sqs", "email", etc.) The values are strings representing the messages being sent to every subscription type. Default: false
        :param subject: (deprecated) Used as the "Subject" line when the message is delivered to email endpoints. Also included, if present, in the standard JSON messages delivered to other endpoints. Default: - No subject

        :deprecated: Use ``SnsPublish``

        :stability: deprecated
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_stepfunctions as stepfunctions
            from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
            
            # task_input: stepfunctions.TaskInput
            
            publish_to_topic_props = stepfunctions_tasks.PublishToTopicProps(
                message=task_input,
            
                # the properties below are optional
                integration_pattern=stepfunctions.ServiceIntegrationPattern.FIRE_AND_FORGET,
                message_per_subscription_type=False,
                subject="subject"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__70e446b283ed6e3b795973a7390855a9f3b9fb8dd793202c4f533dc30fa79307)
            check_type(argname="argument message", value=message, expected_type=type_hints["message"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
            check_type(argname="argument message_per_subscription_type", value=message_per_subscription_type, expected_type=type_hints["message_per_subscription_type"])
            check_type(argname="argument subject", value=subject, expected_type=type_hints["subject"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "message": message,
        }
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern
        if message_per_subscription_type is not None:
            self._values["message_per_subscription_type"] = message_per_subscription_type
        if subject is not None:
            self._values["subject"] = subject

    @builtins.property
    def message(self) -> _TaskInput_71ab46f6:
        '''(deprecated) The text message to send to the topic.

        :stability: deprecated
        '''
        result = self._values.get("message")
        assert result is not None, "Required property 'message' is missing"
        return typing.cast(_TaskInput_71ab46f6, result)

    @builtins.property
    def integration_pattern(
        self,
    ) -> typing.Optional[_ServiceIntegrationPattern_5581ee88]:
        '''(deprecated) The service integration pattern indicates different ways to call Publish to SNS.

        The valid value is either FIRE_AND_FORGET or WAIT_FOR_TASK_TOKEN.

        :default: FIRE_AND_FORGET

        :stability: deprecated
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_ServiceIntegrationPattern_5581ee88], result)

    @builtins.property
    def message_per_subscription_type(self) -> typing.Optional[builtins.bool]:
        '''(deprecated) If true, send a different message to every subscription type.

        If this is set to true, message must be a JSON object with a
        "default" key and a key for every subscription type (such as "sqs",
        "email", etc.) The values are strings representing the messages
        being sent to every subscription type.

        :default: false

        :see: https://docs.aws.amazon.com/sns/latest/api/API_Publish.html#API_Publish_RequestParameters
        :stability: deprecated
        '''
        result = self._values.get("message_per_subscription_type")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def subject(self) -> typing.Optional[builtins.str]:
        '''(deprecated) Used as the "Subject" line when the message is delivered to email endpoints.

        Also included, if present, in the standard JSON messages delivered to other endpoints.

        :default: - No subject

        :stability: deprecated
        '''
        result = self._values.get("subject")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PublishToTopicProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.QueryExecutionContext",
    jsii_struct_bases=[],
    name_mapping={"catalog_name": "catalogName", "database_name": "databaseName"},
)
class QueryExecutionContext:
    def __init__(
        self,
        *,
        catalog_name: typing.Optional[builtins.str] = None,
        database_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''(experimental) Database and data catalog context in which the query execution occurs.

        :param catalog_name: (experimental) Name of catalog used in query execution. Default: - No catalog
        :param database_name: (experimental) Name of database used in query execution. Default: - No database

        :see: https://docs.aws.amazon.com/athena/latest/APIReference/API_QueryExecutionContext.html
        :stability: experimental
        :exampleMetadata: infused

        Example::

            start_query_execution_job = tasks.AthenaStartQueryExecution(self, "Athena Start Query",
                query_string=sfn.JsonPath.format("select contacts where year={};", sfn.JsonPath.string_at("$.year")),
                query_execution_context=dynamodb.aws_stepfunctions_tasks.QueryExecutionContext(
                    database_name="interactions"
                ),
                result_configuration=dynamodb.aws_stepfunctions_tasks.ResultConfiguration(
                    encryption_configuration=dynamodb.aws_stepfunctions_tasks.EncryptionConfiguration(
                        encryption_option=tasks.EncryptionOption.S3_MANAGED
                    ),
                    output_location=dynamodb.aws_s3.Location(
                        bucket_name="mybucket",
                        object_key="myprefix"
                    )
                ),
                integration_pattern=sfn.IntegrationPattern.RUN_JOB
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__40d64ca2965efc07501511a428f28857516218094643d7cc666feed4a47d40a3)
            check_type(argname="argument catalog_name", value=catalog_name, expected_type=type_hints["catalog_name"])
            check_type(argname="argument database_name", value=database_name, expected_type=type_hints["database_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if catalog_name is not None:
            self._values["catalog_name"] = catalog_name
        if database_name is not None:
            self._values["database_name"] = database_name

    @builtins.property
    def catalog_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Name of catalog used in query execution.

        :default: - No catalog

        :stability: experimental
        '''
        result = self._values.get("catalog_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def database_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Name of database used in query execution.

        :default: - No database

        :stability: experimental
        '''
        result = self._values.get("database_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "QueryExecutionContext(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="monocdk.aws_stepfunctions_tasks.RecordWrapperType")
class RecordWrapperType(enum.Enum):
    '''(experimental) Define the format of the input data.

    :stability: experimental
    '''

    NONE = "NONE"
    '''(experimental) None record wrapper type.

    :stability: experimental
    '''
    RECORD_IO = "RECORD_IO"
    '''(experimental) RecordIO record wrapper type.

    :stability: experimental
    '''


class ReleaseLabel(
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.ReleaseLabel",
):
    '''(experimental) The Amazon EMR release version to use for the job run.

    Can be extended to include new EMR releases

    For example, ``new ReleaseLabel('emr-x.xx.x-latest');``

    :stability: experimental
    :exampleMetadata: infused

    Example::

        tasks.EmrContainersStartJobRun(self, "EMR Containers Start Job Run",
            virtual_cluster=tasks.VirtualClusterInput.from_virtual_cluster_id("de92jdei2910fwedz"),
            release_label=tasks.ReleaseLabel.EMR_6_2_0,
            job_name="EMR-Containers-Job",
            job_driver=dynamodb.aws_stepfunctions_tasks.JobDriver(
                spark_submit_job_driver=dynamodb.aws_stepfunctions_tasks.SparkSubmitJobDriver(
                    entry_point=sfn.TaskInput.from_text("local:///usr/lib/spark/examples/src/main/python/pi.py")
                )
            ),
            application_config=[dynamodb.aws_stepfunctions_tasks.ApplicationConfiguration(
                classification=tasks.Classification.SPARK_DEFAULTS,
                properties={
                    "spark.executor.instances": "1",
                    "spark.executor.memory": "512M"
                }
            )]
        )
    '''

    def __init__(self, label: builtins.str) -> None:
        '''(experimental) Initializes the label string.

        :param label: A literal string that contains the release-version ex. 'emr-x.x.x-latest'

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a8197c6db819509ee812fce66deebad24d4e22d38fea7dd0bbb75487ed223655)
            check_type(argname="argument label", value=label, expected_type=type_hints["label"])
        jsii.create(self.__class__, self, [label])

    @jsii.python.classproperty
    @jsii.member(jsii_name="EMR_5_32_0")
    def EMR_5_32_0(cls) -> "ReleaseLabel":
        '''(experimental) EMR Release version 5.32.0.

        :stability: experimental
        '''
        return typing.cast("ReleaseLabel", jsii.sget(cls, "EMR_5_32_0"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="EMR_5_33_0")
    def EMR_5_33_0(cls) -> "ReleaseLabel":
        '''(experimental) EMR Release version 5.33.0.

        :stability: experimental
        '''
        return typing.cast("ReleaseLabel", jsii.sget(cls, "EMR_5_33_0"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="EMR_6_2_0")
    def EMR_6_2_0(cls) -> "ReleaseLabel":
        '''(experimental) EMR Release version 6.2.0.

        :stability: experimental
        '''
        return typing.cast("ReleaseLabel", jsii.sget(cls, "EMR_6_2_0"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="EMR_6_3_0")
    def EMR_6_3_0(cls) -> "ReleaseLabel":
        '''(experimental) EMR Release version 6.3.0.

        :stability: experimental
        '''
        return typing.cast("ReleaseLabel", jsii.sget(cls, "EMR_6_3_0"))

    @builtins.property
    @jsii.member(jsii_name="label")
    def label(self) -> builtins.str:
        '''(experimental) A literal string that contains the release-version ex.

        'emr-x.x.x-latest'

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "label"))


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.ResourceConfig",
    jsii_struct_bases=[],
    name_mapping={
        "instance_count": "instanceCount",
        "instance_type": "instanceType",
        "volume_size": "volumeSize",
        "volume_encryption_key": "volumeEncryptionKey",
    },
)
class ResourceConfig:
    def __init__(
        self,
        *,
        instance_count: jsii.Number,
        instance_type: _InstanceType_072ad323,
        volume_size: _Size_7fbd4337,
        volume_encryption_key: typing.Optional[_IKey_36930160] = None,
    ) -> None:
        '''(experimental) Specifies the resources, ML compute instances, and ML storage volumes to deploy for model training.

        :param instance_count: (experimental) The number of ML compute instances to use. Default: 1 instance.
        :param instance_type: (experimental) ML compute instance type. To provide an instance type from the task input, supply an instance type in the following way where the value in the task input is an EC2 instance type prepended with "ml.":: new ec2.InstanceType(sfn.JsonPath.stringAt('$.path.to.instanceType')); Default: ec2.InstanceType(ec2.InstanceClass.M4, ec2.InstanceType.XLARGE)
        :param volume_size: (experimental) Size of the ML storage volume that you want to provision. Default: 10 GB EBS volume.
        :param volume_encryption_key: (experimental) KMS key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the training job. Default: - Amazon SageMaker uses the default KMS key for Amazon S3 for your role's account

        :stability: experimental
        :exampleMetadata: infused

        Example::

            tasks.SageMakerCreateTrainingJob(self, "TrainSagemaker",
                training_job_name=sfn.JsonPath.string_at("$.JobName"),
                algorithm_specification=dynamodb.aws_stepfunctions_tasks.AlgorithmSpecification(
                    algorithm_name="BlazingText",
                    training_input_mode=tasks.InputMode.FILE
                ),
                input_data_config=[dynamodb.aws_stepfunctions_tasks.Channel(
                    channel_name="train",
                    data_source=dynamodb.aws_stepfunctions_tasks.DataSource(
                        s3_data_source=dynamodb.aws_stepfunctions_tasks.S3DataSource(
                            s3_data_type=tasks.S3DataType.S3_PREFIX,
                            s3_location=tasks.S3Location.from_json_expression("$.S3Bucket")
                        )
                    )
                )],
                output_data_config=dynamodb.aws_stepfunctions_tasks.OutputDataConfig(
                    s3_output_location=tasks.S3Location.from_bucket(s3.Bucket.from_bucket_name(self, "Bucket", "mybucket"), "myoutputpath")
                ),
                resource_config=dynamodb.aws_stepfunctions_tasks.ResourceConfig(
                    instance_count=1,
                    instance_type=ec2.InstanceType(sfn.JsonPath.string_at("$.InstanceType")),
                    volume_size=Size.gibibytes(50)
                ),  # optional: default is 1 instance of EC2 `M4.XLarge` with `10GB` volume
                stopping_condition=dynamodb.aws_stepfunctions_tasks.StoppingCondition(
                    max_runtime=Duration.hours(2)
                )
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__82bb698d067b928ab3ab3e89800378becea2a935ed1e347d89de3aa236c0347c)
            check_type(argname="argument instance_count", value=instance_count, expected_type=type_hints["instance_count"])
            check_type(argname="argument instance_type", value=instance_type, expected_type=type_hints["instance_type"])
            check_type(argname="argument volume_size", value=volume_size, expected_type=type_hints["volume_size"])
            check_type(argname="argument volume_encryption_key", value=volume_encryption_key, expected_type=type_hints["volume_encryption_key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "instance_count": instance_count,
            "instance_type": instance_type,
            "volume_size": volume_size,
        }
        if volume_encryption_key is not None:
            self._values["volume_encryption_key"] = volume_encryption_key

    @builtins.property
    def instance_count(self) -> jsii.Number:
        '''(experimental) The number of ML compute instances to use.

        :default: 1 instance.

        :stability: experimental
        '''
        result = self._values.get("instance_count")
        assert result is not None, "Required property 'instance_count' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def instance_type(self) -> _InstanceType_072ad323:
        '''(experimental) ML compute instance type.

        To provide an instance type from the task input, supply an instance type in the following way
        where the value in the task input is an EC2 instance type prepended with "ml."::

           ec2.InstanceType(sfn.JsonPath.string_at("$.path.to.instanceType"))

        :default: ec2.InstanceType(ec2.InstanceClass.M4, ec2.InstanceType.XLARGE)

        :see: https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_ResourceConfig.html#sagemaker-Type-ResourceConfig-InstanceType
        :stability: experimental
        '''
        result = self._values.get("instance_type")
        assert result is not None, "Required property 'instance_type' is missing"
        return typing.cast(_InstanceType_072ad323, result)

    @builtins.property
    def volume_size(self) -> _Size_7fbd4337:
        '''(experimental) Size of the ML storage volume that you want to provision.

        :default: 10 GB EBS volume.

        :stability: experimental
        '''
        result = self._values.get("volume_size")
        assert result is not None, "Required property 'volume_size' is missing"
        return typing.cast(_Size_7fbd4337, result)

    @builtins.property
    def volume_encryption_key(self) -> typing.Optional[_IKey_36930160]:
        '''(experimental) KMS key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the training job.

        :default: - Amazon SageMaker uses the default KMS key for Amazon S3 for your role's account

        :stability: experimental
        '''
        result = self._values.get("volume_encryption_key")
        return typing.cast(typing.Optional[_IKey_36930160], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ResourceConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.ResultConfiguration",
    jsii_struct_bases=[],
    name_mapping={
        "encryption_configuration": "encryptionConfiguration",
        "output_location": "outputLocation",
    },
)
class ResultConfiguration:
    def __init__(
        self,
        *,
        encryption_configuration: typing.Optional[typing.Union[EncryptionConfiguration, typing.Dict[builtins.str, typing.Any]]] = None,
        output_location: typing.Optional[typing.Union[_Location_cce991ca, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''(experimental) Location of query result along with S3 bucket configuration.

        :param encryption_configuration: (experimental) Encryption option used if enabled in S3. Default: - SSE_S3 encrpytion is enabled with default encryption key
        :param output_location: (experimental) S3 path of query results. Example value: ``s3://query-results-bucket/folder/`` Default: - Query Result Location set in Athena settings for this workgroup

        :see: https://docs.aws.amazon.com/athena/latest/APIReference/API_ResultConfiguration.html
        :stability: experimental
        :exampleMetadata: infused

        Example::

            start_query_execution_job = tasks.AthenaStartQueryExecution(self, "Athena Start Query",
                query_string=sfn.JsonPath.format("select contacts where year={};", sfn.JsonPath.string_at("$.year")),
                query_execution_context=dynamodb.aws_stepfunctions_tasks.QueryExecutionContext(
                    database_name="interactions"
                ),
                result_configuration=dynamodb.aws_stepfunctions_tasks.ResultConfiguration(
                    encryption_configuration=dynamodb.aws_stepfunctions_tasks.EncryptionConfiguration(
                        encryption_option=tasks.EncryptionOption.S3_MANAGED
                    ),
                    output_location=dynamodb.aws_s3.Location(
                        bucket_name="mybucket",
                        object_key="myprefix"
                    )
                ),
                integration_pattern=sfn.IntegrationPattern.RUN_JOB
            )
        '''
        if isinstance(encryption_configuration, dict):
            encryption_configuration = EncryptionConfiguration(**encryption_configuration)
        if isinstance(output_location, dict):
            output_location = _Location_cce991ca(**output_location)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4149f8265f56b01076a4d970dc3f39d4a55eb446b412125c04156293db3973b4)
            check_type(argname="argument encryption_configuration", value=encryption_configuration, expected_type=type_hints["encryption_configuration"])
            check_type(argname="argument output_location", value=output_location, expected_type=type_hints["output_location"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if encryption_configuration is not None:
            self._values["encryption_configuration"] = encryption_configuration
        if output_location is not None:
            self._values["output_location"] = output_location

    @builtins.property
    def encryption_configuration(self) -> typing.Optional[EncryptionConfiguration]:
        '''(experimental) Encryption option used if enabled in S3.

        :default: - SSE_S3 encrpytion is enabled with default encryption key

        :stability: experimental
        '''
        result = self._values.get("encryption_configuration")
        return typing.cast(typing.Optional[EncryptionConfiguration], result)

    @builtins.property
    def output_location(self) -> typing.Optional[_Location_cce991ca]:
        '''(experimental) S3 path of query results.

        Example value: ``s3://query-results-bucket/folder/``

        :default: - Query Result Location set in Athena settings for this workgroup

        :stability: experimental
        '''
        result = self._values.get("output_location")
        return typing.cast(typing.Optional[_Location_cce991ca], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ResultConfiguration(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IStepFunctionsTask_82eb09ab)
class RunBatchJob(
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.RunBatchJob",
):
    '''(deprecated) A Step Functions Task to run AWS Batch.

    :deprecated: use ``BatchSubmitJob``

    :stability: deprecated
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        import monocdk as monocdk
        from monocdk import aws_ec2 as ec2
        from monocdk import aws_stepfunctions as stepfunctions
        from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
        
        # duration: monocdk.Duration
        # instance_type: ec2.InstanceType
        # payload: Any
        
        run_batch_job = stepfunctions_tasks.RunBatchJob(
            job_definition_arn="jobDefinitionArn",
            job_name="jobName",
            job_queue_arn="jobQueueArn",
        
            # the properties below are optional
            array_size=123,
            attempts=123,
            container_overrides=stepfunctions_tasks.ContainerOverrides(
                command=["command"],
                environment={
                    "environment_key": "environment"
                },
                gpu_count=123,
                instance_type=instance_type,
                memory=123,
                vcpus=123
            ),
            depends_on=[stepfunctions_tasks.JobDependency(
                job_id="jobId",
                type="type"
            )],
            integration_pattern=stepfunctions.ServiceIntegrationPattern.FIRE_AND_FORGET,
            payload={
                "payload_key": payload
            },
            timeout=duration
        )
    '''

    def __init__(
        self,
        *,
        job_definition_arn: builtins.str,
        job_name: builtins.str,
        job_queue_arn: builtins.str,
        array_size: typing.Optional[jsii.Number] = None,
        attempts: typing.Optional[jsii.Number] = None,
        container_overrides: typing.Optional[typing.Union[ContainerOverrides, typing.Dict[builtins.str, typing.Any]]] = None,
        depends_on: typing.Optional[typing.Sequence[typing.Union[JobDependency, typing.Dict[builtins.str, typing.Any]]]] = None,
        integration_pattern: typing.Optional[_ServiceIntegrationPattern_5581ee88] = None,
        payload: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
    ) -> None:
        '''
        :param job_definition_arn: (deprecated) The arn of the job definition used by this job.
        :param job_name: (deprecated) The name of the job. The first character must be alphanumeric, and up to 128 letters (uppercase and lowercase), numbers, hyphens, and underscores are allowed.
        :param job_queue_arn: (deprecated) The arn of the job queue into which the job is submitted.
        :param array_size: (deprecated) The array size can be between 2 and 10,000. If you specify array properties for a job, it becomes an array job. For more information, see Array Jobs in the AWS Batch User Guide. Default: - No array size
        :param attempts: (deprecated) The number of times to move a job to the RUNNABLE status. You may specify between 1 and 10 attempts. If the value of attempts is greater than one, the job is retried on failure the same number of attempts as the value. Default: - 1
        :param container_overrides: (deprecated) A list of container overrides in JSON format that specify the name of a container in the specified job definition and the overrides it should receive. Default: - No container overrides
        :param depends_on: (deprecated) A list of dependencies for the job. A job can depend upon a maximum of 20 jobs. Default: - No dependencies
        :param integration_pattern: (deprecated) The service integration pattern indicates different ways to call TerminateCluster. The valid value is either FIRE_AND_FORGET or SYNC. Default: SYNC
        :param payload: (deprecated) The payload to be passed as parametrs to the batch job. Default: - No parameters are passed
        :param timeout: (deprecated) The timeout configuration for this SubmitJob operation. The minimum value for the timeout is 60 seconds. Default: - No timeout

        :stability: deprecated
        '''
        props = RunBatchJobProps(
            job_definition_arn=job_definition_arn,
            job_name=job_name,
            job_queue_arn=job_queue_arn,
            array_size=array_size,
            attempts=attempts,
            container_overrides=container_overrides,
            depends_on=depends_on,
            integration_pattern=integration_pattern,
            payload=payload,
            timeout=timeout,
        )

        jsii.create(self.__class__, self, [props])

    @jsii.member(jsii_name="bind")
    def bind(self, _task: _Task_747ca4f2) -> _StepFunctionsTaskConfig_fa131821:
        '''(deprecated) Called when the task object is used in a workflow.

        :param _task: -

        :stability: deprecated
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c6534a67ebe93b86db70af97a0692f0e8f7c46d721f35f1cb482bb74ca816e00)
            check_type(argname="argument _task", value=_task, expected_type=type_hints["_task"])
        return typing.cast(_StepFunctionsTaskConfig_fa131821, jsii.invoke(self, "bind", [_task]))


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.RunBatchJobProps",
    jsii_struct_bases=[],
    name_mapping={
        "job_definition_arn": "jobDefinitionArn",
        "job_name": "jobName",
        "job_queue_arn": "jobQueueArn",
        "array_size": "arraySize",
        "attempts": "attempts",
        "container_overrides": "containerOverrides",
        "depends_on": "dependsOn",
        "integration_pattern": "integrationPattern",
        "payload": "payload",
        "timeout": "timeout",
    },
)
class RunBatchJobProps:
    def __init__(
        self,
        *,
        job_definition_arn: builtins.str,
        job_name: builtins.str,
        job_queue_arn: builtins.str,
        array_size: typing.Optional[jsii.Number] = None,
        attempts: typing.Optional[jsii.Number] = None,
        container_overrides: typing.Optional[typing.Union[ContainerOverrides, typing.Dict[builtins.str, typing.Any]]] = None,
        depends_on: typing.Optional[typing.Sequence[typing.Union[JobDependency, typing.Dict[builtins.str, typing.Any]]]] = None,
        integration_pattern: typing.Optional[_ServiceIntegrationPattern_5581ee88] = None,
        payload: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
    ) -> None:
        '''(deprecated) Properties for RunBatchJob.

        :param job_definition_arn: (deprecated) The arn of the job definition used by this job.
        :param job_name: (deprecated) The name of the job. The first character must be alphanumeric, and up to 128 letters (uppercase and lowercase), numbers, hyphens, and underscores are allowed.
        :param job_queue_arn: (deprecated) The arn of the job queue into which the job is submitted.
        :param array_size: (deprecated) The array size can be between 2 and 10,000. If you specify array properties for a job, it becomes an array job. For more information, see Array Jobs in the AWS Batch User Guide. Default: - No array size
        :param attempts: (deprecated) The number of times to move a job to the RUNNABLE status. You may specify between 1 and 10 attempts. If the value of attempts is greater than one, the job is retried on failure the same number of attempts as the value. Default: - 1
        :param container_overrides: (deprecated) A list of container overrides in JSON format that specify the name of a container in the specified job definition and the overrides it should receive. Default: - No container overrides
        :param depends_on: (deprecated) A list of dependencies for the job. A job can depend upon a maximum of 20 jobs. Default: - No dependencies
        :param integration_pattern: (deprecated) The service integration pattern indicates different ways to call TerminateCluster. The valid value is either FIRE_AND_FORGET or SYNC. Default: SYNC
        :param payload: (deprecated) The payload to be passed as parametrs to the batch job. Default: - No parameters are passed
        :param timeout: (deprecated) The timeout configuration for this SubmitJob operation. The minimum value for the timeout is 60 seconds. Default: - No timeout

        :deprecated: use ``BatchSubmitJob``

        :stability: deprecated
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            import monocdk as monocdk
            from monocdk import aws_ec2 as ec2
            from monocdk import aws_stepfunctions as stepfunctions
            from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
            
            # duration: monocdk.Duration
            # instance_type: ec2.InstanceType
            # payload: Any
            
            run_batch_job_props = stepfunctions_tasks.RunBatchJobProps(
                job_definition_arn="jobDefinitionArn",
                job_name="jobName",
                job_queue_arn="jobQueueArn",
            
                # the properties below are optional
                array_size=123,
                attempts=123,
                container_overrides=stepfunctions_tasks.ContainerOverrides(
                    command=["command"],
                    environment={
                        "environment_key": "environment"
                    },
                    gpu_count=123,
                    instance_type=instance_type,
                    memory=123,
                    vcpus=123
                ),
                depends_on=[stepfunctions_tasks.JobDependency(
                    job_id="jobId",
                    type="type"
                )],
                integration_pattern=stepfunctions.ServiceIntegrationPattern.FIRE_AND_FORGET,
                payload={
                    "payload_key": payload
                },
                timeout=duration
            )
        '''
        if isinstance(container_overrides, dict):
            container_overrides = ContainerOverrides(**container_overrides)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d38ff894e8824ca4ef04f58e6c966c35132b2887271354f78e324843aa5103dd)
            check_type(argname="argument job_definition_arn", value=job_definition_arn, expected_type=type_hints["job_definition_arn"])
            check_type(argname="argument job_name", value=job_name, expected_type=type_hints["job_name"])
            check_type(argname="argument job_queue_arn", value=job_queue_arn, expected_type=type_hints["job_queue_arn"])
            check_type(argname="argument array_size", value=array_size, expected_type=type_hints["array_size"])
            check_type(argname="argument attempts", value=attempts, expected_type=type_hints["attempts"])
            check_type(argname="argument container_overrides", value=container_overrides, expected_type=type_hints["container_overrides"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
            check_type(argname="argument payload", value=payload, expected_type=type_hints["payload"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "job_definition_arn": job_definition_arn,
            "job_name": job_name,
            "job_queue_arn": job_queue_arn,
        }
        if array_size is not None:
            self._values["array_size"] = array_size
        if attempts is not None:
            self._values["attempts"] = attempts
        if container_overrides is not None:
            self._values["container_overrides"] = container_overrides
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern
        if payload is not None:
            self._values["payload"] = payload
        if timeout is not None:
            self._values["timeout"] = timeout

    @builtins.property
    def job_definition_arn(self) -> builtins.str:
        '''(deprecated) The arn of the job definition used by this job.

        :stability: deprecated
        '''
        result = self._values.get("job_definition_arn")
        assert result is not None, "Required property 'job_definition_arn' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def job_name(self) -> builtins.str:
        '''(deprecated) The name of the job.

        The first character must be alphanumeric, and up to 128 letters (uppercase and lowercase),
        numbers, hyphens, and underscores are allowed.

        :stability: deprecated
        '''
        result = self._values.get("job_name")
        assert result is not None, "Required property 'job_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def job_queue_arn(self) -> builtins.str:
        '''(deprecated) The arn of the job queue into which the job is submitted.

        :stability: deprecated
        '''
        result = self._values.get("job_queue_arn")
        assert result is not None, "Required property 'job_queue_arn' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def array_size(self) -> typing.Optional[jsii.Number]:
        '''(deprecated) The array size can be between 2 and 10,000.

        If you specify array properties for a job, it becomes an array job.
        For more information, see Array Jobs in the AWS Batch User Guide.

        :default: - No array size

        :stability: deprecated
        '''
        result = self._values.get("array_size")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def attempts(self) -> typing.Optional[jsii.Number]:
        '''(deprecated) The number of times to move a job to the RUNNABLE status.

        You may specify between 1 and 10 attempts.
        If the value of attempts is greater than one,
        the job is retried on failure the same number of attempts as the value.

        :default: - 1

        :stability: deprecated
        '''
        result = self._values.get("attempts")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def container_overrides(self) -> typing.Optional[ContainerOverrides]:
        '''(deprecated) A list of container overrides in JSON format that specify the name of a container in the specified job definition and the overrides it should receive.

        :default: - No container overrides

        :see: https://docs.aws.amazon.com/batch/latest/APIReference/API_SubmitJob.html#Batch-SubmitJob-request-containerOverrides
        :stability: deprecated
        '''
        result = self._values.get("container_overrides")
        return typing.cast(typing.Optional[ContainerOverrides], result)

    @builtins.property
    def depends_on(self) -> typing.Optional[typing.List[JobDependency]]:
        '''(deprecated) A list of dependencies for the job.

        A job can depend upon a maximum of 20 jobs.

        :default: - No dependencies

        :see: https://docs.aws.amazon.com/batch/latest/APIReference/API_SubmitJob.html#Batch-SubmitJob-request-dependsOn
        :stability: deprecated
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[JobDependency]], result)

    @builtins.property
    def integration_pattern(
        self,
    ) -> typing.Optional[_ServiceIntegrationPattern_5581ee88]:
        '''(deprecated) The service integration pattern indicates different ways to call TerminateCluster.

        The valid value is either FIRE_AND_FORGET or SYNC.

        :default: SYNC

        :stability: deprecated
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_ServiceIntegrationPattern_5581ee88], result)

    @builtins.property
    def payload(self) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(deprecated) The payload to be passed as parametrs to the batch job.

        :default: - No parameters are passed

        :stability: deprecated
        '''
        result = self._values.get("payload")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def timeout(self) -> typing.Optional[_Duration_070aa057]:
        '''(deprecated) The timeout configuration for this SubmitJob operation.

        The minimum value for the timeout is 60 seconds.

        :default: - No timeout

        :see: https://docs.aws.amazon.com/batch/latest/APIReference/API_SubmitJob.html#Batch-SubmitJob-request-timeout
        :stability: deprecated
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RunBatchJobProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RunEcsEc2Task(
    EcsRunTaskBase,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.RunEcsEc2Task",
):
    '''(deprecated) Run an ECS/EC2 Task in a StepFunctions workflow.

    :deprecated: - replaced by ``EcsRunTask``

    :stability: deprecated
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from monocdk import aws_ec2 as ec2
        from monocdk import aws_ecs as ecs
        from monocdk import aws_stepfunctions as stepfunctions
        from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
        
        # cluster: ecs.Cluster
        # container_definition: ecs.ContainerDefinition
        # placement_constraint: ecs.PlacementConstraint
        # placement_strategy: ecs.PlacementStrategy
        # security_group: ec2.SecurityGroup
        # subnet: ec2.Subnet
        # subnet_filter: ec2.SubnetFilter
        # task_definition: ecs.TaskDefinition
        
        run_ecs_ec2_task = stepfunctions_tasks.RunEcsEc2Task(
            cluster=cluster,
            task_definition=task_definition,
        
            # the properties below are optional
            container_overrides=[stepfunctions_tasks.ContainerOverride(
                container_definition=container_definition,
        
                # the properties below are optional
                command=["command"],
                cpu=123,
                environment=[stepfunctions_tasks.TaskEnvironmentVariable(
                    name="name",
                    value="value"
                )],
                memory_limit=123,
                memory_reservation=123
            )],
            integration_pattern=stepfunctions.ServiceIntegrationPattern.FIRE_AND_FORGET,
            placement_constraints=[placement_constraint],
            placement_strategies=[placement_strategy],
            security_group=security_group,
            subnets=ec2.SubnetSelection(
                availability_zones=["availabilityZones"],
                one_per_az=False,
                subnet_filters=[subnet_filter],
                subnet_group_name="subnetGroupName",
                subnet_name="subnetName",
                subnets=[subnet],
                subnet_type=ec2.SubnetType.ISOLATED
            )
        )
    '''

    def __init__(
        self,
        *,
        placement_constraints: typing.Optional[typing.Sequence[_PlacementConstraint_e22ac48c]] = None,
        placement_strategies: typing.Optional[typing.Sequence[_PlacementStrategy_ea27367e]] = None,
        security_group: typing.Optional[_ISecurityGroup_cdbba9d3] = None,
        subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
        cluster: _ICluster_42c4ec1a,
        task_definition: _TaskDefinition_c0dacfb4,
        container_overrides: typing.Optional[typing.Sequence[typing.Union[ContainerOverride, typing.Dict[builtins.str, typing.Any]]]] = None,
        integration_pattern: typing.Optional[_ServiceIntegrationPattern_5581ee88] = None,
    ) -> None:
        '''
        :param placement_constraints: (deprecated) Placement constraints. Default: No constraints
        :param placement_strategies: (deprecated) Placement strategies. Default: No strategies
        :param security_group: (deprecated) Existing security group to use for the task's ENIs. (Only applicable in case the TaskDefinition is configured for AwsVpc networking) Default: A new security group is created
        :param subnets: (deprecated) In what subnets to place the task's ENIs. (Only applicable in case the TaskDefinition is configured for AwsVpc networking) Default: Private subnets
        :param cluster: (experimental) The topic to run the task on.
        :param task_definition: (experimental) Task Definition used for running tasks in the service. Note: this must be TaskDefinition, and not ITaskDefinition, as it requires properties that are not known for imported task definitions
        :param container_overrides: (experimental) Container setting overrides. Key is the name of the container to override, value is the values you want to override. Default: - No overrides
        :param integration_pattern: (experimental) The service integration pattern indicates different ways to call RunTask in ECS. The valid value for Lambda is FIRE_AND_FORGET, SYNC and WAIT_FOR_TASK_TOKEN. Default: FIRE_AND_FORGET

        :stability: deprecated
        '''
        props = RunEcsEc2TaskProps(
            placement_constraints=placement_constraints,
            placement_strategies=placement_strategies,
            security_group=security_group,
            subnets=subnets,
            cluster=cluster,
            task_definition=task_definition,
            container_overrides=container_overrides,
            integration_pattern=integration_pattern,
        )

        jsii.create(self.__class__, self, [props])


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.RunEcsEc2TaskProps",
    jsii_struct_bases=[CommonEcsRunTaskProps],
    name_mapping={
        "cluster": "cluster",
        "task_definition": "taskDefinition",
        "container_overrides": "containerOverrides",
        "integration_pattern": "integrationPattern",
        "placement_constraints": "placementConstraints",
        "placement_strategies": "placementStrategies",
        "security_group": "securityGroup",
        "subnets": "subnets",
    },
)
class RunEcsEc2TaskProps(CommonEcsRunTaskProps):
    def __init__(
        self,
        *,
        cluster: _ICluster_42c4ec1a,
        task_definition: _TaskDefinition_c0dacfb4,
        container_overrides: typing.Optional[typing.Sequence[typing.Union[ContainerOverride, typing.Dict[builtins.str, typing.Any]]]] = None,
        integration_pattern: typing.Optional[_ServiceIntegrationPattern_5581ee88] = None,
        placement_constraints: typing.Optional[typing.Sequence[_PlacementConstraint_e22ac48c]] = None,
        placement_strategies: typing.Optional[typing.Sequence[_PlacementStrategy_ea27367e]] = None,
        security_group: typing.Optional[_ISecurityGroup_cdbba9d3] = None,
        subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''(deprecated) Properties to run an ECS task on EC2 in StepFunctionsan ECS.

        :param cluster: (experimental) The topic to run the task on.
        :param task_definition: (experimental) Task Definition used for running tasks in the service. Note: this must be TaskDefinition, and not ITaskDefinition, as it requires properties that are not known for imported task definitions
        :param container_overrides: (experimental) Container setting overrides. Key is the name of the container to override, value is the values you want to override. Default: - No overrides
        :param integration_pattern: (experimental) The service integration pattern indicates different ways to call RunTask in ECS. The valid value for Lambda is FIRE_AND_FORGET, SYNC and WAIT_FOR_TASK_TOKEN. Default: FIRE_AND_FORGET
        :param placement_constraints: (deprecated) Placement constraints. Default: No constraints
        :param placement_strategies: (deprecated) Placement strategies. Default: No strategies
        :param security_group: (deprecated) Existing security group to use for the task's ENIs. (Only applicable in case the TaskDefinition is configured for AwsVpc networking) Default: A new security group is created
        :param subnets: (deprecated) In what subnets to place the task's ENIs. (Only applicable in case the TaskDefinition is configured for AwsVpc networking) Default: Private subnets

        :deprecated: use ``EcsRunTask`` and ``EcsRunTaskProps``

        :stability: deprecated
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_ec2 as ec2
            from monocdk import aws_ecs as ecs
            from monocdk import aws_stepfunctions as stepfunctions
            from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
            
            # cluster: ecs.Cluster
            # container_definition: ecs.ContainerDefinition
            # placement_constraint: ecs.PlacementConstraint
            # placement_strategy: ecs.PlacementStrategy
            # security_group: ec2.SecurityGroup
            # subnet: ec2.Subnet
            # subnet_filter: ec2.SubnetFilter
            # task_definition: ecs.TaskDefinition
            
            run_ecs_ec2_task_props = stepfunctions_tasks.RunEcsEc2TaskProps(
                cluster=cluster,
                task_definition=task_definition,
            
                # the properties below are optional
                container_overrides=[stepfunctions_tasks.ContainerOverride(
                    container_definition=container_definition,
            
                    # the properties below are optional
                    command=["command"],
                    cpu=123,
                    environment=[stepfunctions_tasks.TaskEnvironmentVariable(
                        name="name",
                        value="value"
                    )],
                    memory_limit=123,
                    memory_reservation=123
                )],
                integration_pattern=stepfunctions.ServiceIntegrationPattern.FIRE_AND_FORGET,
                placement_constraints=[placement_constraint],
                placement_strategies=[placement_strategy],
                security_group=security_group,
                subnets=ec2.SubnetSelection(
                    availability_zones=["availabilityZones"],
                    one_per_az=False,
                    subnet_filters=[subnet_filter],
                    subnet_group_name="subnetGroupName",
                    subnet_name="subnetName",
                    subnets=[subnet],
                    subnet_type=ec2.SubnetType.ISOLATED
                )
            )
        '''
        if isinstance(subnets, dict):
            subnets = _SubnetSelection_1284e62c(**subnets)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0b568f34f73738ac417a12b802bec8aec20b84dd2ddcc7e6663b452146a75e98)
            check_type(argname="argument cluster", value=cluster, expected_type=type_hints["cluster"])
            check_type(argname="argument task_definition", value=task_definition, expected_type=type_hints["task_definition"])
            check_type(argname="argument container_overrides", value=container_overrides, expected_type=type_hints["container_overrides"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
            check_type(argname="argument placement_constraints", value=placement_constraints, expected_type=type_hints["placement_constraints"])
            check_type(argname="argument placement_strategies", value=placement_strategies, expected_type=type_hints["placement_strategies"])
            check_type(argname="argument security_group", value=security_group, expected_type=type_hints["security_group"])
            check_type(argname="argument subnets", value=subnets, expected_type=type_hints["subnets"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "cluster": cluster,
            "task_definition": task_definition,
        }
        if container_overrides is not None:
            self._values["container_overrides"] = container_overrides
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern
        if placement_constraints is not None:
            self._values["placement_constraints"] = placement_constraints
        if placement_strategies is not None:
            self._values["placement_strategies"] = placement_strategies
        if security_group is not None:
            self._values["security_group"] = security_group
        if subnets is not None:
            self._values["subnets"] = subnets

    @builtins.property
    def cluster(self) -> _ICluster_42c4ec1a:
        '''(experimental) The topic to run the task on.

        :stability: experimental
        '''
        result = self._values.get("cluster")
        assert result is not None, "Required property 'cluster' is missing"
        return typing.cast(_ICluster_42c4ec1a, result)

    @builtins.property
    def task_definition(self) -> _TaskDefinition_c0dacfb4:
        '''(experimental) Task Definition used for running tasks in the service.

        Note: this must be TaskDefinition, and not ITaskDefinition,
        as it requires properties that are not known for imported task definitions

        :stability: experimental
        '''
        result = self._values.get("task_definition")
        assert result is not None, "Required property 'task_definition' is missing"
        return typing.cast(_TaskDefinition_c0dacfb4, result)

    @builtins.property
    def container_overrides(self) -> typing.Optional[typing.List[ContainerOverride]]:
        '''(experimental) Container setting overrides.

        Key is the name of the container to override, value is the
        values you want to override.

        :default: - No overrides

        :stability: experimental
        '''
        result = self._values.get("container_overrides")
        return typing.cast(typing.Optional[typing.List[ContainerOverride]], result)

    @builtins.property
    def integration_pattern(
        self,
    ) -> typing.Optional[_ServiceIntegrationPattern_5581ee88]:
        '''(experimental) The service integration pattern indicates different ways to call RunTask in ECS.

        The valid value for Lambda is FIRE_AND_FORGET, SYNC and WAIT_FOR_TASK_TOKEN.

        :default: FIRE_AND_FORGET

        :stability: experimental
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_ServiceIntegrationPattern_5581ee88], result)

    @builtins.property
    def placement_constraints(
        self,
    ) -> typing.Optional[typing.List[_PlacementConstraint_e22ac48c]]:
        '''(deprecated) Placement constraints.

        :default: No constraints

        :stability: deprecated
        '''
        result = self._values.get("placement_constraints")
        return typing.cast(typing.Optional[typing.List[_PlacementConstraint_e22ac48c]], result)

    @builtins.property
    def placement_strategies(
        self,
    ) -> typing.Optional[typing.List[_PlacementStrategy_ea27367e]]:
        '''(deprecated) Placement strategies.

        :default: No strategies

        :stability: deprecated
        '''
        result = self._values.get("placement_strategies")
        return typing.cast(typing.Optional[typing.List[_PlacementStrategy_ea27367e]], result)

    @builtins.property
    def security_group(self) -> typing.Optional[_ISecurityGroup_cdbba9d3]:
        '''(deprecated) Existing security group to use for the task's ENIs.

        (Only applicable in case the TaskDefinition is configured for AwsVpc networking)

        :default: A new security group is created

        :stability: deprecated
        '''
        result = self._values.get("security_group")
        return typing.cast(typing.Optional[_ISecurityGroup_cdbba9d3], result)

    @builtins.property
    def subnets(self) -> typing.Optional[_SubnetSelection_1284e62c]:
        '''(deprecated) In what subnets to place the task's ENIs.

        (Only applicable in case the TaskDefinition is configured for AwsVpc networking)

        :default: Private subnets

        :stability: deprecated
        '''
        result = self._values.get("subnets")
        return typing.cast(typing.Optional[_SubnetSelection_1284e62c], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RunEcsEc2TaskProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RunEcsFargateTask(
    EcsRunTaskBase,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.RunEcsFargateTask",
):
    '''(deprecated) Start a service on an ECS cluster.

    :deprecated: replaced by ``EcsRunTask``

    :stability: deprecated
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from monocdk import aws_ec2 as ec2
        from monocdk import aws_ecs as ecs
        from monocdk import aws_stepfunctions as stepfunctions
        from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
        
        # cluster: ecs.Cluster
        # container_definition: ecs.ContainerDefinition
        # security_group: ec2.SecurityGroup
        # subnet: ec2.Subnet
        # subnet_filter: ec2.SubnetFilter
        # task_definition: ecs.TaskDefinition
        
        run_ecs_fargate_task = stepfunctions_tasks.RunEcsFargateTask(
            cluster=cluster,
            task_definition=task_definition,
        
            # the properties below are optional
            assign_public_ip=False,
            container_overrides=[stepfunctions_tasks.ContainerOverride(
                container_definition=container_definition,
        
                # the properties below are optional
                command=["command"],
                cpu=123,
                environment=[stepfunctions_tasks.TaskEnvironmentVariable(
                    name="name",
                    value="value"
                )],
                memory_limit=123,
                memory_reservation=123
            )],
            integration_pattern=stepfunctions.ServiceIntegrationPattern.FIRE_AND_FORGET,
            platform_version=ecs.FargatePlatformVersion.LATEST,
            security_group=security_group,
            subnets=ec2.SubnetSelection(
                availability_zones=["availabilityZones"],
                one_per_az=False,
                subnet_filters=[subnet_filter],
                subnet_group_name="subnetGroupName",
                subnet_name="subnetName",
                subnets=[subnet],
                subnet_type=ec2.SubnetType.ISOLATED
            )
        )
    '''

    def __init__(
        self,
        *,
        assign_public_ip: typing.Optional[builtins.bool] = None,
        platform_version: typing.Optional[_FargatePlatformVersion_8169c79a] = None,
        security_group: typing.Optional[_ISecurityGroup_cdbba9d3] = None,
        subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
        cluster: _ICluster_42c4ec1a,
        task_definition: _TaskDefinition_c0dacfb4,
        container_overrides: typing.Optional[typing.Sequence[typing.Union[ContainerOverride, typing.Dict[builtins.str, typing.Any]]]] = None,
        integration_pattern: typing.Optional[_ServiceIntegrationPattern_5581ee88] = None,
    ) -> None:
        '''
        :param assign_public_ip: (deprecated) Assign public IP addresses to each task. Default: false
        :param platform_version: (deprecated) Fargate platform version to run this service on. Unless you have specific compatibility requirements, you don't need to specify this. Default: Latest
        :param security_group: (deprecated) Existing security group to use for the tasks. Default: A new security group is created
        :param subnets: (deprecated) In what subnets to place the task's ENIs. Default: Private subnet if assignPublicIp, public subnets otherwise
        :param cluster: (experimental) The topic to run the task on.
        :param task_definition: (experimental) Task Definition used for running tasks in the service. Note: this must be TaskDefinition, and not ITaskDefinition, as it requires properties that are not known for imported task definitions
        :param container_overrides: (experimental) Container setting overrides. Key is the name of the container to override, value is the values you want to override. Default: - No overrides
        :param integration_pattern: (experimental) The service integration pattern indicates different ways to call RunTask in ECS. The valid value for Lambda is FIRE_AND_FORGET, SYNC and WAIT_FOR_TASK_TOKEN. Default: FIRE_AND_FORGET

        :stability: deprecated
        '''
        props = RunEcsFargateTaskProps(
            assign_public_ip=assign_public_ip,
            platform_version=platform_version,
            security_group=security_group,
            subnets=subnets,
            cluster=cluster,
            task_definition=task_definition,
            container_overrides=container_overrides,
            integration_pattern=integration_pattern,
        )

        jsii.create(self.__class__, self, [props])


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.RunEcsFargateTaskProps",
    jsii_struct_bases=[CommonEcsRunTaskProps],
    name_mapping={
        "cluster": "cluster",
        "task_definition": "taskDefinition",
        "container_overrides": "containerOverrides",
        "integration_pattern": "integrationPattern",
        "assign_public_ip": "assignPublicIp",
        "platform_version": "platformVersion",
        "security_group": "securityGroup",
        "subnets": "subnets",
    },
)
class RunEcsFargateTaskProps(CommonEcsRunTaskProps):
    def __init__(
        self,
        *,
        cluster: _ICluster_42c4ec1a,
        task_definition: _TaskDefinition_c0dacfb4,
        container_overrides: typing.Optional[typing.Sequence[typing.Union[ContainerOverride, typing.Dict[builtins.str, typing.Any]]]] = None,
        integration_pattern: typing.Optional[_ServiceIntegrationPattern_5581ee88] = None,
        assign_public_ip: typing.Optional[builtins.bool] = None,
        platform_version: typing.Optional[_FargatePlatformVersion_8169c79a] = None,
        security_group: typing.Optional[_ISecurityGroup_cdbba9d3] = None,
        subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''(deprecated) Properties to define an ECS service.

        :param cluster: (experimental) The topic to run the task on.
        :param task_definition: (experimental) Task Definition used for running tasks in the service. Note: this must be TaskDefinition, and not ITaskDefinition, as it requires properties that are not known for imported task definitions
        :param container_overrides: (experimental) Container setting overrides. Key is the name of the container to override, value is the values you want to override. Default: - No overrides
        :param integration_pattern: (experimental) The service integration pattern indicates different ways to call RunTask in ECS. The valid value for Lambda is FIRE_AND_FORGET, SYNC and WAIT_FOR_TASK_TOKEN. Default: FIRE_AND_FORGET
        :param assign_public_ip: (deprecated) Assign public IP addresses to each task. Default: false
        :param platform_version: (deprecated) Fargate platform version to run this service on. Unless you have specific compatibility requirements, you don't need to specify this. Default: Latest
        :param security_group: (deprecated) Existing security group to use for the tasks. Default: A new security group is created
        :param subnets: (deprecated) In what subnets to place the task's ENIs. Default: Private subnet if assignPublicIp, public subnets otherwise

        :deprecated: replaced by ``EcsRunTask`` and ``EcsRunTaskProps``

        :stability: deprecated
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_ec2 as ec2
            from monocdk import aws_ecs as ecs
            from monocdk import aws_stepfunctions as stepfunctions
            from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
            
            # cluster: ecs.Cluster
            # container_definition: ecs.ContainerDefinition
            # security_group: ec2.SecurityGroup
            # subnet: ec2.Subnet
            # subnet_filter: ec2.SubnetFilter
            # task_definition: ecs.TaskDefinition
            
            run_ecs_fargate_task_props = stepfunctions_tasks.RunEcsFargateTaskProps(
                cluster=cluster,
                task_definition=task_definition,
            
                # the properties below are optional
                assign_public_ip=False,
                container_overrides=[stepfunctions_tasks.ContainerOverride(
                    container_definition=container_definition,
            
                    # the properties below are optional
                    command=["command"],
                    cpu=123,
                    environment=[stepfunctions_tasks.TaskEnvironmentVariable(
                        name="name",
                        value="value"
                    )],
                    memory_limit=123,
                    memory_reservation=123
                )],
                integration_pattern=stepfunctions.ServiceIntegrationPattern.FIRE_AND_FORGET,
                platform_version=ecs.FargatePlatformVersion.LATEST,
                security_group=security_group,
                subnets=ec2.SubnetSelection(
                    availability_zones=["availabilityZones"],
                    one_per_az=False,
                    subnet_filters=[subnet_filter],
                    subnet_group_name="subnetGroupName",
                    subnet_name="subnetName",
                    subnets=[subnet],
                    subnet_type=ec2.SubnetType.ISOLATED
                )
            )
        '''
        if isinstance(subnets, dict):
            subnets = _SubnetSelection_1284e62c(**subnets)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7b16a5f43d385023abec55cbc7f1f66d3e020c5435a4afaf3bc5fd37c45a8f83)
            check_type(argname="argument cluster", value=cluster, expected_type=type_hints["cluster"])
            check_type(argname="argument task_definition", value=task_definition, expected_type=type_hints["task_definition"])
            check_type(argname="argument container_overrides", value=container_overrides, expected_type=type_hints["container_overrides"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
            check_type(argname="argument assign_public_ip", value=assign_public_ip, expected_type=type_hints["assign_public_ip"])
            check_type(argname="argument platform_version", value=platform_version, expected_type=type_hints["platform_version"])
            check_type(argname="argument security_group", value=security_group, expected_type=type_hints["security_group"])
            check_type(argname="argument subnets", value=subnets, expected_type=type_hints["subnets"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "cluster": cluster,
            "task_definition": task_definition,
        }
        if container_overrides is not None:
            self._values["container_overrides"] = container_overrides
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern
        if assign_public_ip is not None:
            self._values["assign_public_ip"] = assign_public_ip
        if platform_version is not None:
            self._values["platform_version"] = platform_version
        if security_group is not None:
            self._values["security_group"] = security_group
        if subnets is not None:
            self._values["subnets"] = subnets

    @builtins.property
    def cluster(self) -> _ICluster_42c4ec1a:
        '''(experimental) The topic to run the task on.

        :stability: experimental
        '''
        result = self._values.get("cluster")
        assert result is not None, "Required property 'cluster' is missing"
        return typing.cast(_ICluster_42c4ec1a, result)

    @builtins.property
    def task_definition(self) -> _TaskDefinition_c0dacfb4:
        '''(experimental) Task Definition used for running tasks in the service.

        Note: this must be TaskDefinition, and not ITaskDefinition,
        as it requires properties that are not known for imported task definitions

        :stability: experimental
        '''
        result = self._values.get("task_definition")
        assert result is not None, "Required property 'task_definition' is missing"
        return typing.cast(_TaskDefinition_c0dacfb4, result)

    @builtins.property
    def container_overrides(self) -> typing.Optional[typing.List[ContainerOverride]]:
        '''(experimental) Container setting overrides.

        Key is the name of the container to override, value is the
        values you want to override.

        :default: - No overrides

        :stability: experimental
        '''
        result = self._values.get("container_overrides")
        return typing.cast(typing.Optional[typing.List[ContainerOverride]], result)

    @builtins.property
    def integration_pattern(
        self,
    ) -> typing.Optional[_ServiceIntegrationPattern_5581ee88]:
        '''(experimental) The service integration pattern indicates different ways to call RunTask in ECS.

        The valid value for Lambda is FIRE_AND_FORGET, SYNC and WAIT_FOR_TASK_TOKEN.

        :default: FIRE_AND_FORGET

        :stability: experimental
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_ServiceIntegrationPattern_5581ee88], result)

    @builtins.property
    def assign_public_ip(self) -> typing.Optional[builtins.bool]:
        '''(deprecated) Assign public IP addresses to each task.

        :default: false

        :stability: deprecated
        '''
        result = self._values.get("assign_public_ip")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def platform_version(self) -> typing.Optional[_FargatePlatformVersion_8169c79a]:
        '''(deprecated) Fargate platform version to run this service on.

        Unless you have specific compatibility requirements, you don't need to
        specify this.

        :default: Latest

        :stability: deprecated
        '''
        result = self._values.get("platform_version")
        return typing.cast(typing.Optional[_FargatePlatformVersion_8169c79a], result)

    @builtins.property
    def security_group(self) -> typing.Optional[_ISecurityGroup_cdbba9d3]:
        '''(deprecated) Existing security group to use for the tasks.

        :default: A new security group is created

        :stability: deprecated
        '''
        result = self._values.get("security_group")
        return typing.cast(typing.Optional[_ISecurityGroup_cdbba9d3], result)

    @builtins.property
    def subnets(self) -> typing.Optional[_SubnetSelection_1284e62c]:
        '''(deprecated) In what subnets to place the task's ENIs.

        :default: Private subnet if assignPublicIp, public subnets otherwise

        :stability: deprecated
        '''
        result = self._values.get("subnets")
        return typing.cast(typing.Optional[_SubnetSelection_1284e62c], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RunEcsFargateTaskProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IStepFunctionsTask_82eb09ab)
class RunGlueJobTask(
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.RunGlueJobTask",
):
    '''(deprecated) Invoke a Glue job as a Task.

    OUTPUT: the output of this task is a JobRun structure, for details consult
    https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-jobs-runs.html#aws-glue-api-jobs-runs-JobRun

    :deprecated: use ``GlueStartJobRun``

    :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-glue.html
    :stability: deprecated
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        import monocdk as monocdk
        from monocdk import aws_stepfunctions as stepfunctions
        from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
        
        # duration: monocdk.Duration
        
        run_glue_job_task = stepfunctions_tasks.RunGlueJobTask("glueJobName",
            arguments={
                "arguments_key": "arguments"
            },
            integration_pattern=stepfunctions.ServiceIntegrationPattern.FIRE_AND_FORGET,
            notify_delay_after=duration,
            security_configuration="securityConfiguration",
            timeout=duration
        )
    '''

    def __init__(
        self,
        glue_job_name: builtins.str,
        *,
        arguments: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        integration_pattern: typing.Optional[_ServiceIntegrationPattern_5581ee88] = None,
        notify_delay_after: typing.Optional[_Duration_070aa057] = None,
        security_configuration: typing.Optional[builtins.str] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
    ) -> None:
        '''
        :param glue_job_name: -
        :param arguments: (deprecated) The job arguments specifically for this run. For this job run, they replace the default arguments set in the job definition itself. Default: - Default arguments set in the job definition
        :param integration_pattern: (deprecated) The service integration pattern indicates different ways to start the Glue job. The valid value for Glue is either FIRE_AND_FORGET or SYNC. Default: FIRE_AND_FORGET
        :param notify_delay_after: (deprecated) After a job run starts, the number of minutes to wait before sending a job run delay notification. Must be at least 1 minute. Default: - Default delay set in the job definition
        :param security_configuration: (deprecated) The name of the SecurityConfiguration structure to be used with this job run. This must match the Glue API `single-line string pattern <https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-common.html#aws-glue-api-regex-oneLine>`_. Default: - Default configuration set in the job definition
        :param timeout: (deprecated) The job run timeout. This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. Must be at least 1 minute. Default: - Default timeout set in the job definition

        :stability: deprecated
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e8e6f5242e4f16c941035137359f0f6fab04fefcf3225bbd02e860756fcb0d9f)
            check_type(argname="argument glue_job_name", value=glue_job_name, expected_type=type_hints["glue_job_name"])
        props = RunGlueJobTaskProps(
            arguments=arguments,
            integration_pattern=integration_pattern,
            notify_delay_after=notify_delay_after,
            security_configuration=security_configuration,
            timeout=timeout,
        )

        jsii.create(self.__class__, self, [glue_job_name, props])

    @jsii.member(jsii_name="bind")
    def bind(self, task: _Task_747ca4f2) -> _StepFunctionsTaskConfig_fa131821:
        '''(deprecated) Called when the task object is used in a workflow.

        :param task: -

        :stability: deprecated
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8b3551f539108156f671a9fdd738f340d4a8936ecad3030d0013c9f960b5a225)
            check_type(argname="argument task", value=task, expected_type=type_hints["task"])
        return typing.cast(_StepFunctionsTaskConfig_fa131821, jsii.invoke(self, "bind", [task]))


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.RunGlueJobTaskProps",
    jsii_struct_bases=[],
    name_mapping={
        "arguments": "arguments",
        "integration_pattern": "integrationPattern",
        "notify_delay_after": "notifyDelayAfter",
        "security_configuration": "securityConfiguration",
        "timeout": "timeout",
    },
)
class RunGlueJobTaskProps:
    def __init__(
        self,
        *,
        arguments: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        integration_pattern: typing.Optional[_ServiceIntegrationPattern_5581ee88] = None,
        notify_delay_after: typing.Optional[_Duration_070aa057] = None,
        security_configuration: typing.Optional[builtins.str] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
    ) -> None:
        '''(deprecated) Properties for RunGlueJobTask.

        :param arguments: (deprecated) The job arguments specifically for this run. For this job run, they replace the default arguments set in the job definition itself. Default: - Default arguments set in the job definition
        :param integration_pattern: (deprecated) The service integration pattern indicates different ways to start the Glue job. The valid value for Glue is either FIRE_AND_FORGET or SYNC. Default: FIRE_AND_FORGET
        :param notify_delay_after: (deprecated) After a job run starts, the number of minutes to wait before sending a job run delay notification. Must be at least 1 minute. Default: - Default delay set in the job definition
        :param security_configuration: (deprecated) The name of the SecurityConfiguration structure to be used with this job run. This must match the Glue API `single-line string pattern <https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-common.html#aws-glue-api-regex-oneLine>`_. Default: - Default configuration set in the job definition
        :param timeout: (deprecated) The job run timeout. This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. Must be at least 1 minute. Default: - Default timeout set in the job definition

        :deprecated: use ``GlueStartJobRun``

        :stability: deprecated
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            import monocdk as monocdk
            from monocdk import aws_stepfunctions as stepfunctions
            from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
            
            # duration: monocdk.Duration
            
            run_glue_job_task_props = stepfunctions_tasks.RunGlueJobTaskProps(
                arguments={
                    "arguments_key": "arguments"
                },
                integration_pattern=stepfunctions.ServiceIntegrationPattern.FIRE_AND_FORGET,
                notify_delay_after=duration,
                security_configuration="securityConfiguration",
                timeout=duration
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2105da9efc1f22328b2650bb62c6d6786fe2a7db444bfa1b566f651f9921d832)
            check_type(argname="argument arguments", value=arguments, expected_type=type_hints["arguments"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
            check_type(argname="argument notify_delay_after", value=notify_delay_after, expected_type=type_hints["notify_delay_after"])
            check_type(argname="argument security_configuration", value=security_configuration, expected_type=type_hints["security_configuration"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if arguments is not None:
            self._values["arguments"] = arguments
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern
        if notify_delay_after is not None:
            self._values["notify_delay_after"] = notify_delay_after
        if security_configuration is not None:
            self._values["security_configuration"] = security_configuration
        if timeout is not None:
            self._values["timeout"] = timeout

    @builtins.property
    def arguments(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''(deprecated) The job arguments specifically for this run.

        For this job run, they replace the default arguments set in the job definition itself.

        :default: - Default arguments set in the job definition

        :stability: deprecated
        '''
        result = self._values.get("arguments")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def integration_pattern(
        self,
    ) -> typing.Optional[_ServiceIntegrationPattern_5581ee88]:
        '''(deprecated) The service integration pattern indicates different ways to start the Glue job.

        The valid value for Glue is either FIRE_AND_FORGET or SYNC.

        :default: FIRE_AND_FORGET

        :stability: deprecated
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_ServiceIntegrationPattern_5581ee88], result)

    @builtins.property
    def notify_delay_after(self) -> typing.Optional[_Duration_070aa057]:
        '''(deprecated) After a job run starts, the number of minutes to wait before sending a job run delay notification.

        Must be at least 1 minute.

        :default: - Default delay set in the job definition

        :stability: deprecated
        '''
        result = self._values.get("notify_delay_after")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def security_configuration(self) -> typing.Optional[builtins.str]:
        '''(deprecated) The name of the SecurityConfiguration structure to be used with this job run.

        This must match the Glue API
        `single-line string pattern <https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-common.html#aws-glue-api-regex-oneLine>`_.

        :default: - Default configuration set in the job definition

        :stability: deprecated
        '''
        result = self._values.get("security_configuration")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def timeout(self) -> typing.Optional[_Duration_070aa057]:
        '''(deprecated) The job run timeout.

        This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status.
        Must be at least 1 minute.

        :default: - Default timeout set in the job definition

        :stability: deprecated
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RunGlueJobTaskProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IStepFunctionsTask_82eb09ab)
class RunLambdaTask(
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.RunLambdaTask",
):
    '''(deprecated) Invoke a Lambda function as a Task.

    OUTPUT: the output of this task is either the return value of Lambda's
    Invoke call, or whatever the Lambda Function posted back using
    ``SendTaskSuccess/SendTaskFailure`` in ``waitForTaskToken`` mode.

    :deprecated: Use ``LambdaInvoke``

    :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-lambda.html
    :stability: deprecated
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from monocdk import aws_lambda as lambda_
        from monocdk import aws_stepfunctions as stepfunctions
        from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
        
        # function_: lambda.Function
        # task_input: stepfunctions.TaskInput
        
        run_lambda_task = stepfunctions_tasks.RunLambdaTask(function_,
            client_context="clientContext",
            integration_pattern=stepfunctions.ServiceIntegrationPattern.FIRE_AND_FORGET,
            invocation_type=stepfunctions_tasks.InvocationType.REQUEST_RESPONSE,
            payload=task_input,
            qualifier="qualifier"
        )
    '''

    def __init__(
        self,
        lambda_function: _IFunction_6e14f09e,
        *,
        client_context: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_ServiceIntegrationPattern_5581ee88] = None,
        invocation_type: typing.Optional[InvocationType] = None,
        payload: typing.Optional[_TaskInput_71ab46f6] = None,
        qualifier: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param lambda_function: -
        :param client_context: (deprecated) Client context to pass to the function. Default: - No context
        :param integration_pattern: (deprecated) The service integration pattern indicates different ways to invoke Lambda function. The valid value for Lambda is either FIRE_AND_FORGET or WAIT_FOR_TASK_TOKEN, it determines whether to pause the workflow until a task token is returned. If this is set to WAIT_FOR_TASK_TOKEN, the JsonPath.taskToken value must be included somewhere in the payload and the Lambda must call ``SendTaskSuccess/SendTaskFailure`` using that token. Default: FIRE_AND_FORGET
        :param invocation_type: (deprecated) Invocation type of the Lambda function. Default: RequestResponse
        :param payload: (deprecated) The JSON that you want to provide to your Lambda function as input. Default: - The state input (JSON path '$')
        :param qualifier: (deprecated) Version or alias of the function to be invoked. Default: - No qualifier

        :stability: deprecated
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ebf5cb3aeff1e164f7453b43973fb03a7fec5275931e365d53826c5029a9c581)
            check_type(argname="argument lambda_function", value=lambda_function, expected_type=type_hints["lambda_function"])
        props = RunLambdaTaskProps(
            client_context=client_context,
            integration_pattern=integration_pattern,
            invocation_type=invocation_type,
            payload=payload,
            qualifier=qualifier,
        )

        jsii.create(self.__class__, self, [lambda_function, props])

    @jsii.member(jsii_name="bind")
    def bind(self, _task: _Task_747ca4f2) -> _StepFunctionsTaskConfig_fa131821:
        '''(deprecated) Called when the task object is used in a workflow.

        :param _task: -

        :stability: deprecated
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0ca93d208385999857b4f942a385847fdc406f343dec2e274b58d8468b1f9d60)
            check_type(argname="argument _task", value=_task, expected_type=type_hints["_task"])
        return typing.cast(_StepFunctionsTaskConfig_fa131821, jsii.invoke(self, "bind", [_task]))


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.RunLambdaTaskProps",
    jsii_struct_bases=[],
    name_mapping={
        "client_context": "clientContext",
        "integration_pattern": "integrationPattern",
        "invocation_type": "invocationType",
        "payload": "payload",
        "qualifier": "qualifier",
    },
)
class RunLambdaTaskProps:
    def __init__(
        self,
        *,
        client_context: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_ServiceIntegrationPattern_5581ee88] = None,
        invocation_type: typing.Optional[InvocationType] = None,
        payload: typing.Optional[_TaskInput_71ab46f6] = None,
        qualifier: typing.Optional[builtins.str] = None,
    ) -> None:
        '''(deprecated) Properties for RunLambdaTask.

        :param client_context: (deprecated) Client context to pass to the function. Default: - No context
        :param integration_pattern: (deprecated) The service integration pattern indicates different ways to invoke Lambda function. The valid value for Lambda is either FIRE_AND_FORGET or WAIT_FOR_TASK_TOKEN, it determines whether to pause the workflow until a task token is returned. If this is set to WAIT_FOR_TASK_TOKEN, the JsonPath.taskToken value must be included somewhere in the payload and the Lambda must call ``SendTaskSuccess/SendTaskFailure`` using that token. Default: FIRE_AND_FORGET
        :param invocation_type: (deprecated) Invocation type of the Lambda function. Default: RequestResponse
        :param payload: (deprecated) The JSON that you want to provide to your Lambda function as input. Default: - The state input (JSON path '$')
        :param qualifier: (deprecated) Version or alias of the function to be invoked. Default: - No qualifier

        :deprecated: Use ``LambdaInvoke``

        :stability: deprecated
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_stepfunctions as stepfunctions
            from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
            
            # task_input: stepfunctions.TaskInput
            
            run_lambda_task_props = stepfunctions_tasks.RunLambdaTaskProps(
                client_context="clientContext",
                integration_pattern=stepfunctions.ServiceIntegrationPattern.FIRE_AND_FORGET,
                invocation_type=stepfunctions_tasks.InvocationType.REQUEST_RESPONSE,
                payload=task_input,
                qualifier="qualifier"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e13246c709d5e2b8ab3461fb2b2ad058f7d98e211e139b667977836fd4bae24d)
            check_type(argname="argument client_context", value=client_context, expected_type=type_hints["client_context"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
            check_type(argname="argument invocation_type", value=invocation_type, expected_type=type_hints["invocation_type"])
            check_type(argname="argument payload", value=payload, expected_type=type_hints["payload"])
            check_type(argname="argument qualifier", value=qualifier, expected_type=type_hints["qualifier"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if client_context is not None:
            self._values["client_context"] = client_context
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern
        if invocation_type is not None:
            self._values["invocation_type"] = invocation_type
        if payload is not None:
            self._values["payload"] = payload
        if qualifier is not None:
            self._values["qualifier"] = qualifier

    @builtins.property
    def client_context(self) -> typing.Optional[builtins.str]:
        '''(deprecated) Client context to pass to the function.

        :default: - No context

        :stability: deprecated
        '''
        result = self._values.get("client_context")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def integration_pattern(
        self,
    ) -> typing.Optional[_ServiceIntegrationPattern_5581ee88]:
        '''(deprecated) The service integration pattern indicates different ways to invoke Lambda function.

        The valid value for Lambda is either FIRE_AND_FORGET or WAIT_FOR_TASK_TOKEN,
        it determines whether to pause the workflow until a task token is returned.

        If this is set to WAIT_FOR_TASK_TOKEN, the JsonPath.taskToken value must be included
        somewhere in the payload and the Lambda must call
        ``SendTaskSuccess/SendTaskFailure`` using that token.

        :default: FIRE_AND_FORGET

        :stability: deprecated
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_ServiceIntegrationPattern_5581ee88], result)

    @builtins.property
    def invocation_type(self) -> typing.Optional[InvocationType]:
        '''(deprecated) Invocation type of the Lambda function.

        :default: RequestResponse

        :stability: deprecated
        '''
        result = self._values.get("invocation_type")
        return typing.cast(typing.Optional[InvocationType], result)

    @builtins.property
    def payload(self) -> typing.Optional[_TaskInput_71ab46f6]:
        '''(deprecated) The JSON that you want to provide to your Lambda function as input.

        :default: - The state input (JSON path '$')

        :stability: deprecated
        '''
        result = self._values.get("payload")
        return typing.cast(typing.Optional[_TaskInput_71ab46f6], result)

    @builtins.property
    def qualifier(self) -> typing.Optional[builtins.str]:
        '''(deprecated) Version or alias of the function to be invoked.

        :default: - No qualifier

        :deprecated: pass a Version or Alias object as lambdaFunction instead

        :stability: deprecated
        '''
        result = self._values.get("qualifier")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RunLambdaTaskProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="monocdk.aws_stepfunctions_tasks.S3DataDistributionType")
class S3DataDistributionType(enum.Enum):
    '''(experimental) S3 Data Distribution Type.

    :stability: experimental
    '''

    FULLY_REPLICATED = "FULLY_REPLICATED"
    '''(experimental) Fully replicated S3 Data Distribution Type.

    :stability: experimental
    '''
    SHARDED_BY_S3_KEY = "SHARDED_BY_S3_KEY"
    '''(experimental) Sharded By S3 Key Data Distribution Type.

    :stability: experimental
    '''


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.S3DataSource",
    jsii_struct_bases=[],
    name_mapping={
        "s3_location": "s3Location",
        "attribute_names": "attributeNames",
        "s3_data_distribution_type": "s3DataDistributionType",
        "s3_data_type": "s3DataType",
    },
)
class S3DataSource:
    def __init__(
        self,
        *,
        s3_location: "S3Location",
        attribute_names: typing.Optional[typing.Sequence[builtins.str]] = None,
        s3_data_distribution_type: typing.Optional[S3DataDistributionType] = None,
        s3_data_type: typing.Optional["S3DataType"] = None,
    ) -> None:
        '''(experimental) S3 location of the channel data.

        :param s3_location: (experimental) S3 Uri.
        :param attribute_names: (experimental) List of one or more attribute names to use that are found in a specified augmented manifest file. Default: - No attribute names
        :param s3_data_distribution_type: (experimental) S3 Data Distribution Type. Default: - None
        :param s3_data_type: (experimental) S3 Data Type. Default: S3_PREFIX

        :see: https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_S3DataSource.html
        :stability: experimental
        :exampleMetadata: infused

        Example::

            tasks.SageMakerCreateTrainingJob(self, "TrainSagemaker",
                training_job_name=sfn.JsonPath.string_at("$.JobName"),
                algorithm_specification=dynamodb.aws_stepfunctions_tasks.AlgorithmSpecification(
                    algorithm_name="BlazingText",
                    training_input_mode=tasks.InputMode.FILE
                ),
                input_data_config=[dynamodb.aws_stepfunctions_tasks.Channel(
                    channel_name="train",
                    data_source=dynamodb.aws_stepfunctions_tasks.DataSource(
                        s3_data_source=dynamodb.aws_stepfunctions_tasks.S3DataSource(
                            s3_data_type=tasks.S3DataType.S3_PREFIX,
                            s3_location=tasks.S3Location.from_json_expression("$.S3Bucket")
                        )
                    )
                )],
                output_data_config=dynamodb.aws_stepfunctions_tasks.OutputDataConfig(
                    s3_output_location=tasks.S3Location.from_bucket(s3.Bucket.from_bucket_name(self, "Bucket", "mybucket"), "myoutputpath")
                ),
                resource_config=dynamodb.aws_stepfunctions_tasks.ResourceConfig(
                    instance_count=1,
                    instance_type=ec2.InstanceType(sfn.JsonPath.string_at("$.InstanceType")),
                    volume_size=Size.gibibytes(50)
                ),  # optional: default is 1 instance of EC2 `M4.XLarge` with `10GB` volume
                stopping_condition=dynamodb.aws_stepfunctions_tasks.StoppingCondition(
                    max_runtime=Duration.hours(2)
                )
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__03ef2946c81526f19908ae1eb6f610fe7f51620d76dd9964674953dcfb82883e)
            check_type(argname="argument s3_location", value=s3_location, expected_type=type_hints["s3_location"])
            check_type(argname="argument attribute_names", value=attribute_names, expected_type=type_hints["attribute_names"])
            check_type(argname="argument s3_data_distribution_type", value=s3_data_distribution_type, expected_type=type_hints["s3_data_distribution_type"])
            check_type(argname="argument s3_data_type", value=s3_data_type, expected_type=type_hints["s3_data_type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "s3_location": s3_location,
        }
        if attribute_names is not None:
            self._values["attribute_names"] = attribute_names
        if s3_data_distribution_type is not None:
            self._values["s3_data_distribution_type"] = s3_data_distribution_type
        if s3_data_type is not None:
            self._values["s3_data_type"] = s3_data_type

    @builtins.property
    def s3_location(self) -> "S3Location":
        '''(experimental) S3 Uri.

        :stability: experimental
        '''
        result = self._values.get("s3_location")
        assert result is not None, "Required property 's3_location' is missing"
        return typing.cast("S3Location", result)

    @builtins.property
    def attribute_names(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) List of one or more attribute names to use that are found in a specified augmented manifest file.

        :default: - No attribute names

        :stability: experimental
        '''
        result = self._values.get("attribute_names")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def s3_data_distribution_type(self) -> typing.Optional[S3DataDistributionType]:
        '''(experimental) S3 Data Distribution Type.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("s3_data_distribution_type")
        return typing.cast(typing.Optional[S3DataDistributionType], result)

    @builtins.property
    def s3_data_type(self) -> typing.Optional["S3DataType"]:
        '''(experimental) S3 Data Type.

        :default: S3_PREFIX

        :stability: experimental
        '''
        result = self._values.get("s3_data_type")
        return typing.cast(typing.Optional["S3DataType"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "S3DataSource(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="monocdk.aws_stepfunctions_tasks.S3DataType")
class S3DataType(enum.Enum):
    '''(experimental) S3 Data Type.

    :stability: experimental
    :exampleMetadata: infused

    Example::

        tasks.SageMakerCreateTrainingJob(self, "TrainSagemaker",
            training_job_name=sfn.JsonPath.string_at("$.JobName"),
            algorithm_specification=dynamodb.aws_stepfunctions_tasks.AlgorithmSpecification(
                algorithm_name="BlazingText",
                training_input_mode=tasks.InputMode.FILE
            ),
            input_data_config=[dynamodb.aws_stepfunctions_tasks.Channel(
                channel_name="train",
                data_source=dynamodb.aws_stepfunctions_tasks.DataSource(
                    s3_data_source=dynamodb.aws_stepfunctions_tasks.S3DataSource(
                        s3_data_type=tasks.S3DataType.S3_PREFIX,
                        s3_location=tasks.S3Location.from_json_expression("$.S3Bucket")
                    )
                )
            )],
            output_data_config=dynamodb.aws_stepfunctions_tasks.OutputDataConfig(
                s3_output_location=tasks.S3Location.from_bucket(s3.Bucket.from_bucket_name(self, "Bucket", "mybucket"), "myoutputpath")
            ),
            resource_config=dynamodb.aws_stepfunctions_tasks.ResourceConfig(
                instance_count=1,
                instance_type=ec2.InstanceType(sfn.JsonPath.string_at("$.InstanceType")),
                volume_size=Size.gibibytes(50)
            ),  # optional: default is 1 instance of EC2 `M4.XLarge` with `10GB` volume
            stopping_condition=dynamodb.aws_stepfunctions_tasks.StoppingCondition(
                max_runtime=Duration.hours(2)
            )
        )
    '''

    MANIFEST_FILE = "MANIFEST_FILE"
    '''(experimental) Manifest File Data Type.

    :stability: experimental
    '''
    S3_PREFIX = "S3_PREFIX"
    '''(experimental) S3 Prefix Data Type.

    :stability: experimental
    '''
    AUGMENTED_MANIFEST_FILE = "AUGMENTED_MANIFEST_FILE"
    '''(experimental) Augmented Manifest File Data Type.

    :stability: experimental
    '''


class S3Location(
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="monocdk.aws_stepfunctions_tasks.S3Location",
):
    '''(experimental) Constructs ``IS3Location`` objects.

    :stability: experimental
    :exampleMetadata: infused

    Example::

        tasks.SageMakerCreateTrainingJob(self, "TrainSagemaker",
            training_job_name=sfn.JsonPath.string_at("$.JobName"),
            algorithm_specification=dynamodb.aws_stepfunctions_tasks.AlgorithmSpecification(
                algorithm_name="BlazingText",
                training_input_mode=tasks.InputMode.FILE
            ),
            input_data_config=[dynamodb.aws_stepfunctions_tasks.Channel(
                channel_name="train",
                data_source=dynamodb.aws_stepfunctions_tasks.DataSource(
                    s3_data_source=dynamodb.aws_stepfunctions_tasks.S3DataSource(
                        s3_data_type=tasks.S3DataType.S3_PREFIX,
                        s3_location=tasks.S3Location.from_json_expression("$.S3Bucket")
                    )
                )
            )],
            output_data_config=dynamodb.aws_stepfunctions_tasks.OutputDataConfig(
                s3_output_location=tasks.S3Location.from_bucket(s3.Bucket.from_bucket_name(self, "Bucket", "mybucket"), "myoutputpath")
            ),
            resource_config=dynamodb.aws_stepfunctions_tasks.ResourceConfig(
                instance_count=1,
                instance_type=ec2.InstanceType(sfn.JsonPath.string_at("$.InstanceType")),
                volume_size=Size.gibibytes(50)
            ),  # optional: default is 1 instance of EC2 `M4.XLarge` with `10GB` volume
            stopping_condition=dynamodb.aws_stepfunctions_tasks.StoppingCondition(
                max_runtime=Duration.hours(2)
            )
        )
    '''

    def __init__(self) -> None:
        '''
        :stability: experimental
        '''
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="fromBucket")
    @builtins.classmethod
    def from_bucket(
        cls,
        bucket: _IBucket_73486e29,
        key_prefix: builtins.str,
    ) -> "S3Location":
        '''(experimental) An ``IS3Location`` built with a determined bucket and key prefix.

        :param bucket: is the bucket where the objects are to be stored.
        :param key_prefix: is the key prefix used by the location.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a469d9f0a3757b8af9cd95c3a3397cb81c023532a3bbd13870cbb18aaa6e7412)
            check_type(argname="argument bucket", value=bucket, expected_type=type_hints["bucket"])
            check_type(argname="argument key_prefix", value=key_prefix, expected_type=type_hints["key_prefix"])
        return typing.cast("S3Location", jsii.sinvoke(cls, "fromBucket", [bucket, key_prefix]))

    @jsii.member(jsii_name="fromJsonExpression")
    @builtins.classmethod
    def from_json_expression(cls, expression: builtins.str) -> "S3Location":
        '''(experimental) An ``IS3Location`` determined fully by a JSON Path from the task input.

        Due to the dynamic nature of those locations, the IAM grants that will be set by ``grantRead`` and ``grantWrite``
        apply to the ``*`` resource.

        :param expression: the JSON expression resolving to an S3 location URI.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9d79f087a6940cb4167ddede4f4b9c83461ec3cdd6601e083c7eb87014503466)
            check_type(argname="argument expression", value=expression, expected_type=type_hints["expression"])
        return typing.cast("S3Location", jsii.sinvoke(cls, "fromJsonExpression", [expression]))

    @jsii.member(jsii_name="bind")
    @abc.abstractmethod
    def bind(
        self,
        task: ISageMakerTask,
        *,
        for_reading: typing.Optional[builtins.bool] = None,
        for_writing: typing.Optional[builtins.bool] = None,
    ) -> "S3LocationConfig":
        '''(experimental) Called when the S3Location is bound to a StepFunctions task.

        :param task: -
        :param for_reading: (experimental) Allow reading from the S3 Location. Default: false
        :param for_writing: (experimental) Allow writing to the S3 Location. Default: false

        :stability: experimental
        '''
        ...


class _S3LocationProxy(S3Location):
    @jsii.member(jsii_name="bind")
    def bind(
        self,
        task: ISageMakerTask,
        *,
        for_reading: typing.Optional[builtins.bool] = None,
        for_writing: typing.Optional[builtins.bool] = None,
    ) -> "S3LocationConfig":
        '''(experimental) Called when the S3Location is bound to a StepFunctions task.

        :param task: -
        :param for_reading: (experimental) Allow reading from the S3 Location. Default: false
        :param for_writing: (experimental) Allow writing to the S3 Location. Default: false

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__17b44b096335460b2196db9c8cece7d21d948fbc748f5cebbeba5688ea2bd32a)
            check_type(argname="argument task", value=task, expected_type=type_hints["task"])
        opts = S3LocationBindOptions(for_reading=for_reading, for_writing=for_writing)

        return typing.cast("S3LocationConfig", jsii.invoke(self, "bind", [task, opts]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, S3Location).__jsii_proxy_class__ = lambda : _S3LocationProxy


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.S3LocationBindOptions",
    jsii_struct_bases=[],
    name_mapping={"for_reading": "forReading", "for_writing": "forWriting"},
)
class S3LocationBindOptions:
    def __init__(
        self,
        *,
        for_reading: typing.Optional[builtins.bool] = None,
        for_writing: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''(experimental) Options for binding an S3 Location.

        :param for_reading: (experimental) Allow reading from the S3 Location. Default: false
        :param for_writing: (experimental) Allow writing to the S3 Location. Default: false

        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
            
            s3_location_bind_options = stepfunctions_tasks.S3LocationBindOptions(
                for_reading=False,
                for_writing=False
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__334b3797922d19bf49232b3bf264561c97cb66ba8e8c5956a1b999f116b490fb)
            check_type(argname="argument for_reading", value=for_reading, expected_type=type_hints["for_reading"])
            check_type(argname="argument for_writing", value=for_writing, expected_type=type_hints["for_writing"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if for_reading is not None:
            self._values["for_reading"] = for_reading
        if for_writing is not None:
            self._values["for_writing"] = for_writing

    @builtins.property
    def for_reading(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Allow reading from the S3 Location.

        :default: false

        :stability: experimental
        '''
        result = self._values.get("for_reading")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def for_writing(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Allow writing to the S3 Location.

        :default: false

        :stability: experimental
        '''
        result = self._values.get("for_writing")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "S3LocationBindOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.S3LocationConfig",
    jsii_struct_bases=[],
    name_mapping={"uri": "uri"},
)
class S3LocationConfig:
    def __init__(self, *, uri: builtins.str) -> None:
        '''(experimental) Stores information about the location of an object in Amazon S3.

        :param uri: (experimental) Uniquely identifies the resource in Amazon S3.

        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
            
            s3_location_config = stepfunctions_tasks.S3LocationConfig(
                uri="uri"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9f7073512b9c94121cbea80c7e1266273b6e458a9014d7b62c8b63d70d3bd1a5)
            check_type(argname="argument uri", value=uri, expected_type=type_hints["uri"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "uri": uri,
        }

    @builtins.property
    def uri(self) -> builtins.str:
        '''(experimental) Uniquely identifies the resource in Amazon S3.

        :stability: experimental
        '''
        result = self._values.get("uri")
        assert result is not None, "Required property 'uri' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "S3LocationConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SageMakerCreateEndpoint(
    _TaskStateBase_c3080646,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.SageMakerCreateEndpoint",
):
    '''(experimental) A Step Functions Task to create a SageMaker endpoint.

    :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-sagemaker.html
    :stability: experimental
    :exampleMetadata: infused

    Example::

        tasks.SageMakerCreateEndpoint(self, "SagemakerEndpoint",
            endpoint_name=sfn.JsonPath.string_at("$.EndpointName"),
            endpoint_config_name=sfn.JsonPath.string_at("$.EndpointConfigName")
        )
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        endpoint_config_name: builtins.str,
        endpoint_name: builtins.str,
        tags: typing.Optional[_TaskInput_71ab46f6] = None,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param endpoint_config_name: (experimental) The name of an endpoint configuration.
        :param endpoint_name: (experimental) The name of the endpoint. The name must be unique within an AWS Region in your AWS account.
        :param tags: (experimental) Tags to be applied to the endpoint. Default: - No tags
        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9527ee3f0c10b3a79fa156d30060e783c6d22b73dbc57ae849d600a37e8fb60f)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = SageMakerCreateEndpointProps(
            endpoint_config_name=endpoint_config_name,
            endpoint_name=endpoint_name,
            tags=tags,
            comment=comment,
            heartbeat=heartbeat,
            input_path=input_path,
            integration_pattern=integration_pattern,
            output_path=output_path,
            result_path=result_path,
            result_selector=result_selector,
            timeout=timeout,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="taskMetrics")
    def _task_metrics(self) -> typing.Optional[_TaskMetricsConfig_5aaea59e]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[_TaskMetricsConfig_5aaea59e], jsii.get(self, "taskMetrics"))

    @builtins.property
    @jsii.member(jsii_name="taskPolicies")
    def _task_policies(self) -> typing.Optional[typing.List[_PolicyStatement_296fe8a3]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.List[_PolicyStatement_296fe8a3]], jsii.get(self, "taskPolicies"))


class SageMakerCreateEndpointConfig(
    _TaskStateBase_c3080646,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.SageMakerCreateEndpointConfig",
):
    '''(experimental) A Step Functions Task to create a SageMaker endpoint configuration.

    :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-sagemaker.html
    :stability: experimental
    :exampleMetadata: infused

    Example::

        tasks.SageMakerCreateEndpointConfig(self, "SagemakerEndpointConfig",
            endpoint_config_name="MyEndpointConfig",
            production_variants=[dynamodb.aws_stepfunctions_tasks.ProductionVariant(
                initial_instance_count=2,
                instance_type=ec2.InstanceType.of(ec2.InstanceClass.M5, ec2.InstanceSize.XLARGE),
                model_name="MyModel",
                variant_name="awesome-variant"
            )]
        )
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        endpoint_config_name: builtins.str,
        production_variants: typing.Sequence[typing.Union[ProductionVariant, typing.Dict[builtins.str, typing.Any]]],
        kms_key: typing.Optional[_IKey_36930160] = None,
        tags: typing.Optional[_TaskInput_71ab46f6] = None,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param endpoint_config_name: (experimental) The name of the endpoint configuration.
        :param production_variants: (experimental) An list of ProductionVariant objects, one for each model that you want to host at this endpoint. Identifies a model that you want to host and the resources to deploy for hosting it. If you are deploying multiple models, tell Amazon SageMaker how to distribute traffic among the models by specifying variant weights.
        :param kms_key: (experimental) AWS Key Management Service key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance that hosts the endpoint. Default: - None
        :param tags: (experimental) Tags to be applied to the endpoint configuration. Default: - No tags
        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a8b5f7dccf4dcc7948fa7362fde487829b9e9850f6135b81eea2d18fbad5ecd0)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = SageMakerCreateEndpointConfigProps(
            endpoint_config_name=endpoint_config_name,
            production_variants=production_variants,
            kms_key=kms_key,
            tags=tags,
            comment=comment,
            heartbeat=heartbeat,
            input_path=input_path,
            integration_pattern=integration_pattern,
            output_path=output_path,
            result_path=result_path,
            result_selector=result_selector,
            timeout=timeout,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="taskMetrics")
    def _task_metrics(self) -> typing.Optional[_TaskMetricsConfig_5aaea59e]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[_TaskMetricsConfig_5aaea59e], jsii.get(self, "taskMetrics"))

    @builtins.property
    @jsii.member(jsii_name="taskPolicies")
    def _task_policies(self) -> typing.Optional[typing.List[_PolicyStatement_296fe8a3]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.List[_PolicyStatement_296fe8a3]], jsii.get(self, "taskPolicies"))


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.SageMakerCreateEndpointConfigProps",
    jsii_struct_bases=[_TaskStateBaseProps_b13f6332],
    name_mapping={
        "comment": "comment",
        "heartbeat": "heartbeat",
        "input_path": "inputPath",
        "integration_pattern": "integrationPattern",
        "output_path": "outputPath",
        "result_path": "resultPath",
        "result_selector": "resultSelector",
        "timeout": "timeout",
        "endpoint_config_name": "endpointConfigName",
        "production_variants": "productionVariants",
        "kms_key": "kmsKey",
        "tags": "tags",
    },
)
class SageMakerCreateEndpointConfigProps(_TaskStateBaseProps_b13f6332):
    def __init__(
        self,
        *,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
        endpoint_config_name: builtins.str,
        production_variants: typing.Sequence[typing.Union[ProductionVariant, typing.Dict[builtins.str, typing.Any]]],
        kms_key: typing.Optional[_IKey_36930160] = None,
        tags: typing.Optional[_TaskInput_71ab46f6] = None,
    ) -> None:
        '''(experimental) Properties for creating an Amazon SageMaker endpoint configuration.

        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None
        :param endpoint_config_name: (experimental) The name of the endpoint configuration.
        :param production_variants: (experimental) An list of ProductionVariant objects, one for each model that you want to host at this endpoint. Identifies a model that you want to host and the resources to deploy for hosting it. If you are deploying multiple models, tell Amazon SageMaker how to distribute traffic among the models by specifying variant weights.
        :param kms_key: (experimental) AWS Key Management Service key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance that hosts the endpoint. Default: - None
        :param tags: (experimental) Tags to be applied to the endpoint configuration. Default: - No tags

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-sagemaker.html
        :stability: experimental
        :exampleMetadata: infused

        Example::

            tasks.SageMakerCreateEndpointConfig(self, "SagemakerEndpointConfig",
                endpoint_config_name="MyEndpointConfig",
                production_variants=[dynamodb.aws_stepfunctions_tasks.ProductionVariant(
                    initial_instance_count=2,
                    instance_type=ec2.InstanceType.of(ec2.InstanceClass.M5, ec2.InstanceSize.XLARGE),
                    model_name="MyModel",
                    variant_name="awesome-variant"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__aee63b2e353aaa63b3a062e1b10682e2a1127cd609d089e45a9b58fd6bad7b9b)
            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
            check_type(argname="argument heartbeat", value=heartbeat, expected_type=type_hints["heartbeat"])
            check_type(argname="argument input_path", value=input_path, expected_type=type_hints["input_path"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
            check_type(argname="argument output_path", value=output_path, expected_type=type_hints["output_path"])
            check_type(argname="argument result_path", value=result_path, expected_type=type_hints["result_path"])
            check_type(argname="argument result_selector", value=result_selector, expected_type=type_hints["result_selector"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
            check_type(argname="argument endpoint_config_name", value=endpoint_config_name, expected_type=type_hints["endpoint_config_name"])
            check_type(argname="argument production_variants", value=production_variants, expected_type=type_hints["production_variants"])
            check_type(argname="argument kms_key", value=kms_key, expected_type=type_hints["kms_key"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "endpoint_config_name": endpoint_config_name,
            "production_variants": production_variants,
        }
        if comment is not None:
            self._values["comment"] = comment
        if heartbeat is not None:
            self._values["heartbeat"] = heartbeat
        if input_path is not None:
            self._values["input_path"] = input_path
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern
        if output_path is not None:
            self._values["output_path"] = output_path
        if result_path is not None:
            self._values["result_path"] = result_path
        if result_selector is not None:
            self._values["result_selector"] = result_selector
        if timeout is not None:
            self._values["timeout"] = timeout
        if kms_key is not None:
            self._values["kms_key"] = kms_key
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def comment(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional description for this state.

        :default: - No comment

        :stability: experimental
        '''
        result = self._values.get("comment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def heartbeat(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the heartbeat.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("heartbeat")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def input_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select part of the state to be the input to this state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        input to be the empty object {}.

        :default: - The entire task input (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("input_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def integration_pattern(self) -> typing.Optional[_IntegrationPattern_fbb35786]:
        '''(experimental) AWS Step Functions integrates with services directly in the Amazon States Language.

        You can control these AWS services using service integration patterns

        :default:

        - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks.
        ``IntegrationPattern.RUN_JOB`` for the following exceptions:
        ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html#connect-wait-token
        :stability: experimental
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_IntegrationPattern_fbb35786], result)

    @builtins.property
    def output_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select select a portion of the state output to pass to the next state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        output to be the empty object {}.

        :default:

        - The entire JSON node determined by the state input, the task result,
        and resultPath is passed to the next state (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("output_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to indicate where to inject the state's output.

        May also be the special value JsonPath.DISCARD, which will cause the state's
        input to become its output.

        :default: - Replaces the entire input with the result (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("result_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied.

        You can use ResultSelector to create a payload with values that are static
        or selected from the state's raw result.

        :default: - None

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/input-output-inputpath-params.html#input-output-resultselector
        :stability: experimental
        '''
        result = self._values.get("result_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def timeout(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the state machine.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def endpoint_config_name(self) -> builtins.str:
        '''(experimental) The name of the endpoint configuration.

        :stability: experimental
        '''
        result = self._values.get("endpoint_config_name")
        assert result is not None, "Required property 'endpoint_config_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def production_variants(self) -> typing.List[ProductionVariant]:
        '''(experimental) An list of ProductionVariant objects, one for each model that you want to host at this endpoint.

        Identifies a model that you want to host and the resources to deploy for hosting it.
        If you are deploying multiple models, tell Amazon SageMaker how to distribute traffic among the models by specifying variant weights.

        :stability: experimental
        '''
        result = self._values.get("production_variants")
        assert result is not None, "Required property 'production_variants' is missing"
        return typing.cast(typing.List[ProductionVariant], result)

    @builtins.property
    def kms_key(self) -> typing.Optional[_IKey_36930160]:
        '''(experimental) AWS Key Management Service key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance that hosts the endpoint.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("kms_key")
        return typing.cast(typing.Optional[_IKey_36930160], result)

    @builtins.property
    def tags(self) -> typing.Optional[_TaskInput_71ab46f6]:
        '''(experimental) Tags to be applied to the endpoint configuration.

        :default: - No tags

        :stability: experimental
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[_TaskInput_71ab46f6], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SageMakerCreateEndpointConfigProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.SageMakerCreateEndpointProps",
    jsii_struct_bases=[_TaskStateBaseProps_b13f6332],
    name_mapping={
        "comment": "comment",
        "heartbeat": "heartbeat",
        "input_path": "inputPath",
        "integration_pattern": "integrationPattern",
        "output_path": "outputPath",
        "result_path": "resultPath",
        "result_selector": "resultSelector",
        "timeout": "timeout",
        "endpoint_config_name": "endpointConfigName",
        "endpoint_name": "endpointName",
        "tags": "tags",
    },
)
class SageMakerCreateEndpointProps(_TaskStateBaseProps_b13f6332):
    def __init__(
        self,
        *,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
        endpoint_config_name: builtins.str,
        endpoint_name: builtins.str,
        tags: typing.Optional[_TaskInput_71ab46f6] = None,
    ) -> None:
        '''(experimental) Properties for creating an Amazon SageMaker endpoint.

        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None
        :param endpoint_config_name: (experimental) The name of an endpoint configuration.
        :param endpoint_name: (experimental) The name of the endpoint. The name must be unique within an AWS Region in your AWS account.
        :param tags: (experimental) Tags to be applied to the endpoint. Default: - No tags

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-sagemaker.html
        :stability: experimental
        :exampleMetadata: infused

        Example::

            tasks.SageMakerCreateEndpoint(self, "SagemakerEndpoint",
                endpoint_name=sfn.JsonPath.string_at("$.EndpointName"),
                endpoint_config_name=sfn.JsonPath.string_at("$.EndpointConfigName")
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__21b89c2b588aa81ecea0df9ca076be778ab283f7337d7bc57d899aa761245b22)
            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
            check_type(argname="argument heartbeat", value=heartbeat, expected_type=type_hints["heartbeat"])
            check_type(argname="argument input_path", value=input_path, expected_type=type_hints["input_path"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
            check_type(argname="argument output_path", value=output_path, expected_type=type_hints["output_path"])
            check_type(argname="argument result_path", value=result_path, expected_type=type_hints["result_path"])
            check_type(argname="argument result_selector", value=result_selector, expected_type=type_hints["result_selector"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
            check_type(argname="argument endpoint_config_name", value=endpoint_config_name, expected_type=type_hints["endpoint_config_name"])
            check_type(argname="argument endpoint_name", value=endpoint_name, expected_type=type_hints["endpoint_name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "endpoint_config_name": endpoint_config_name,
            "endpoint_name": endpoint_name,
        }
        if comment is not None:
            self._values["comment"] = comment
        if heartbeat is not None:
            self._values["heartbeat"] = heartbeat
        if input_path is not None:
            self._values["input_path"] = input_path
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern
        if output_path is not None:
            self._values["output_path"] = output_path
        if result_path is not None:
            self._values["result_path"] = result_path
        if result_selector is not None:
            self._values["result_selector"] = result_selector
        if timeout is not None:
            self._values["timeout"] = timeout
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def comment(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional description for this state.

        :default: - No comment

        :stability: experimental
        '''
        result = self._values.get("comment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def heartbeat(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the heartbeat.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("heartbeat")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def input_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select part of the state to be the input to this state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        input to be the empty object {}.

        :default: - The entire task input (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("input_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def integration_pattern(self) -> typing.Optional[_IntegrationPattern_fbb35786]:
        '''(experimental) AWS Step Functions integrates with services directly in the Amazon States Language.

        You can control these AWS services using service integration patterns

        :default:

        - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks.
        ``IntegrationPattern.RUN_JOB`` for the following exceptions:
        ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html#connect-wait-token
        :stability: experimental
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_IntegrationPattern_fbb35786], result)

    @builtins.property
    def output_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select select a portion of the state output to pass to the next state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        output to be the empty object {}.

        :default:

        - The entire JSON node determined by the state input, the task result,
        and resultPath is passed to the next state (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("output_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to indicate where to inject the state's output.

        May also be the special value JsonPath.DISCARD, which will cause the state's
        input to become its output.

        :default: - Replaces the entire input with the result (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("result_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied.

        You can use ResultSelector to create a payload with values that are static
        or selected from the state's raw result.

        :default: - None

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/input-output-inputpath-params.html#input-output-resultselector
        :stability: experimental
        '''
        result = self._values.get("result_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def timeout(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the state machine.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def endpoint_config_name(self) -> builtins.str:
        '''(experimental) The name of an endpoint configuration.

        :stability: experimental
        '''
        result = self._values.get("endpoint_config_name")
        assert result is not None, "Required property 'endpoint_config_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def endpoint_name(self) -> builtins.str:
        '''(experimental) The name of the endpoint.

        The name must be unique within an AWS Region in your AWS account.

        :stability: experimental
        '''
        result = self._values.get("endpoint_name")
        assert result is not None, "Required property 'endpoint_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def tags(self) -> typing.Optional[_TaskInput_71ab46f6]:
        '''(experimental) Tags to be applied to the endpoint.

        :default: - No tags

        :stability: experimental
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[_TaskInput_71ab46f6], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SageMakerCreateEndpointProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IGrantable_4c5a91d1, _IConnectable_c1c0e72c)
class SageMakerCreateModel(
    _TaskStateBase_c3080646,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.SageMakerCreateModel",
):
    '''(experimental) A Step Functions Task to create a SageMaker model.

    :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-sagemaker.html
    :stability: experimental
    :exampleMetadata: infused

    Example::

        tasks.SageMakerCreateModel(self, "Sagemaker",
            model_name="MyModel",
            primary_container=tasks.ContainerDefinition(
                image=tasks.DockerImage.from_json_expression(sfn.JsonPath.string_at("$.Model.imageName")),
                mode=tasks.Mode.SINGLE_MODEL,
                model_s3_location=tasks.S3Location.from_json_expression("$.TrainingJob.ModelArtifacts.S3ModelArtifacts")
            )
        )
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        model_name: builtins.str,
        primary_container: IContainerDefinition,
        containers: typing.Optional[typing.Sequence[IContainerDefinition]] = None,
        enable_network_isolation: typing.Optional[builtins.bool] = None,
        role: typing.Optional[_IRole_59af6f50] = None,
        subnet_selection: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
        tags: typing.Optional[_TaskInput_71ab46f6] = None,
        vpc: typing.Optional[_IVpc_6d1f76c4] = None,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param model_name: (experimental) The name of the new model.
        :param primary_container: (experimental) The definition of the primary docker image containing inference code, associated artifacts, and custom environment map that the inference code uses when the model is deployed for predictions.
        :param containers: (experimental) Specifies the containers in the inference pipeline. Default: - None
        :param enable_network_isolation: (experimental) Isolates the model container. No inbound or outbound network calls can be made to or from the model container. Default: false
        :param role: (experimental) An execution role that you can pass in a CreateModel API request. Default: - a role will be created.
        :param subnet_selection: (experimental) The subnets of the VPC to which the hosted model is connected (Note this parameter is only used when VPC is provided). Default: - Private Subnets are selected
        :param tags: (experimental) Tags to be applied to the model. Default: - No tags
        :param vpc: (experimental) The VPC that is accessible by the hosted model. Default: - None
        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5d9b0a013e5d17d7f5cc66b30072671109196c35673b7ee5b91e20b3c2350d64)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = SageMakerCreateModelProps(
            model_name=model_name,
            primary_container=primary_container,
            containers=containers,
            enable_network_isolation=enable_network_isolation,
            role=role,
            subnet_selection=subnet_selection,
            tags=tags,
            vpc=vpc,
            comment=comment,
            heartbeat=heartbeat,
            input_path=input_path,
            integration_pattern=integration_pattern,
            output_path=output_path,
            result_path=result_path,
            result_selector=result_selector,
            timeout=timeout,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="addSecurityGroup")
    def add_security_group(self, security_group: _ISecurityGroup_cdbba9d3) -> None:
        '''(experimental) Add the security group to all instances via the launch configuration security groups array.

        :param security_group: : The security group to add.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b899e54b6c516b1d1bee86847cfd911d23505474423ac4adb906cf0a07934e81)
            check_type(argname="argument security_group", value=security_group, expected_type=type_hints["security_group"])
        return typing.cast(None, jsii.invoke(self, "addSecurityGroup", [security_group]))

    @builtins.property
    @jsii.member(jsii_name="connections")
    def connections(self) -> _Connections_57ccbda9:
        '''(experimental) Allows specify security group connections for instances of this fleet.

        :stability: experimental
        '''
        return typing.cast(_Connections_57ccbda9, jsii.get(self, "connections"))

    @builtins.property
    @jsii.member(jsii_name="grantPrincipal")
    def grant_principal(self) -> _IPrincipal_93b48231:
        '''(experimental) The principal to grant permissions to.

        :stability: experimental
        '''
        return typing.cast(_IPrincipal_93b48231, jsii.get(self, "grantPrincipal"))

    @builtins.property
    @jsii.member(jsii_name="role")
    def role(self) -> _IRole_59af6f50:
        '''(experimental) The execution role for the Sagemaker Create Model API.

        :stability: experimental
        '''
        return typing.cast(_IRole_59af6f50, jsii.get(self, "role"))

    @builtins.property
    @jsii.member(jsii_name="taskMetrics")
    def _task_metrics(self) -> typing.Optional[_TaskMetricsConfig_5aaea59e]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[_TaskMetricsConfig_5aaea59e], jsii.get(self, "taskMetrics"))

    @builtins.property
    @jsii.member(jsii_name="taskPolicies")
    def _task_policies(self) -> typing.Optional[typing.List[_PolicyStatement_296fe8a3]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.List[_PolicyStatement_296fe8a3]], jsii.get(self, "taskPolicies"))


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.SageMakerCreateModelProps",
    jsii_struct_bases=[_TaskStateBaseProps_b13f6332],
    name_mapping={
        "comment": "comment",
        "heartbeat": "heartbeat",
        "input_path": "inputPath",
        "integration_pattern": "integrationPattern",
        "output_path": "outputPath",
        "result_path": "resultPath",
        "result_selector": "resultSelector",
        "timeout": "timeout",
        "model_name": "modelName",
        "primary_container": "primaryContainer",
        "containers": "containers",
        "enable_network_isolation": "enableNetworkIsolation",
        "role": "role",
        "subnet_selection": "subnetSelection",
        "tags": "tags",
        "vpc": "vpc",
    },
)
class SageMakerCreateModelProps(_TaskStateBaseProps_b13f6332):
    def __init__(
        self,
        *,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
        model_name: builtins.str,
        primary_container: IContainerDefinition,
        containers: typing.Optional[typing.Sequence[IContainerDefinition]] = None,
        enable_network_isolation: typing.Optional[builtins.bool] = None,
        role: typing.Optional[_IRole_59af6f50] = None,
        subnet_selection: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
        tags: typing.Optional[_TaskInput_71ab46f6] = None,
        vpc: typing.Optional[_IVpc_6d1f76c4] = None,
    ) -> None:
        '''(experimental) Properties for creating an Amazon SageMaker model.

        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None
        :param model_name: (experimental) The name of the new model.
        :param primary_container: (experimental) The definition of the primary docker image containing inference code, associated artifacts, and custom environment map that the inference code uses when the model is deployed for predictions.
        :param containers: (experimental) Specifies the containers in the inference pipeline. Default: - None
        :param enable_network_isolation: (experimental) Isolates the model container. No inbound or outbound network calls can be made to or from the model container. Default: false
        :param role: (experimental) An execution role that you can pass in a CreateModel API request. Default: - a role will be created.
        :param subnet_selection: (experimental) The subnets of the VPC to which the hosted model is connected (Note this parameter is only used when VPC is provided). Default: - Private Subnets are selected
        :param tags: (experimental) Tags to be applied to the model. Default: - No tags
        :param vpc: (experimental) The VPC that is accessible by the hosted model. Default: - None

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-sagemaker.html
        :stability: experimental
        :exampleMetadata: infused

        Example::

            tasks.SageMakerCreateModel(self, "Sagemaker",
                model_name="MyModel",
                primary_container=tasks.ContainerDefinition(
                    image=tasks.DockerImage.from_json_expression(sfn.JsonPath.string_at("$.Model.imageName")),
                    mode=tasks.Mode.SINGLE_MODEL,
                    model_s3_location=tasks.S3Location.from_json_expression("$.TrainingJob.ModelArtifacts.S3ModelArtifacts")
                )
            )
        '''
        if isinstance(subnet_selection, dict):
            subnet_selection = _SubnetSelection_1284e62c(**subnet_selection)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2584dc82090ec0181eb4013b44d129c17ae88927700ebe5d70703a069f1c10a0)
            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
            check_type(argname="argument heartbeat", value=heartbeat, expected_type=type_hints["heartbeat"])
            check_type(argname="argument input_path", value=input_path, expected_type=type_hints["input_path"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
            check_type(argname="argument output_path", value=output_path, expected_type=type_hints["output_path"])
            check_type(argname="argument result_path", value=result_path, expected_type=type_hints["result_path"])
            check_type(argname="argument result_selector", value=result_selector, expected_type=type_hints["result_selector"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
            check_type(argname="argument model_name", value=model_name, expected_type=type_hints["model_name"])
            check_type(argname="argument primary_container", value=primary_container, expected_type=type_hints["primary_container"])
            check_type(argname="argument containers", value=containers, expected_type=type_hints["containers"])
            check_type(argname="argument enable_network_isolation", value=enable_network_isolation, expected_type=type_hints["enable_network_isolation"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            check_type(argname="argument subnet_selection", value=subnet_selection, expected_type=type_hints["subnet_selection"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument vpc", value=vpc, expected_type=type_hints["vpc"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "model_name": model_name,
            "primary_container": primary_container,
        }
        if comment is not None:
            self._values["comment"] = comment
        if heartbeat is not None:
            self._values["heartbeat"] = heartbeat
        if input_path is not None:
            self._values["input_path"] = input_path
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern
        if output_path is not None:
            self._values["output_path"] = output_path
        if result_path is not None:
            self._values["result_path"] = result_path
        if result_selector is not None:
            self._values["result_selector"] = result_selector
        if timeout is not None:
            self._values["timeout"] = timeout
        if containers is not None:
            self._values["containers"] = containers
        if enable_network_isolation is not None:
            self._values["enable_network_isolation"] = enable_network_isolation
        if role is not None:
            self._values["role"] = role
        if subnet_selection is not None:
            self._values["subnet_selection"] = subnet_selection
        if tags is not None:
            self._values["tags"] = tags
        if vpc is not None:
            self._values["vpc"] = vpc

    @builtins.property
    def comment(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional description for this state.

        :default: - No comment

        :stability: experimental
        '''
        result = self._values.get("comment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def heartbeat(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the heartbeat.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("heartbeat")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def input_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select part of the state to be the input to this state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        input to be the empty object {}.

        :default: - The entire task input (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("input_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def integration_pattern(self) -> typing.Optional[_IntegrationPattern_fbb35786]:
        '''(experimental) AWS Step Functions integrates with services directly in the Amazon States Language.

        You can control these AWS services using service integration patterns

        :default:

        - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks.
        ``IntegrationPattern.RUN_JOB`` for the following exceptions:
        ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html#connect-wait-token
        :stability: experimental
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_IntegrationPattern_fbb35786], result)

    @builtins.property
    def output_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select select a portion of the state output to pass to the next state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        output to be the empty object {}.

        :default:

        - The entire JSON node determined by the state input, the task result,
        and resultPath is passed to the next state (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("output_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to indicate where to inject the state's output.

        May also be the special value JsonPath.DISCARD, which will cause the state's
        input to become its output.

        :default: - Replaces the entire input with the result (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("result_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied.

        You can use ResultSelector to create a payload with values that are static
        or selected from the state's raw result.

        :default: - None

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/input-output-inputpath-params.html#input-output-resultselector
        :stability: experimental
        '''
        result = self._values.get("result_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def timeout(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the state machine.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def model_name(self) -> builtins.str:
        '''(experimental) The name of the new model.

        :stability: experimental
        '''
        result = self._values.get("model_name")
        assert result is not None, "Required property 'model_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def primary_container(self) -> IContainerDefinition:
        '''(experimental) The definition of the primary docker image containing inference code, associated artifacts, and custom environment map that the inference code uses when the model is deployed for predictions.

        :stability: experimental
        '''
        result = self._values.get("primary_container")
        assert result is not None, "Required property 'primary_container' is missing"
        return typing.cast(IContainerDefinition, result)

    @builtins.property
    def containers(self) -> typing.Optional[typing.List[IContainerDefinition]]:
        '''(experimental) Specifies the containers in the inference pipeline.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("containers")
        return typing.cast(typing.Optional[typing.List[IContainerDefinition]], result)

    @builtins.property
    def enable_network_isolation(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Isolates the model container.

        No inbound or outbound network calls can be made to or from the model container.

        :default: false

        :stability: experimental
        '''
        result = self._values.get("enable_network_isolation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def role(self) -> typing.Optional[_IRole_59af6f50]:
        '''(experimental) An execution role that you can pass in a CreateModel API request.

        :default: - a role will be created.

        :stability: experimental
        '''
        result = self._values.get("role")
        return typing.cast(typing.Optional[_IRole_59af6f50], result)

    @builtins.property
    def subnet_selection(self) -> typing.Optional[_SubnetSelection_1284e62c]:
        '''(experimental) The subnets of the VPC to which the hosted model is connected (Note this parameter is only used when VPC is provided).

        :default: - Private Subnets are selected

        :stability: experimental
        '''
        result = self._values.get("subnet_selection")
        return typing.cast(typing.Optional[_SubnetSelection_1284e62c], result)

    @builtins.property
    def tags(self) -> typing.Optional[_TaskInput_71ab46f6]:
        '''(experimental) Tags to be applied to the model.

        :default: - No tags

        :stability: experimental
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[_TaskInput_71ab46f6], result)

    @builtins.property
    def vpc(self) -> typing.Optional[_IVpc_6d1f76c4]:
        '''(experimental) The VPC that is accessible by the hosted model.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("vpc")
        return typing.cast(typing.Optional[_IVpc_6d1f76c4], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SageMakerCreateModelProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IGrantable_4c5a91d1, _IConnectable_c1c0e72c)
class SageMakerCreateTrainingJob(
    _TaskStateBase_c3080646,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.SageMakerCreateTrainingJob",
):
    '''(experimental) Class representing the SageMaker Create Training Job task.

    :stability: experimental
    :exampleMetadata: infused

    Example::

        tasks.SageMakerCreateTrainingJob(self, "TrainSagemaker",
            training_job_name=sfn.JsonPath.string_at("$.JobName"),
            algorithm_specification=dynamodb.aws_stepfunctions_tasks.AlgorithmSpecification(
                algorithm_name="BlazingText",
                training_input_mode=tasks.InputMode.FILE
            ),
            input_data_config=[dynamodb.aws_stepfunctions_tasks.Channel(
                channel_name="train",
                data_source=dynamodb.aws_stepfunctions_tasks.DataSource(
                    s3_data_source=dynamodb.aws_stepfunctions_tasks.S3DataSource(
                        s3_data_type=tasks.S3DataType.S3_PREFIX,
                        s3_location=tasks.S3Location.from_json_expression("$.S3Bucket")
                    )
                )
            )],
            output_data_config=dynamodb.aws_stepfunctions_tasks.OutputDataConfig(
                s3_output_location=tasks.S3Location.from_bucket(s3.Bucket.from_bucket_name(self, "Bucket", "mybucket"), "myoutputpath")
            ),
            resource_config=dynamodb.aws_stepfunctions_tasks.ResourceConfig(
                instance_count=1,
                instance_type=ec2.InstanceType(sfn.JsonPath.string_at("$.InstanceType")),
                volume_size=Size.gibibytes(50)
            ),  # optional: default is 1 instance of EC2 `M4.XLarge` with `10GB` volume
            stopping_condition=dynamodb.aws_stepfunctions_tasks.StoppingCondition(
                max_runtime=Duration.hours(2)
            )
        )
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        algorithm_specification: typing.Union[AlgorithmSpecification, typing.Dict[builtins.str, typing.Any]],
        input_data_config: typing.Sequence[typing.Union[Channel, typing.Dict[builtins.str, typing.Any]]],
        output_data_config: typing.Union[OutputDataConfig, typing.Dict[builtins.str, typing.Any]],
        training_job_name: builtins.str,
        enable_network_isolation: typing.Optional[builtins.bool] = None,
        environment: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        hyperparameters: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        resource_config: typing.Optional[typing.Union[ResourceConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        role: typing.Optional[_IRole_59af6f50] = None,
        stopping_condition: typing.Optional[typing.Union["StoppingCondition", typing.Dict[builtins.str, typing.Any]]] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        vpc_config: typing.Optional[typing.Union["VpcConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param algorithm_specification: (experimental) Identifies the training algorithm to use.
        :param input_data_config: (experimental) Describes the various datasets (e.g. train, validation, test) and the Amazon S3 location where stored.
        :param output_data_config: (experimental) Identifies the Amazon S3 location where you want Amazon SageMaker to save the results of model training.
        :param training_job_name: (experimental) Training Job Name.
        :param enable_network_isolation: (experimental) Isolates the training container. No inbound or outbound network calls can be made to or from the training container. Default: false
        :param environment: (experimental) Environment variables to set in the Docker container. Default: - No environment variables
        :param hyperparameters: (experimental) Algorithm-specific parameters that influence the quality of the model. Set hyperparameters before you start the learning process. For a list of hyperparameters provided by Amazon SageMaker Default: - No hyperparameters
        :param resource_config: (experimental) Specifies the resources, ML compute instances, and ML storage volumes to deploy for model training. Default: - 1 instance of EC2 ``M4.XLarge`` with ``10GB`` volume
        :param role: (experimental) Role for the Training Job. The role must be granted all necessary permissions for the SageMaker training job to be able to operate. See https://docs.aws.amazon.com/fr_fr/sagemaker/latest/dg/sagemaker-roles.html#sagemaker-roles-createtrainingjob-perms Default: - a role will be created.
        :param stopping_condition: (experimental) Sets a time limit for training. Default: - max runtime of 1 hour
        :param tags: (experimental) Tags to be applied to the train job. Default: - No tags
        :param vpc_config: (experimental) Specifies the VPC that you want your training job to connect to. Default: - No VPC
        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ee1ab3616f7627c3f9f0792c8b041ea0b1a7f6e4ec8df1987ee468959020f075)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = SageMakerCreateTrainingJobProps(
            algorithm_specification=algorithm_specification,
            input_data_config=input_data_config,
            output_data_config=output_data_config,
            training_job_name=training_job_name,
            enable_network_isolation=enable_network_isolation,
            environment=environment,
            hyperparameters=hyperparameters,
            resource_config=resource_config,
            role=role,
            stopping_condition=stopping_condition,
            tags=tags,
            vpc_config=vpc_config,
            comment=comment,
            heartbeat=heartbeat,
            input_path=input_path,
            integration_pattern=integration_pattern,
            output_path=output_path,
            result_path=result_path,
            result_selector=result_selector,
            timeout=timeout,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="addSecurityGroup")
    def add_security_group(self, security_group: _ISecurityGroup_cdbba9d3) -> None:
        '''(experimental) Add the security group to all instances via the launch configuration security groups array.

        :param security_group: : The security group to add.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1cd32dc5e54d05c6b79dd9e817a74be0c51620ce4bb03edf2a1522fc5ea650ef)
            check_type(argname="argument security_group", value=security_group, expected_type=type_hints["security_group"])
        return typing.cast(None, jsii.invoke(self, "addSecurityGroup", [security_group]))

    @builtins.property
    @jsii.member(jsii_name="connections")
    def connections(self) -> _Connections_57ccbda9:
        '''(experimental) Allows specify security group connections for instances of this fleet.

        :stability: experimental
        '''
        return typing.cast(_Connections_57ccbda9, jsii.get(self, "connections"))

    @builtins.property
    @jsii.member(jsii_name="grantPrincipal")
    def grant_principal(self) -> _IPrincipal_93b48231:
        '''(experimental) The principal to grant permissions to.

        :stability: experimental
        '''
        return typing.cast(_IPrincipal_93b48231, jsii.get(self, "grantPrincipal"))

    @builtins.property
    @jsii.member(jsii_name="role")
    def role(self) -> _IRole_59af6f50:
        '''(experimental) The execution role for the Sagemaker training job.

        Only available after task has been added to a state machine.

        :stability: experimental
        '''
        return typing.cast(_IRole_59af6f50, jsii.get(self, "role"))

    @builtins.property
    @jsii.member(jsii_name="taskMetrics")
    def _task_metrics(self) -> typing.Optional[_TaskMetricsConfig_5aaea59e]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[_TaskMetricsConfig_5aaea59e], jsii.get(self, "taskMetrics"))

    @builtins.property
    @jsii.member(jsii_name="taskPolicies")
    def _task_policies(self) -> typing.Optional[typing.List[_PolicyStatement_296fe8a3]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.List[_PolicyStatement_296fe8a3]], jsii.get(self, "taskPolicies"))


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.SageMakerCreateTrainingJobProps",
    jsii_struct_bases=[_TaskStateBaseProps_b13f6332],
    name_mapping={
        "comment": "comment",
        "heartbeat": "heartbeat",
        "input_path": "inputPath",
        "integration_pattern": "integrationPattern",
        "output_path": "outputPath",
        "result_path": "resultPath",
        "result_selector": "resultSelector",
        "timeout": "timeout",
        "algorithm_specification": "algorithmSpecification",
        "input_data_config": "inputDataConfig",
        "output_data_config": "outputDataConfig",
        "training_job_name": "trainingJobName",
        "enable_network_isolation": "enableNetworkIsolation",
        "environment": "environment",
        "hyperparameters": "hyperparameters",
        "resource_config": "resourceConfig",
        "role": "role",
        "stopping_condition": "stoppingCondition",
        "tags": "tags",
        "vpc_config": "vpcConfig",
    },
)
class SageMakerCreateTrainingJobProps(_TaskStateBaseProps_b13f6332):
    def __init__(
        self,
        *,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
        algorithm_specification: typing.Union[AlgorithmSpecification, typing.Dict[builtins.str, typing.Any]],
        input_data_config: typing.Sequence[typing.Union[Channel, typing.Dict[builtins.str, typing.Any]]],
        output_data_config: typing.Union[OutputDataConfig, typing.Dict[builtins.str, typing.Any]],
        training_job_name: builtins.str,
        enable_network_isolation: typing.Optional[builtins.bool] = None,
        environment: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        hyperparameters: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        resource_config: typing.Optional[typing.Union[ResourceConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        role: typing.Optional[_IRole_59af6f50] = None,
        stopping_condition: typing.Optional[typing.Union["StoppingCondition", typing.Dict[builtins.str, typing.Any]]] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        vpc_config: typing.Optional[typing.Union["VpcConfig", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''(experimental) Properties for creating an Amazon SageMaker training job.

        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None
        :param algorithm_specification: (experimental) Identifies the training algorithm to use.
        :param input_data_config: (experimental) Describes the various datasets (e.g. train, validation, test) and the Amazon S3 location where stored.
        :param output_data_config: (experimental) Identifies the Amazon S3 location where you want Amazon SageMaker to save the results of model training.
        :param training_job_name: (experimental) Training Job Name.
        :param enable_network_isolation: (experimental) Isolates the training container. No inbound or outbound network calls can be made to or from the training container. Default: false
        :param environment: (experimental) Environment variables to set in the Docker container. Default: - No environment variables
        :param hyperparameters: (experimental) Algorithm-specific parameters that influence the quality of the model. Set hyperparameters before you start the learning process. For a list of hyperparameters provided by Amazon SageMaker Default: - No hyperparameters
        :param resource_config: (experimental) Specifies the resources, ML compute instances, and ML storage volumes to deploy for model training. Default: - 1 instance of EC2 ``M4.XLarge`` with ``10GB`` volume
        :param role: (experimental) Role for the Training Job. The role must be granted all necessary permissions for the SageMaker training job to be able to operate. See https://docs.aws.amazon.com/fr_fr/sagemaker/latest/dg/sagemaker-roles.html#sagemaker-roles-createtrainingjob-perms Default: - a role will be created.
        :param stopping_condition: (experimental) Sets a time limit for training. Default: - max runtime of 1 hour
        :param tags: (experimental) Tags to be applied to the train job. Default: - No tags
        :param vpc_config: (experimental) Specifies the VPC that you want your training job to connect to. Default: - No VPC

        :stability: experimental
        :exampleMetadata: infused

        Example::

            tasks.SageMakerCreateTrainingJob(self, "TrainSagemaker",
                training_job_name=sfn.JsonPath.string_at("$.JobName"),
                algorithm_specification=dynamodb.aws_stepfunctions_tasks.AlgorithmSpecification(
                    algorithm_name="BlazingText",
                    training_input_mode=tasks.InputMode.FILE
                ),
                input_data_config=[dynamodb.aws_stepfunctions_tasks.Channel(
                    channel_name="train",
                    data_source=dynamodb.aws_stepfunctions_tasks.DataSource(
                        s3_data_source=dynamodb.aws_stepfunctions_tasks.S3DataSource(
                            s3_data_type=tasks.S3DataType.S3_PREFIX,
                            s3_location=tasks.S3Location.from_json_expression("$.S3Bucket")
                        )
                    )
                )],
                output_data_config=dynamodb.aws_stepfunctions_tasks.OutputDataConfig(
                    s3_output_location=tasks.S3Location.from_bucket(s3.Bucket.from_bucket_name(self, "Bucket", "mybucket"), "myoutputpath")
                ),
                resource_config=dynamodb.aws_stepfunctions_tasks.ResourceConfig(
                    instance_count=1,
                    instance_type=ec2.InstanceType(sfn.JsonPath.string_at("$.InstanceType")),
                    volume_size=Size.gibibytes(50)
                ),  # optional: default is 1 instance of EC2 `M4.XLarge` with `10GB` volume
                stopping_condition=dynamodb.aws_stepfunctions_tasks.StoppingCondition(
                    max_runtime=Duration.hours(2)
                )
            )
        '''
        if isinstance(algorithm_specification, dict):
            algorithm_specification = AlgorithmSpecification(**algorithm_specification)
        if isinstance(output_data_config, dict):
            output_data_config = OutputDataConfig(**output_data_config)
        if isinstance(resource_config, dict):
            resource_config = ResourceConfig(**resource_config)
        if isinstance(stopping_condition, dict):
            stopping_condition = StoppingCondition(**stopping_condition)
        if isinstance(vpc_config, dict):
            vpc_config = VpcConfig(**vpc_config)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2167905d754de5200c2b10dc18b658d3bdbb5648bc6408e17fdd47dbd47d8be5)
            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
            check_type(argname="argument heartbeat", value=heartbeat, expected_type=type_hints["heartbeat"])
            check_type(argname="argument input_path", value=input_path, expected_type=type_hints["input_path"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
            check_type(argname="argument output_path", value=output_path, expected_type=type_hints["output_path"])
            check_type(argname="argument result_path", value=result_path, expected_type=type_hints["result_path"])
            check_type(argname="argument result_selector", value=result_selector, expected_type=type_hints["result_selector"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
            check_type(argname="argument algorithm_specification", value=algorithm_specification, expected_type=type_hints["algorithm_specification"])
            check_type(argname="argument input_data_config", value=input_data_config, expected_type=type_hints["input_data_config"])
            check_type(argname="argument output_data_config", value=output_data_config, expected_type=type_hints["output_data_config"])
            check_type(argname="argument training_job_name", value=training_job_name, expected_type=type_hints["training_job_name"])
            check_type(argname="argument enable_network_isolation", value=enable_network_isolation, expected_type=type_hints["enable_network_isolation"])
            check_type(argname="argument environment", value=environment, expected_type=type_hints["environment"])
            check_type(argname="argument hyperparameters", value=hyperparameters, expected_type=type_hints["hyperparameters"])
            check_type(argname="argument resource_config", value=resource_config, expected_type=type_hints["resource_config"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            check_type(argname="argument stopping_condition", value=stopping_condition, expected_type=type_hints["stopping_condition"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument vpc_config", value=vpc_config, expected_type=type_hints["vpc_config"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "algorithm_specification": algorithm_specification,
            "input_data_config": input_data_config,
            "output_data_config": output_data_config,
            "training_job_name": training_job_name,
        }
        if comment is not None:
            self._values["comment"] = comment
        if heartbeat is not None:
            self._values["heartbeat"] = heartbeat
        if input_path is not None:
            self._values["input_path"] = input_path
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern
        if output_path is not None:
            self._values["output_path"] = output_path
        if result_path is not None:
            self._values["result_path"] = result_path
        if result_selector is not None:
            self._values["result_selector"] = result_selector
        if timeout is not None:
            self._values["timeout"] = timeout
        if enable_network_isolation is not None:
            self._values["enable_network_isolation"] = enable_network_isolation
        if environment is not None:
            self._values["environment"] = environment
        if hyperparameters is not None:
            self._values["hyperparameters"] = hyperparameters
        if resource_config is not None:
            self._values["resource_config"] = resource_config
        if role is not None:
            self._values["role"] = role
        if stopping_condition is not None:
            self._values["stopping_condition"] = stopping_condition
        if tags is not None:
            self._values["tags"] = tags
        if vpc_config is not None:
            self._values["vpc_config"] = vpc_config

    @builtins.property
    def comment(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional description for this state.

        :default: - No comment

        :stability: experimental
        '''
        result = self._values.get("comment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def heartbeat(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the heartbeat.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("heartbeat")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def input_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select part of the state to be the input to this state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        input to be the empty object {}.

        :default: - The entire task input (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("input_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def integration_pattern(self) -> typing.Optional[_IntegrationPattern_fbb35786]:
        '''(experimental) AWS Step Functions integrates with services directly in the Amazon States Language.

        You can control these AWS services using service integration patterns

        :default:

        - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks.
        ``IntegrationPattern.RUN_JOB`` for the following exceptions:
        ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html#connect-wait-token
        :stability: experimental
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_IntegrationPattern_fbb35786], result)

    @builtins.property
    def output_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select select a portion of the state output to pass to the next state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        output to be the empty object {}.

        :default:

        - The entire JSON node determined by the state input, the task result,
        and resultPath is passed to the next state (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("output_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to indicate where to inject the state's output.

        May also be the special value JsonPath.DISCARD, which will cause the state's
        input to become its output.

        :default: - Replaces the entire input with the result (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("result_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied.

        You can use ResultSelector to create a payload with values that are static
        or selected from the state's raw result.

        :default: - None

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/input-output-inputpath-params.html#input-output-resultselector
        :stability: experimental
        '''
        result = self._values.get("result_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def timeout(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the state machine.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def algorithm_specification(self) -> AlgorithmSpecification:
        '''(experimental) Identifies the training algorithm to use.

        :stability: experimental
        '''
        result = self._values.get("algorithm_specification")
        assert result is not None, "Required property 'algorithm_specification' is missing"
        return typing.cast(AlgorithmSpecification, result)

    @builtins.property
    def input_data_config(self) -> typing.List[Channel]:
        '''(experimental) Describes the various datasets (e.g. train, validation, test) and the Amazon S3 location where stored.

        :stability: experimental
        '''
        result = self._values.get("input_data_config")
        assert result is not None, "Required property 'input_data_config' is missing"
        return typing.cast(typing.List[Channel], result)

    @builtins.property
    def output_data_config(self) -> OutputDataConfig:
        '''(experimental) Identifies the Amazon S3 location where you want Amazon SageMaker to save the results of model training.

        :stability: experimental
        '''
        result = self._values.get("output_data_config")
        assert result is not None, "Required property 'output_data_config' is missing"
        return typing.cast(OutputDataConfig, result)

    @builtins.property
    def training_job_name(self) -> builtins.str:
        '''(experimental) Training Job Name.

        :stability: experimental
        '''
        result = self._values.get("training_job_name")
        assert result is not None, "Required property 'training_job_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def enable_network_isolation(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Isolates the training container.

        No inbound or outbound network calls can be made to or from the training container.

        :default: false

        :stability: experimental
        '''
        result = self._values.get("enable_network_isolation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def environment(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''(experimental) Environment variables to set in the Docker container.

        :default: - No environment variables

        :stability: experimental
        '''
        result = self._values.get("environment")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def hyperparameters(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) Algorithm-specific parameters that influence the quality of the model.

        Set hyperparameters before you start the learning process.
        For a list of hyperparameters provided by Amazon SageMaker

        :default: - No hyperparameters

        :see: https://docs.aws.amazon.com/sagemaker/latest/dg/algos.html
        :stability: experimental
        '''
        result = self._values.get("hyperparameters")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def resource_config(self) -> typing.Optional[ResourceConfig]:
        '''(experimental) Specifies the resources, ML compute instances, and ML storage volumes to deploy for model training.

        :default: - 1 instance of EC2 ``M4.XLarge`` with ``10GB`` volume

        :stability: experimental
        '''
        result = self._values.get("resource_config")
        return typing.cast(typing.Optional[ResourceConfig], result)

    @builtins.property
    def role(self) -> typing.Optional[_IRole_59af6f50]:
        '''(experimental) Role for the Training Job.

        The role must be granted all necessary permissions for the SageMaker training job to
        be able to operate.

        See https://docs.aws.amazon.com/fr_fr/sagemaker/latest/dg/sagemaker-roles.html#sagemaker-roles-createtrainingjob-perms

        :default: - a role will be created.

        :stability: experimental
        '''
        result = self._values.get("role")
        return typing.cast(typing.Optional[_IRole_59af6f50], result)

    @builtins.property
    def stopping_condition(self) -> typing.Optional["StoppingCondition"]:
        '''(experimental) Sets a time limit for training.

        :default: - max runtime of 1 hour

        :stability: experimental
        '''
        result = self._values.get("stopping_condition")
        return typing.cast(typing.Optional["StoppingCondition"], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''(experimental) Tags to be applied to the train job.

        :default: - No tags

        :stability: experimental
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def vpc_config(self) -> typing.Optional["VpcConfig"]:
        '''(experimental) Specifies the VPC that you want your training job to connect to.

        :default: - No VPC

        :stability: experimental
        '''
        result = self._values.get("vpc_config")
        return typing.cast(typing.Optional["VpcConfig"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SageMakerCreateTrainingJobProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SageMakerCreateTransformJob(
    _TaskStateBase_c3080646,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.SageMakerCreateTransformJob",
):
    '''(experimental) Class representing the SageMaker Create Transform Job task.

    :stability: experimental
    :exampleMetadata: infused

    Example::

        tasks.SageMakerCreateTransformJob(self, "Batch Inference",
            transform_job_name="MyTransformJob",
            model_name="MyModelName",
            model_client_options=dynamodb.aws_stepfunctions_tasks.ModelClientOptions(
                invocations_max_retries=3,  # default is 0
                invocations_timeout=Duration.minutes(5)
            ),
            transform_input=dynamodb.aws_stepfunctions_tasks.TransformInput(
                transform_data_source=dynamodb.aws_stepfunctions_tasks.TransformDataSource(
                    s3_data_source=dynamodb.aws_stepfunctions_tasks.TransformS3DataSource(
                        s3_uri="s3://inputbucket/train",
                        s3_data_type=tasks.S3DataType.S3_PREFIX
                    )
                )
            ),
            transform_output=dynamodb.aws_stepfunctions_tasks.TransformOutput(
                s3_output_path="s3://outputbucket/TransformJobOutputPath"
            ),
            transform_resources=dynamodb.aws_stepfunctions_tasks.TransformResources(
                instance_count=1,
                instance_type=ec2.InstanceType.of(ec2.InstanceClass.M4, ec2.InstanceSize.XLARGE)
            )
        )
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        model_name: builtins.str,
        transform_input: typing.Union["TransformInput", typing.Dict[builtins.str, typing.Any]],
        transform_job_name: builtins.str,
        transform_output: typing.Union["TransformOutput", typing.Dict[builtins.str, typing.Any]],
        batch_strategy: typing.Optional[BatchStrategy] = None,
        environment: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        max_concurrent_transforms: typing.Optional[jsii.Number] = None,
        max_payload: typing.Optional[_Size_7fbd4337] = None,
        model_client_options: typing.Optional[typing.Union[ModelClientOptions, typing.Dict[builtins.str, typing.Any]]] = None,
        role: typing.Optional[_IRole_59af6f50] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        transform_resources: typing.Optional[typing.Union["TransformResources", typing.Dict[builtins.str, typing.Any]]] = None,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param model_name: (experimental) Name of the model that you want to use for the transform job.
        :param transform_input: (experimental) Dataset to be transformed and the Amazon S3 location where it is stored.
        :param transform_job_name: (experimental) Transform Job Name.
        :param transform_output: (experimental) S3 location where you want Amazon SageMaker to save the results from the transform job.
        :param batch_strategy: (experimental) Number of records to include in a mini-batch for an HTTP inference request. Default: - No batch strategy
        :param environment: (experimental) Environment variables to set in the Docker container. Default: - No environment variables
        :param max_concurrent_transforms: (experimental) Maximum number of parallel requests that can be sent to each instance in a transform job. Default: - Amazon SageMaker checks the optional execution-parameters to determine the settings for your chosen algorithm. If the execution-parameters endpoint is not enabled, the default value is 1.
        :param max_payload: (experimental) Maximum allowed size of the payload, in MB. Default: 6
        :param model_client_options: (experimental) Configures the timeout and maximum number of retries for processing a transform job invocation. Default: - 0 retries and 60 seconds of timeout
        :param role: (experimental) Role for the Transform Job. Default: - A role is created with ``AmazonSageMakerFullAccess`` managed policy
        :param tags: (experimental) Tags to be applied to the train job. Default: - No tags
        :param transform_resources: (experimental) ML compute instances for the transform job. Default: - 1 instance of type M4.XLarge
        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ba93956e42ef14ad9d4492567511968e4f4c0c5a5982acf1d0705d70ab580ed5)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = SageMakerCreateTransformJobProps(
            model_name=model_name,
            transform_input=transform_input,
            transform_job_name=transform_job_name,
            transform_output=transform_output,
            batch_strategy=batch_strategy,
            environment=environment,
            max_concurrent_transforms=max_concurrent_transforms,
            max_payload=max_payload,
            model_client_options=model_client_options,
            role=role,
            tags=tags,
            transform_resources=transform_resources,
            comment=comment,
            heartbeat=heartbeat,
            input_path=input_path,
            integration_pattern=integration_pattern,
            output_path=output_path,
            result_path=result_path,
            result_selector=result_selector,
            timeout=timeout,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="role")
    def role(self) -> _IRole_59af6f50:
        '''(experimental) The execution role for the Sagemaker transform job.

        Only available after task has been added to a state machine.

        :stability: experimental
        '''
        return typing.cast(_IRole_59af6f50, jsii.get(self, "role"))

    @builtins.property
    @jsii.member(jsii_name="taskMetrics")
    def _task_metrics(self) -> typing.Optional[_TaskMetricsConfig_5aaea59e]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[_TaskMetricsConfig_5aaea59e], jsii.get(self, "taskMetrics"))

    @builtins.property
    @jsii.member(jsii_name="taskPolicies")
    def _task_policies(self) -> typing.Optional[typing.List[_PolicyStatement_296fe8a3]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.List[_PolicyStatement_296fe8a3]], jsii.get(self, "taskPolicies"))


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.SageMakerCreateTransformJobProps",
    jsii_struct_bases=[_TaskStateBaseProps_b13f6332],
    name_mapping={
        "comment": "comment",
        "heartbeat": "heartbeat",
        "input_path": "inputPath",
        "integration_pattern": "integrationPattern",
        "output_path": "outputPath",
        "result_path": "resultPath",
        "result_selector": "resultSelector",
        "timeout": "timeout",
        "model_name": "modelName",
        "transform_input": "transformInput",
        "transform_job_name": "transformJobName",
        "transform_output": "transformOutput",
        "batch_strategy": "batchStrategy",
        "environment": "environment",
        "max_concurrent_transforms": "maxConcurrentTransforms",
        "max_payload": "maxPayload",
        "model_client_options": "modelClientOptions",
        "role": "role",
        "tags": "tags",
        "transform_resources": "transformResources",
    },
)
class SageMakerCreateTransformJobProps(_TaskStateBaseProps_b13f6332):
    def __init__(
        self,
        *,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
        model_name: builtins.str,
        transform_input: typing.Union["TransformInput", typing.Dict[builtins.str, typing.Any]],
        transform_job_name: builtins.str,
        transform_output: typing.Union["TransformOutput", typing.Dict[builtins.str, typing.Any]],
        batch_strategy: typing.Optional[BatchStrategy] = None,
        environment: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        max_concurrent_transforms: typing.Optional[jsii.Number] = None,
        max_payload: typing.Optional[_Size_7fbd4337] = None,
        model_client_options: typing.Optional[typing.Union[ModelClientOptions, typing.Dict[builtins.str, typing.Any]]] = None,
        role: typing.Optional[_IRole_59af6f50] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        transform_resources: typing.Optional[typing.Union["TransformResources", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''(experimental) Properties for creating an Amazon SageMaker transform job task.

        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None
        :param model_name: (experimental) Name of the model that you want to use for the transform job.
        :param transform_input: (experimental) Dataset to be transformed and the Amazon S3 location where it is stored.
        :param transform_job_name: (experimental) Transform Job Name.
        :param transform_output: (experimental) S3 location where you want Amazon SageMaker to save the results from the transform job.
        :param batch_strategy: (experimental) Number of records to include in a mini-batch for an HTTP inference request. Default: - No batch strategy
        :param environment: (experimental) Environment variables to set in the Docker container. Default: - No environment variables
        :param max_concurrent_transforms: (experimental) Maximum number of parallel requests that can be sent to each instance in a transform job. Default: - Amazon SageMaker checks the optional execution-parameters to determine the settings for your chosen algorithm. If the execution-parameters endpoint is not enabled, the default value is 1.
        :param max_payload: (experimental) Maximum allowed size of the payload, in MB. Default: 6
        :param model_client_options: (experimental) Configures the timeout and maximum number of retries for processing a transform job invocation. Default: - 0 retries and 60 seconds of timeout
        :param role: (experimental) Role for the Transform Job. Default: - A role is created with ``AmazonSageMakerFullAccess`` managed policy
        :param tags: (experimental) Tags to be applied to the train job. Default: - No tags
        :param transform_resources: (experimental) ML compute instances for the transform job. Default: - 1 instance of type M4.XLarge

        :stability: experimental
        :exampleMetadata: infused

        Example::

            tasks.SageMakerCreateTransformJob(self, "Batch Inference",
                transform_job_name="MyTransformJob",
                model_name="MyModelName",
                model_client_options=dynamodb.aws_stepfunctions_tasks.ModelClientOptions(
                    invocations_max_retries=3,  # default is 0
                    invocations_timeout=Duration.minutes(5)
                ),
                transform_input=dynamodb.aws_stepfunctions_tasks.TransformInput(
                    transform_data_source=dynamodb.aws_stepfunctions_tasks.TransformDataSource(
                        s3_data_source=dynamodb.aws_stepfunctions_tasks.TransformS3DataSource(
                            s3_uri="s3://inputbucket/train",
                            s3_data_type=tasks.S3DataType.S3_PREFIX
                        )
                    )
                ),
                transform_output=dynamodb.aws_stepfunctions_tasks.TransformOutput(
                    s3_output_path="s3://outputbucket/TransformJobOutputPath"
                ),
                transform_resources=dynamodb.aws_stepfunctions_tasks.TransformResources(
                    instance_count=1,
                    instance_type=ec2.InstanceType.of(ec2.InstanceClass.M4, ec2.InstanceSize.XLARGE)
                )
            )
        '''
        if isinstance(transform_input, dict):
            transform_input = TransformInput(**transform_input)
        if isinstance(transform_output, dict):
            transform_output = TransformOutput(**transform_output)
        if isinstance(model_client_options, dict):
            model_client_options = ModelClientOptions(**model_client_options)
        if isinstance(transform_resources, dict):
            transform_resources = TransformResources(**transform_resources)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f82d7968560796ad78d9e3ea10a2d883eaeee3e79f2e5497a4b2e4dbd4cd8106)
            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
            check_type(argname="argument heartbeat", value=heartbeat, expected_type=type_hints["heartbeat"])
            check_type(argname="argument input_path", value=input_path, expected_type=type_hints["input_path"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
            check_type(argname="argument output_path", value=output_path, expected_type=type_hints["output_path"])
            check_type(argname="argument result_path", value=result_path, expected_type=type_hints["result_path"])
            check_type(argname="argument result_selector", value=result_selector, expected_type=type_hints["result_selector"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
            check_type(argname="argument model_name", value=model_name, expected_type=type_hints["model_name"])
            check_type(argname="argument transform_input", value=transform_input, expected_type=type_hints["transform_input"])
            check_type(argname="argument transform_job_name", value=transform_job_name, expected_type=type_hints["transform_job_name"])
            check_type(argname="argument transform_output", value=transform_output, expected_type=type_hints["transform_output"])
            check_type(argname="argument batch_strategy", value=batch_strategy, expected_type=type_hints["batch_strategy"])
            check_type(argname="argument environment", value=environment, expected_type=type_hints["environment"])
            check_type(argname="argument max_concurrent_transforms", value=max_concurrent_transforms, expected_type=type_hints["max_concurrent_transforms"])
            check_type(argname="argument max_payload", value=max_payload, expected_type=type_hints["max_payload"])
            check_type(argname="argument model_client_options", value=model_client_options, expected_type=type_hints["model_client_options"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument transform_resources", value=transform_resources, expected_type=type_hints["transform_resources"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "model_name": model_name,
            "transform_input": transform_input,
            "transform_job_name": transform_job_name,
            "transform_output": transform_output,
        }
        if comment is not None:
            self._values["comment"] = comment
        if heartbeat is not None:
            self._values["heartbeat"] = heartbeat
        if input_path is not None:
            self._values["input_path"] = input_path
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern
        if output_path is not None:
            self._values["output_path"] = output_path
        if result_path is not None:
            self._values["result_path"] = result_path
        if result_selector is not None:
            self._values["result_selector"] = result_selector
        if timeout is not None:
            self._values["timeout"] = timeout
        if batch_strategy is not None:
            self._values["batch_strategy"] = batch_strategy
        if environment is not None:
            self._values["environment"] = environment
        if max_concurrent_transforms is not None:
            self._values["max_concurrent_transforms"] = max_concurrent_transforms
        if max_payload is not None:
            self._values["max_payload"] = max_payload
        if model_client_options is not None:
            self._values["model_client_options"] = model_client_options
        if role is not None:
            self._values["role"] = role
        if tags is not None:
            self._values["tags"] = tags
        if transform_resources is not None:
            self._values["transform_resources"] = transform_resources

    @builtins.property
    def comment(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional description for this state.

        :default: - No comment

        :stability: experimental
        '''
        result = self._values.get("comment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def heartbeat(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the heartbeat.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("heartbeat")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def input_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select part of the state to be the input to this state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        input to be the empty object {}.

        :default: - The entire task input (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("input_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def integration_pattern(self) -> typing.Optional[_IntegrationPattern_fbb35786]:
        '''(experimental) AWS Step Functions integrates with services directly in the Amazon States Language.

        You can control these AWS services using service integration patterns

        :default:

        - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks.
        ``IntegrationPattern.RUN_JOB`` for the following exceptions:
        ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html#connect-wait-token
        :stability: experimental
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_IntegrationPattern_fbb35786], result)

    @builtins.property
    def output_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select select a portion of the state output to pass to the next state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        output to be the empty object {}.

        :default:

        - The entire JSON node determined by the state input, the task result,
        and resultPath is passed to the next state (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("output_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to indicate where to inject the state's output.

        May also be the special value JsonPath.DISCARD, which will cause the state's
        input to become its output.

        :default: - Replaces the entire input with the result (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("result_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied.

        You can use ResultSelector to create a payload with values that are static
        or selected from the state's raw result.

        :default: - None

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/input-output-inputpath-params.html#input-output-resultselector
        :stability: experimental
        '''
        result = self._values.get("result_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def timeout(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the state machine.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def model_name(self) -> builtins.str:
        '''(experimental) Name of the model that you want to use for the transform job.

        :stability: experimental
        '''
        result = self._values.get("model_name")
        assert result is not None, "Required property 'model_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def transform_input(self) -> "TransformInput":
        '''(experimental) Dataset to be transformed and the Amazon S3 location where it is stored.

        :stability: experimental
        '''
        result = self._values.get("transform_input")
        assert result is not None, "Required property 'transform_input' is missing"
        return typing.cast("TransformInput", result)

    @builtins.property
    def transform_job_name(self) -> builtins.str:
        '''(experimental) Transform Job Name.

        :stability: experimental
        '''
        result = self._values.get("transform_job_name")
        assert result is not None, "Required property 'transform_job_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def transform_output(self) -> "TransformOutput":
        '''(experimental) S3 location where you want Amazon SageMaker to save the results from the transform job.

        :stability: experimental
        '''
        result = self._values.get("transform_output")
        assert result is not None, "Required property 'transform_output' is missing"
        return typing.cast("TransformOutput", result)

    @builtins.property
    def batch_strategy(self) -> typing.Optional[BatchStrategy]:
        '''(experimental) Number of records to include in a mini-batch for an HTTP inference request.

        :default: - No batch strategy

        :stability: experimental
        '''
        result = self._values.get("batch_strategy")
        return typing.cast(typing.Optional[BatchStrategy], result)

    @builtins.property
    def environment(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''(experimental) Environment variables to set in the Docker container.

        :default: - No environment variables

        :stability: experimental
        '''
        result = self._values.get("environment")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def max_concurrent_transforms(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Maximum number of parallel requests that can be sent to each instance in a transform job.

        :default:

        - Amazon SageMaker checks the optional execution-parameters to determine the settings for your chosen algorithm.
        If the execution-parameters endpoint is not enabled, the default value is 1.

        :stability: experimental
        '''
        result = self._values.get("max_concurrent_transforms")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def max_payload(self) -> typing.Optional[_Size_7fbd4337]:
        '''(experimental) Maximum allowed size of the payload, in MB.

        :default: 6

        :stability: experimental
        '''
        result = self._values.get("max_payload")
        return typing.cast(typing.Optional[_Size_7fbd4337], result)

    @builtins.property
    def model_client_options(self) -> typing.Optional[ModelClientOptions]:
        '''(experimental) Configures the timeout and maximum number of retries for processing a transform job invocation.

        :default: - 0 retries and 60 seconds of timeout

        :stability: experimental
        '''
        result = self._values.get("model_client_options")
        return typing.cast(typing.Optional[ModelClientOptions], result)

    @builtins.property
    def role(self) -> typing.Optional[_IRole_59af6f50]:
        '''(experimental) Role for the Transform Job.

        :default: - A role is created with ``AmazonSageMakerFullAccess`` managed policy

        :stability: experimental
        '''
        result = self._values.get("role")
        return typing.cast(typing.Optional[_IRole_59af6f50], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''(experimental) Tags to be applied to the train job.

        :default: - No tags

        :stability: experimental
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def transform_resources(self) -> typing.Optional["TransformResources"]:
        '''(experimental) ML compute instances for the transform job.

        :default: - 1 instance of type M4.XLarge

        :stability: experimental
        '''
        result = self._values.get("transform_resources")
        return typing.cast(typing.Optional["TransformResources"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SageMakerCreateTransformJobProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SageMakerUpdateEndpoint(
    _TaskStateBase_c3080646,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.SageMakerUpdateEndpoint",
):
    '''(experimental) A Step Functions Task to update a SageMaker endpoint.

    :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-sagemaker.html
    :stability: experimental
    :exampleMetadata: infused

    Example::

        tasks.SageMakerUpdateEndpoint(self, "SagemakerEndpoint",
            endpoint_name=sfn.JsonPath.string_at("$.Endpoint.Name"),
            endpoint_config_name=sfn.JsonPath.string_at("$.Endpoint.EndpointConfig")
        )
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        endpoint_config_name: builtins.str,
        endpoint_name: builtins.str,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param endpoint_config_name: (experimental) The name of the new endpoint configuration.
        :param endpoint_name: (experimental) The name of the endpoint whose configuration you want to update.
        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__be45d0e25f2e60446e7a5116b5b753073c283982d0f460a1d4df09229990b74c)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = SageMakerUpdateEndpointProps(
            endpoint_config_name=endpoint_config_name,
            endpoint_name=endpoint_name,
            comment=comment,
            heartbeat=heartbeat,
            input_path=input_path,
            integration_pattern=integration_pattern,
            output_path=output_path,
            result_path=result_path,
            result_selector=result_selector,
            timeout=timeout,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="taskMetrics")
    def _task_metrics(self) -> typing.Optional[_TaskMetricsConfig_5aaea59e]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[_TaskMetricsConfig_5aaea59e], jsii.get(self, "taskMetrics"))

    @builtins.property
    @jsii.member(jsii_name="taskPolicies")
    def _task_policies(self) -> typing.Optional[typing.List[_PolicyStatement_296fe8a3]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.List[_PolicyStatement_296fe8a3]], jsii.get(self, "taskPolicies"))


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.SageMakerUpdateEndpointProps",
    jsii_struct_bases=[_TaskStateBaseProps_b13f6332],
    name_mapping={
        "comment": "comment",
        "heartbeat": "heartbeat",
        "input_path": "inputPath",
        "integration_pattern": "integrationPattern",
        "output_path": "outputPath",
        "result_path": "resultPath",
        "result_selector": "resultSelector",
        "timeout": "timeout",
        "endpoint_config_name": "endpointConfigName",
        "endpoint_name": "endpointName",
    },
)
class SageMakerUpdateEndpointProps(_TaskStateBaseProps_b13f6332):
    def __init__(
        self,
        *,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
        endpoint_config_name: builtins.str,
        endpoint_name: builtins.str,
    ) -> None:
        '''(experimental) Properties for updating Amazon SageMaker endpoint.

        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None
        :param endpoint_config_name: (experimental) The name of the new endpoint configuration.
        :param endpoint_name: (experimental) The name of the endpoint whose configuration you want to update.

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-sagemaker.html
        :stability: experimental
        :exampleMetadata: infused

        Example::

            tasks.SageMakerUpdateEndpoint(self, "SagemakerEndpoint",
                endpoint_name=sfn.JsonPath.string_at("$.Endpoint.Name"),
                endpoint_config_name=sfn.JsonPath.string_at("$.Endpoint.EndpointConfig")
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0117728830f92badd55bcd6d23e68eca54c501a851860f2f9d10c2b426fd78e4)
            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
            check_type(argname="argument heartbeat", value=heartbeat, expected_type=type_hints["heartbeat"])
            check_type(argname="argument input_path", value=input_path, expected_type=type_hints["input_path"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
            check_type(argname="argument output_path", value=output_path, expected_type=type_hints["output_path"])
            check_type(argname="argument result_path", value=result_path, expected_type=type_hints["result_path"])
            check_type(argname="argument result_selector", value=result_selector, expected_type=type_hints["result_selector"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
            check_type(argname="argument endpoint_config_name", value=endpoint_config_name, expected_type=type_hints["endpoint_config_name"])
            check_type(argname="argument endpoint_name", value=endpoint_name, expected_type=type_hints["endpoint_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "endpoint_config_name": endpoint_config_name,
            "endpoint_name": endpoint_name,
        }
        if comment is not None:
            self._values["comment"] = comment
        if heartbeat is not None:
            self._values["heartbeat"] = heartbeat
        if input_path is not None:
            self._values["input_path"] = input_path
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern
        if output_path is not None:
            self._values["output_path"] = output_path
        if result_path is not None:
            self._values["result_path"] = result_path
        if result_selector is not None:
            self._values["result_selector"] = result_selector
        if timeout is not None:
            self._values["timeout"] = timeout

    @builtins.property
    def comment(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional description for this state.

        :default: - No comment

        :stability: experimental
        '''
        result = self._values.get("comment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def heartbeat(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the heartbeat.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("heartbeat")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def input_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select part of the state to be the input to this state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        input to be the empty object {}.

        :default: - The entire task input (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("input_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def integration_pattern(self) -> typing.Optional[_IntegrationPattern_fbb35786]:
        '''(experimental) AWS Step Functions integrates with services directly in the Amazon States Language.

        You can control these AWS services using service integration patterns

        :default:

        - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks.
        ``IntegrationPattern.RUN_JOB`` for the following exceptions:
        ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html#connect-wait-token
        :stability: experimental
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_IntegrationPattern_fbb35786], result)

    @builtins.property
    def output_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select select a portion of the state output to pass to the next state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        output to be the empty object {}.

        :default:

        - The entire JSON node determined by the state input, the task result,
        and resultPath is passed to the next state (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("output_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to indicate where to inject the state's output.

        May also be the special value JsonPath.DISCARD, which will cause the state's
        input to become its output.

        :default: - Replaces the entire input with the result (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("result_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied.

        You can use ResultSelector to create a payload with values that are static
        or selected from the state's raw result.

        :default: - None

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/input-output-inputpath-params.html#input-output-resultselector
        :stability: experimental
        '''
        result = self._values.get("result_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def timeout(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the state machine.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def endpoint_config_name(self) -> builtins.str:
        '''(experimental) The name of the new endpoint configuration.

        :stability: experimental
        '''
        result = self._values.get("endpoint_config_name")
        assert result is not None, "Required property 'endpoint_config_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def endpoint_name(self) -> builtins.str:
        '''(experimental) The name of the endpoint whose configuration you want to update.

        :stability: experimental
        '''
        result = self._values.get("endpoint_name")
        assert result is not None, "Required property 'endpoint_name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SageMakerUpdateEndpointProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IStepFunctionsTask_82eb09ab)
class SendToQueue(
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.SendToQueue",
):
    '''(deprecated) A StepFunctions Task to send messages to SQS queue.

    A Function can be used directly as a Resource, but this class mirrors
    integration with other AWS services via a specific class instance.

    :deprecated: Use ``SqsSendMessage``

    :stability: deprecated
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        import monocdk as monocdk
        from monocdk import aws_sqs as sqs
        from monocdk import aws_stepfunctions as stepfunctions
        from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
        
        # duration: monocdk.Duration
        # queue: sqs.Queue
        # task_input: stepfunctions.TaskInput
        
        send_to_queue = stepfunctions_tasks.SendToQueue(queue,
            message_body=task_input,
        
            # the properties below are optional
            delay=duration,
            integration_pattern=stepfunctions.ServiceIntegrationPattern.FIRE_AND_FORGET,
            message_deduplication_id="messageDeduplicationId",
            message_group_id="messageGroupId"
        )
    '''

    def __init__(
        self,
        queue: _IQueue_45a01ab4,
        *,
        message_body: _TaskInput_71ab46f6,
        delay: typing.Optional[_Duration_070aa057] = None,
        integration_pattern: typing.Optional[_ServiceIntegrationPattern_5581ee88] = None,
        message_deduplication_id: typing.Optional[builtins.str] = None,
        message_group_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param queue: -
        :param message_body: (deprecated) The text message to send to the queue.
        :param delay: (deprecated) The length of time, in seconds, for which to delay a specific message. Valid values are 0-900 seconds. Default: Default value of the queue is used
        :param integration_pattern: (deprecated) The service integration pattern indicates different ways to call SendMessage to SQS. The valid value is either FIRE_AND_FORGET or WAIT_FOR_TASK_TOKEN. Default: FIRE_AND_FORGET
        :param message_deduplication_id: (deprecated) The token used for deduplication of sent messages. Default: Use content-based deduplication
        :param message_group_id: (deprecated) The tag that specifies that a message belongs to a specific message group. Required for FIFO queues. FIFO ordering applies to messages in the same message group. Default: No group ID

        :stability: deprecated
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f176727d478e887f3cdb3698a293aeb94d778d00ce558ca06c11708c7bcac122)
            check_type(argname="argument queue", value=queue, expected_type=type_hints["queue"])
        props = SendToQueueProps(
            message_body=message_body,
            delay=delay,
            integration_pattern=integration_pattern,
            message_deduplication_id=message_deduplication_id,
            message_group_id=message_group_id,
        )

        jsii.create(self.__class__, self, [queue, props])

    @jsii.member(jsii_name="bind")
    def bind(self, _task: _Task_747ca4f2) -> _StepFunctionsTaskConfig_fa131821:
        '''(deprecated) Called when the task object is used in a workflow.

        :param _task: -

        :stability: deprecated
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d8f9db47ccda162277bc4e146cd60bf7214bb53000b55be4faede933d870f3e2)
            check_type(argname="argument _task", value=_task, expected_type=type_hints["_task"])
        return typing.cast(_StepFunctionsTaskConfig_fa131821, jsii.invoke(self, "bind", [_task]))


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.SendToQueueProps",
    jsii_struct_bases=[],
    name_mapping={
        "message_body": "messageBody",
        "delay": "delay",
        "integration_pattern": "integrationPattern",
        "message_deduplication_id": "messageDeduplicationId",
        "message_group_id": "messageGroupId",
    },
)
class SendToQueueProps:
    def __init__(
        self,
        *,
        message_body: _TaskInput_71ab46f6,
        delay: typing.Optional[_Duration_070aa057] = None,
        integration_pattern: typing.Optional[_ServiceIntegrationPattern_5581ee88] = None,
        message_deduplication_id: typing.Optional[builtins.str] = None,
        message_group_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''(deprecated) Properties for SendMessageTask.

        :param message_body: (deprecated) The text message to send to the queue.
        :param delay: (deprecated) The length of time, in seconds, for which to delay a specific message. Valid values are 0-900 seconds. Default: Default value of the queue is used
        :param integration_pattern: (deprecated) The service integration pattern indicates different ways to call SendMessage to SQS. The valid value is either FIRE_AND_FORGET or WAIT_FOR_TASK_TOKEN. Default: FIRE_AND_FORGET
        :param message_deduplication_id: (deprecated) The token used for deduplication of sent messages. Default: Use content-based deduplication
        :param message_group_id: (deprecated) The tag that specifies that a message belongs to a specific message group. Required for FIFO queues. FIFO ordering applies to messages in the same message group. Default: No group ID

        :deprecated: Use ``SqsSendMessage``

        :stability: deprecated
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            import monocdk as monocdk
            from monocdk import aws_stepfunctions as stepfunctions
            from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
            
            # duration: monocdk.Duration
            # task_input: stepfunctions.TaskInput
            
            send_to_queue_props = stepfunctions_tasks.SendToQueueProps(
                message_body=task_input,
            
                # the properties below are optional
                delay=duration,
                integration_pattern=stepfunctions.ServiceIntegrationPattern.FIRE_AND_FORGET,
                message_deduplication_id="messageDeduplicationId",
                message_group_id="messageGroupId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ea96dfcf54705f638b87be06a6307af7bc07599e53cfec0d0c0117f0a8289630)
            check_type(argname="argument message_body", value=message_body, expected_type=type_hints["message_body"])
            check_type(argname="argument delay", value=delay, expected_type=type_hints["delay"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
            check_type(argname="argument message_deduplication_id", value=message_deduplication_id, expected_type=type_hints["message_deduplication_id"])
            check_type(argname="argument message_group_id", value=message_group_id, expected_type=type_hints["message_group_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "message_body": message_body,
        }
        if delay is not None:
            self._values["delay"] = delay
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern
        if message_deduplication_id is not None:
            self._values["message_deduplication_id"] = message_deduplication_id
        if message_group_id is not None:
            self._values["message_group_id"] = message_group_id

    @builtins.property
    def message_body(self) -> _TaskInput_71ab46f6:
        '''(deprecated) The text message to send to the queue.

        :stability: deprecated
        '''
        result = self._values.get("message_body")
        assert result is not None, "Required property 'message_body' is missing"
        return typing.cast(_TaskInput_71ab46f6, result)

    @builtins.property
    def delay(self) -> typing.Optional[_Duration_070aa057]:
        '''(deprecated) The length of time, in seconds, for which to delay a specific message.

        Valid values are 0-900 seconds.

        :default: Default value of the queue is used

        :stability: deprecated
        '''
        result = self._values.get("delay")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def integration_pattern(
        self,
    ) -> typing.Optional[_ServiceIntegrationPattern_5581ee88]:
        '''(deprecated) The service integration pattern indicates different ways to call SendMessage to SQS.

        The valid value is either FIRE_AND_FORGET or WAIT_FOR_TASK_TOKEN.

        :default: FIRE_AND_FORGET

        :stability: deprecated
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_ServiceIntegrationPattern_5581ee88], result)

    @builtins.property
    def message_deduplication_id(self) -> typing.Optional[builtins.str]:
        '''(deprecated) The token used for deduplication of sent messages.

        :default: Use content-based deduplication

        :stability: deprecated
        '''
        result = self._values.get("message_deduplication_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def message_group_id(self) -> typing.Optional[builtins.str]:
        '''(deprecated) The tag that specifies that a message belongs to a specific message group.

        Required for FIFO queues. FIFO ordering applies to messages in the same message
        group.

        :default: No group ID

        :stability: deprecated
        '''
        result = self._values.get("message_group_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SendToQueueProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.ShuffleConfig",
    jsii_struct_bases=[],
    name_mapping={"seed": "seed"},
)
class ShuffleConfig:
    def __init__(self, *, seed: jsii.Number) -> None:
        '''(experimental) Configuration for a shuffle option for input data in a channel.

        :param seed: (experimental) Determines the shuffling order.

        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
            
            shuffle_config = stepfunctions_tasks.ShuffleConfig(
                seed=123
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8ca6f3efe96cc334c40473e2ac72bd8c6bbfb4169f6962c993edfb013cd7e85e)
            check_type(argname="argument seed", value=seed, expected_type=type_hints["seed"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "seed": seed,
        }

    @builtins.property
    def seed(self) -> jsii.Number:
        '''(experimental) Determines the shuffling order.

        :stability: experimental
        '''
        result = self._values.get("seed")
        assert result is not None, "Required property 'seed' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ShuffleConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SnsPublish(
    _TaskStateBase_c3080646,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.SnsPublish",
):
    '''(experimental) A Step Functions Task to publish messages to SNS topic.

    :stability: experimental
    :exampleMetadata: infused

    Example::

        convert_to_seconds = tasks.EvaluateExpression(self, "Convert to seconds",
            expression="$.waitMilliseconds / 1000",
            result_path="$.waitSeconds"
        )
        
        create_message = tasks.EvaluateExpression(self, "Create message",
            # Note: this is a string inside a string.
            expression="`Now waiting ${$.waitSeconds} seconds...`",
            runtime=lambda_.Runtime.NODEJS_14_X,
            result_path="$.message"
        )
        
        publish_message = tasks.SnsPublish(self, "Publish message",
            topic=sns.Topic(self, "cool-topic"),
            message=sfn.TaskInput.from_json_path_at("$.message"),
            result_path="$.sns"
        )
        
        wait = sfn.Wait(self, "Wait",
            time=sfn.WaitTime.seconds_path("$.waitSeconds")
        )
        
        sfn.StateMachine(self, "StateMachine",
            definition=convert_to_seconds.next(create_message).next(publish_message).next(wait)
        )
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        message: _TaskInput_71ab46f6,
        topic: _ITopic_465e36b9,
        message_attributes: typing.Optional[typing.Mapping[builtins.str, typing.Union[MessageAttribute, typing.Dict[builtins.str, typing.Any]]]] = None,
        message_per_subscription_type: typing.Optional[builtins.bool] = None,
        subject: typing.Optional[builtins.str] = None,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param message: (experimental) The message you want to send. With the exception of SMS, messages must be UTF-8 encoded strings and at most 256 KB in size. For SMS, each message can contain up to 140 characters.
        :param topic: (experimental) The SNS topic that the task will publish to.
        :param message_attributes: (experimental) Add message attributes when publishing. These attributes carry additional metadata about the message and may be used for subscription filters. Default: {}
        :param message_per_subscription_type: (experimental) Send different messages for each transport protocol. For example, you might want to send a shorter message to SMS subscribers and a more verbose message to email and SQS subscribers. Your message must be a JSON object with a top-level JSON key of "default" with a value that is a string You can define other top-level keys that define the message you want to send to a specific transport protocol (i.e. "sqs", "email", "http", etc) Default: false
        :param subject: (experimental) Used as the "Subject" line when the message is delivered to email endpoints. This field will also be included, if present, in the standard JSON messages delivered to other endpoints. Default: - No subject
        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__91c387033c988e2e16400f75073469cac1a84dcb4ebd3ab022967c675b2a445b)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = SnsPublishProps(
            message=message,
            topic=topic,
            message_attributes=message_attributes,
            message_per_subscription_type=message_per_subscription_type,
            subject=subject,
            comment=comment,
            heartbeat=heartbeat,
            input_path=input_path,
            integration_pattern=integration_pattern,
            output_path=output_path,
            result_path=result_path,
            result_selector=result_selector,
            timeout=timeout,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="taskMetrics")
    def _task_metrics(self) -> typing.Optional[_TaskMetricsConfig_5aaea59e]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[_TaskMetricsConfig_5aaea59e], jsii.get(self, "taskMetrics"))

    @builtins.property
    @jsii.member(jsii_name="taskPolicies")
    def _task_policies(self) -> typing.Optional[typing.List[_PolicyStatement_296fe8a3]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.List[_PolicyStatement_296fe8a3]], jsii.get(self, "taskPolicies"))


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.SnsPublishProps",
    jsii_struct_bases=[_TaskStateBaseProps_b13f6332],
    name_mapping={
        "comment": "comment",
        "heartbeat": "heartbeat",
        "input_path": "inputPath",
        "integration_pattern": "integrationPattern",
        "output_path": "outputPath",
        "result_path": "resultPath",
        "result_selector": "resultSelector",
        "timeout": "timeout",
        "message": "message",
        "topic": "topic",
        "message_attributes": "messageAttributes",
        "message_per_subscription_type": "messagePerSubscriptionType",
        "subject": "subject",
    },
)
class SnsPublishProps(_TaskStateBaseProps_b13f6332):
    def __init__(
        self,
        *,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
        message: _TaskInput_71ab46f6,
        topic: _ITopic_465e36b9,
        message_attributes: typing.Optional[typing.Mapping[builtins.str, typing.Union[MessageAttribute, typing.Dict[builtins.str, typing.Any]]]] = None,
        message_per_subscription_type: typing.Optional[builtins.bool] = None,
        subject: typing.Optional[builtins.str] = None,
    ) -> None:
        '''(experimental) Properties for publishing a message to an SNS topic.

        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None
        :param message: (experimental) The message you want to send. With the exception of SMS, messages must be UTF-8 encoded strings and at most 256 KB in size. For SMS, each message can contain up to 140 characters.
        :param topic: (experimental) The SNS topic that the task will publish to.
        :param message_attributes: (experimental) Add message attributes when publishing. These attributes carry additional metadata about the message and may be used for subscription filters. Default: {}
        :param message_per_subscription_type: (experimental) Send different messages for each transport protocol. For example, you might want to send a shorter message to SMS subscribers and a more verbose message to email and SQS subscribers. Your message must be a JSON object with a top-level JSON key of "default" with a value that is a string You can define other top-level keys that define the message you want to send to a specific transport protocol (i.e. "sqs", "email", "http", etc) Default: false
        :param subject: (experimental) Used as the "Subject" line when the message is delivered to email endpoints. This field will also be included, if present, in the standard JSON messages delivered to other endpoints. Default: - No subject

        :stability: experimental
        :exampleMetadata: infused

        Example::

            convert_to_seconds = tasks.EvaluateExpression(self, "Convert to seconds",
                expression="$.waitMilliseconds / 1000",
                result_path="$.waitSeconds"
            )
            
            create_message = tasks.EvaluateExpression(self, "Create message",
                # Note: this is a string inside a string.
                expression="`Now waiting ${$.waitSeconds} seconds...`",
                runtime=lambda_.Runtime.NODEJS_14_X,
                result_path="$.message"
            )
            
            publish_message = tasks.SnsPublish(self, "Publish message",
                topic=sns.Topic(self, "cool-topic"),
                message=sfn.TaskInput.from_json_path_at("$.message"),
                result_path="$.sns"
            )
            
            wait = sfn.Wait(self, "Wait",
                time=sfn.WaitTime.seconds_path("$.waitSeconds")
            )
            
            sfn.StateMachine(self, "StateMachine",
                definition=convert_to_seconds.next(create_message).next(publish_message).next(wait)
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8c1ae6c4746b9d25874c5c5dea7a0a4ecae2c04cb383e80d1bdf0b6a3849e5cb)
            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
            check_type(argname="argument heartbeat", value=heartbeat, expected_type=type_hints["heartbeat"])
            check_type(argname="argument input_path", value=input_path, expected_type=type_hints["input_path"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
            check_type(argname="argument output_path", value=output_path, expected_type=type_hints["output_path"])
            check_type(argname="argument result_path", value=result_path, expected_type=type_hints["result_path"])
            check_type(argname="argument result_selector", value=result_selector, expected_type=type_hints["result_selector"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
            check_type(argname="argument message", value=message, expected_type=type_hints["message"])
            check_type(argname="argument topic", value=topic, expected_type=type_hints["topic"])
            check_type(argname="argument message_attributes", value=message_attributes, expected_type=type_hints["message_attributes"])
            check_type(argname="argument message_per_subscription_type", value=message_per_subscription_type, expected_type=type_hints["message_per_subscription_type"])
            check_type(argname="argument subject", value=subject, expected_type=type_hints["subject"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "message": message,
            "topic": topic,
        }
        if comment is not None:
            self._values["comment"] = comment
        if heartbeat is not None:
            self._values["heartbeat"] = heartbeat
        if input_path is not None:
            self._values["input_path"] = input_path
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern
        if output_path is not None:
            self._values["output_path"] = output_path
        if result_path is not None:
            self._values["result_path"] = result_path
        if result_selector is not None:
            self._values["result_selector"] = result_selector
        if timeout is not None:
            self._values["timeout"] = timeout
        if message_attributes is not None:
            self._values["message_attributes"] = message_attributes
        if message_per_subscription_type is not None:
            self._values["message_per_subscription_type"] = message_per_subscription_type
        if subject is not None:
            self._values["subject"] = subject

    @builtins.property
    def comment(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional description for this state.

        :default: - No comment

        :stability: experimental
        '''
        result = self._values.get("comment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def heartbeat(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the heartbeat.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("heartbeat")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def input_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select part of the state to be the input to this state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        input to be the empty object {}.

        :default: - The entire task input (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("input_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def integration_pattern(self) -> typing.Optional[_IntegrationPattern_fbb35786]:
        '''(experimental) AWS Step Functions integrates with services directly in the Amazon States Language.

        You can control these AWS services using service integration patterns

        :default:

        - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks.
        ``IntegrationPattern.RUN_JOB`` for the following exceptions:
        ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html#connect-wait-token
        :stability: experimental
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_IntegrationPattern_fbb35786], result)

    @builtins.property
    def output_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select select a portion of the state output to pass to the next state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        output to be the empty object {}.

        :default:

        - The entire JSON node determined by the state input, the task result,
        and resultPath is passed to the next state (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("output_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to indicate where to inject the state's output.

        May also be the special value JsonPath.DISCARD, which will cause the state's
        input to become its output.

        :default: - Replaces the entire input with the result (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("result_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied.

        You can use ResultSelector to create a payload with values that are static
        or selected from the state's raw result.

        :default: - None

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/input-output-inputpath-params.html#input-output-resultselector
        :stability: experimental
        '''
        result = self._values.get("result_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def timeout(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the state machine.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def message(self) -> _TaskInput_71ab46f6:
        '''(experimental) The message you want to send.

        With the exception of SMS, messages must be UTF-8 encoded strings and
        at most 256 KB in size.
        For SMS, each message can contain up to 140 characters.

        :stability: experimental
        '''
        result = self._values.get("message")
        assert result is not None, "Required property 'message' is missing"
        return typing.cast(_TaskInput_71ab46f6, result)

    @builtins.property
    def topic(self) -> _ITopic_465e36b9:
        '''(experimental) The SNS topic that the task will publish to.

        :stability: experimental
        '''
        result = self._values.get("topic")
        assert result is not None, "Required property 'topic' is missing"
        return typing.cast(_ITopic_465e36b9, result)

    @builtins.property
    def message_attributes(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, MessageAttribute]]:
        '''(experimental) Add message attributes when publishing.

        These attributes carry additional metadata about the message and may be used
        for subscription filters.

        :default: {}

        :see: https://docs.aws.amazon.com/sns/latest/dg/sns-message-attributes.html
        :stability: experimental
        '''
        result = self._values.get("message_attributes")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, MessageAttribute]], result)

    @builtins.property
    def message_per_subscription_type(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Send different messages for each transport protocol.

        For example, you might want to send a shorter message to SMS subscribers
        and a more verbose message to email and SQS subscribers.

        Your message must be a JSON object with a top-level JSON key of
        "default" with a value that is a string
        You can define other top-level keys that define the message you want to
        send to a specific transport protocol (i.e. "sqs", "email", "http", etc)

        :default: false

        :see: https://docs.aws.amazon.com/sns/latest/api/API_Publish.html#API_Publish_RequestParameters
        :stability: experimental
        '''
        result = self._values.get("message_per_subscription_type")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def subject(self) -> typing.Optional[builtins.str]:
        '''(experimental) Used as the "Subject" line when the message is delivered to email endpoints.

        This field will also be included, if present, in the standard JSON messages
        delivered to other endpoints.

        :default: - No subject

        :stability: experimental
        '''
        result = self._values.get("subject")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SnsPublishProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.SparkSubmitJobDriver",
    jsii_struct_bases=[],
    name_mapping={
        "entry_point": "entryPoint",
        "entry_point_arguments": "entryPointArguments",
        "spark_submit_parameters": "sparkSubmitParameters",
    },
)
class SparkSubmitJobDriver:
    def __init__(
        self,
        *,
        entry_point: _TaskInput_71ab46f6,
        entry_point_arguments: typing.Optional[_TaskInput_71ab46f6] = None,
        spark_submit_parameters: typing.Optional[builtins.str] = None,
    ) -> None:
        '''(experimental) The information about job driver for Spark submit.

        :param entry_point: (experimental) The entry point of job application. Length Constraints: Minimum length of 1. Maximum length of 256.
        :param entry_point_arguments: (experimental) The arguments for a job application in a task input object containing an array of strings. Length Constraints: Minimum length of 1. Maximum length of 10280. Default: - No arguments defined
        :param spark_submit_parameters: (experimental) The Spark submit parameters that are used for job runs. Length Constraints: Minimum length of 1. Maximum length of 102400. Default: - No spark submit parameters

        :stability: experimental
        :exampleMetadata: infused

        Example::

            tasks.EmrContainersStartJobRun(self, "EMR Containers Start Job Run",
                virtual_cluster=tasks.VirtualClusterInput.from_virtual_cluster_id("de92jdei2910fwedz"),
                release_label=tasks.ReleaseLabel.EMR_6_2_0,
                job_name="EMR-Containers-Job",
                job_driver=dynamodb.aws_stepfunctions_tasks.JobDriver(
                    spark_submit_job_driver=dynamodb.aws_stepfunctions_tasks.SparkSubmitJobDriver(
                        entry_point=sfn.TaskInput.from_text("local:///usr/lib/spark/examples/src/main/python/pi.py")
                    )
                ),
                application_config=[dynamodb.aws_stepfunctions_tasks.ApplicationConfiguration(
                    classification=tasks.Classification.SPARK_DEFAULTS,
                    properties={
                        "spark.executor.instances": "1",
                        "spark.executor.memory": "512M"
                    }
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9b63048fc12785a3966ac4eba41c3b1cbc3a3cca168939dbaa89f92ba4477c6e)
            check_type(argname="argument entry_point", value=entry_point, expected_type=type_hints["entry_point"])
            check_type(argname="argument entry_point_arguments", value=entry_point_arguments, expected_type=type_hints["entry_point_arguments"])
            check_type(argname="argument spark_submit_parameters", value=spark_submit_parameters, expected_type=type_hints["spark_submit_parameters"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "entry_point": entry_point,
        }
        if entry_point_arguments is not None:
            self._values["entry_point_arguments"] = entry_point_arguments
        if spark_submit_parameters is not None:
            self._values["spark_submit_parameters"] = spark_submit_parameters

    @builtins.property
    def entry_point(self) -> _TaskInput_71ab46f6:
        '''(experimental) The entry point of job application.

        Length Constraints: Minimum length of 1. Maximum length of 256.

        :stability: experimental
        '''
        result = self._values.get("entry_point")
        assert result is not None, "Required property 'entry_point' is missing"
        return typing.cast(_TaskInput_71ab46f6, result)

    @builtins.property
    def entry_point_arguments(self) -> typing.Optional[_TaskInput_71ab46f6]:
        '''(experimental) The arguments for a job application in a task input object containing an array of strings.

        Length Constraints: Minimum length of 1. Maximum length of 10280.

        :default: - No arguments defined

        :stability: experimental
        :type: sfn.TaskInput which expects payload as an array of strings
        '''
        result = self._values.get("entry_point_arguments")
        return typing.cast(typing.Optional[_TaskInput_71ab46f6], result)

    @builtins.property
    def spark_submit_parameters(self) -> typing.Optional[builtins.str]:
        '''(experimental) The Spark submit parameters that are used for job runs.

        Length Constraints: Minimum length of 1. Maximum length of 102400.

        :default: - No spark submit parameters

        :stability: experimental
        '''
        result = self._values.get("spark_submit_parameters")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SparkSubmitJobDriver(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="monocdk.aws_stepfunctions_tasks.SplitType")
class SplitType(enum.Enum):
    '''(experimental) Method to use to split the transform job's data files into smaller batches.

    :stability: experimental
    '''

    NONE = "NONE"
    '''(experimental) Input data files are not split,.

    :stability: experimental
    '''
    LINE = "LINE"
    '''(experimental) Split records on a newline character boundary.

    :stability: experimental
    '''
    RECORD_IO = "RECORD_IO"
    '''(experimental) Split using MXNet RecordIO format.

    :stability: experimental
    '''
    TF_RECORD = "TF_RECORD"
    '''(experimental) Split using TensorFlow TFRecord format.

    :stability: experimental
    '''


class SqsSendMessage(
    _TaskStateBase_c3080646,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.SqsSendMessage",
):
    '''(experimental) A StepFunctions Task to send messages to SQS queue.

    :stability: experimental
    :exampleMetadata: infused

    Example::

        queue = sqs.Queue(self, "Queue")
        
        # Use a field from the execution data as message.
        task1 = tasks.SqsSendMessage(self, "Send1",
            queue=queue,
            message_body=sfn.TaskInput.from_json_path_at("$.message")
        )
        
        # Combine a field from the execution data with
        # a literal object.
        task2 = tasks.SqsSendMessage(self, "Send2",
            queue=queue,
            message_body=sfn.TaskInput.from_object({
                "field1": "somedata",
                "field2": sfn.JsonPath.string_at("$.field2")
            })
        )
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        message_body: _TaskInput_71ab46f6,
        queue: _IQueue_45a01ab4,
        delay: typing.Optional[_Duration_070aa057] = None,
        message_deduplication_id: typing.Optional[builtins.str] = None,
        message_group_id: typing.Optional[builtins.str] = None,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param message_body: (experimental) The text message to send to the queue.
        :param queue: (experimental) The SQS queue that messages will be sent to.
        :param delay: (experimental) The length of time, for which to delay a message. Messages that you send to the queue remain invisible to consumers for the duration of the delay period. The maximum allowed delay is 15 minutes. Default: - delay set on the queue. If a delay is not set on the queue, messages are sent immediately (0 seconds).
        :param message_deduplication_id: (experimental) The token used for deduplication of sent messages. Any messages sent with the same deduplication ID are accepted successfully, but aren't delivered during the 5-minute deduplication interval. Default: - None
        :param message_group_id: (experimental) The tag that specifies that a message belongs to a specific message group. Messages that belong to the same message group are processed in a FIFO manner. Messages in different message groups might be processed out of order. Default: - None
        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__26f391dfc8e6d2fe57be6be1471c6a623a71bce120d0b2adaa6245617b798f1e)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = SqsSendMessageProps(
            message_body=message_body,
            queue=queue,
            delay=delay,
            message_deduplication_id=message_deduplication_id,
            message_group_id=message_group_id,
            comment=comment,
            heartbeat=heartbeat,
            input_path=input_path,
            integration_pattern=integration_pattern,
            output_path=output_path,
            result_path=result_path,
            result_selector=result_selector,
            timeout=timeout,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="taskMetrics")
    def _task_metrics(self) -> typing.Optional[_TaskMetricsConfig_5aaea59e]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[_TaskMetricsConfig_5aaea59e], jsii.get(self, "taskMetrics"))

    @builtins.property
    @jsii.member(jsii_name="taskPolicies")
    def _task_policies(self) -> typing.Optional[typing.List[_PolicyStatement_296fe8a3]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.List[_PolicyStatement_296fe8a3]], jsii.get(self, "taskPolicies"))


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.SqsSendMessageProps",
    jsii_struct_bases=[_TaskStateBaseProps_b13f6332],
    name_mapping={
        "comment": "comment",
        "heartbeat": "heartbeat",
        "input_path": "inputPath",
        "integration_pattern": "integrationPattern",
        "output_path": "outputPath",
        "result_path": "resultPath",
        "result_selector": "resultSelector",
        "timeout": "timeout",
        "message_body": "messageBody",
        "queue": "queue",
        "delay": "delay",
        "message_deduplication_id": "messageDeduplicationId",
        "message_group_id": "messageGroupId",
    },
)
class SqsSendMessageProps(_TaskStateBaseProps_b13f6332):
    def __init__(
        self,
        *,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
        message_body: _TaskInput_71ab46f6,
        queue: _IQueue_45a01ab4,
        delay: typing.Optional[_Duration_070aa057] = None,
        message_deduplication_id: typing.Optional[builtins.str] = None,
        message_group_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''(experimental) Properties for sending a message to an SQS queue.

        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None
        :param message_body: (experimental) The text message to send to the queue.
        :param queue: (experimental) The SQS queue that messages will be sent to.
        :param delay: (experimental) The length of time, for which to delay a message. Messages that you send to the queue remain invisible to consumers for the duration of the delay period. The maximum allowed delay is 15 minutes. Default: - delay set on the queue. If a delay is not set on the queue, messages are sent immediately (0 seconds).
        :param message_deduplication_id: (experimental) The token used for deduplication of sent messages. Any messages sent with the same deduplication ID are accepted successfully, but aren't delivered during the 5-minute deduplication interval. Default: - None
        :param message_group_id: (experimental) The tag that specifies that a message belongs to a specific message group. Messages that belong to the same message group are processed in a FIFO manner. Messages in different message groups might be processed out of order. Default: - None

        :stability: experimental
        :exampleMetadata: infused

        Example::

            queue = sqs.Queue(self, "Queue")
            
            # Use a field from the execution data as message.
            task1 = tasks.SqsSendMessage(self, "Send1",
                queue=queue,
                message_body=sfn.TaskInput.from_json_path_at("$.message")
            )
            
            # Combine a field from the execution data with
            # a literal object.
            task2 = tasks.SqsSendMessage(self, "Send2",
                queue=queue,
                message_body=sfn.TaskInput.from_object({
                    "field1": "somedata",
                    "field2": sfn.JsonPath.string_at("$.field2")
                })
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4f3e5ffb1178b0d17f41df80f4868922f9c55ff9ca8a3b4571577a7b88e6770f)
            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
            check_type(argname="argument heartbeat", value=heartbeat, expected_type=type_hints["heartbeat"])
            check_type(argname="argument input_path", value=input_path, expected_type=type_hints["input_path"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
            check_type(argname="argument output_path", value=output_path, expected_type=type_hints["output_path"])
            check_type(argname="argument result_path", value=result_path, expected_type=type_hints["result_path"])
            check_type(argname="argument result_selector", value=result_selector, expected_type=type_hints["result_selector"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
            check_type(argname="argument message_body", value=message_body, expected_type=type_hints["message_body"])
            check_type(argname="argument queue", value=queue, expected_type=type_hints["queue"])
            check_type(argname="argument delay", value=delay, expected_type=type_hints["delay"])
            check_type(argname="argument message_deduplication_id", value=message_deduplication_id, expected_type=type_hints["message_deduplication_id"])
            check_type(argname="argument message_group_id", value=message_group_id, expected_type=type_hints["message_group_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "message_body": message_body,
            "queue": queue,
        }
        if comment is not None:
            self._values["comment"] = comment
        if heartbeat is not None:
            self._values["heartbeat"] = heartbeat
        if input_path is not None:
            self._values["input_path"] = input_path
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern
        if output_path is not None:
            self._values["output_path"] = output_path
        if result_path is not None:
            self._values["result_path"] = result_path
        if result_selector is not None:
            self._values["result_selector"] = result_selector
        if timeout is not None:
            self._values["timeout"] = timeout
        if delay is not None:
            self._values["delay"] = delay
        if message_deduplication_id is not None:
            self._values["message_deduplication_id"] = message_deduplication_id
        if message_group_id is not None:
            self._values["message_group_id"] = message_group_id

    @builtins.property
    def comment(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional description for this state.

        :default: - No comment

        :stability: experimental
        '''
        result = self._values.get("comment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def heartbeat(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the heartbeat.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("heartbeat")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def input_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select part of the state to be the input to this state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        input to be the empty object {}.

        :default: - The entire task input (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("input_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def integration_pattern(self) -> typing.Optional[_IntegrationPattern_fbb35786]:
        '''(experimental) AWS Step Functions integrates with services directly in the Amazon States Language.

        You can control these AWS services using service integration patterns

        :default:

        - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks.
        ``IntegrationPattern.RUN_JOB`` for the following exceptions:
        ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html#connect-wait-token
        :stability: experimental
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_IntegrationPattern_fbb35786], result)

    @builtins.property
    def output_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select select a portion of the state output to pass to the next state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        output to be the empty object {}.

        :default:

        - The entire JSON node determined by the state input, the task result,
        and resultPath is passed to the next state (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("output_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to indicate where to inject the state's output.

        May also be the special value JsonPath.DISCARD, which will cause the state's
        input to become its output.

        :default: - Replaces the entire input with the result (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("result_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied.

        You can use ResultSelector to create a payload with values that are static
        or selected from the state's raw result.

        :default: - None

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/input-output-inputpath-params.html#input-output-resultselector
        :stability: experimental
        '''
        result = self._values.get("result_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def timeout(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the state machine.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def message_body(self) -> _TaskInput_71ab46f6:
        '''(experimental) The text message to send to the queue.

        :stability: experimental
        '''
        result = self._values.get("message_body")
        assert result is not None, "Required property 'message_body' is missing"
        return typing.cast(_TaskInput_71ab46f6, result)

    @builtins.property
    def queue(self) -> _IQueue_45a01ab4:
        '''(experimental) The SQS queue that messages will be sent to.

        :stability: experimental
        '''
        result = self._values.get("queue")
        assert result is not None, "Required property 'queue' is missing"
        return typing.cast(_IQueue_45a01ab4, result)

    @builtins.property
    def delay(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) The length of time, for which to delay a message.

        Messages that you send to the queue remain invisible to consumers for the duration
        of the delay period. The maximum allowed delay is 15 minutes.

        :default:

        - delay set on the queue. If a delay is not set on the queue,
        messages are sent immediately (0 seconds).

        :stability: experimental
        '''
        result = self._values.get("delay")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def message_deduplication_id(self) -> typing.Optional[builtins.str]:
        '''(experimental) The token used for deduplication of sent messages.

        Any messages sent with the same deduplication ID are accepted successfully,
        but aren't delivered during the 5-minute deduplication interval.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("message_deduplication_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def message_group_id(self) -> typing.Optional[builtins.str]:
        '''(experimental) The tag that specifies that a message belongs to a specific message group.

        Messages that belong to the same message group are processed in a FIFO manner.
        Messages in different message groups might be processed out of order.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("message_group_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SqsSendMessageProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IStepFunctionsTask_82eb09ab)
class StartExecution(
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.StartExecution",
):
    '''(deprecated) A Step Functions Task to call StartExecution on another state machine.

    It supports three service integration patterns: FIRE_AND_FORGET, SYNC and WAIT_FOR_TASK_TOKEN.

    :deprecated: - use 'StepFunctionsStartExecution'

    :stability: deprecated
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from monocdk import aws_stepfunctions as stepfunctions
        from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
        
        # input: Any
        # state_machine: stepfunctions.StateMachine
        
        start_execution = stepfunctions_tasks.StartExecution(state_machine,
            input={
                "input_key": input
            },
            integration_pattern=stepfunctions.ServiceIntegrationPattern.FIRE_AND_FORGET,
            name="name"
        )
    '''

    def __init__(
        self,
        state_machine: _IStateMachine_269a89c4,
        *,
        input: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        integration_pattern: typing.Optional[_ServiceIntegrationPattern_5581ee88] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param state_machine: -
        :param input: (deprecated) The JSON input for the execution, same as that of StartExecution. Default: - No input
        :param integration_pattern: (deprecated) The service integration pattern indicates different ways to call StartExecution to Step Functions. Default: FIRE_AND_FORGET
        :param name: (deprecated) The name of the execution, same as that of StartExecution. Default: - None

        :stability: deprecated
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d2b17b6d0be920f09914377d3b781b84d8803c7de53545c1a503464b7da909e3)
            check_type(argname="argument state_machine", value=state_machine, expected_type=type_hints["state_machine"])
        props = StartExecutionProps(
            input=input, integration_pattern=integration_pattern, name=name
        )

        jsii.create(self.__class__, self, [state_machine, props])

    @jsii.member(jsii_name="bind")
    def bind(self, task: _Task_747ca4f2) -> _StepFunctionsTaskConfig_fa131821:
        '''(deprecated) Called when the task object is used in a workflow.

        :param task: -

        :stability: deprecated
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__633d634da0fab3146ef36b972d7e36a3918dd22ba5435279ec08b77774b197c8)
            check_type(argname="argument task", value=task, expected_type=type_hints["task"])
        return typing.cast(_StepFunctionsTaskConfig_fa131821, jsii.invoke(self, "bind", [task]))


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.StartExecutionProps",
    jsii_struct_bases=[],
    name_mapping={
        "input": "input",
        "integration_pattern": "integrationPattern",
        "name": "name",
    },
)
class StartExecutionProps:
    def __init__(
        self,
        *,
        input: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        integration_pattern: typing.Optional[_ServiceIntegrationPattern_5581ee88] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''(deprecated) Properties for StartExecution.

        :param input: (deprecated) The JSON input for the execution, same as that of StartExecution. Default: - No input
        :param integration_pattern: (deprecated) The service integration pattern indicates different ways to call StartExecution to Step Functions. Default: FIRE_AND_FORGET
        :param name: (deprecated) The name of the execution, same as that of StartExecution. Default: - None

        :deprecated: - use 'StepFunctionsStartExecution'

        :stability: deprecated
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_stepfunctions as stepfunctions
            from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
            
            # input: Any
            
            start_execution_props = stepfunctions_tasks.StartExecutionProps(
                input={
                    "input_key": input
                },
                integration_pattern=stepfunctions.ServiceIntegrationPattern.FIRE_AND_FORGET,
                name="name"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d5941cffcc773ec36d8f99a83d411bc0c1db656a1795c658bdf6fefc00f56ea7)
            check_type(argname="argument input", value=input, expected_type=type_hints["input"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if input is not None:
            self._values["input"] = input
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def input(self) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(deprecated) The JSON input for the execution, same as that of StartExecution.

        :default: - No input

        :see: https://docs.aws.amazon.com/step-functions/latest/apireference/API_StartExecution.html
        :stability: deprecated
        '''
        result = self._values.get("input")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def integration_pattern(
        self,
    ) -> typing.Optional[_ServiceIntegrationPattern_5581ee88]:
        '''(deprecated) The service integration pattern indicates different ways to call StartExecution to Step Functions.

        :default: FIRE_AND_FORGET

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html
        :stability: deprecated
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_ServiceIntegrationPattern_5581ee88], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''(deprecated) The name of the execution, same as that of StartExecution.

        :default: - None

        :see: https://docs.aws.amazon.com/step-functions/latest/apireference/API_StartExecution.html
        :stability: deprecated
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "StartExecutionProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class StepFunctionsInvokeActivity(
    _TaskStateBase_c3080646,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.StepFunctionsInvokeActivity",
):
    '''(experimental) A Step Functions Task to invoke an Activity worker.

    An Activity can be used directly as a Resource.

    :stability: experimental
    :exampleMetadata: infused

    Example::

        submit_job_activity = sfn.Activity(self, "SubmitJob")
        
        tasks.StepFunctionsInvokeActivity(self, "Submit Job",
            activity=submit_job_activity
        )
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        activity: _IActivity_4524952f,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param activity: (experimental) Step Functions Activity to invoke.
        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__03a30edce5bdddaa2245be6c19834fc529b0c2ad409ed06182e5bf53298c967b)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = StepFunctionsInvokeActivityProps(
            activity=activity,
            comment=comment,
            heartbeat=heartbeat,
            input_path=input_path,
            integration_pattern=integration_pattern,
            output_path=output_path,
            result_path=result_path,
            result_selector=result_selector,
            timeout=timeout,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="taskMetrics")
    def _task_metrics(self) -> typing.Optional[_TaskMetricsConfig_5aaea59e]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[_TaskMetricsConfig_5aaea59e], jsii.get(self, "taskMetrics"))

    @builtins.property
    @jsii.member(jsii_name="taskPolicies")
    def _task_policies(self) -> typing.Optional[typing.List[_PolicyStatement_296fe8a3]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.List[_PolicyStatement_296fe8a3]], jsii.get(self, "taskPolicies"))


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.StepFunctionsInvokeActivityProps",
    jsii_struct_bases=[_TaskStateBaseProps_b13f6332],
    name_mapping={
        "comment": "comment",
        "heartbeat": "heartbeat",
        "input_path": "inputPath",
        "integration_pattern": "integrationPattern",
        "output_path": "outputPath",
        "result_path": "resultPath",
        "result_selector": "resultSelector",
        "timeout": "timeout",
        "activity": "activity",
    },
)
class StepFunctionsInvokeActivityProps(_TaskStateBaseProps_b13f6332):
    def __init__(
        self,
        *,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
        activity: _IActivity_4524952f,
    ) -> None:
        '''(experimental) Properties for invoking an Activity worker.

        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None
        :param activity: (experimental) Step Functions Activity to invoke.

        :stability: experimental
        :exampleMetadata: infused

        Example::

            submit_job_activity = sfn.Activity(self, "SubmitJob")
            
            tasks.StepFunctionsInvokeActivity(self, "Submit Job",
                activity=submit_job_activity
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2d9f01c8041b6832f726632defd6b2c36b5f85aa104f618f220b9fd3d14d6d76)
            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
            check_type(argname="argument heartbeat", value=heartbeat, expected_type=type_hints["heartbeat"])
            check_type(argname="argument input_path", value=input_path, expected_type=type_hints["input_path"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
            check_type(argname="argument output_path", value=output_path, expected_type=type_hints["output_path"])
            check_type(argname="argument result_path", value=result_path, expected_type=type_hints["result_path"])
            check_type(argname="argument result_selector", value=result_selector, expected_type=type_hints["result_selector"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
            check_type(argname="argument activity", value=activity, expected_type=type_hints["activity"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "activity": activity,
        }
        if comment is not None:
            self._values["comment"] = comment
        if heartbeat is not None:
            self._values["heartbeat"] = heartbeat
        if input_path is not None:
            self._values["input_path"] = input_path
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern
        if output_path is not None:
            self._values["output_path"] = output_path
        if result_path is not None:
            self._values["result_path"] = result_path
        if result_selector is not None:
            self._values["result_selector"] = result_selector
        if timeout is not None:
            self._values["timeout"] = timeout

    @builtins.property
    def comment(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional description for this state.

        :default: - No comment

        :stability: experimental
        '''
        result = self._values.get("comment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def heartbeat(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the heartbeat.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("heartbeat")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def input_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select part of the state to be the input to this state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        input to be the empty object {}.

        :default: - The entire task input (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("input_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def integration_pattern(self) -> typing.Optional[_IntegrationPattern_fbb35786]:
        '''(experimental) AWS Step Functions integrates with services directly in the Amazon States Language.

        You can control these AWS services using service integration patterns

        :default:

        - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks.
        ``IntegrationPattern.RUN_JOB`` for the following exceptions:
        ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html#connect-wait-token
        :stability: experimental
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_IntegrationPattern_fbb35786], result)

    @builtins.property
    def output_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select select a portion of the state output to pass to the next state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        output to be the empty object {}.

        :default:

        - The entire JSON node determined by the state input, the task result,
        and resultPath is passed to the next state (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("output_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to indicate where to inject the state's output.

        May also be the special value JsonPath.DISCARD, which will cause the state's
        input to become its output.

        :default: - Replaces the entire input with the result (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("result_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied.

        You can use ResultSelector to create a payload with values that are static
        or selected from the state's raw result.

        :default: - None

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/input-output-inputpath-params.html#input-output-resultselector
        :stability: experimental
        '''
        result = self._values.get("result_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def timeout(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the state machine.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def activity(self) -> _IActivity_4524952f:
        '''(experimental) Step Functions Activity to invoke.

        :stability: experimental
        '''
        result = self._values.get("activity")
        assert result is not None, "Required property 'activity' is missing"
        return typing.cast(_IActivity_4524952f, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "StepFunctionsInvokeActivityProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class StepFunctionsStartExecution(
    _TaskStateBase_c3080646,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.StepFunctionsStartExecution",
):
    '''(experimental) A Step Functions Task to call StartExecution on another state machine.

    It supports three service integration patterns: REQUEST_RESPONSE, RUN_JOB, and WAIT_FOR_TASK_TOKEN.

    :stability: experimental
    :exampleMetadata: infused

    Example::

        # Define a state machine with one Pass state
        child = sfn.StateMachine(self, "ChildStateMachine",
            definition=sfn.Chain.start(sfn.Pass(self, "PassState"))
        )
        
        # Include the state machine in a Task state with callback pattern
        task = tasks.StepFunctionsStartExecution(self, "ChildTask",
            state_machine=child,
            integration_pattern=sfn.IntegrationPattern.WAIT_FOR_TASK_TOKEN,
            input=sfn.TaskInput.from_object({
                "token": sfn.JsonPath.task_token,
                "foo": "bar"
            }),
            name="MyExecutionName"
        )
        
        # Define a second state machine with the Task state above
        sfn.StateMachine(self, "ParentStateMachine",
            definition=task
        )
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        state_machine: _IStateMachine_269a89c4,
        associate_with_parent: typing.Optional[builtins.bool] = None,
        input: typing.Optional[_TaskInput_71ab46f6] = None,
        name: typing.Optional[builtins.str] = None,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param state_machine: (experimental) The Step Functions state machine to start the execution on.
        :param associate_with_parent: (experimental) Pass the execution ID from the context object to the execution input. This allows the Step Functions UI to link child executions from parent executions, making it easier to trace execution flow across state machines. If you set this property to ``true``, the ``input`` property must be an object (provided by ``sfn.TaskInput.fromObject``) or omitted entirely. Default: - false
        :param input: (experimental) The JSON input for the execution, same as that of StartExecution. Default: - The state input (JSON path '$')
        :param name: (experimental) The name of the execution, same as that of StartExecution. Default: - None
        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__260ed092e69c03255ac8feeccada41ecc04aad819dad75ae1b18f7f8500d9fa5)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = StepFunctionsStartExecutionProps(
            state_machine=state_machine,
            associate_with_parent=associate_with_parent,
            input=input,
            name=name,
            comment=comment,
            heartbeat=heartbeat,
            input_path=input_path,
            integration_pattern=integration_pattern,
            output_path=output_path,
            result_path=result_path,
            result_selector=result_selector,
            timeout=timeout,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="taskMetrics")
    def _task_metrics(self) -> typing.Optional[_TaskMetricsConfig_5aaea59e]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[_TaskMetricsConfig_5aaea59e], jsii.get(self, "taskMetrics"))

    @builtins.property
    @jsii.member(jsii_name="taskPolicies")
    def _task_policies(self) -> typing.Optional[typing.List[_PolicyStatement_296fe8a3]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.List[_PolicyStatement_296fe8a3]], jsii.get(self, "taskPolicies"))


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.StepFunctionsStartExecutionProps",
    jsii_struct_bases=[_TaskStateBaseProps_b13f6332],
    name_mapping={
        "comment": "comment",
        "heartbeat": "heartbeat",
        "input_path": "inputPath",
        "integration_pattern": "integrationPattern",
        "output_path": "outputPath",
        "result_path": "resultPath",
        "result_selector": "resultSelector",
        "timeout": "timeout",
        "state_machine": "stateMachine",
        "associate_with_parent": "associateWithParent",
        "input": "input",
        "name": "name",
    },
)
class StepFunctionsStartExecutionProps(_TaskStateBaseProps_b13f6332):
    def __init__(
        self,
        *,
        comment: typing.Optional[builtins.str] = None,
        heartbeat: typing.Optional[_Duration_070aa057] = None,
        input_path: typing.Optional[builtins.str] = None,
        integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
        output_path: typing.Optional[builtins.str] = None,
        result_path: typing.Optional[builtins.str] = None,
        result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeout: typing.Optional[_Duration_070aa057] = None,
        state_machine: _IStateMachine_269a89c4,
        associate_with_parent: typing.Optional[builtins.bool] = None,
        input: typing.Optional[_TaskInput_71ab46f6] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''(experimental) Properties for StartExecution.

        :param comment: (experimental) An optional description for this state. Default: - No comment
        :param heartbeat: (experimental) Timeout for the heartbeat. Default: - None
        :param input_path: (experimental) JSONPath expression to select part of the state to be the input to this state. May also be the special value JsonPath.DISCARD, which will cause the effective input to be the empty object {}. Default: - The entire task input (JSON path '$')
        :param integration_pattern: (experimental) AWS Step Functions integrates with services directly in the Amazon States Language. You can control these AWS services using service integration patterns Default: - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks. ``IntegrationPattern.RUN_JOB`` for the following exceptions: ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.
        :param output_path: (experimental) JSONPath expression to select select a portion of the state output to pass to the next state. May also be the special value JsonPath.DISCARD, which will cause the effective output to be the empty object {}. Default: - The entire JSON node determined by the state input, the task result, and resultPath is passed to the next state (JSON path '$')
        :param result_path: (experimental) JSONPath expression to indicate where to inject the state's output. May also be the special value JsonPath.DISCARD, which will cause the state's input to become its output. Default: - Replaces the entire input with the result (JSON path '$')
        :param result_selector: (experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied. You can use ResultSelector to create a payload with values that are static or selected from the state's raw result. Default: - None
        :param timeout: (experimental) Timeout for the state machine. Default: - None
        :param state_machine: (experimental) The Step Functions state machine to start the execution on.
        :param associate_with_parent: (experimental) Pass the execution ID from the context object to the execution input. This allows the Step Functions UI to link child executions from parent executions, making it easier to trace execution flow across state machines. If you set this property to ``true``, the ``input`` property must be an object (provided by ``sfn.TaskInput.fromObject``) or omitted entirely. Default: - false
        :param input: (experimental) The JSON input for the execution, same as that of StartExecution. Default: - The state input (JSON path '$')
        :param name: (experimental) The name of the execution, same as that of StartExecution. Default: - None

        :stability: experimental
        :exampleMetadata: infused

        Example::

            # Define a state machine with one Pass state
            child = sfn.StateMachine(self, "ChildStateMachine",
                definition=sfn.Chain.start(sfn.Pass(self, "PassState"))
            )
            
            # Include the state machine in a Task state with callback pattern
            task = tasks.StepFunctionsStartExecution(self, "ChildTask",
                state_machine=child,
                integration_pattern=sfn.IntegrationPattern.WAIT_FOR_TASK_TOKEN,
                input=sfn.TaskInput.from_object({
                    "token": sfn.JsonPath.task_token,
                    "foo": "bar"
                }),
                name="MyExecutionName"
            )
            
            # Define a second state machine with the Task state above
            sfn.StateMachine(self, "ParentStateMachine",
                definition=task
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1e4c565f4cce756ce3a1ce52fbb8229a3a9687bc42eef8807167ae5684fae30c)
            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
            check_type(argname="argument heartbeat", value=heartbeat, expected_type=type_hints["heartbeat"])
            check_type(argname="argument input_path", value=input_path, expected_type=type_hints["input_path"])
            check_type(argname="argument integration_pattern", value=integration_pattern, expected_type=type_hints["integration_pattern"])
            check_type(argname="argument output_path", value=output_path, expected_type=type_hints["output_path"])
            check_type(argname="argument result_path", value=result_path, expected_type=type_hints["result_path"])
            check_type(argname="argument result_selector", value=result_selector, expected_type=type_hints["result_selector"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
            check_type(argname="argument state_machine", value=state_machine, expected_type=type_hints["state_machine"])
            check_type(argname="argument associate_with_parent", value=associate_with_parent, expected_type=type_hints["associate_with_parent"])
            check_type(argname="argument input", value=input, expected_type=type_hints["input"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "state_machine": state_machine,
        }
        if comment is not None:
            self._values["comment"] = comment
        if heartbeat is not None:
            self._values["heartbeat"] = heartbeat
        if input_path is not None:
            self._values["input_path"] = input_path
        if integration_pattern is not None:
            self._values["integration_pattern"] = integration_pattern
        if output_path is not None:
            self._values["output_path"] = output_path
        if result_path is not None:
            self._values["result_path"] = result_path
        if result_selector is not None:
            self._values["result_selector"] = result_selector
        if timeout is not None:
            self._values["timeout"] = timeout
        if associate_with_parent is not None:
            self._values["associate_with_parent"] = associate_with_parent
        if input is not None:
            self._values["input"] = input
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def comment(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional description for this state.

        :default: - No comment

        :stability: experimental
        '''
        result = self._values.get("comment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def heartbeat(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the heartbeat.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("heartbeat")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def input_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select part of the state to be the input to this state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        input to be the empty object {}.

        :default: - The entire task input (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("input_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def integration_pattern(self) -> typing.Optional[_IntegrationPattern_fbb35786]:
        '''(experimental) AWS Step Functions integrates with services directly in the Amazon States Language.

        You can control these AWS services using service integration patterns

        :default:

        - ``IntegrationPattern.REQUEST_RESPONSE`` for most tasks.
        ``IntegrationPattern.RUN_JOB`` for the following exceptions:
        ``BatchSubmitJob``, ``EmrAddStep``, ``EmrCreateCluster``, ``EmrTerminationCluster``, and ``EmrContainersStartJobRun``.

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html#connect-wait-token
        :stability: experimental
        '''
        result = self._values.get("integration_pattern")
        return typing.cast(typing.Optional[_IntegrationPattern_fbb35786], result)

    @builtins.property
    def output_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to select select a portion of the state output to pass to the next state.

        May also be the special value JsonPath.DISCARD, which will cause the effective
        output to be the empty object {}.

        :default:

        - The entire JSON node determined by the state input, the task result,
        and resultPath is passed to the next state (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("output_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_path(self) -> typing.Optional[builtins.str]:
        '''(experimental) JSONPath expression to indicate where to inject the state's output.

        May also be the special value JsonPath.DISCARD, which will cause the state's
        input to become its output.

        :default: - Replaces the entire input with the result (JSON path '$')

        :stability: experimental
        '''
        result = self._values.get("result_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) The JSON that will replace the state's raw result and become the effective result before ResultPath is applied.

        You can use ResultSelector to create a payload with values that are static
        or selected from the state's raw result.

        :default: - None

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/input-output-inputpath-params.html#input-output-resultselector
        :stability: experimental
        '''
        result = self._values.get("result_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def timeout(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Timeout for the state machine.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def state_machine(self) -> _IStateMachine_269a89c4:
        '''(experimental) The Step Functions state machine to start the execution on.

        :stability: experimental
        '''
        result = self._values.get("state_machine")
        assert result is not None, "Required property 'state_machine' is missing"
        return typing.cast(_IStateMachine_269a89c4, result)

    @builtins.property
    def associate_with_parent(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Pass the execution ID from the context object to the execution input.

        This allows the Step Functions UI to link child executions from parent executions, making it easier to trace execution flow across state machines.

        If you set this property to ``true``, the ``input`` property must be an object (provided by ``sfn.TaskInput.fromObject``) or omitted entirely.

        :default: - false

        :see: https://docs.aws.amazon.com/step-functions/latest/dg/concepts-nested-workflows.html#nested-execution-startid
        :stability: experimental
        '''
        result = self._values.get("associate_with_parent")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def input(self) -> typing.Optional[_TaskInput_71ab46f6]:
        '''(experimental) The JSON input for the execution, same as that of StartExecution.

        :default: - The state input (JSON path '$')

        :see: https://docs.aws.amazon.com/step-functions/latest/apireference/API_StartExecution.html
        :stability: experimental
        '''
        result = self._values.get("input")
        return typing.cast(typing.Optional[_TaskInput_71ab46f6], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''(experimental) The name of the execution, same as that of StartExecution.

        :default: - None

        :see: https://docs.aws.amazon.com/step-functions/latest/apireference/API_StartExecution.html
        :stability: experimental
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "StepFunctionsStartExecutionProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.StoppingCondition",
    jsii_struct_bases=[],
    name_mapping={"max_runtime": "maxRuntime"},
)
class StoppingCondition:
    def __init__(
        self,
        *,
        max_runtime: typing.Optional[_Duration_070aa057] = None,
    ) -> None:
        '''(experimental) Specifies a limit to how long a model training job can run.

        When the job reaches the time limit, Amazon SageMaker ends the training job.

        :param max_runtime: (experimental) The maximum length of time, in seconds, that the training or compilation job can run. Default: - 1 hour

        :stability: experimental
        :exampleMetadata: infused

        Example::

            tasks.SageMakerCreateTrainingJob(self, "TrainSagemaker",
                training_job_name=sfn.JsonPath.string_at("$.JobName"),
                algorithm_specification=dynamodb.aws_stepfunctions_tasks.AlgorithmSpecification(
                    algorithm_name="BlazingText",
                    training_input_mode=tasks.InputMode.FILE
                ),
                input_data_config=[dynamodb.aws_stepfunctions_tasks.Channel(
                    channel_name="train",
                    data_source=dynamodb.aws_stepfunctions_tasks.DataSource(
                        s3_data_source=dynamodb.aws_stepfunctions_tasks.S3DataSource(
                            s3_data_type=tasks.S3DataType.S3_PREFIX,
                            s3_location=tasks.S3Location.from_json_expression("$.S3Bucket")
                        )
                    )
                )],
                output_data_config=dynamodb.aws_stepfunctions_tasks.OutputDataConfig(
                    s3_output_location=tasks.S3Location.from_bucket(s3.Bucket.from_bucket_name(self, "Bucket", "mybucket"), "myoutputpath")
                ),
                resource_config=dynamodb.aws_stepfunctions_tasks.ResourceConfig(
                    instance_count=1,
                    instance_type=ec2.InstanceType(sfn.JsonPath.string_at("$.InstanceType")),
                    volume_size=Size.gibibytes(50)
                ),  # optional: default is 1 instance of EC2 `M4.XLarge` with `10GB` volume
                stopping_condition=dynamodb.aws_stepfunctions_tasks.StoppingCondition(
                    max_runtime=Duration.hours(2)
                )
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a3bf5e0d0c500a12f38dee1475592b2054b726b3ee116cd0d85aa9cfa20179c7)
            check_type(argname="argument max_runtime", value=max_runtime, expected_type=type_hints["max_runtime"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if max_runtime is not None:
            self._values["max_runtime"] = max_runtime

    @builtins.property
    def max_runtime(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) The maximum length of time, in seconds, that the training or compilation job can run.

        :default: - 1 hour

        :stability: experimental
        '''
        result = self._values.get("max_runtime")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "StoppingCondition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.TaskEnvironmentVariable",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value"},
)
class TaskEnvironmentVariable:
    def __init__(self, *, name: builtins.str, value: builtins.str) -> None:
        '''(experimental) An environment variable to be set in the container run as a task.

        :param name: (experimental) Name for the environment variable. Use ``JsonPath`` class's static methods to specify name from a JSON path.
        :param value: (experimental) Value of the environment variable. Use ``JsonPath`` class's static methods to specify value from a JSON path.

        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
            
            task_environment_variable = stepfunctions_tasks.TaskEnvironmentVariable(
                name="name",
                value="value"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0bc6f819032bcc1b2dc7d3df176c129cbd10ea0a6cb6fe5537970e70ca050fa2)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
            "value": value,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''(experimental) Name for the environment variable.

        Use ``JsonPath`` class's static methods to specify name from a JSON path.

        :stability: experimental
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> builtins.str:
        '''(experimental) Value of the environment variable.

        Use ``JsonPath`` class's static methods to specify value from a JSON path.

        :stability: experimental
        '''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TaskEnvironmentVariable(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.TransformDataSource",
    jsii_struct_bases=[],
    name_mapping={"s3_data_source": "s3DataSource"},
)
class TransformDataSource:
    def __init__(
        self,
        *,
        s3_data_source: typing.Union["TransformS3DataSource", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''(experimental) S3 location of the input data that the model can consume.

        :param s3_data_source: (experimental) S3 location of the input data.

        :stability: experimental
        :exampleMetadata: infused

        Example::

            tasks.SageMakerCreateTransformJob(self, "Batch Inference",
                transform_job_name="MyTransformJob",
                model_name="MyModelName",
                model_client_options=dynamodb.aws_stepfunctions_tasks.ModelClientOptions(
                    invocations_max_retries=3,  # default is 0
                    invocations_timeout=Duration.minutes(5)
                ),
                transform_input=dynamodb.aws_stepfunctions_tasks.TransformInput(
                    transform_data_source=dynamodb.aws_stepfunctions_tasks.TransformDataSource(
                        s3_data_source=dynamodb.aws_stepfunctions_tasks.TransformS3DataSource(
                            s3_uri="s3://inputbucket/train",
                            s3_data_type=tasks.S3DataType.S3_PREFIX
                        )
                    )
                ),
                transform_output=dynamodb.aws_stepfunctions_tasks.TransformOutput(
                    s3_output_path="s3://outputbucket/TransformJobOutputPath"
                ),
                transform_resources=dynamodb.aws_stepfunctions_tasks.TransformResources(
                    instance_count=1,
                    instance_type=ec2.InstanceType.of(ec2.InstanceClass.M4, ec2.InstanceSize.XLARGE)
                )
            )
        '''
        if isinstance(s3_data_source, dict):
            s3_data_source = TransformS3DataSource(**s3_data_source)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ca84dfe9887db1a5e05af498c51695bea5ae2772652530c500c61c8268c61560)
            check_type(argname="argument s3_data_source", value=s3_data_source, expected_type=type_hints["s3_data_source"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "s3_data_source": s3_data_source,
        }

    @builtins.property
    def s3_data_source(self) -> "TransformS3DataSource":
        '''(experimental) S3 location of the input data.

        :stability: experimental
        '''
        result = self._values.get("s3_data_source")
        assert result is not None, "Required property 's3_data_source' is missing"
        return typing.cast("TransformS3DataSource", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TransformDataSource(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.TransformInput",
    jsii_struct_bases=[],
    name_mapping={
        "transform_data_source": "transformDataSource",
        "compression_type": "compressionType",
        "content_type": "contentType",
        "split_type": "splitType",
    },
)
class TransformInput:
    def __init__(
        self,
        *,
        transform_data_source: typing.Union[TransformDataSource, typing.Dict[builtins.str, typing.Any]],
        compression_type: typing.Optional[CompressionType] = None,
        content_type: typing.Optional[builtins.str] = None,
        split_type: typing.Optional[SplitType] = None,
    ) -> None:
        '''(experimental) Dataset to be transformed and the Amazon S3 location where it is stored.

        :param transform_data_source: (experimental) S3 location of the channel data.
        :param compression_type: (experimental) The compression type of the transform data. Default: NONE
        :param content_type: (experimental) Multipurpose internet mail extension (MIME) type of the data. Default: - None
        :param split_type: (experimental) Method to use to split the transform job's data files into smaller batches. Default: NONE

        :stability: experimental
        :exampleMetadata: infused

        Example::

            tasks.SageMakerCreateTransformJob(self, "Batch Inference",
                transform_job_name="MyTransformJob",
                model_name="MyModelName",
                model_client_options=dynamodb.aws_stepfunctions_tasks.ModelClientOptions(
                    invocations_max_retries=3,  # default is 0
                    invocations_timeout=Duration.minutes(5)
                ),
                transform_input=dynamodb.aws_stepfunctions_tasks.TransformInput(
                    transform_data_source=dynamodb.aws_stepfunctions_tasks.TransformDataSource(
                        s3_data_source=dynamodb.aws_stepfunctions_tasks.TransformS3DataSource(
                            s3_uri="s3://inputbucket/train",
                            s3_data_type=tasks.S3DataType.S3_PREFIX
                        )
                    )
                ),
                transform_output=dynamodb.aws_stepfunctions_tasks.TransformOutput(
                    s3_output_path="s3://outputbucket/TransformJobOutputPath"
                ),
                transform_resources=dynamodb.aws_stepfunctions_tasks.TransformResources(
                    instance_count=1,
                    instance_type=ec2.InstanceType.of(ec2.InstanceClass.M4, ec2.InstanceSize.XLARGE)
                )
            )
        '''
        if isinstance(transform_data_source, dict):
            transform_data_source = TransformDataSource(**transform_data_source)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2c79c860db038a74bebbc98791103900e1893cca5025c7051d439536b889ae02)
            check_type(argname="argument transform_data_source", value=transform_data_source, expected_type=type_hints["transform_data_source"])
            check_type(argname="argument compression_type", value=compression_type, expected_type=type_hints["compression_type"])
            check_type(argname="argument content_type", value=content_type, expected_type=type_hints["content_type"])
            check_type(argname="argument split_type", value=split_type, expected_type=type_hints["split_type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "transform_data_source": transform_data_source,
        }
        if compression_type is not None:
            self._values["compression_type"] = compression_type
        if content_type is not None:
            self._values["content_type"] = content_type
        if split_type is not None:
            self._values["split_type"] = split_type

    @builtins.property
    def transform_data_source(self) -> TransformDataSource:
        '''(experimental) S3 location of the channel data.

        :stability: experimental
        '''
        result = self._values.get("transform_data_source")
        assert result is not None, "Required property 'transform_data_source' is missing"
        return typing.cast(TransformDataSource, result)

    @builtins.property
    def compression_type(self) -> typing.Optional[CompressionType]:
        '''(experimental) The compression type of the transform data.

        :default: NONE

        :stability: experimental
        '''
        result = self._values.get("compression_type")
        return typing.cast(typing.Optional[CompressionType], result)

    @builtins.property
    def content_type(self) -> typing.Optional[builtins.str]:
        '''(experimental) Multipurpose internet mail extension (MIME) type of the data.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("content_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def split_type(self) -> typing.Optional[SplitType]:
        '''(experimental) Method to use to split the transform job's data files into smaller batches.

        :default: NONE

        :stability: experimental
        '''
        result = self._values.get("split_type")
        return typing.cast(typing.Optional[SplitType], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TransformInput(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.TransformOutput",
    jsii_struct_bases=[],
    name_mapping={
        "s3_output_path": "s3OutputPath",
        "accept": "accept",
        "assemble_with": "assembleWith",
        "encryption_key": "encryptionKey",
    },
)
class TransformOutput:
    def __init__(
        self,
        *,
        s3_output_path: builtins.str,
        accept: typing.Optional[builtins.str] = None,
        assemble_with: typing.Optional[AssembleWith] = None,
        encryption_key: typing.Optional[_IKey_36930160] = None,
    ) -> None:
        '''(experimental) S3 location where you want Amazon SageMaker to save the results from the transform job.

        :param s3_output_path: (experimental) S3 path where you want Amazon SageMaker to store the results of the transform job.
        :param accept: (experimental) MIME type used to specify the output data. Default: - None
        :param assemble_with: (experimental) Defines how to assemble the results of the transform job as a single S3 object. Default: - None
        :param encryption_key: (experimental) AWS KMS key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption. Default: - default KMS key for Amazon S3 for your role's account.

        :stability: experimental
        :exampleMetadata: infused

        Example::

            tasks.SageMakerCreateTransformJob(self, "Batch Inference",
                transform_job_name="MyTransformJob",
                model_name="MyModelName",
                model_client_options=dynamodb.aws_stepfunctions_tasks.ModelClientOptions(
                    invocations_max_retries=3,  # default is 0
                    invocations_timeout=Duration.minutes(5)
                ),
                transform_input=dynamodb.aws_stepfunctions_tasks.TransformInput(
                    transform_data_source=dynamodb.aws_stepfunctions_tasks.TransformDataSource(
                        s3_data_source=dynamodb.aws_stepfunctions_tasks.TransformS3DataSource(
                            s3_uri="s3://inputbucket/train",
                            s3_data_type=tasks.S3DataType.S3_PREFIX
                        )
                    )
                ),
                transform_output=dynamodb.aws_stepfunctions_tasks.TransformOutput(
                    s3_output_path="s3://outputbucket/TransformJobOutputPath"
                ),
                transform_resources=dynamodb.aws_stepfunctions_tasks.TransformResources(
                    instance_count=1,
                    instance_type=ec2.InstanceType.of(ec2.InstanceClass.M4, ec2.InstanceSize.XLARGE)
                )
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a5b1ce2497b26f995e5d78aa9e69e53fbfac58710d036debce4fdd7b01035679)
            check_type(argname="argument s3_output_path", value=s3_output_path, expected_type=type_hints["s3_output_path"])
            check_type(argname="argument accept", value=accept, expected_type=type_hints["accept"])
            check_type(argname="argument assemble_with", value=assemble_with, expected_type=type_hints["assemble_with"])
            check_type(argname="argument encryption_key", value=encryption_key, expected_type=type_hints["encryption_key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "s3_output_path": s3_output_path,
        }
        if accept is not None:
            self._values["accept"] = accept
        if assemble_with is not None:
            self._values["assemble_with"] = assemble_with
        if encryption_key is not None:
            self._values["encryption_key"] = encryption_key

    @builtins.property
    def s3_output_path(self) -> builtins.str:
        '''(experimental) S3 path where you want Amazon SageMaker to store the results of the transform job.

        :stability: experimental
        '''
        result = self._values.get("s3_output_path")
        assert result is not None, "Required property 's3_output_path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def accept(self) -> typing.Optional[builtins.str]:
        '''(experimental) MIME type used to specify the output data.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("accept")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def assemble_with(self) -> typing.Optional[AssembleWith]:
        '''(experimental) Defines how to assemble the results of the transform job as a single S3 object.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("assemble_with")
        return typing.cast(typing.Optional[AssembleWith], result)

    @builtins.property
    def encryption_key(self) -> typing.Optional[_IKey_36930160]:
        '''(experimental) AWS KMS key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption.

        :default: - default KMS key for Amazon S3 for your role's account.

        :stability: experimental
        '''
        result = self._values.get("encryption_key")
        return typing.cast(typing.Optional[_IKey_36930160], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TransformOutput(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.TransformResources",
    jsii_struct_bases=[],
    name_mapping={
        "instance_count": "instanceCount",
        "instance_type": "instanceType",
        "volume_encryption_key": "volumeEncryptionKey",
    },
)
class TransformResources:
    def __init__(
        self,
        *,
        instance_count: jsii.Number,
        instance_type: _InstanceType_072ad323,
        volume_encryption_key: typing.Optional[_IKey_36930160] = None,
    ) -> None:
        '''(experimental) ML compute instances for the transform job.

        :param instance_count: (experimental) Number of ML compute instances to use in the transform job.
        :param instance_type: (experimental) ML compute instance type for the transform job.
        :param volume_encryption_key: (experimental) AWS KMS key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s). Default: - None

        :stability: experimental
        :exampleMetadata: infused

        Example::

            tasks.SageMakerCreateTransformJob(self, "Batch Inference",
                transform_job_name="MyTransformJob",
                model_name="MyModelName",
                model_client_options=dynamodb.aws_stepfunctions_tasks.ModelClientOptions(
                    invocations_max_retries=3,  # default is 0
                    invocations_timeout=Duration.minutes(5)
                ),
                transform_input=dynamodb.aws_stepfunctions_tasks.TransformInput(
                    transform_data_source=dynamodb.aws_stepfunctions_tasks.TransformDataSource(
                        s3_data_source=dynamodb.aws_stepfunctions_tasks.TransformS3DataSource(
                            s3_uri="s3://inputbucket/train",
                            s3_data_type=tasks.S3DataType.S3_PREFIX
                        )
                    )
                ),
                transform_output=dynamodb.aws_stepfunctions_tasks.TransformOutput(
                    s3_output_path="s3://outputbucket/TransformJobOutputPath"
                ),
                transform_resources=dynamodb.aws_stepfunctions_tasks.TransformResources(
                    instance_count=1,
                    instance_type=ec2.InstanceType.of(ec2.InstanceClass.M4, ec2.InstanceSize.XLARGE)
                )
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f26957810a479378b02b0e03f1210a0254da7fff662a99fe5754d7c298d0a435)
            check_type(argname="argument instance_count", value=instance_count, expected_type=type_hints["instance_count"])
            check_type(argname="argument instance_type", value=instance_type, expected_type=type_hints["instance_type"])
            check_type(argname="argument volume_encryption_key", value=volume_encryption_key, expected_type=type_hints["volume_encryption_key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "instance_count": instance_count,
            "instance_type": instance_type,
        }
        if volume_encryption_key is not None:
            self._values["volume_encryption_key"] = volume_encryption_key

    @builtins.property
    def instance_count(self) -> jsii.Number:
        '''(experimental) Number of ML compute instances to use in the transform job.

        :stability: experimental
        '''
        result = self._values.get("instance_count")
        assert result is not None, "Required property 'instance_count' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def instance_type(self) -> _InstanceType_072ad323:
        '''(experimental) ML compute instance type for the transform job.

        :stability: experimental
        '''
        result = self._values.get("instance_type")
        assert result is not None, "Required property 'instance_type' is missing"
        return typing.cast(_InstanceType_072ad323, result)

    @builtins.property
    def volume_encryption_key(self) -> typing.Optional[_IKey_36930160]:
        '''(experimental) AWS KMS key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s).

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("volume_encryption_key")
        return typing.cast(typing.Optional[_IKey_36930160], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TransformResources(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.TransformS3DataSource",
    jsii_struct_bases=[],
    name_mapping={"s3_uri": "s3Uri", "s3_data_type": "s3DataType"},
)
class TransformS3DataSource:
    def __init__(
        self,
        *,
        s3_uri: builtins.str,
        s3_data_type: typing.Optional[S3DataType] = None,
    ) -> None:
        '''(experimental) Location of the channel data.

        :param s3_uri: (experimental) Identifies either a key name prefix or a manifest.
        :param s3_data_type: (experimental) S3 Data Type. Default: 'S3Prefix'

        :stability: experimental
        :exampleMetadata: infused

        Example::

            tasks.SageMakerCreateTransformJob(self, "Batch Inference",
                transform_job_name="MyTransformJob",
                model_name="MyModelName",
                model_client_options=dynamodb.aws_stepfunctions_tasks.ModelClientOptions(
                    invocations_max_retries=3,  # default is 0
                    invocations_timeout=Duration.minutes(5)
                ),
                transform_input=dynamodb.aws_stepfunctions_tasks.TransformInput(
                    transform_data_source=dynamodb.aws_stepfunctions_tasks.TransformDataSource(
                        s3_data_source=dynamodb.aws_stepfunctions_tasks.TransformS3DataSource(
                            s3_uri="s3://inputbucket/train",
                            s3_data_type=tasks.S3DataType.S3_PREFIX
                        )
                    )
                ),
                transform_output=dynamodb.aws_stepfunctions_tasks.TransformOutput(
                    s3_output_path="s3://outputbucket/TransformJobOutputPath"
                ),
                transform_resources=dynamodb.aws_stepfunctions_tasks.TransformResources(
                    instance_count=1,
                    instance_type=ec2.InstanceType.of(ec2.InstanceClass.M4, ec2.InstanceSize.XLARGE)
                )
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a8fd7a3003b9dcfa59980d827a69de3f99d7846d7957cd312ee8fa51d2b08877)
            check_type(argname="argument s3_uri", value=s3_uri, expected_type=type_hints["s3_uri"])
            check_type(argname="argument s3_data_type", value=s3_data_type, expected_type=type_hints["s3_data_type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "s3_uri": s3_uri,
        }
        if s3_data_type is not None:
            self._values["s3_data_type"] = s3_data_type

    @builtins.property
    def s3_uri(self) -> builtins.str:
        '''(experimental) Identifies either a key name prefix or a manifest.

        :stability: experimental
        '''
        result = self._values.get("s3_uri")
        assert result is not None, "Required property 's3_uri' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def s3_data_type(self) -> typing.Optional[S3DataType]:
        '''(experimental) S3 Data Type.

        :default: 'S3Prefix'

        :stability: experimental
        '''
        result = self._values.get("s3_data_type")
        return typing.cast(typing.Optional[S3DataType], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TransformS3DataSource(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class VirtualClusterInput(
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.VirtualClusterInput",
):
    '''(experimental) Class that returns a virtual cluster's id depending on input type.

    :stability: experimental
    :exampleMetadata: infused

    Example::

        tasks.EmrContainersStartJobRun(self, "EMR Containers Start Job Run",
            virtual_cluster=tasks.VirtualClusterInput.from_virtual_cluster_id("de92jdei2910fwedz"),
            release_label=tasks.ReleaseLabel.EMR_6_2_0,
            job_name="EMR-Containers-Job",
            job_driver=dynamodb.aws_stepfunctions_tasks.JobDriver(
                spark_submit_job_driver=dynamodb.aws_stepfunctions_tasks.SparkSubmitJobDriver(
                    entry_point=sfn.TaskInput.from_text("local:///usr/lib/spark/examples/src/main/python/pi.py")
                )
            ),
            application_config=[dynamodb.aws_stepfunctions_tasks.ApplicationConfiguration(
                classification=tasks.Classification.SPARK_DEFAULTS,
                properties={
                    "spark.executor.instances": "1",
                    "spark.executor.memory": "512M"
                }
            )]
        )
    '''

    @jsii.member(jsii_name="fromTaskInput")
    @builtins.classmethod
    def from_task_input(cls, task_input: _TaskInput_71ab46f6) -> "VirtualClusterInput":
        '''(experimental) Input for a virtualClusterId from a Task Input.

        :param task_input: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5eef6af0b7d9fe8e53733afb666644523158e87e47cd14f0199e63326df27e9d)
            check_type(argname="argument task_input", value=task_input, expected_type=type_hints["task_input"])
        return typing.cast("VirtualClusterInput", jsii.sinvoke(cls, "fromTaskInput", [task_input]))

    @jsii.member(jsii_name="fromVirtualClusterId")
    @builtins.classmethod
    def from_virtual_cluster_id(
        cls,
        virtual_cluster_id: builtins.str,
    ) -> "VirtualClusterInput":
        '''(experimental) Input for virtualClusterId from a literal string.

        :param virtual_cluster_id: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e8e37f20d8bfa225652d8a8c7ac333f7dd80e7e3a831d9c691e376fe497c7628)
            check_type(argname="argument virtual_cluster_id", value=virtual_cluster_id, expected_type=type_hints["virtual_cluster_id"])
        return typing.cast("VirtualClusterInput", jsii.sinvoke(cls, "fromVirtualClusterId", [virtual_cluster_id]))

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        '''(experimental) The VirtualCluster Id.

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "id"))


@jsii.data_type(
    jsii_type="monocdk.aws_stepfunctions_tasks.VpcConfig",
    jsii_struct_bases=[],
    name_mapping={"vpc": "vpc", "subnets": "subnets"},
)
class VpcConfig:
    def __init__(
        self,
        *,
        vpc: _IVpc_6d1f76c4,
        subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''(experimental) Specifies the VPC that you want your Amazon SageMaker training job to connect to.

        :param vpc: (experimental) VPC.
        :param subnets: (experimental) VPC subnets. Default: - Private Subnets are selected

        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_ec2 as ec2
            from monocdk import aws_stepfunctions_tasks as stepfunctions_tasks
            
            # subnet: ec2.Subnet
            # subnet_filter: ec2.SubnetFilter
            # vpc: ec2.Vpc
            
            vpc_config = stepfunctions_tasks.VpcConfig(
                vpc=vpc,
            
                # the properties below are optional
                subnets=ec2.SubnetSelection(
                    availability_zones=["availabilityZones"],
                    one_per_az=False,
                    subnet_filters=[subnet_filter],
                    subnet_group_name="subnetGroupName",
                    subnet_name="subnetName",
                    subnets=[subnet],
                    subnet_type=ec2.SubnetType.ISOLATED
                )
            )
        '''
        if isinstance(subnets, dict):
            subnets = _SubnetSelection_1284e62c(**subnets)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3eb08759bd4609d0139e7e9b2c0e80010331588cbe310f2b8b9b45b635482735)
            check_type(argname="argument vpc", value=vpc, expected_type=type_hints["vpc"])
            check_type(argname="argument subnets", value=subnets, expected_type=type_hints["subnets"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "vpc": vpc,
        }
        if subnets is not None:
            self._values["subnets"] = subnets

    @builtins.property
    def vpc(self) -> _IVpc_6d1f76c4:
        '''(experimental) VPC.

        :stability: experimental
        '''
        result = self._values.get("vpc")
        assert result is not None, "Required property 'vpc' is missing"
        return typing.cast(_IVpc_6d1f76c4, result)

    @builtins.property
    def subnets(self) -> typing.Optional[_SubnetSelection_1284e62c]:
        '''(experimental) VPC subnets.

        :default: - Private Subnets are selected

        :stability: experimental
        '''
        result = self._values.get("subnets")
        return typing.cast(typing.Optional[_SubnetSelection_1284e62c], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VpcConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(IContainerDefinition)
class ContainerDefinition(
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.ContainerDefinition",
):
    '''(experimental) Describes the container, as part of model definition.

    :see: https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_ContainerDefinition.html
    :stability: experimental
    :exampleMetadata: infused

    Example::

        tasks.SageMakerCreateModel(self, "Sagemaker",
            model_name="MyModel",
            primary_container=tasks.ContainerDefinition(
                image=tasks.DockerImage.from_json_expression(sfn.JsonPath.string_at("$.Model.imageName")),
                mode=tasks.Mode.SINGLE_MODEL,
                model_s3_location=tasks.S3Location.from_json_expression("$.TrainingJob.ModelArtifacts.S3ModelArtifacts")
            )
        )
    '''

    def __init__(
        self,
        *,
        container_host_name: typing.Optional[builtins.str] = None,
        environment_variables: typing.Optional[_TaskInput_71ab46f6] = None,
        image: typing.Optional[DockerImage] = None,
        mode: typing.Optional[Mode] = None,
        model_package_name: typing.Optional[builtins.str] = None,
        model_s3_location: typing.Optional[S3Location] = None,
    ) -> None:
        '''
        :param container_host_name: (experimental) This parameter is ignored for models that contain only a PrimaryContainer. When a ContainerDefinition is part of an inference pipeline, the value of the parameter uniquely identifies the container for the purposes of logging and metrics. Default: - None
        :param environment_variables: (experimental) The environment variables to set in the Docker container. Default: - No variables
        :param image: (experimental) The Amazon EC2 Container Registry (Amazon ECR) path where inference code is stored. Default: - None
        :param mode: (experimental) Defines how many models the container hosts. Default: - Mode.SINGLE_MODEL
        :param model_package_name: (experimental) The name or Amazon Resource Name (ARN) of the model package to use to create the model. Default: - None
        :param model_s3_location: (experimental) The S3 path where the model artifacts, which result from model training, are stored. This path must point to a single gzip compressed tar archive (.tar.gz suffix). The S3 path is required for Amazon SageMaker built-in algorithms, but not if you use your own algorithms. Default: - None

        :stability: experimental
        '''
        options = ContainerDefinitionOptions(
            container_host_name=container_host_name,
            environment_variables=environment_variables,
            image=image,
            mode=mode,
            model_package_name=model_package_name,
            model_s3_location=model_s3_location,
        )

        jsii.create(self.__class__, self, [options])

    @jsii.member(jsii_name="bind")
    def bind(self, task: ISageMakerTask) -> ContainerDefinitionConfig:
        '''(experimental) Called when the ContainerDefinition type configured on Sagemaker Task.

        :param task: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fbf452567c26247a93cef1cd325f4472c3a5cb4abca48655aaaa85a6db7dcf82)
            check_type(argname="argument task", value=task, expected_type=type_hints["task"])
        return typing.cast(ContainerDefinitionConfig, jsii.invoke(self, "bind", [task]))


@jsii.implements(IEcsLaunchTarget)
class EcsEc2LaunchTarget(
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.EcsEc2LaunchTarget",
):
    '''(experimental) Configuration for running an ECS task on EC2.

    :see: https://docs.aws.amazon.com/AmazonECS/latest/userguide/launch_types.html#launch-type-ec2
    :stability: experimental
    :exampleMetadata: infused

    Example::

        vpc = ec2.Vpc.from_lookup(self, "Vpc",
            is_default=True
        )
        
        cluster = ecs.Cluster(self, "Ec2Cluster", vpc=vpc)
        cluster.add_capacity("DefaultAutoScalingGroup",
            instance_type=ec2.InstanceType("t2.micro"),
            vpc_subnets=dynamodb.aws_ec2.SubnetSelection(subnet_type=ec2.SubnetType.PUBLIC)
        )
        
        task_definition = ecs.TaskDefinition(self, "TD",
            compatibility=ecs.Compatibility.EC2
        )
        
        task_definition.add_container("TheContainer",
            image=ecs.ContainerImage.from_registry("foo/bar"),
            memory_limit_mi_b=256
        )
        
        run_task = tasks.EcsRunTask(self, "Run",
            integration_pattern=sfn.IntegrationPattern.RUN_JOB,
            cluster=cluster,
            task_definition=task_definition,
            launch_target=tasks.EcsEc2LaunchTarget(
                placement_strategies=[
                    ecs.PlacementStrategy.spread_across_instances(),
                    ecs.PlacementStrategy.packed_by_cpu(),
                    ecs.PlacementStrategy.randomly()
                ],
                placement_constraints=[
                    ecs.PlacementConstraint.member_of("blieptuut")
                ]
            )
        )
    '''

    def __init__(
        self,
        *,
        placement_constraints: typing.Optional[typing.Sequence[_PlacementConstraint_e22ac48c]] = None,
        placement_strategies: typing.Optional[typing.Sequence[_PlacementStrategy_ea27367e]] = None,
    ) -> None:
        '''
        :param placement_constraints: (experimental) Placement constraints. Default: - None
        :param placement_strategies: (experimental) Placement strategies. Default: - None

        :stability: experimental
        '''
        options = EcsEc2LaunchTargetOptions(
            placement_constraints=placement_constraints,
            placement_strategies=placement_strategies,
        )

        jsii.create(self.__class__, self, [options])

    @jsii.member(jsii_name="bind")
    def bind(
        self,
        _task: EcsRunTask,
        *,
        task_definition: _ITaskDefinition_ee0d1862,
        cluster: typing.Optional[_ICluster_42c4ec1a] = None,
    ) -> EcsLaunchTargetConfig:
        '''(experimental) Called when the EC2 launch type is configured on RunTask.

        :param _task: -
        :param task_definition: (experimental) Task definition to run Docker containers in Amazon ECS.
        :param cluster: (experimental) A regional grouping of one or more container instances on which you can run tasks and services. Default: - No cluster

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__960bc36be2f8e6b88028bc75eb8a02defdc265dec7366f10f1ad73266918ef0e)
            check_type(argname="argument _task", value=_task, expected_type=type_hints["_task"])
        launch_target_options = LaunchTargetBindOptions(
            task_definition=task_definition, cluster=cluster
        )

        return typing.cast(EcsLaunchTargetConfig, jsii.invoke(self, "bind", [_task, launch_target_options]))


@jsii.implements(IEcsLaunchTarget)
class EcsFargateLaunchTarget(
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_stepfunctions_tasks.EcsFargateLaunchTarget",
):
    '''(experimental) Configuration for running an ECS task on Fargate.

    :see: https://docs.aws.amazon.com/AmazonECS/latest/userguide/launch_types.html#launch-type-fargate
    :stability: experimental
    :exampleMetadata: infused

    Example::

        vpc = ec2.Vpc.from_lookup(self, "Vpc",
            is_default=True
        )
        
        cluster = ecs.Cluster(self, "FargateCluster", vpc=vpc)
        
        task_definition = ecs.TaskDefinition(self, "TD",
            memory_mi_b="512",
            cpu="256",
            compatibility=ecs.Compatibility.FARGATE
        )
        
        container_definition = task_definition.add_container("TheContainer",
            image=ecs.ContainerImage.from_registry("foo/bar"),
            memory_limit_mi_b=256
        )
        
        run_task = tasks.EcsRunTask(self, "RunFargate",
            integration_pattern=sfn.IntegrationPattern.RUN_JOB,
            cluster=cluster,
            task_definition=task_definition,
            assign_public_ip=True,
            container_overrides=[dynamodb.aws_stepfunctions_tasks.ContainerOverride(
                container_definition=container_definition,
                environment=[dynamodb.aws_stepfunctions_tasks.TaskEnvironmentVariable(name="SOME_KEY", value=sfn.JsonPath.string_at("$.SomeKey"))]
            )],
            launch_target=tasks.EcsFargateLaunchTarget()
        )
    '''

    def __init__(self, *, platform_version: _FargatePlatformVersion_8169c79a) -> None:
        '''
        :param platform_version: (experimental) Refers to a specific runtime environment for Fargate task infrastructure. Fargate platform version is a combination of the kernel and container runtime versions.

        :stability: experimental
        '''
        options = EcsFargateLaunchTargetOptions(platform_version=platform_version)

        jsii.create(self.__class__, self, [options])

    @jsii.member(jsii_name="bind")
    def bind(
        self,
        _task: EcsRunTask,
        *,
        task_definition: _ITaskDefinition_ee0d1862,
        cluster: typing.Optional[_ICluster_42c4ec1a] = None,
    ) -> EcsLaunchTargetConfig:
        '''(experimental) Called when the Fargate launch type configured on RunTask.

        :param _task: -
        :param task_definition: (experimental) Task definition to run Docker containers in Amazon ECS.
        :param cluster: (experimental) A regional grouping of one or more container instances on which you can run tasks and services. Default: - No cluster

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7ac9c95b5b678681ac5d5bb2da25a1448399aa8d17a74a662c31191b350258cb)
            check_type(argname="argument _task", value=_task, expected_type=type_hints["_task"])
        launch_target_options = LaunchTargetBindOptions(
            task_definition=task_definition, cluster=cluster
        )

        return typing.cast(EcsLaunchTargetConfig, jsii.invoke(self, "bind", [_task, launch_target_options]))


__all__ = [
    "AcceleratorClass",
    "AcceleratorType",
    "ActionOnFailure",
    "AlgorithmSpecification",
    "ApplicationConfiguration",
    "AssembleWith",
    "AthenaGetQueryExecution",
    "AthenaGetQueryExecutionProps",
    "AthenaGetQueryResults",
    "AthenaGetQueryResultsProps",
    "AthenaStartQueryExecution",
    "AthenaStartQueryExecutionProps",
    "AthenaStopQueryExecution",
    "AthenaStopQueryExecutionProps",
    "AuthType",
    "BatchContainerOverrides",
    "BatchJobDependency",
    "BatchStrategy",
    "BatchSubmitJob",
    "BatchSubmitJobProps",
    "CallApiGatewayEndpointBaseProps",
    "CallApiGatewayHttpApiEndpoint",
    "CallApiGatewayHttpApiEndpointProps",
    "CallApiGatewayRestApiEndpoint",
    "CallApiGatewayRestApiEndpointProps",
    "CallAwsService",
    "CallAwsServiceProps",
    "Channel",
    "Classification",
    "CodeBuildStartBuild",
    "CodeBuildStartBuildProps",
    "CommonEcsRunTaskProps",
    "CompressionType",
    "ContainerDefinition",
    "ContainerDefinitionConfig",
    "ContainerDefinitionOptions",
    "ContainerOverride",
    "ContainerOverrides",
    "DataSource",
    "DockerImage",
    "DockerImageConfig",
    "DynamoAttributeValue",
    "DynamoConsumedCapacity",
    "DynamoDeleteItem",
    "DynamoDeleteItemProps",
    "DynamoGetItem",
    "DynamoGetItemProps",
    "DynamoItemCollectionMetrics",
    "DynamoProjectionExpression",
    "DynamoPutItem",
    "DynamoPutItemProps",
    "DynamoReturnValues",
    "DynamoUpdateItem",
    "DynamoUpdateItemProps",
    "EcsEc2LaunchTarget",
    "EcsEc2LaunchTargetOptions",
    "EcsFargateLaunchTarget",
    "EcsFargateLaunchTargetOptions",
    "EcsLaunchTargetConfig",
    "EcsRunTask",
    "EcsRunTaskBase",
    "EcsRunTaskBaseProps",
    "EcsRunTaskProps",
    "EksCall",
    "EksCallProps",
    "EksClusterInput",
    "EmrAddStep",
    "EmrAddStepProps",
    "EmrCancelStep",
    "EmrCancelStepProps",
    "EmrContainersCreateVirtualCluster",
    "EmrContainersCreateVirtualClusterProps",
    "EmrContainersDeleteVirtualCluster",
    "EmrContainersDeleteVirtualClusterProps",
    "EmrContainersStartJobRun",
    "EmrContainersStartJobRunProps",
    "EmrCreateCluster",
    "EmrCreateClusterProps",
    "EmrModifyInstanceFleetByName",
    "EmrModifyInstanceFleetByNameProps",
    "EmrModifyInstanceGroupByName",
    "EmrModifyInstanceGroupByNameProps",
    "EmrSetClusterTerminationProtection",
    "EmrSetClusterTerminationProtectionProps",
    "EmrTerminateCluster",
    "EmrTerminateClusterProps",
    "EncryptionConfiguration",
    "EncryptionOption",
    "EvaluateExpression",
    "EvaluateExpressionProps",
    "EventBridgePutEvents",
    "EventBridgePutEventsEntry",
    "EventBridgePutEventsProps",
    "GlueDataBrewStartJobRun",
    "GlueDataBrewStartJobRunProps",
    "GlueStartJobRun",
    "GlueStartJobRunProps",
    "HttpMethod",
    "HttpMethods",
    "IContainerDefinition",
    "IEcsLaunchTarget",
    "ISageMakerTask",
    "InputMode",
    "InvocationType",
    "InvokeActivity",
    "InvokeActivityProps",
    "InvokeFunction",
    "InvokeFunctionProps",
    "JobDependency",
    "JobDriver",
    "LambdaInvocationType",
    "LambdaInvoke",
    "LambdaInvokeProps",
    "LaunchTargetBindOptions",
    "MessageAttribute",
    "MessageAttributeDataType",
    "MetricDefinition",
    "Mode",
    "ModelClientOptions",
    "Monitoring",
    "OutputDataConfig",
    "ProductionVariant",
    "PublishToTopic",
    "PublishToTopicProps",
    "QueryExecutionContext",
    "RecordWrapperType",
    "ReleaseLabel",
    "ResourceConfig",
    "ResultConfiguration",
    "RunBatchJob",
    "RunBatchJobProps",
    "RunEcsEc2Task",
    "RunEcsEc2TaskProps",
    "RunEcsFargateTask",
    "RunEcsFargateTaskProps",
    "RunGlueJobTask",
    "RunGlueJobTaskProps",
    "RunLambdaTask",
    "RunLambdaTaskProps",
    "S3DataDistributionType",
    "S3DataSource",
    "S3DataType",
    "S3Location",
    "S3LocationBindOptions",
    "S3LocationConfig",
    "SageMakerCreateEndpoint",
    "SageMakerCreateEndpointConfig",
    "SageMakerCreateEndpointConfigProps",
    "SageMakerCreateEndpointProps",
    "SageMakerCreateModel",
    "SageMakerCreateModelProps",
    "SageMakerCreateTrainingJob",
    "SageMakerCreateTrainingJobProps",
    "SageMakerCreateTransformJob",
    "SageMakerCreateTransformJobProps",
    "SageMakerUpdateEndpoint",
    "SageMakerUpdateEndpointProps",
    "SendToQueue",
    "SendToQueueProps",
    "ShuffleConfig",
    "SnsPublish",
    "SnsPublishProps",
    "SparkSubmitJobDriver",
    "SplitType",
    "SqsSendMessage",
    "SqsSendMessageProps",
    "StartExecution",
    "StartExecutionProps",
    "StepFunctionsInvokeActivity",
    "StepFunctionsInvokeActivityProps",
    "StepFunctionsStartExecution",
    "StepFunctionsStartExecutionProps",
    "StoppingCondition",
    "TaskEnvironmentVariable",
    "TransformDataSource",
    "TransformInput",
    "TransformOutput",
    "TransformResources",
    "TransformS3DataSource",
    "VirtualClusterInput",
    "VpcConfig",
]

publication.publish()

def _typecheckingstub__959021e0fa058c9927caef9274414bb711beb5dfed040d9e9101321edf09c83b(
    version: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6a1fbdecafdd35f93690fc078b36cc353e68f467f7b2b0b9fb9ddf045cf984e3(
    instance_type_identifier: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__039f775b31e61c74e088a28a14b8b89d2f4aeec6015ec4ab3f34a7e8e2745d80(
    accelerator_class: AcceleratorClass,
    instance_size: _InstanceSize_decfb0b1,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e3bd3dae22cf03d691dffad872788e09abd3bf303ae0a0cf00614dacf74bcb93(
    *,
    algorithm_name: typing.Optional[builtins.str] = None,
    metric_definitions: typing.Optional[typing.Sequence[typing.Union[MetricDefinition, typing.Dict[builtins.str, typing.Any]]]] = None,
    training_image: typing.Optional[DockerImage] = None,
    training_input_mode: typing.Optional[InputMode] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2c77854aa4b1d73a50c484db2443d3f56cfd5535e6ac2108db436f3e3aea788c(
    *,
    classification: Classification,
    nested_config: typing.Optional[typing.Sequence[typing.Union[ApplicationConfiguration, typing.Dict[builtins.str, typing.Any]]]] = None,
    properties: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5524d4a94b8d2be5baa96c623258de8e956391b4b013a16b2907811d75cf3f42(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    query_execution_id: builtins.str,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__174bf3d04320a38708b32a0e4a83db0ffab60c76536d1bbb77eb97976453c8f0(
    *,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
    query_execution_id: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c0464d6a97ba64391d2c2ee191c965c6c38eebf816d16f74687b3cd090d17f13(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    query_execution_id: builtins.str,
    max_results: typing.Optional[jsii.Number] = None,
    next_token: typing.Optional[builtins.str] = None,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1145ec793294ac2d2738d9d3cb83de26e7273a081f4a572d7a38ecb00855f65a(
    *,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
    query_execution_id: builtins.str,
    max_results: typing.Optional[jsii.Number] = None,
    next_token: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__54bfbda94fa785c270854d8d0d075ceb2272c647614e085bf7a25794c653686d(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    query_string: builtins.str,
    client_request_token: typing.Optional[builtins.str] = None,
    query_execution_context: typing.Optional[typing.Union[QueryExecutionContext, typing.Dict[builtins.str, typing.Any]]] = None,
    result_configuration: typing.Optional[typing.Union[ResultConfiguration, typing.Dict[builtins.str, typing.Any]]] = None,
    work_group: typing.Optional[builtins.str] = None,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8b958e9e9e74b96e2b8caff95ccee2e2c056805db4b0e907dc0ce89fd1dfca8a(
    *,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
    query_string: builtins.str,
    client_request_token: typing.Optional[builtins.str] = None,
    query_execution_context: typing.Optional[typing.Union[QueryExecutionContext, typing.Dict[builtins.str, typing.Any]]] = None,
    result_configuration: typing.Optional[typing.Union[ResultConfiguration, typing.Dict[builtins.str, typing.Any]]] = None,
    work_group: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__27e526f5e76e3c6abd77a248fdb8af805399e01d52c0d563ee848163ca78aded(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    query_execution_id: builtins.str,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5048d7d7a753b92b87296c2325d425f7547649e375360ec46bbe38641c7f95d2(
    *,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
    query_execution_id: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__01e94d7181aa8e1397c000ceace2adda19dd1b79f94b97696e37d4e8ab796799(
    *,
    command: typing.Optional[typing.Sequence[builtins.str]] = None,
    environment: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    gpu_count: typing.Optional[jsii.Number] = None,
    instance_type: typing.Optional[_InstanceType_072ad323] = None,
    memory: typing.Optional[_Size_7fbd4337] = None,
    vcpus: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__32d05e6969be932149d6678f37f0ae479b50855643c7d9f81d032193e1efe367(
    *,
    job_id: typing.Optional[builtins.str] = None,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f34cd63192e3916bd75ab01fa2eddd6c39c257e56436428a659eb9a8272dd07c(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    job_definition_arn: builtins.str,
    job_name: builtins.str,
    job_queue_arn: builtins.str,
    array_size: typing.Optional[jsii.Number] = None,
    attempts: typing.Optional[jsii.Number] = None,
    container_overrides: typing.Optional[typing.Union[BatchContainerOverrides, typing.Dict[builtins.str, typing.Any]]] = None,
    depends_on: typing.Optional[typing.Sequence[typing.Union[BatchJobDependency, typing.Dict[builtins.str, typing.Any]]]] = None,
    payload: typing.Optional[_TaskInput_71ab46f6] = None,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ca493b1b57c5a51f3b2afe28129defcde9ae649c09611805a05b493ba63b79cc(
    *,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
    job_definition_arn: builtins.str,
    job_name: builtins.str,
    job_queue_arn: builtins.str,
    array_size: typing.Optional[jsii.Number] = None,
    attempts: typing.Optional[jsii.Number] = None,
    container_overrides: typing.Optional[typing.Union[BatchContainerOverrides, typing.Dict[builtins.str, typing.Any]]] = None,
    depends_on: typing.Optional[typing.Sequence[typing.Union[BatchJobDependency, typing.Dict[builtins.str, typing.Any]]]] = None,
    payload: typing.Optional[_TaskInput_71ab46f6] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2d6c62a9bdb9d3f037b0d365fe73a3e5112fe3a3009f2600abe385d6b794e70a(
    *,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
    method: HttpMethod,
    api_path: typing.Optional[builtins.str] = None,
    auth_type: typing.Optional[AuthType] = None,
    headers: typing.Optional[_TaskInput_71ab46f6] = None,
    query_parameters: typing.Optional[_TaskInput_71ab46f6] = None,
    request_body: typing.Optional[_TaskInput_71ab46f6] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b55b003c7982b9b58c9a2b9deca99e8cb3360d30d6b247b7712322bb66b78f10(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    api_id: builtins.str,
    api_stack: _Stack_9f43e4a3,
    stage_name: typing.Optional[builtins.str] = None,
    method: HttpMethod,
    api_path: typing.Optional[builtins.str] = None,
    auth_type: typing.Optional[AuthType] = None,
    headers: typing.Optional[_TaskInput_71ab46f6] = None,
    query_parameters: typing.Optional[_TaskInput_71ab46f6] = None,
    request_body: typing.Optional[_TaskInput_71ab46f6] = None,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6f1e0132f6a5a32af459e8750866c10a1d246d1ed6d3cb4d477e31f5d1e57621(
    *,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
    method: HttpMethod,
    api_path: typing.Optional[builtins.str] = None,
    auth_type: typing.Optional[AuthType] = None,
    headers: typing.Optional[_TaskInput_71ab46f6] = None,
    query_parameters: typing.Optional[_TaskInput_71ab46f6] = None,
    request_body: typing.Optional[_TaskInput_71ab46f6] = None,
    api_id: builtins.str,
    api_stack: _Stack_9f43e4a3,
    stage_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__508affe57ea1e2f3119725bcdcd4e1e18ac42ba09c8620cb9993bdad3954625f(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    api: _IRestApi_a27d4788,
    stage_name: builtins.str,
    method: HttpMethod,
    api_path: typing.Optional[builtins.str] = None,
    auth_type: typing.Optional[AuthType] = None,
    headers: typing.Optional[_TaskInput_71ab46f6] = None,
    query_parameters: typing.Optional[_TaskInput_71ab46f6] = None,
    request_body: typing.Optional[_TaskInput_71ab46f6] = None,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c15645443f1d3723a03a2bfba6ac660ee72db9dc16a31fec99c99b53510e104f(
    *,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
    method: HttpMethod,
    api_path: typing.Optional[builtins.str] = None,
    auth_type: typing.Optional[AuthType] = None,
    headers: typing.Optional[_TaskInput_71ab46f6] = None,
    query_parameters: typing.Optional[_TaskInput_71ab46f6] = None,
    request_body: typing.Optional[_TaskInput_71ab46f6] = None,
    api: _IRestApi_a27d4788,
    stage_name: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2b78fcaf67b0f989b1ac54e1c0b74ca22a679df83969389413d6b09a35550e9a(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    action: builtins.str,
    iam_resources: typing.Sequence[builtins.str],
    service: builtins.str,
    iam_action: typing.Optional[builtins.str] = None,
    parameters: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5803a26cfc1e2247ca0d98af98a9536ee0944e658343f8f6673c91ffd6050954(
    *,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
    action: builtins.str,
    iam_resources: typing.Sequence[builtins.str],
    service: builtins.str,
    iam_action: typing.Optional[builtins.str] = None,
    parameters: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4f825ae449ecea944d6f37787a6d795fe89fa543e25f930bc0efb5102db4cb94(
    *,
    channel_name: builtins.str,
    data_source: typing.Union[DataSource, typing.Dict[builtins.str, typing.Any]],
    compression_type: typing.Optional[CompressionType] = None,
    content_type: typing.Optional[builtins.str] = None,
    input_mode: typing.Optional[InputMode] = None,
    record_wrapper_type: typing.Optional[RecordWrapperType] = None,
    shuffle_config: typing.Optional[typing.Union[ShuffleConfig, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0db5ad534c508b5437a3c577eba01046accc6bfb30e8511bbee402133fbec1b2(
    classification_statement: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__46a0879ab4a77972f8aef79453df3a294e3bb04c5341ca0a3703c45c28f2079a(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    project: _IProject_6da8803e,
    environment_variables_override: typing.Optional[typing.Mapping[builtins.str, typing.Union[_BuildEnvironmentVariable_00095c97, typing.Dict[builtins.str, typing.Any]]]] = None,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__512ed52086e9a97c66d11ac149d455e72907de8832bad1a13a78a3e7d6bf198c(
    *,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
    project: _IProject_6da8803e,
    environment_variables_override: typing.Optional[typing.Mapping[builtins.str, typing.Union[_BuildEnvironmentVariable_00095c97, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1f186f0a4b0ad92412e4de2a554d25c2dd32d3f4ab3344c8e969f53c92e97c08(
    *,
    cluster: _ICluster_42c4ec1a,
    task_definition: _TaskDefinition_c0dacfb4,
    container_overrides: typing.Optional[typing.Sequence[typing.Union[ContainerOverride, typing.Dict[builtins.str, typing.Any]]]] = None,
    integration_pattern: typing.Optional[_ServiceIntegrationPattern_5581ee88] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__383968e7c273fd817450b495f2dddceb1d518bd8349567660d1a594589265f7a(
    *,
    parameters: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__abc88b0def593b1547be3a29aab0de06896ad69a0d5e3c866aa98f4871cecca3(
    *,
    container_host_name: typing.Optional[builtins.str] = None,
    environment_variables: typing.Optional[_TaskInput_71ab46f6] = None,
    image: typing.Optional[DockerImage] = None,
    mode: typing.Optional[Mode] = None,
    model_package_name: typing.Optional[builtins.str] = None,
    model_s3_location: typing.Optional[S3Location] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__686adc5122dbcb831fcd730a331141f18e31185ba78eb385fdfdc2f9b86d7aba(
    *,
    container_definition: _ContainerDefinition_7934d1e1,
    command: typing.Optional[typing.Sequence[builtins.str]] = None,
    cpu: typing.Optional[jsii.Number] = None,
    environment: typing.Optional[typing.Sequence[typing.Union[TaskEnvironmentVariable, typing.Dict[builtins.str, typing.Any]]]] = None,
    memory_limit: typing.Optional[jsii.Number] = None,
    memory_reservation: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__df353834bed53580f81dbf38a41e1228045a40fc4ce60c0d509fadeb7287c654(
    *,
    command: typing.Optional[typing.Sequence[builtins.str]] = None,
    environment: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    gpu_count: typing.Optional[jsii.Number] = None,
    instance_type: typing.Optional[_InstanceType_072ad323] = None,
    memory: typing.Optional[jsii.Number] = None,
    vcpus: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__69771688b002fd56442cd1803873821bfaad2ca08127473634c63bf68add1f6a(
    *,
    s3_data_source: typing.Union[S3DataSource, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__099630af2705e74e3c4180fbd5f5ae3ed64915ed291a581ae6f2b2122dac81d9(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    directory: builtins.str,
    build_args: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    file: typing.Optional[builtins.str] = None,
    invalidation: typing.Optional[typing.Union[_DockerImageAssetInvalidationOptions_e5375707, typing.Dict[builtins.str, typing.Any]]] = None,
    network_mode: typing.Optional[_NetworkMode_2d19607e] = None,
    platform: typing.Optional[_Platform_5ed8dbaf] = None,
    repository_name: typing.Optional[builtins.str] = None,
    target: typing.Optional[builtins.str] = None,
    extra_hash: typing.Optional[builtins.str] = None,
    exclude: typing.Optional[typing.Sequence[builtins.str]] = None,
    follow: typing.Optional[_FollowMode_98b05cc5] = None,
    ignore_mode: typing.Optional[_IgnoreMode_31d8bf46] = None,
    follow_symlinks: typing.Optional[_SymlinkFollowMode_abf4527a] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b2a0dc1c79098867beb966c8800d37a1d3655d5cc440124678866a1bcc6e6828(
    repository: _IRepository_8b4d2894,
    tag_or_digest: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b06ee298eec94a8601b63b4ca77c8e3ddf45343f2de7e03a85889b67e8bed9fc(
    expression: builtins.str,
    allow_any_ecr_image_pull: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c393b1773eb71269e52749d1ffa68f6dd910779301fef716d99766ca0553f48d(
    image_uri: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__607df61fcc915521d92a5ad608280a7e6b92845f15c09954bd98871f861e0600(
    task: ISageMakerTask,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7e9d16424cdb7ff9f2e0d63bdee7e5ece9ffb4277af2de9c7f12dbe7395e2873(
    *,
    image_uri: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eb770b2bba955477ff060791cdf3df4d172abbc77427fae130ed43e52246a3bc(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__17a2eba24d2cfa55c71d47a62a2aa4bfcb8eb01558f8741bd6322456a32af345(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5d792c0556d9ef30b55c5807bba9752c6fea4dea6821b3d45af2c5f453ba411c(
    value: typing.Sequence[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b6c30781d30eebf22a891712e819d5cbecaafb581375971485191423f62b5597(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__301630a08247dfe2512e30693066bc3613375f3d11f3ebdd489ab4aa15f4b858(
    value: typing.Sequence[DynamoAttributeValue],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0edc34959a9d14105c75b076b843a04762d5f14ca8874d4d786ae55a7b12c972(
    value: typing.Mapping[builtins.str, DynamoAttributeValue],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__919bdbe2bc361af09b09786a220c7900a135c13f21b9e0182b36ea46e562e57a(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1e3c5348e081b3c76abab63d78243006019c49f14795ef1c14c86d1df2f283c0(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__91c9ad98c9a6ef95576c0e09c8e425005bcbf3bc371017157841093787150b68(
    value: typing.Sequence[jsii.Number],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4e7d42265baa8f8d9e3bf2abe9cab077bac05ecbc6c210b57e44a64aa263254d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__246c1d8678c674960ad997104291fd7e95f84f830477ed92de09b26e902b8c12(
    value: typing.Sequence[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6aa2cbf966d499423ad97bf52c406a9ec5706524bab966718e288c08a01cef20(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e64ca519e98b4d3d03964d5f9d54b88629f3ac5cca3d3f7f295d490f0862669a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b4b1dac4f24d054ff9621ac3023e3b3c26e77d8774487c91da76f665ba6257e8(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__86563431d7adb5a2e8be11163965b252d7632bec663c8c0baf722a1a1fb6b087(
    value: typing.Sequence[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__50c2b778c4c1620aeac0366e32b28097b565e90b0acf30493521474717155ed2(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    key: typing.Mapping[builtins.str, DynamoAttributeValue],
    table: _ITable_24826f7e,
    condition_expression: typing.Optional[builtins.str] = None,
    expression_attribute_names: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    expression_attribute_values: typing.Optional[typing.Mapping[builtins.str, DynamoAttributeValue]] = None,
    return_consumed_capacity: typing.Optional[DynamoConsumedCapacity] = None,
    return_item_collection_metrics: typing.Optional[DynamoItemCollectionMetrics] = None,
    return_values: typing.Optional[DynamoReturnValues] = None,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5c5b01d167c8c11d094ef327d09567d84cad84aacbcfba36494f6c9ad40503de(
    *,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
    key: typing.Mapping[builtins.str, DynamoAttributeValue],
    table: _ITable_24826f7e,
    condition_expression: typing.Optional[builtins.str] = None,
    expression_attribute_names: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    expression_attribute_values: typing.Optional[typing.Mapping[builtins.str, DynamoAttributeValue]] = None,
    return_consumed_capacity: typing.Optional[DynamoConsumedCapacity] = None,
    return_item_collection_metrics: typing.Optional[DynamoItemCollectionMetrics] = None,
    return_values: typing.Optional[DynamoReturnValues] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8276391e436f94a7403556ee7362ed2a4d229575b73a338cd658934e4f63599b(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    key: typing.Mapping[builtins.str, DynamoAttributeValue],
    table: _ITable_24826f7e,
    consistent_read: typing.Optional[builtins.bool] = None,
    expression_attribute_names: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    projection_expression: typing.Optional[typing.Sequence[DynamoProjectionExpression]] = None,
    return_consumed_capacity: typing.Optional[DynamoConsumedCapacity] = None,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__42389f04aefc537dd7a6bf215d2903332790dd058b3000d43e045c6fcf414da1(
    *,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
    key: typing.Mapping[builtins.str, DynamoAttributeValue],
    table: _ITable_24826f7e,
    consistent_read: typing.Optional[builtins.bool] = None,
    expression_attribute_names: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    projection_expression: typing.Optional[typing.Sequence[DynamoProjectionExpression]] = None,
    return_consumed_capacity: typing.Optional[DynamoConsumedCapacity] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cb3d5ec055b9dcf5ecc75675f8c6ca06bcedcdf15772560c13df804dd6eeaa5d(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a020ab37fae0793b590a90b329b49b0b5313d4a04aeb8a574fdc2b5d258e278a(
    attr: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__db7aea571d3fd842f791f23987396695de8e613650f2ed6c94269e6dd286215f(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    item: typing.Mapping[builtins.str, DynamoAttributeValue],
    table: _ITable_24826f7e,
    condition_expression: typing.Optional[builtins.str] = None,
    expression_attribute_names: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    expression_attribute_values: typing.Optional[typing.Mapping[builtins.str, DynamoAttributeValue]] = None,
    return_consumed_capacity: typing.Optional[DynamoConsumedCapacity] = None,
    return_item_collection_metrics: typing.Optional[DynamoItemCollectionMetrics] = None,
    return_values: typing.Optional[DynamoReturnValues] = None,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5a9776444beb6effaf99c18f81bc32dabbe7912532feae2ef7cf8ae71dcd055b(
    *,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
    item: typing.Mapping[builtins.str, DynamoAttributeValue],
    table: _ITable_24826f7e,
    condition_expression: typing.Optional[builtins.str] = None,
    expression_attribute_names: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    expression_attribute_values: typing.Optional[typing.Mapping[builtins.str, DynamoAttributeValue]] = None,
    return_consumed_capacity: typing.Optional[DynamoConsumedCapacity] = None,
    return_item_collection_metrics: typing.Optional[DynamoItemCollectionMetrics] = None,
    return_values: typing.Optional[DynamoReturnValues] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bda2681bd9811640c8e6b7ee098f9e11b3396b79f4fbc85f0b812abd0f9a90f3(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    key: typing.Mapping[builtins.str, DynamoAttributeValue],
    table: _ITable_24826f7e,
    condition_expression: typing.Optional[builtins.str] = None,
    expression_attribute_names: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    expression_attribute_values: typing.Optional[typing.Mapping[builtins.str, DynamoAttributeValue]] = None,
    return_consumed_capacity: typing.Optional[DynamoConsumedCapacity] = None,
    return_item_collection_metrics: typing.Optional[DynamoItemCollectionMetrics] = None,
    return_values: typing.Optional[DynamoReturnValues] = None,
    update_expression: typing.Optional[builtins.str] = None,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__39adb8dd023e34c3306c4560b60cb064fe46453e0f50ccdd57bcc5effc3cdeee(
    *,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
    key: typing.Mapping[builtins.str, DynamoAttributeValue],
    table: _ITable_24826f7e,
    condition_expression: typing.Optional[builtins.str] = None,
    expression_attribute_names: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    expression_attribute_values: typing.Optional[typing.Mapping[builtins.str, DynamoAttributeValue]] = None,
    return_consumed_capacity: typing.Optional[DynamoConsumedCapacity] = None,
    return_item_collection_metrics: typing.Optional[DynamoItemCollectionMetrics] = None,
    return_values: typing.Optional[DynamoReturnValues] = None,
    update_expression: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e324f53d03df7d8acc34db14dbd33526e646a679b3998b58a9e0894894409622(
    *,
    placement_constraints: typing.Optional[typing.Sequence[_PlacementConstraint_e22ac48c]] = None,
    placement_strategies: typing.Optional[typing.Sequence[_PlacementStrategy_ea27367e]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6c5c23e107327d82dac97cbcae0ef541969abf912847a5428a3ae4ab4fd4ca84(
    *,
    platform_version: _FargatePlatformVersion_8169c79a,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ef5a4b62cc441b94242ae1ad1b7ec623baac4b0101f3ccf77409f903aeff2e4b(
    *,
    parameters: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e87e83174e33e1c6a526fa133f7ed43cae78024979076c92e599a33429e55328(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    cluster: _ICluster_42c4ec1a,
    launch_target: IEcsLaunchTarget,
    task_definition: _TaskDefinition_c0dacfb4,
    assign_public_ip: typing.Optional[builtins.bool] = None,
    container_overrides: typing.Optional[typing.Sequence[typing.Union[ContainerOverride, typing.Dict[builtins.str, typing.Any]]]] = None,
    security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
    subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__21ba7eaca3d6186e68c5587fb07fe61f1c30392456a11143676fdfc4f0adcca1(
    task: _Task_747ca4f2,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e5f14dd1a2e95d8fcaf8e2be6d8ee0c5b9ea268b264868901b9f11abc540bcbe(
    vpc: _IVpc_6d1f76c4,
    assign_public_ip: typing.Optional[builtins.bool] = None,
    subnet_selection: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    security_group: typing.Optional[_ISecurityGroup_cdbba9d3] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__15b45e87400dff8f9e18d7ec69f4372f8700035c9caa27c520ac54d0dbbd0c6a(
    *,
    cluster: _ICluster_42c4ec1a,
    task_definition: _TaskDefinition_c0dacfb4,
    container_overrides: typing.Optional[typing.Sequence[typing.Union[ContainerOverride, typing.Dict[builtins.str, typing.Any]]]] = None,
    integration_pattern: typing.Optional[_ServiceIntegrationPattern_5581ee88] = None,
    parameters: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__78ae706f3b0cf3baf3b98884089849b7db43f47a158cf29c575c4a10a485e52e(
    *,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
    cluster: _ICluster_42c4ec1a,
    launch_target: IEcsLaunchTarget,
    task_definition: _TaskDefinition_c0dacfb4,
    assign_public_ip: typing.Optional[builtins.bool] = None,
    container_overrides: typing.Optional[typing.Sequence[typing.Union[ContainerOverride, typing.Dict[builtins.str, typing.Any]]]] = None,
    security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
    subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e952c65435db52e3e70a5ff0952708975260083434274179be34128c9267f2ef(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    cluster: _ICluster_e7e676cf,
    http_method: HttpMethods,
    http_path: builtins.str,
    query_parameters: typing.Optional[typing.Mapping[builtins.str, typing.Sequence[builtins.str]]] = None,
    request_body: typing.Optional[_TaskInput_71ab46f6] = None,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3cfe7a2596f78fdcb3164eeff3590eaad18da457b9f277a880c8bff1eda34f21(
    *,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
    cluster: _ICluster_e7e676cf,
    http_method: HttpMethods,
    http_path: builtins.str,
    query_parameters: typing.Optional[typing.Mapping[builtins.str, typing.Sequence[builtins.str]]] = None,
    request_body: typing.Optional[_TaskInput_71ab46f6] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9b762513b331e394a955c4b80a0b39d8ce380d2c8a002e56224afef1c30f5b4e(
    cluster: _ICluster_e7e676cf,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__57beafa94208c3483ddb350ef86642f4e7f2a01a800a3c1225936c3f866d9858(
    task_input: _TaskInput_71ab46f6,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f927b1d063aa72dc51ccf6339fd43cb6313f25265881eed13f3cc2cc14791e49(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    cluster_id: builtins.str,
    jar: builtins.str,
    name: builtins.str,
    action_on_failure: typing.Optional[ActionOnFailure] = None,
    args: typing.Optional[typing.Sequence[builtins.str]] = None,
    main_class: typing.Optional[builtins.str] = None,
    properties: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3c5db24e8ea456e8a91d9f0b2b1fa6e548b76aa7ad57e3b3f8974a1b9e62c7da(
    *,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
    cluster_id: builtins.str,
    jar: builtins.str,
    name: builtins.str,
    action_on_failure: typing.Optional[ActionOnFailure] = None,
    args: typing.Optional[typing.Sequence[builtins.str]] = None,
    main_class: typing.Optional[builtins.str] = None,
    properties: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__785f802bfae1a766e505bc131de09693420af308a74dcf9d89112d2c5cfe3128(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    cluster_id: builtins.str,
    step_id: builtins.str,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eb31d268cb374fca02551f55095d596ae04a6b153f8b53763c03078f3a91d38d(
    *,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
    cluster_id: builtins.str,
    step_id: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__50ac8afd98d0b18f69b953dfe878c155573b69c5b7f6ed8649c50fb7033283e1(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    eks_cluster: EksClusterInput,
    eks_namespace: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    virtual_cluster_name: typing.Optional[builtins.str] = None,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__abf1ab32a8d29073fe21e35bccf34024dd0830802b68510fbfd98d480ae41c17(
    *,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
    eks_cluster: EksClusterInput,
    eks_namespace: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    virtual_cluster_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4c2be350ed024a4864230b8c3e097e05964c922f44f55946856112b9853e1534(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    virtual_cluster_id: _TaskInput_71ab46f6,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a2b98be7e6895a4c94529af2df5ad7dbd7875558b5c29ad782553277a67c4190(
    *,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
    virtual_cluster_id: _TaskInput_71ab46f6,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6d0e21e7654207f458a68f87a628a631eb0bb59f2167aa14a1939914622d172c(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    job_driver: typing.Union[JobDriver, typing.Dict[builtins.str, typing.Any]],
    release_label: ReleaseLabel,
    virtual_cluster: VirtualClusterInput,
    application_config: typing.Optional[typing.Sequence[typing.Union[ApplicationConfiguration, typing.Dict[builtins.str, typing.Any]]]] = None,
    execution_role: typing.Optional[_IRole_59af6f50] = None,
    job_name: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[Monitoring, typing.Dict[builtins.str, typing.Any]]] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d350350fad378b3b805a1287f452171d3029dc873cc06799d8a400ceb523e700(
    *,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
    job_driver: typing.Union[JobDriver, typing.Dict[builtins.str, typing.Any]],
    release_label: ReleaseLabel,
    virtual_cluster: VirtualClusterInput,
    application_config: typing.Optional[typing.Sequence[typing.Union[ApplicationConfiguration, typing.Dict[builtins.str, typing.Any]]]] = None,
    execution_role: typing.Optional[_IRole_59af6f50] = None,
    job_name: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[Monitoring, typing.Dict[builtins.str, typing.Any]]] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d311b70081c11860696da2d7a5ed040392beffc7948a514b206959d42bf767c4(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    instances: typing.Union[EmrCreateCluster.InstancesConfigProperty, typing.Dict[builtins.str, typing.Any]],
    name: builtins.str,
    additional_info: typing.Optional[builtins.str] = None,
    applications: typing.Optional[typing.Sequence[typing.Union[EmrCreateCluster.ApplicationConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    auto_scaling_role: typing.Optional[_IRole_59af6f50] = None,
    bootstrap_actions: typing.Optional[typing.Sequence[typing.Union[EmrCreateCluster.BootstrapActionConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    cluster_role: typing.Optional[_IRole_59af6f50] = None,
    configurations: typing.Optional[typing.Sequence[typing.Union[EmrCreateCluster.ConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    custom_ami_id: typing.Optional[builtins.str] = None,
    ebs_root_volume_size: typing.Optional[_Size_7fbd4337] = None,
    kerberos_attributes: typing.Optional[typing.Union[EmrCreateCluster.KerberosAttributesProperty, typing.Dict[builtins.str, typing.Any]]] = None,
    log_uri: typing.Optional[builtins.str] = None,
    release_label: typing.Optional[builtins.str] = None,
    scale_down_behavior: typing.Optional[EmrCreateCluster.EmrClusterScaleDownBehavior] = None,
    security_configuration: typing.Optional[builtins.str] = None,
    service_role: typing.Optional[_IRole_59af6f50] = None,
    step_concurrency_level: typing.Optional[jsii.Number] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    visible_to_all_users: typing.Optional[builtins.bool] = None,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__36613d8534c1f85ffdd6947683c01f52b90bc8775624ea62fb5fe8a6add10187(
    *,
    name: builtins.str,
    additional_info: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    args: typing.Optional[typing.Sequence[builtins.str]] = None,
    version: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b6bca5ece65cceca581f95ccb67bac90474b6641b9243c189d1a2bdf40c17e17(
    *,
    constraints: typing.Union[EmrCreateCluster.ScalingConstraintsProperty, typing.Dict[builtins.str, typing.Any]],
    rules: typing.Sequence[typing.Union[EmrCreateCluster.ScalingRuleProperty, typing.Dict[builtins.str, typing.Any]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6f2af2e590a08520f7954e22f47c00ec46844f002d4d5c987ba5153b0e1d653d(
    *,
    name: builtins.str,
    script_bootstrap_action: typing.Union[EmrCreateCluster.ScriptBootstrapActionConfigProperty, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__43258c1172514a96087a56d6b3ae6235b82bd01f5607c944fb5c2ff713c7d087(
    *,
    comparison_operator: EmrCreateCluster.CloudWatchAlarmComparisonOperator,
    metric_name: builtins.str,
    period: _Duration_070aa057,
    dimensions: typing.Optional[typing.Sequence[typing.Union[EmrCreateCluster.MetricDimensionProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    namespace: typing.Optional[builtins.str] = None,
    statistic: typing.Optional[EmrCreateCluster.CloudWatchAlarmStatistic] = None,
    threshold: typing.Optional[jsii.Number] = None,
    unit: typing.Optional[EmrCreateCluster.CloudWatchAlarmUnit] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9ae2ee8097495fd12cd5833887efb282ad1c19fb9f4ae5262a5be0ebcc0f8d63(
    *,
    classification: typing.Optional[builtins.str] = None,
    configurations: typing.Optional[typing.Sequence[typing.Union[EmrCreateCluster.ConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    properties: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__99356cdcd3fbfdb8aec5e85f5d099153c7d84fae3a74f9e4af52992fabd5fb77(
    *,
    volume_specification: typing.Union[EmrCreateCluster.VolumeSpecificationProperty, typing.Dict[builtins.str, typing.Any]],
    volumes_per_instance: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a7ec60066da51c822fa8df948a576174accc8c6838f6d181f94c9891a42287f6(
    *,
    ebs_block_device_configs: typing.Optional[typing.Sequence[typing.Union[EmrCreateCluster.EbsBlockDeviceConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    ebs_optimized: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a61ba1d8f8b1c620b1bc6cdf9818e7a79d53671406d2d7d84b8e558297ab66a1(
    *,
    instance_fleet_type: EmrCreateCluster.InstanceRoleType,
    instance_type_configs: typing.Optional[typing.Sequence[typing.Union[EmrCreateCluster.InstanceTypeConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    launch_specifications: typing.Optional[typing.Union[EmrCreateCluster.InstanceFleetProvisioningSpecificationsProperty, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    target_on_demand_capacity: typing.Optional[jsii.Number] = None,
    target_spot_capacity: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__113d0cee43e6794ae00544c2880ba879f56bced02264ff7bf12998044b94a0ec(
    *,
    spot_specification: typing.Union[EmrCreateCluster.SpotProvisioningSpecificationProperty, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__af293198e70e6c58079357a9498bbcaba7d3a8f7b8d14dd81f77826de6be3d63(
    *,
    instance_count: jsii.Number,
    instance_role: EmrCreateCluster.InstanceRoleType,
    instance_type: builtins.str,
    auto_scaling_policy: typing.Optional[typing.Union[EmrCreateCluster.AutoScalingPolicyProperty, typing.Dict[builtins.str, typing.Any]]] = None,
    bid_price: typing.Optional[builtins.str] = None,
    configurations: typing.Optional[typing.Sequence[typing.Union[EmrCreateCluster.ConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    ebs_configuration: typing.Optional[typing.Union[EmrCreateCluster.EbsConfigurationProperty, typing.Dict[builtins.str, typing.Any]]] = None,
    market: typing.Optional[EmrCreateCluster.InstanceMarket] = None,
    name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__135d6ae68c0159bd67fba8f902f6d26035d64e3cc0c44122cb36fab58a2cda81(
    *,
    instance_type: builtins.str,
    bid_price: typing.Optional[builtins.str] = None,
    bid_price_as_percentage_of_on_demand_price: typing.Optional[jsii.Number] = None,
    configurations: typing.Optional[typing.Sequence[typing.Union[EmrCreateCluster.ConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    ebs_configuration: typing.Optional[typing.Union[EmrCreateCluster.EbsConfigurationProperty, typing.Dict[builtins.str, typing.Any]]] = None,
    weighted_capacity: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9a82907ccd17b55a3b869119d4e86b9e5ea5c4970a526a743393ced97298f0f3(
    *,
    additional_master_security_groups: typing.Optional[typing.Sequence[builtins.str]] = None,
    additional_slave_security_groups: typing.Optional[typing.Sequence[builtins.str]] = None,
    ec2_key_name: typing.Optional[builtins.str] = None,
    ec2_subnet_id: typing.Optional[builtins.str] = None,
    ec2_subnet_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
    emr_managed_master_security_group: typing.Optional[builtins.str] = None,
    emr_managed_slave_security_group: typing.Optional[builtins.str] = None,
    hadoop_version: typing.Optional[builtins.str] = None,
    instance_count: typing.Optional[jsii.Number] = None,
    instance_fleets: typing.Optional[typing.Sequence[typing.Union[EmrCreateCluster.InstanceFleetConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    instance_groups: typing.Optional[typing.Sequence[typing.Union[EmrCreateCluster.InstanceGroupConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    master_instance_type: typing.Optional[builtins.str] = None,
    placement: typing.Optional[typing.Union[EmrCreateCluster.PlacementTypeProperty, typing.Dict[builtins.str, typing.Any]]] = None,
    service_access_security_group: typing.Optional[builtins.str] = None,
    slave_instance_type: typing.Optional[builtins.str] = None,
    termination_protected: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bc6ff17025091bfeddd48f2f7ef87320f733e72d4a73f14ad0613304e65b27d5(
    *,
    realm: builtins.str,
    ad_domain_join_password: typing.Optional[builtins.str] = None,
    ad_domain_join_user: typing.Optional[builtins.str] = None,
    cross_realm_trust_principal_password: typing.Optional[builtins.str] = None,
    kdc_admin_password: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6080a83b61b630725049800cd02d9e902ca564fb1b6400fbf509a6c211013c95(
    *,
    key: builtins.str,
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8ad08ccbf1f276ef9cd54bc146df7ccaa98c01ff4be42cca061a4b039e9d534f(
    *,
    availability_zone: typing.Optional[builtins.str] = None,
    availability_zones: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c337be68f6aecc86b2dff837a3c3d1fd511c4374d27a6967723e2d3861a76874(
    *,
    simple_scaling_policy_configuration: typing.Union[EmrCreateCluster.SimpleScalingPolicyConfigurationProperty, typing.Dict[builtins.str, typing.Any]],
    market: typing.Optional[EmrCreateCluster.InstanceMarket] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1e1d78376ffd5e8000bf9fa260fed7bbb40930219e861e6718c250534eb5ed90(
    *,
    max_capacity: jsii.Number,
    min_capacity: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__982fff6ea3bf67f59f3007e313e188189d3b19720ca3573cf92e43d53d467ada(
    *,
    action: typing.Union[EmrCreateCluster.ScalingActionProperty, typing.Dict[builtins.str, typing.Any]],
    name: builtins.str,
    trigger: typing.Union[EmrCreateCluster.ScalingTriggerProperty, typing.Dict[builtins.str, typing.Any]],
    description: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__325dd5c947d53a3ecdedf472dee7fcfada4f94b3f52b81cee5c69b352b3d7522(
    *,
    cloud_watch_alarm_definition: typing.Union[EmrCreateCluster.CloudWatchAlarmDefinitionProperty, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__765be7c8263df974c985de7cd6e835131253c4d2e4f96f372805fbf93f11668e(
    *,
    path: builtins.str,
    args: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b75fbe84747859a1da505a0de377d8ee5510bbee584646d687b623a758a4e2bf(
    *,
    scaling_adjustment: jsii.Number,
    adjustment_type: typing.Optional[EmrCreateCluster.ScalingAdjustmentType] = None,
    cool_down: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ddf4a9a2adda278dd6bbf6685d23a9596c5a5c4f79fa572c5d379f1ed7d2e2e6(
    *,
    timeout_action: EmrCreateCluster.SpotTimeoutAction,
    timeout_duration_minutes: jsii.Number,
    allocation_strategy: typing.Optional[EmrCreateCluster.SpotAllocationStrategy] = None,
    block_duration_minutes: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__882ee971e514dfab22a0e25f7b48fd0da754428efa677e83e77ee09f6058a9b8(
    *,
    volume_size: _Size_7fbd4337,
    volume_type: EmrCreateCluster.EbsBlockDeviceVolumeType,
    iops: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__47d2a570fa281111b9865f9f17b142e67e413dbd739cbde770ed607bef4e053f(
    *,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
    instances: typing.Union[EmrCreateCluster.InstancesConfigProperty, typing.Dict[builtins.str, typing.Any]],
    name: builtins.str,
    additional_info: typing.Optional[builtins.str] = None,
    applications: typing.Optional[typing.Sequence[typing.Union[EmrCreateCluster.ApplicationConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    auto_scaling_role: typing.Optional[_IRole_59af6f50] = None,
    bootstrap_actions: typing.Optional[typing.Sequence[typing.Union[EmrCreateCluster.BootstrapActionConfigProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    cluster_role: typing.Optional[_IRole_59af6f50] = None,
    configurations: typing.Optional[typing.Sequence[typing.Union[EmrCreateCluster.ConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    custom_ami_id: typing.Optional[builtins.str] = None,
    ebs_root_volume_size: typing.Optional[_Size_7fbd4337] = None,
    kerberos_attributes: typing.Optional[typing.Union[EmrCreateCluster.KerberosAttributesProperty, typing.Dict[builtins.str, typing.Any]]] = None,
    log_uri: typing.Optional[builtins.str] = None,
    release_label: typing.Optional[builtins.str] = None,
    scale_down_behavior: typing.Optional[EmrCreateCluster.EmrClusterScaleDownBehavior] = None,
    security_configuration: typing.Optional[builtins.str] = None,
    service_role: typing.Optional[_IRole_59af6f50] = None,
    step_concurrency_level: typing.Optional[jsii.Number] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    visible_to_all_users: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7c19490a585b5bd6c60eaa3531c62dc463fbf43407480a70f5a523a1652ed523(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    cluster_id: builtins.str,
    instance_fleet_name: builtins.str,
    target_on_demand_capacity: jsii.Number,
    target_spot_capacity: jsii.Number,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4aa4d71be75f4ce06916577b5289c209591a1254666ba08edaeb593b04f97ef6(
    *,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
    cluster_id: builtins.str,
    instance_fleet_name: builtins.str,
    target_on_demand_capacity: jsii.Number,
    target_spot_capacity: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d4fa925d38c3a36e7cad8cc214aa3bac12a0116b0f43a5c9325049aa25412acf(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    cluster_id: builtins.str,
    instance_group: typing.Union[EmrModifyInstanceGroupByName.InstanceGroupModifyConfigProperty, typing.Dict[builtins.str, typing.Any]],
    instance_group_name: builtins.str,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__00aac5b2e54eccc7c1203ab57db517bb4650f378508b680c827966ea755027c2(
    *,
    configurations: typing.Optional[typing.Sequence[typing.Union[EmrCreateCluster.ConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    e_c2_instance_ids_to_terminate: typing.Optional[typing.Sequence[builtins.str]] = None,
    instance_count: typing.Optional[jsii.Number] = None,
    shrink_policy: typing.Optional[typing.Union[EmrModifyInstanceGroupByName.ShrinkPolicyProperty, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__528a6388a1fb63dcb58017ebf85c190eef9b1860e9efd59a6994028a620bcdd9(
    *,
    instances_to_protect: typing.Optional[typing.Sequence[builtins.str]] = None,
    instances_to_terminate: typing.Optional[typing.Sequence[builtins.str]] = None,
    instance_termination_timeout: typing.Optional[_Duration_070aa057] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__47047e7e0c8fbb6046fbd53ef5e2767c497fc959a4fd9f467fe6a2847bd3bd8a(
    *,
    decommission_timeout: typing.Optional[_Duration_070aa057] = None,
    instance_resize_policy: typing.Optional[typing.Union[EmrModifyInstanceGroupByName.InstanceResizePolicyProperty, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__405350534d121e0eae18960e9cfe1491e6404dcf72eb03f262da62acd14758c4(
    *,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
    cluster_id: builtins.str,
    instance_group: typing.Union[EmrModifyInstanceGroupByName.InstanceGroupModifyConfigProperty, typing.Dict[builtins.str, typing.Any]],
    instance_group_name: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__900464b8236509208ce14dca533abcc549a595d074c251d236d77b669b80d8ad(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    cluster_id: builtins.str,
    termination_protected: builtins.bool,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__100c18ed35eba6ea676971cdfefb76a3bb6dda0c436e5116064070e17dc7d8e7(
    *,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
    cluster_id: builtins.str,
    termination_protected: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3be0548636ce7b8bd9e5c2dc3b21144e6321c6614eb15befed54aec40a3fced5(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    cluster_id: builtins.str,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__365a067d98e75c911084d2d82d2d1e7aca007e823e80e9e0652c389f433e7492(
    *,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
    cluster_id: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4f88042f1cde743480b78a496056d71c52ff349a10a858db3ffabedfa508936c(
    *,
    encryption_option: EncryptionOption,
    encryption_key: typing.Optional[_IKey_36930160] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0e0f38b85436d20d4eb2d3de9b592d48384442852329444058c8aba26c5065c3(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    expression: builtins.str,
    runtime: typing.Optional[_Runtime_932d369a] = None,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1432e39948365e95528d48263d3cc007e597a9bf6ea213e75663e8bca1ead323(
    *,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
    expression: builtins.str,
    runtime: typing.Optional[_Runtime_932d369a] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__95e8b397d75d8eb0c06e9dd578f8f8eb0ce04a391b884ce7de4dfbe40bf0139d(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    entries: typing.Sequence[typing.Union[EventBridgePutEventsEntry, typing.Dict[builtins.str, typing.Any]]],
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6bfb2fcd60ebc7366cf36ab20393a70593e841c272d834c8a81476cd3ce8e103(
    *,
    detail: _TaskInput_71ab46f6,
    detail_type: builtins.str,
    source: builtins.str,
    event_bus: typing.Optional[_IEventBus_2ca38c95] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__69129595995787769e468fbfdea5494d101b4ee54e3c954504ad5dbb78eea1a6(
    *,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
    entries: typing.Sequence[typing.Union[EventBridgePutEventsEntry, typing.Dict[builtins.str, typing.Any]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8a115da6edd50c0d9d6c9a1bd6c6faf814e955de4fa3db108773866d781b0f7f(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    name: builtins.str,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dc107df28802e5844a992ad0f860e9f7385386c0ef765aee96bb7c06b60d9efd(
    *,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
    name: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c27f7438792488798490ece09425a1eec1038a71d90df7d92314ff9e1062d525(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    glue_job_name: builtins.str,
    arguments: typing.Optional[_TaskInput_71ab46f6] = None,
    notify_delay_after: typing.Optional[_Duration_070aa057] = None,
    security_configuration: typing.Optional[builtins.str] = None,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1d070e025ef86245d2bab0e382e188b228c5ea242241faedb3fd8b0a2aba3dd6(
    *,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
    glue_job_name: builtins.str,
    arguments: typing.Optional[_TaskInput_71ab46f6] = None,
    notify_delay_after: typing.Optional[_Duration_070aa057] = None,
    security_configuration: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__69adf3a722b2a8ec0dea54b76fa143d8d024f0fe5239f8044532df991e91f9ba(
    task: ISageMakerTask,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__11f001e0bddae5d5c1e66870283f786d1e5170b415910310c0501875ad64d87a(
    task: EcsRunTask,
    *,
    task_definition: _ITaskDefinition_ee0d1862,
    cluster: typing.Optional[_ICluster_42c4ec1a] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__af53cd8c5c34c216808cdd97d2f1de9c92704a7d5613f0f5587b6fa63410a4a4(
    activity: _IActivity_4524952f,
    *,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1d9faf3eee50026bf2616f77ba1832aef1e7e5031f1a041cf5c3c4d40fa80740(
    _task: _Task_747ca4f2,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9e36fa17794305764f9d0b5aae88008ac8e9cdcc20902bd4e5b1fe4e00865ed6(
    *,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__05648f1c06eee80dc9730e0fac2030a0177c18c649abba6711349fd6aabaff91(
    lambda_function: _IFunction_6e14f09e,
    *,
    payload: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b6309970979b53bba42a0bd3164727193d778901e0629d8dfa8d226a6cc50371(
    _task: _Task_747ca4f2,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1434d05684e9f5ba95c534058cecba56f1bf1b0cdc597969db4a29dea1542f5b(
    *,
    payload: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__afcf8bb3736a14739da99cc56dad750c52607c57e8bf79ade4520e4393259be5(
    *,
    job_id: typing.Optional[builtins.str] = None,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__27b63bf75f018407d586bbf4a22d2d81f55bd8baca7ee05c13d12db86440d333(
    *,
    spark_submit_job_driver: typing.Union[SparkSubmitJobDriver, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e46d794f3aa056d13dc307e1d2c9cd9cbf2ca41a1e42fb826b46cd9f31d8ac85(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    lambda_function: _IFunction_6e14f09e,
    client_context: typing.Optional[builtins.str] = None,
    invocation_type: typing.Optional[LambdaInvocationType] = None,
    payload: typing.Optional[_TaskInput_71ab46f6] = None,
    payload_response_only: typing.Optional[builtins.bool] = None,
    qualifier: typing.Optional[builtins.str] = None,
    retry_on_service_exceptions: typing.Optional[builtins.bool] = None,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dd2bdfb3e4319c9c6bacf133aaa8034c4393055c5108cc5c21c8344590f94238(
    *,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
    lambda_function: _IFunction_6e14f09e,
    client_context: typing.Optional[builtins.str] = None,
    invocation_type: typing.Optional[LambdaInvocationType] = None,
    payload: typing.Optional[_TaskInput_71ab46f6] = None,
    payload_response_only: typing.Optional[builtins.bool] = None,
    qualifier: typing.Optional[builtins.str] = None,
    retry_on_service_exceptions: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__660c84d4bc50145e150d416b117c8fbcd77fc5f42c348d92f236700c2742356c(
    *,
    task_definition: _ITaskDefinition_ee0d1862,
    cluster: typing.Optional[_ICluster_42c4ec1a] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fb5fc4b80d4033a1fa69f1e9d0a1cd8230ce2f5c6a70d43a751a671cb7401df2(
    *,
    value: typing.Any,
    data_type: typing.Optional[MessageAttributeDataType] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c58e2cf8cf19ebcd227d250131280ae233f594b977bec71973cfc6c15adb21db(
    *,
    name: builtins.str,
    regex: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b8ce32a56d555f0339f7f894455b01e67956e8f73b2a5ac506094938b516cce2(
    *,
    invocations_max_retries: typing.Optional[jsii.Number] = None,
    invocations_timeout: typing.Optional[_Duration_070aa057] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9ad4a7297283a4b1be860a18eb37087129871f99f9710c01d141cf6d55813512(
    *,
    log_bucket: typing.Optional[_IBucket_73486e29] = None,
    logging: typing.Optional[builtins.bool] = None,
    log_group: typing.Optional[_ILogGroup_846e17a0] = None,
    log_stream_name_prefix: typing.Optional[builtins.str] = None,
    persistent_app_ui: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__32bb8b4ecebc36c2c73f97899442cbac4197d571bffc9fcc4346e5ab5a5e456e(
    *,
    s3_output_location: S3Location,
    encryption_key: typing.Optional[_IKey_36930160] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__459d279ec601800dd458d9d18f56450aa57f340add9a31d1bd1ce1dcc7b02dbd(
    *,
    instance_type: _InstanceType_072ad323,
    model_name: builtins.str,
    variant_name: builtins.str,
    accelerator_type: typing.Optional[AcceleratorType] = None,
    initial_instance_count: typing.Optional[jsii.Number] = None,
    initial_variant_weight: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c77e58c3914b6c4d0cccd4c0f15d9635ea0705d6302f47a08175ede1a3127f73(
    topic: _ITopic_465e36b9,
    *,
    message: _TaskInput_71ab46f6,
    integration_pattern: typing.Optional[_ServiceIntegrationPattern_5581ee88] = None,
    message_per_subscription_type: typing.Optional[builtins.bool] = None,
    subject: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d100c57e2b0f752ce95681cd9e49cef1b7f567fc07c551afc443707a093017b0(
    _task: _Task_747ca4f2,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__70e446b283ed6e3b795973a7390855a9f3b9fb8dd793202c4f533dc30fa79307(
    *,
    message: _TaskInput_71ab46f6,
    integration_pattern: typing.Optional[_ServiceIntegrationPattern_5581ee88] = None,
    message_per_subscription_type: typing.Optional[builtins.bool] = None,
    subject: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__40d64ca2965efc07501511a428f28857516218094643d7cc666feed4a47d40a3(
    *,
    catalog_name: typing.Optional[builtins.str] = None,
    database_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a8197c6db819509ee812fce66deebad24d4e22d38fea7dd0bbb75487ed223655(
    label: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__82bb698d067b928ab3ab3e89800378becea2a935ed1e347d89de3aa236c0347c(
    *,
    instance_count: jsii.Number,
    instance_type: _InstanceType_072ad323,
    volume_size: _Size_7fbd4337,
    volume_encryption_key: typing.Optional[_IKey_36930160] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4149f8265f56b01076a4d970dc3f39d4a55eb446b412125c04156293db3973b4(
    *,
    encryption_configuration: typing.Optional[typing.Union[EncryptionConfiguration, typing.Dict[builtins.str, typing.Any]]] = None,
    output_location: typing.Optional[typing.Union[_Location_cce991ca, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c6534a67ebe93b86db70af97a0692f0e8f7c46d721f35f1cb482bb74ca816e00(
    _task: _Task_747ca4f2,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d38ff894e8824ca4ef04f58e6c966c35132b2887271354f78e324843aa5103dd(
    *,
    job_definition_arn: builtins.str,
    job_name: builtins.str,
    job_queue_arn: builtins.str,
    array_size: typing.Optional[jsii.Number] = None,
    attempts: typing.Optional[jsii.Number] = None,
    container_overrides: typing.Optional[typing.Union[ContainerOverrides, typing.Dict[builtins.str, typing.Any]]] = None,
    depends_on: typing.Optional[typing.Sequence[typing.Union[JobDependency, typing.Dict[builtins.str, typing.Any]]]] = None,
    integration_pattern: typing.Optional[_ServiceIntegrationPattern_5581ee88] = None,
    payload: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0b568f34f73738ac417a12b802bec8aec20b84dd2ddcc7e6663b452146a75e98(
    *,
    cluster: _ICluster_42c4ec1a,
    task_definition: _TaskDefinition_c0dacfb4,
    container_overrides: typing.Optional[typing.Sequence[typing.Union[ContainerOverride, typing.Dict[builtins.str, typing.Any]]]] = None,
    integration_pattern: typing.Optional[_ServiceIntegrationPattern_5581ee88] = None,
    placement_constraints: typing.Optional[typing.Sequence[_PlacementConstraint_e22ac48c]] = None,
    placement_strategies: typing.Optional[typing.Sequence[_PlacementStrategy_ea27367e]] = None,
    security_group: typing.Optional[_ISecurityGroup_cdbba9d3] = None,
    subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7b16a5f43d385023abec55cbc7f1f66d3e020c5435a4afaf3bc5fd37c45a8f83(
    *,
    cluster: _ICluster_42c4ec1a,
    task_definition: _TaskDefinition_c0dacfb4,
    container_overrides: typing.Optional[typing.Sequence[typing.Union[ContainerOverride, typing.Dict[builtins.str, typing.Any]]]] = None,
    integration_pattern: typing.Optional[_ServiceIntegrationPattern_5581ee88] = None,
    assign_public_ip: typing.Optional[builtins.bool] = None,
    platform_version: typing.Optional[_FargatePlatformVersion_8169c79a] = None,
    security_group: typing.Optional[_ISecurityGroup_cdbba9d3] = None,
    subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e8e6f5242e4f16c941035137359f0f6fab04fefcf3225bbd02e860756fcb0d9f(
    glue_job_name: builtins.str,
    *,
    arguments: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    integration_pattern: typing.Optional[_ServiceIntegrationPattern_5581ee88] = None,
    notify_delay_after: typing.Optional[_Duration_070aa057] = None,
    security_configuration: typing.Optional[builtins.str] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8b3551f539108156f671a9fdd738f340d4a8936ecad3030d0013c9f960b5a225(
    task: _Task_747ca4f2,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2105da9efc1f22328b2650bb62c6d6786fe2a7db444bfa1b566f651f9921d832(
    *,
    arguments: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    integration_pattern: typing.Optional[_ServiceIntegrationPattern_5581ee88] = None,
    notify_delay_after: typing.Optional[_Duration_070aa057] = None,
    security_configuration: typing.Optional[builtins.str] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ebf5cb3aeff1e164f7453b43973fb03a7fec5275931e365d53826c5029a9c581(
    lambda_function: _IFunction_6e14f09e,
    *,
    client_context: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_ServiceIntegrationPattern_5581ee88] = None,
    invocation_type: typing.Optional[InvocationType] = None,
    payload: typing.Optional[_TaskInput_71ab46f6] = None,
    qualifier: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0ca93d208385999857b4f942a385847fdc406f343dec2e274b58d8468b1f9d60(
    _task: _Task_747ca4f2,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e13246c709d5e2b8ab3461fb2b2ad058f7d98e211e139b667977836fd4bae24d(
    *,
    client_context: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_ServiceIntegrationPattern_5581ee88] = None,
    invocation_type: typing.Optional[InvocationType] = None,
    payload: typing.Optional[_TaskInput_71ab46f6] = None,
    qualifier: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__03ef2946c81526f19908ae1eb6f610fe7f51620d76dd9964674953dcfb82883e(
    *,
    s3_location: S3Location,
    attribute_names: typing.Optional[typing.Sequence[builtins.str]] = None,
    s3_data_distribution_type: typing.Optional[S3DataDistributionType] = None,
    s3_data_type: typing.Optional[S3DataType] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a469d9f0a3757b8af9cd95c3a3397cb81c023532a3bbd13870cbb18aaa6e7412(
    bucket: _IBucket_73486e29,
    key_prefix: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9d79f087a6940cb4167ddede4f4b9c83461ec3cdd6601e083c7eb87014503466(
    expression: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__17b44b096335460b2196db9c8cece7d21d948fbc748f5cebbeba5688ea2bd32a(
    task: ISageMakerTask,
    *,
    for_reading: typing.Optional[builtins.bool] = None,
    for_writing: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__334b3797922d19bf49232b3bf264561c97cb66ba8e8c5956a1b999f116b490fb(
    *,
    for_reading: typing.Optional[builtins.bool] = None,
    for_writing: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9f7073512b9c94121cbea80c7e1266273b6e458a9014d7b62c8b63d70d3bd1a5(
    *,
    uri: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9527ee3f0c10b3a79fa156d30060e783c6d22b73dbc57ae849d600a37e8fb60f(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    endpoint_config_name: builtins.str,
    endpoint_name: builtins.str,
    tags: typing.Optional[_TaskInput_71ab46f6] = None,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a8b5f7dccf4dcc7948fa7362fde487829b9e9850f6135b81eea2d18fbad5ecd0(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    endpoint_config_name: builtins.str,
    production_variants: typing.Sequence[typing.Union[ProductionVariant, typing.Dict[builtins.str, typing.Any]]],
    kms_key: typing.Optional[_IKey_36930160] = None,
    tags: typing.Optional[_TaskInput_71ab46f6] = None,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__aee63b2e353aaa63b3a062e1b10682e2a1127cd609d089e45a9b58fd6bad7b9b(
    *,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
    endpoint_config_name: builtins.str,
    production_variants: typing.Sequence[typing.Union[ProductionVariant, typing.Dict[builtins.str, typing.Any]]],
    kms_key: typing.Optional[_IKey_36930160] = None,
    tags: typing.Optional[_TaskInput_71ab46f6] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__21b89c2b588aa81ecea0df9ca076be778ab283f7337d7bc57d899aa761245b22(
    *,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
    endpoint_config_name: builtins.str,
    endpoint_name: builtins.str,
    tags: typing.Optional[_TaskInput_71ab46f6] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5d9b0a013e5d17d7f5cc66b30072671109196c35673b7ee5b91e20b3c2350d64(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    model_name: builtins.str,
    primary_container: IContainerDefinition,
    containers: typing.Optional[typing.Sequence[IContainerDefinition]] = None,
    enable_network_isolation: typing.Optional[builtins.bool] = None,
    role: typing.Optional[_IRole_59af6f50] = None,
    subnet_selection: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    tags: typing.Optional[_TaskInput_71ab46f6] = None,
    vpc: typing.Optional[_IVpc_6d1f76c4] = None,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b899e54b6c516b1d1bee86847cfd911d23505474423ac4adb906cf0a07934e81(
    security_group: _ISecurityGroup_cdbba9d3,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2584dc82090ec0181eb4013b44d129c17ae88927700ebe5d70703a069f1c10a0(
    *,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
    model_name: builtins.str,
    primary_container: IContainerDefinition,
    containers: typing.Optional[typing.Sequence[IContainerDefinition]] = None,
    enable_network_isolation: typing.Optional[builtins.bool] = None,
    role: typing.Optional[_IRole_59af6f50] = None,
    subnet_selection: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    tags: typing.Optional[_TaskInput_71ab46f6] = None,
    vpc: typing.Optional[_IVpc_6d1f76c4] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ee1ab3616f7627c3f9f0792c8b041ea0b1a7f6e4ec8df1987ee468959020f075(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    algorithm_specification: typing.Union[AlgorithmSpecification, typing.Dict[builtins.str, typing.Any]],
    input_data_config: typing.Sequence[typing.Union[Channel, typing.Dict[builtins.str, typing.Any]]],
    output_data_config: typing.Union[OutputDataConfig, typing.Dict[builtins.str, typing.Any]],
    training_job_name: builtins.str,
    enable_network_isolation: typing.Optional[builtins.bool] = None,
    environment: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    hyperparameters: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    resource_config: typing.Optional[typing.Union[ResourceConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    role: typing.Optional[_IRole_59af6f50] = None,
    stopping_condition: typing.Optional[typing.Union[StoppingCondition, typing.Dict[builtins.str, typing.Any]]] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    vpc_config: typing.Optional[typing.Union[VpcConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1cd32dc5e54d05c6b79dd9e817a74be0c51620ce4bb03edf2a1522fc5ea650ef(
    security_group: _ISecurityGroup_cdbba9d3,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2167905d754de5200c2b10dc18b658d3bdbb5648bc6408e17fdd47dbd47d8be5(
    *,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
    algorithm_specification: typing.Union[AlgorithmSpecification, typing.Dict[builtins.str, typing.Any]],
    input_data_config: typing.Sequence[typing.Union[Channel, typing.Dict[builtins.str, typing.Any]]],
    output_data_config: typing.Union[OutputDataConfig, typing.Dict[builtins.str, typing.Any]],
    training_job_name: builtins.str,
    enable_network_isolation: typing.Optional[builtins.bool] = None,
    environment: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    hyperparameters: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    resource_config: typing.Optional[typing.Union[ResourceConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    role: typing.Optional[_IRole_59af6f50] = None,
    stopping_condition: typing.Optional[typing.Union[StoppingCondition, typing.Dict[builtins.str, typing.Any]]] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    vpc_config: typing.Optional[typing.Union[VpcConfig, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ba93956e42ef14ad9d4492567511968e4f4c0c5a5982acf1d0705d70ab580ed5(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    model_name: builtins.str,
    transform_input: typing.Union[TransformInput, typing.Dict[builtins.str, typing.Any]],
    transform_job_name: builtins.str,
    transform_output: typing.Union[TransformOutput, typing.Dict[builtins.str, typing.Any]],
    batch_strategy: typing.Optional[BatchStrategy] = None,
    environment: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    max_concurrent_transforms: typing.Optional[jsii.Number] = None,
    max_payload: typing.Optional[_Size_7fbd4337] = None,
    model_client_options: typing.Optional[typing.Union[ModelClientOptions, typing.Dict[builtins.str, typing.Any]]] = None,
    role: typing.Optional[_IRole_59af6f50] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    transform_resources: typing.Optional[typing.Union[TransformResources, typing.Dict[builtins.str, typing.Any]]] = None,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f82d7968560796ad78d9e3ea10a2d883eaeee3e79f2e5497a4b2e4dbd4cd8106(
    *,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
    model_name: builtins.str,
    transform_input: typing.Union[TransformInput, typing.Dict[builtins.str, typing.Any]],
    transform_job_name: builtins.str,
    transform_output: typing.Union[TransformOutput, typing.Dict[builtins.str, typing.Any]],
    batch_strategy: typing.Optional[BatchStrategy] = None,
    environment: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    max_concurrent_transforms: typing.Optional[jsii.Number] = None,
    max_payload: typing.Optional[_Size_7fbd4337] = None,
    model_client_options: typing.Optional[typing.Union[ModelClientOptions, typing.Dict[builtins.str, typing.Any]]] = None,
    role: typing.Optional[_IRole_59af6f50] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    transform_resources: typing.Optional[typing.Union[TransformResources, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__be45d0e25f2e60446e7a5116b5b753073c283982d0f460a1d4df09229990b74c(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    endpoint_config_name: builtins.str,
    endpoint_name: builtins.str,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0117728830f92badd55bcd6d23e68eca54c501a851860f2f9d10c2b426fd78e4(
    *,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
    endpoint_config_name: builtins.str,
    endpoint_name: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f176727d478e887f3cdb3698a293aeb94d778d00ce558ca06c11708c7bcac122(
    queue: _IQueue_45a01ab4,
    *,
    message_body: _TaskInput_71ab46f6,
    delay: typing.Optional[_Duration_070aa057] = None,
    integration_pattern: typing.Optional[_ServiceIntegrationPattern_5581ee88] = None,
    message_deduplication_id: typing.Optional[builtins.str] = None,
    message_group_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d8f9db47ccda162277bc4e146cd60bf7214bb53000b55be4faede933d870f3e2(
    _task: _Task_747ca4f2,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ea96dfcf54705f638b87be06a6307af7bc07599e53cfec0d0c0117f0a8289630(
    *,
    message_body: _TaskInput_71ab46f6,
    delay: typing.Optional[_Duration_070aa057] = None,
    integration_pattern: typing.Optional[_ServiceIntegrationPattern_5581ee88] = None,
    message_deduplication_id: typing.Optional[builtins.str] = None,
    message_group_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8ca6f3efe96cc334c40473e2ac72bd8c6bbfb4169f6962c993edfb013cd7e85e(
    *,
    seed: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__91c387033c988e2e16400f75073469cac1a84dcb4ebd3ab022967c675b2a445b(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    message: _TaskInput_71ab46f6,
    topic: _ITopic_465e36b9,
    message_attributes: typing.Optional[typing.Mapping[builtins.str, typing.Union[MessageAttribute, typing.Dict[builtins.str, typing.Any]]]] = None,
    message_per_subscription_type: typing.Optional[builtins.bool] = None,
    subject: typing.Optional[builtins.str] = None,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8c1ae6c4746b9d25874c5c5dea7a0a4ecae2c04cb383e80d1bdf0b6a3849e5cb(
    *,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
    message: _TaskInput_71ab46f6,
    topic: _ITopic_465e36b9,
    message_attributes: typing.Optional[typing.Mapping[builtins.str, typing.Union[MessageAttribute, typing.Dict[builtins.str, typing.Any]]]] = None,
    message_per_subscription_type: typing.Optional[builtins.bool] = None,
    subject: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9b63048fc12785a3966ac4eba41c3b1cbc3a3cca168939dbaa89f92ba4477c6e(
    *,
    entry_point: _TaskInput_71ab46f6,
    entry_point_arguments: typing.Optional[_TaskInput_71ab46f6] = None,
    spark_submit_parameters: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__26f391dfc8e6d2fe57be6be1471c6a623a71bce120d0b2adaa6245617b798f1e(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    message_body: _TaskInput_71ab46f6,
    queue: _IQueue_45a01ab4,
    delay: typing.Optional[_Duration_070aa057] = None,
    message_deduplication_id: typing.Optional[builtins.str] = None,
    message_group_id: typing.Optional[builtins.str] = None,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4f3e5ffb1178b0d17f41df80f4868922f9c55ff9ca8a3b4571577a7b88e6770f(
    *,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
    message_body: _TaskInput_71ab46f6,
    queue: _IQueue_45a01ab4,
    delay: typing.Optional[_Duration_070aa057] = None,
    message_deduplication_id: typing.Optional[builtins.str] = None,
    message_group_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d2b17b6d0be920f09914377d3b781b84d8803c7de53545c1a503464b7da909e3(
    state_machine: _IStateMachine_269a89c4,
    *,
    input: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    integration_pattern: typing.Optional[_ServiceIntegrationPattern_5581ee88] = None,
    name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__633d634da0fab3146ef36b972d7e36a3918dd22ba5435279ec08b77774b197c8(
    task: _Task_747ca4f2,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d5941cffcc773ec36d8f99a83d411bc0c1db656a1795c658bdf6fefc00f56ea7(
    *,
    input: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    integration_pattern: typing.Optional[_ServiceIntegrationPattern_5581ee88] = None,
    name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__03a30edce5bdddaa2245be6c19834fc529b0c2ad409ed06182e5bf53298c967b(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    activity: _IActivity_4524952f,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2d9f01c8041b6832f726632defd6b2c36b5f85aa104f618f220b9fd3d14d6d76(
    *,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
    activity: _IActivity_4524952f,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__260ed092e69c03255ac8feeccada41ecc04aad819dad75ae1b18f7f8500d9fa5(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    state_machine: _IStateMachine_269a89c4,
    associate_with_parent: typing.Optional[builtins.bool] = None,
    input: typing.Optional[_TaskInput_71ab46f6] = None,
    name: typing.Optional[builtins.str] = None,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1e4c565f4cce756ce3a1ce52fbb8229a3a9687bc42eef8807167ae5684fae30c(
    *,
    comment: typing.Optional[builtins.str] = None,
    heartbeat: typing.Optional[_Duration_070aa057] = None,
    input_path: typing.Optional[builtins.str] = None,
    integration_pattern: typing.Optional[_IntegrationPattern_fbb35786] = None,
    output_path: typing.Optional[builtins.str] = None,
    result_path: typing.Optional[builtins.str] = None,
    result_selector: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeout: typing.Optional[_Duration_070aa057] = None,
    state_machine: _IStateMachine_269a89c4,
    associate_with_parent: typing.Optional[builtins.bool] = None,
    input: typing.Optional[_TaskInput_71ab46f6] = None,
    name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a3bf5e0d0c500a12f38dee1475592b2054b726b3ee116cd0d85aa9cfa20179c7(
    *,
    max_runtime: typing.Optional[_Duration_070aa057] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0bc6f819032bcc1b2dc7d3df176c129cbd10ea0a6cb6fe5537970e70ca050fa2(
    *,
    name: builtins.str,
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ca84dfe9887db1a5e05af498c51695bea5ae2772652530c500c61c8268c61560(
    *,
    s3_data_source: typing.Union[TransformS3DataSource, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2c79c860db038a74bebbc98791103900e1893cca5025c7051d439536b889ae02(
    *,
    transform_data_source: typing.Union[TransformDataSource, typing.Dict[builtins.str, typing.Any]],
    compression_type: typing.Optional[CompressionType] = None,
    content_type: typing.Optional[builtins.str] = None,
    split_type: typing.Optional[SplitType] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a5b1ce2497b26f995e5d78aa9e69e53fbfac58710d036debce4fdd7b01035679(
    *,
    s3_output_path: builtins.str,
    accept: typing.Optional[builtins.str] = None,
    assemble_with: typing.Optional[AssembleWith] = None,
    encryption_key: typing.Optional[_IKey_36930160] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f26957810a479378b02b0e03f1210a0254da7fff662a99fe5754d7c298d0a435(
    *,
    instance_count: jsii.Number,
    instance_type: _InstanceType_072ad323,
    volume_encryption_key: typing.Optional[_IKey_36930160] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a8fd7a3003b9dcfa59980d827a69de3f99d7846d7957cd312ee8fa51d2b08877(
    *,
    s3_uri: builtins.str,
    s3_data_type: typing.Optional[S3DataType] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5eef6af0b7d9fe8e53733afb666644523158e87e47cd14f0199e63326df27e9d(
    task_input: _TaskInput_71ab46f6,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e8e37f20d8bfa225652d8a8c7ac333f7dd80e7e3a831d9c691e376fe497c7628(
    virtual_cluster_id: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3eb08759bd4609d0139e7e9b2c0e80010331588cbe310f2b8b9b45b635482735(
    *,
    vpc: _IVpc_6d1f76c4,
    subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fbf452567c26247a93cef1cd325f4472c3a5cb4abca48655aaaa85a6db7dcf82(
    task: ISageMakerTask,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__960bc36be2f8e6b88028bc75eb8a02defdc265dec7366f10f1ad73266918ef0e(
    _task: EcsRunTask,
    *,
    task_definition: _ITaskDefinition_ee0d1862,
    cluster: typing.Optional[_ICluster_42c4ec1a] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7ac9c95b5b678681ac5d5bb2da25a1448399aa8d17a74a662c31191b350258cb(
    _task: EcsRunTask,
    *,
    task_definition: _ITaskDefinition_ee0d1862,
    cluster: typing.Optional[_ICluster_42c4ec1a] = None,
) -> None:
    """Type checking stubs"""
    pass

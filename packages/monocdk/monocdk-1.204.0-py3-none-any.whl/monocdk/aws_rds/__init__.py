'''
# Amazon Relational Database Service Construct Library

```python
import monocdk as rds
```

## Starting a clustered database

To set up a clustered database (like Aurora), define a `DatabaseCluster`. You must
always launch a database in a VPC. Use the `vpcSubnets` attribute to control whether
your instances will be launched privately or publicly:

```python
# vpc: ec2.Vpc

cluster = rds.DatabaseCluster(self, "Database",
    engine=rds.DatabaseClusterEngine.aurora_mysql(version=rds.AuroraMysqlEngineVersion.VER_2_08_1),
    credentials=rds.Credentials.from_generated_secret("clusteradmin"),  # Optional - will default to 'admin' username and generated password
    instance_props=ec2.aws_rds.InstanceProps(
        # optional , defaults to t3.medium
        instance_type=ec2.InstanceType.of(ec2.InstanceClass.BURSTABLE2, ec2.InstanceSize.SMALL),
        vpc_subnets=ec2.aws_ec2.SubnetSelection(
            subnet_type=ec2.SubnetType.PRIVATE_WITH_NAT
        ),
        vpc=vpc
    )
)
```

If there isn't a constant for the exact version you want to use,
all of the `Version` classes have a static `of` method that can be used to create an arbitrary version.

```python
custom_engine_version = rds.AuroraMysqlEngineVersion.of("5.7.mysql_aurora.2.08.1")
```

By default, the master password will be generated and stored in AWS Secrets Manager with auto-generated description.

Your cluster will be empty by default. To add a default database upon construction, specify the
`defaultDatabaseName` attribute.

Use `DatabaseClusterFromSnapshot` to create a cluster from a snapshot:

```python
# vpc: ec2.Vpc

rds.DatabaseClusterFromSnapshot(self, "Database",
    engine=rds.DatabaseClusterEngine.aurora(version=rds.AuroraEngineVersion.VER_1_22_2),
    instance_props=ec2.aws_rds.InstanceProps(
        vpc=vpc
    ),
    snapshot_identifier="mySnapshot"
)
```

## Starting an instance database

To set up a instance database, define a `DatabaseInstance`. You must
always launch a database in a VPC. Use the `vpcSubnets` attribute to control whether
your instances will be launched privately or publicly:

```python
# vpc: ec2.Vpc

instance = rds.DatabaseInstance(self, "Instance",
    engine=rds.DatabaseInstanceEngine.oracle_se2(version=rds.OracleEngineVersion.VER_19_0_0_0_2020_04_R1),
    # optional, defaults to m5.large
    instance_type=ec2.InstanceType.of(ec2.InstanceClass.BURSTABLE3, ec2.InstanceSize.SMALL),
    credentials=rds.Credentials.from_generated_secret("syscdk"),  # Optional - will default to 'admin' username and generated password
    vpc=vpc,
    vpc_subnets=ec2.aws_ec2.SubnetSelection(
        subnet_type=ec2.SubnetType.PRIVATE_WITH_NAT
    )
)
```

If there isn't a constant for the exact engine version you want to use,
all of the `Version` classes have a static `of` method that can be used to create an arbitrary version.

```python
custom_engine_version = rds.OracleEngineVersion.of("19.0.0.0.ru-2020-04.rur-2020-04.r1", "19")
```

By default, the master password will be generated and stored in AWS Secrets Manager.

To use the storage auto scaling option of RDS you can specify the maximum allocated storage.
This is the upper limit to which RDS can automatically scale the storage. More info can be found
[here](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PIOPS.StorageTypes.html#USER_PIOPS.Autoscaling)
Example for max storage configuration:

```python
# vpc: ec2.Vpc

instance = rds.DatabaseInstance(self, "Instance",
    engine=rds.DatabaseInstanceEngine.postgres(version=rds.PostgresEngineVersion.VER_12_3),
    # optional, defaults to m5.large
    instance_type=ec2.InstanceType.of(ec2.InstanceClass.BURSTABLE2, ec2.InstanceSize.SMALL),
    vpc=vpc,
    max_allocated_storage=200
)
```

Use `DatabaseInstanceFromSnapshot` and `DatabaseInstanceReadReplica` to create an instance from snapshot or
a source database respectively:

```python
# vpc: ec2.Vpc

# source_instance: rds.DatabaseInstance

rds.DatabaseInstanceFromSnapshot(self, "Instance",
    snapshot_identifier="my-snapshot",
    engine=rds.DatabaseInstanceEngine.postgres(version=rds.PostgresEngineVersion.VER_12_3),
    # optional, defaults to m5.large
    instance_type=ec2.InstanceType.of(ec2.InstanceClass.BURSTABLE2, ec2.InstanceSize.LARGE),
    vpc=vpc
)
rds.DatabaseInstanceReadReplica(self, "ReadReplica",
    source_database_instance=source_instance,
    instance_type=ec2.InstanceType.of(ec2.InstanceClass.BURSTABLE2, ec2.InstanceSize.LARGE),
    vpc=vpc
)
```

Automatic backups of read replica instances are only supported for MySQL and MariaDB. By default,
automatic backups are disabled for read replicas and can only be enabled (using `backupRetention`)
if also enabled on the source instance.

Creating a "production" Oracle database instance with option and parameter groups:

```python
# Set open cursors with parameter group
parameter_group = rds.ParameterGroup(self, "ParameterGroup",
    engine=rds.DatabaseInstanceEngine.oracle_se2(version=rds.OracleEngineVersion.VER_19_0_0_0_2020_04_R1),
    parameters={
        "open_cursors": "2500"
    }
)

option_group = rds.OptionGroup(self, "OptionGroup",
    engine=rds.DatabaseInstanceEngine.oracle_se2(version=rds.OracleEngineVersion.VER_19_0_0_0_2020_04_R1),
    configurations=[cdk.aws_rds.OptionConfiguration(
        name="LOCATOR"
    ), cdk.aws_rds.OptionConfiguration(
        name="OEM",
        port=1158,
        vpc=vpc
    )
    ]
)

# Allow connections to OEM
option_group.option_connections.OEM.connections.allow_default_port_from_any_ipv4()

# Database instance with production values
instance = rds.DatabaseInstance(self, "Instance",
    engine=rds.DatabaseInstanceEngine.oracle_se2(version=rds.OracleEngineVersion.VER_19_0_0_0_2020_04_R1),
    license_model=rds.LicenseModel.BRING_YOUR_OWN_LICENSE,
    instance_type=ec2.InstanceType.of(ec2.InstanceClass.BURSTABLE3, ec2.InstanceSize.MEDIUM),
    multi_az=True,
    storage_type=rds.StorageType.IO1,
    credentials=rds.Credentials.from_username("syscdk"),
    vpc=vpc,
    database_name="ORCL",
    storage_encrypted=True,
    backup_retention=cdk.Duration.days(7),
    monitoring_interval=cdk.Duration.seconds(60),
    enable_performance_insights=True,
    cloudwatch_logs_exports=["trace", "audit", "alert", "listener"
    ],
    cloudwatch_logs_retention=logs.RetentionDays.ONE_MONTH,
    auto_minor_version_upgrade=True,  # required to be true if LOCATOR is used in the option group
    option_group=option_group,
    parameter_group=parameter_group,
    removal_policy=RemovalPolicy.DESTROY
)

# Allow connections on default port from any IPV4
instance.connections.allow_default_port_from_any_ipv4()

# Rotate the master user password every 30 days
instance.add_rotation_single_user()

# Add alarm for high CPU
cloudwatch.Alarm(self, "HighCPU",
    metric=instance.metric_cPUUtilization(),
    threshold=90,
    evaluation_periods=1
)

# Trigger Lambda function on instance availability events
fn = lambda_.Function(self, "Function",
    code=lambda_.Code.from_inline("exports.handler = (event) => console.log(event);"),
    handler="index.handler",
    runtime=lambda_.Runtime.NODEJS_14_X
)

availability_rule = instance.on_event("Availability", target=targets.LambdaFunction(fn))
availability_rule.add_event_pattern(
    detail={
        "EventCategories": ["availability"
        ]
    }
)
```

Add XMLDB and OEM with option group

```python
# Set open cursors with parameter group
parameter_group = rds.ParameterGroup(self, "ParameterGroup",
    engine=rds.DatabaseInstanceEngine.oracle_se2(version=rds.OracleEngineVersion.VER_19_0_0_0_2020_04_R1),
    parameters={
        "open_cursors": "2500"
    }
)

option_group = rds.OptionGroup(self, "OptionGroup",
    engine=rds.DatabaseInstanceEngine.oracle_se2(version=rds.OracleEngineVersion.VER_19_0_0_0_2020_04_R1),
    configurations=[cdk.aws_rds.OptionConfiguration(
        name="LOCATOR"
    ), cdk.aws_rds.OptionConfiguration(
        name="OEM",
        port=1158,
        vpc=vpc
    )
    ]
)

# Allow connections to OEM
option_group.option_connections.OEM.connections.allow_default_port_from_any_ipv4()

# Database instance with production values
instance = rds.DatabaseInstance(self, "Instance",
    engine=rds.DatabaseInstanceEngine.oracle_se2(version=rds.OracleEngineVersion.VER_19_0_0_0_2020_04_R1),
    license_model=rds.LicenseModel.BRING_YOUR_OWN_LICENSE,
    instance_type=ec2.InstanceType.of(ec2.InstanceClass.BURSTABLE3, ec2.InstanceSize.MEDIUM),
    multi_az=True,
    storage_type=rds.StorageType.IO1,
    credentials=rds.Credentials.from_username("syscdk"),
    vpc=vpc,
    database_name="ORCL",
    storage_encrypted=True,
    backup_retention=cdk.Duration.days(7),
    monitoring_interval=cdk.Duration.seconds(60),
    enable_performance_insights=True,
    cloudwatch_logs_exports=["trace", "audit", "alert", "listener"
    ],
    cloudwatch_logs_retention=logs.RetentionDays.ONE_MONTH,
    auto_minor_version_upgrade=True,  # required to be true if LOCATOR is used in the option group
    option_group=option_group,
    parameter_group=parameter_group,
    removal_policy=RemovalPolicy.DESTROY
)

# Allow connections on default port from any IPV4
instance.connections.allow_default_port_from_any_ipv4()

# Rotate the master user password every 30 days
instance.add_rotation_single_user()

# Add alarm for high CPU
cloudwatch.Alarm(self, "HighCPU",
    metric=instance.metric_cPUUtilization(),
    threshold=90,
    evaluation_periods=1
)

# Trigger Lambda function on instance availability events
fn = lambda_.Function(self, "Function",
    code=lambda_.Code.from_inline("exports.handler = (event) => console.log(event);"),
    handler="index.handler",
    runtime=lambda_.Runtime.NODEJS_14_X
)

availability_rule = instance.on_event("Availability", target=targets.LambdaFunction(fn))
availability_rule.add_event_pattern(
    detail={
        "EventCategories": ["availability"
        ]
    }
)
```

## Setting Public Accessibility

You can set public accessibility for the database instance or cluster using the `publiclyAccessible` property.
If you specify `true`, it creates an instance with a publicly resolvable DNS name, which resolves to a public IP address.
If you specify `false`, it creates an internal instance with a DNS name that resolves to a private IP address.
The default value depends on `vpcSubnets`.
It will be `true` if `vpcSubnets` is `subnetType: SubnetType.PUBLIC`, `false` otherwise.

```python
# vpc: ec2.Vpc

# Setting public accessibility for DB instance
rds.DatabaseInstance(self, "Instance",
    engine=rds.DatabaseInstanceEngine.mysql(
        version=rds.MysqlEngineVersion.VER_8_0_19
    ),
    vpc=vpc,
    vpc_subnets=ec2.aws_ec2.SubnetSelection(
        subnet_type=ec2.SubnetType.PRIVATE_WITH_NAT
    ),
    publicly_accessible=True
)

# Setting public accessibility for DB cluster
rds.DatabaseCluster(self, "DatabaseCluster",
    engine=rds.DatabaseClusterEngine.AURORA,
    instance_props=ec2.aws_rds.InstanceProps(
        vpc=vpc,
        vpc_subnets=ec2.aws_ec2.SubnetSelection(
            subnet_type=ec2.SubnetType.PRIVATE_WITH_NAT
        ),
        publicly_accessible=True
    )
)
```

## Instance events

To define Amazon CloudWatch event rules for database instances, use the `onEvent`
method:

```python
# instance: rds.DatabaseInstance
# fn: lambda.Function

rule = instance.on_event("InstanceEvent", target=targets.LambdaFunction(fn))
```

## Login credentials

By default, database instances and clusters (with the exception of `DatabaseInstanceFromSnapshot` and `ServerlessClusterFromSnapshot`) will have `admin` user with an auto-generated password.
An alternative username (and password) may be specified for the admin user instead of the default.

The following examples use a `DatabaseInstance`, but the same usage is applicable to `DatabaseCluster`.

```python
# vpc: ec2.Vpc

engine = rds.DatabaseInstanceEngine.postgres(version=rds.PostgresEngineVersion.VER_12_3)
rds.DatabaseInstance(self, "InstanceWithUsername",
    engine=engine,
    vpc=vpc,
    credentials=rds.Credentials.from_generated_secret("postgres")
)

rds.DatabaseInstance(self, "InstanceWithUsernameAndPassword",
    engine=engine,
    vpc=vpc,
    credentials=rds.Credentials.from_password("postgres", SecretValue.ssm_secure("/dbPassword", "1"))
)

my_secret = secretsmanager.Secret.from_secret_name(self, "DBSecret", "myDBLoginInfo")
rds.DatabaseInstance(self, "InstanceWithSecretLogin",
    engine=engine,
    vpc=vpc,
    credentials=rds.Credentials.from_secret(my_secret)
)
```

Secrets generated by `fromGeneratedSecret()` can be customized:

```python
# vpc: ec2.Vpc

engine = rds.DatabaseInstanceEngine.postgres(version=rds.PostgresEngineVersion.VER_12_3)
my_key = kms.Key(self, "MyKey")

rds.DatabaseInstance(self, "InstanceWithCustomizedSecret",
    engine=engine,
    vpc=vpc,
    credentials=rds.Credentials.from_generated_secret("postgres",
        secret_name="my-cool-name",
        encryption_key=my_key,
        exclude_characters="!&*^#@()",
        replica_regions=[ec2.aws_secretsmanager.ReplicaRegion(region="eu-west-1"), ec2.aws_secretsmanager.ReplicaRegion(region="eu-west-2")]
    )
)
```

### Snapshot credentials

As noted above, Databases created with `DatabaseInstanceFromSnapshot` or `ServerlessClusterFromSnapshot` will not create user and auto-generated password by default because it's not possible to change the master username for a snapshot. Instead, they will use the existing username and password from the snapshot. You can still generate a new password - to generate a secret similarly to the other constructs, pass in credentials with `fromGeneratedSecret()` or `fromGeneratedPassword()`.

```python
# vpc: ec2.Vpc

engine = rds.DatabaseInstanceEngine.postgres(version=rds.PostgresEngineVersion.VER_12_3)
my_key = kms.Key(self, "MyKey")

rds.DatabaseInstanceFromSnapshot(self, "InstanceFromSnapshotWithCustomizedSecret",
    engine=engine,
    vpc=vpc,
    snapshot_identifier="mySnapshot",
    credentials=rds.SnapshotCredentials.from_generated_secret("username",
        encryption_key=my_key,
        exclude_characters="!&*^#@()",
        replica_regions=[ec2.aws_secretsmanager.ReplicaRegion(region="eu-west-1"), ec2.aws_secretsmanager.ReplicaRegion(region="eu-west-2")]
    )
)
```

## Connecting

To control who can access the cluster or instance, use the `.connections` attribute. RDS databases have
a default port, so you don't need to specify the port:

```python
# cluster: rds.DatabaseCluster

cluster.connections.allow_from_any_ipv4(ec2.Port.all_traffic(), "Open to the world")
```

The endpoints to access your database cluster will be available as the `.clusterEndpoint` and `.readerEndpoint`
attributes:

```python
# cluster: rds.DatabaseCluster

write_address = cluster.cluster_endpoint.socket_address
```

For an instance database:

```python
# instance: rds.DatabaseInstance

address = instance.instance_endpoint.socket_address
```

## Rotating credentials

When the master password is generated and stored in AWS Secrets Manager, it can be rotated automatically:

```python
import monocdk as cdk

# instance: rds.DatabaseInstance

instance.add_rotation_single_user(
    automatically_after=cdk.Duration.days(7),  # defaults to 30 days
    exclude_characters="!@#$%^&*"
)
```

```python
cluster = rds.DatabaseCluster(stack, "Database",
    engine=rds.DatabaseClusterEngine.AURORA,
    instance_props=cdk.aws_rds.InstanceProps(
        instance_type=ec2.InstanceType.of(ec2.InstanceClass.BURSTABLE3, ec2.InstanceSize.SMALL),
        vpc=vpc
    )
)

cluster.add_rotation_single_user()
```

The multi user rotation scheme is also available:

```python
# instance: rds.DatabaseInstance
# my_imported_secret: rds.DatabaseSecret

instance.add_rotation_multi_user("MyUser",
    secret=my_imported_secret
)
```

It's also possible to create user credentials together with the instance/cluster and add rotation:

```python
# instance: rds.DatabaseInstance

my_user_secret = rds.DatabaseSecret(self, "MyUserSecret",
    username="myuser",
    secret_name="my-user-secret",  # optional, defaults to a CloudFormation-generated name
    master_secret=instance.secret,
    exclude_characters="{}[]()'\"/\\"
)
my_user_secret_attached = my_user_secret.attach(instance) # Adds DB connections information in the secret

instance.add_rotation_multi_user("MyUser",  # Add rotation using the multi user scheme
    secret=my_user_secret_attached)
```

**Note**: This user must be created manually in the database using the master credentials.
The rotation will start as soon as this user exists.

Access to the Secrets Manager API is required for the secret rotation. This can be achieved either with
internet connectivity (through NAT) or with a VPC interface endpoint. By default, the rotation Lambda function
is deployed in the same subnets as the instance/cluster. If access to the Secrets Manager API is not possible from
those subnets or using the default API endpoint, use the `vpcSubnets` and/or `endpoint` options:

```python
# instance: rds.DatabaseInstance
# my_endpoint: ec2.InterfaceVpcEndpoint


instance.add_rotation_single_user(
    vpc_subnets=ec2.aws_ec2.SubnetSelection(subnet_type=ec2.SubnetType.PRIVATE_WITH_NAT),  # Place rotation Lambda in private subnets
    endpoint=my_endpoint
)
```

See also [@aws-cdk/aws-secretsmanager](https://github.com/aws/aws-cdk/blob/master/packages/%40aws-cdk/aws-secretsmanager/README.md) for credentials rotation of existing clusters/instances.

## IAM Authentication

You can also authenticate to a database instance using AWS Identity and Access Management (IAM) database authentication;
See [https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.IAMDBAuth.html](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.IAMDBAuth.html) for more information
and a list of supported versions and limitations.

**Note**: `grantConnect()` does not currently work - see [this GitHub issue](https://github.com/aws/aws-cdk/issues/11851).

The following example shows enabling IAM authentication for a database instance and granting connection access to an IAM role.

```python
# vpc: ec2.Vpc

instance = rds.DatabaseInstance(self, "Instance",
    engine=rds.DatabaseInstanceEngine.mysql(version=rds.MysqlEngineVersion.VER_8_0_19),
    vpc=vpc,
    iam_authentication=True
)
role = iam.Role(self, "DBRole", assumed_by=iam.AccountPrincipal(self.account))
instance.grant_connect(role)
```

The following example shows granting connection access for RDS Proxy to an IAM role.

```python
# vpc: ec2.Vpc

cluster = rds.DatabaseCluster(self, "Database",
    engine=rds.DatabaseClusterEngine.AURORA,
    instance_props=ec2.aws_rds.InstanceProps(vpc=vpc)
)

proxy = rds.DatabaseProxy(self, "Proxy",
    proxy_target=rds.ProxyTarget.from_cluster(cluster),
    secrets=[cluster.secret],
    vpc=vpc
)

role = iam.Role(self, "DBProxyRole", assumed_by=iam.AccountPrincipal(self.account))
proxy.grant_connect(role, "admin")
```

**Note**: In addition to the setup above, a database user will need to be created to support IAM auth.
See [https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.IAMDBAuth.DBAccounts.html](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.IAMDBAuth.DBAccounts.html) for setup instructions.

## Kerberos Authentication

You can also authenticate using Kerberos to a database instance using AWS Managed Microsoft AD for authentication;
See [https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/kerberos-authentication.html](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/kerberos-authentication.html) for more information
and a list of supported versions and limitations.

The following example shows enabling domain support for a database instance and creating an IAM role to access
Directory Services.

```python
# vpc: ec2.Vpc

role = iam.Role(self, "RDSDirectoryServicesRole",
    assumed_by=iam.ServicePrincipal("rds.amazonaws.com"),
    managed_policies=[
        iam.ManagedPolicy.from_aws_managed_policy_name("service-role/AmazonRDSDirectoryServiceAccess")
    ]
)
instance = rds.DatabaseInstance(self, "Instance",
    engine=rds.DatabaseInstanceEngine.mysql(version=rds.MysqlEngineVersion.VER_8_0_19),
    vpc=vpc,
    domain="d-????????",  # The ID of the domain for the instance to join.
    domain_role=role
)
```

**Note**: In addition to the setup above, you need to make sure that the database instance has network connectivity
to the domain controllers. This includes enabling cross-VPC traffic if in a different VPC and setting up the
appropriate security groups/network ACL to allow traffic between the database instance and domain controllers.
Once configured, see [https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/kerberos-authentication.html](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/kerberos-authentication.html) for details
on configuring users for each available database engine.

## Metrics

Database instances and clusters both expose metrics (`cloudwatch.Metric`):

```python
# The number of database connections in use (average over 5 minutes)
# instance: rds.DatabaseInstance

# Average CPU utilization over 5 minutes
# cluster: rds.DatabaseCluster

db_connections = instance.metric_database_connections()
cpu_utilization = cluster.metric_cPUUtilization()

# The average amount of time taken per disk I/O operation (average over 1 minute)
read_latency = instance.metric("ReadLatency", statistic="Average", period=Duration.seconds(60))
```

## Enabling S3 integration

Data in S3 buckets can be imported to and exported from certain database engines using SQL queries. To enable this
functionality, set the `s3ImportBuckets` and `s3ExportBuckets` properties for import and export respectively. When
configured, the CDK automatically creates and configures IAM roles as required.
Additionally, the `s3ImportRole` and `s3ExportRole` properties can be used to set this role directly.

You can read more about loading data to (or from) S3 here:

* Aurora MySQL - [import](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/AuroraMySQL.Integrating.LoadFromS3.html)
  and [export](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/AuroraMySQL.Integrating.SaveIntoS3.html).
* Aurora PostgreSQL - [import](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/AuroraPostgreSQL.Migrating.html#USER_PostgreSQL.S3Import)
  and [export](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/postgresql-s3-export.html).
* Microsoft SQL Server - [import and export](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/SQLServer.Procedural.Importing.html)
* PostgreSQL - [import](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/PostgreSQL.Procedural.Importing.html)
  and [export](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/postgresql-s3-export.html)
* Oracle - [import and export](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/oracle-s3-integration.html)

The following snippet sets up a database cluster with different S3 buckets where the data is imported and exported -

```python
import monocdk as s3

# vpc: ec2.Vpc

import_bucket = s3.Bucket(self, "importbucket")
export_bucket = s3.Bucket(self, "exportbucket")
rds.DatabaseCluster(self, "dbcluster",
    engine=rds.DatabaseClusterEngine.AURORA,
    instance_props=s3.aws_rds.InstanceProps(
        vpc=vpc
    ),
    s3_import_buckets=[import_bucket],
    s3_export_buckets=[export_bucket]
)
```

## Creating a Database Proxy

Amazon RDS Proxy sits between your application and your relational database to efficiently manage
connections to the database and improve scalability of the application. Learn more about at [Amazon RDS Proxy](https://aws.amazon.com/rds/proxy/)

The following code configures an RDS Proxy for a `DatabaseInstance`.

```python
# vpc: ec2.Vpc
# security_group: ec2.SecurityGroup
# secrets: List[secretsmanager.Secret[]]
# db_instance: rds.DatabaseInstance


proxy = db_instance.add_proxy("proxy",
    borrow_timeout=Duration.seconds(30),
    max_connections_percent=50,
    secrets=secrets,
    vpc=vpc
)
```

## Exporting Logs

You can publish database logs to Amazon CloudWatch Logs. With CloudWatch Logs, you can perform real-time analysis of the log data,
store the data in highly durable storage, and manage the data with the CloudWatch Logs Agent. This is available for both database
instances and clusters; the types of logs available depend on the database type and engine being used.

```python
import monocdk as logs
# my_logs_publishing_role: iam.Role
# vpc: ec2.Vpc


# Exporting logs from a cluster
cluster = rds.DatabaseCluster(self, "Database",
    engine=rds.DatabaseClusterEngine.aurora(
        version=rds.AuroraEngineVersion.VER_1_17_9
    ),
    instance_props=logs.aws_rds.InstanceProps(
        vpc=vpc
    ),
    cloudwatch_logs_exports=["error", "general", "slowquery", "audit"],  # Export all available MySQL-based logs
    cloudwatch_logs_retention=logs.RetentionDays.THREE_MONTHS,  # Optional - default is to never expire logs
    cloudwatch_logs_retention_role=my_logs_publishing_role
)

# Exporting logs from an instance
instance = rds.DatabaseInstance(self, "Instance",
    engine=rds.DatabaseInstanceEngine.postgres(
        version=rds.PostgresEngineVersion.VER_12_3
    ),
    vpc=vpc,
    cloudwatch_logs_exports=["postgresql"]
)
```

## Option Groups

Some DB engines offer additional features that make it easier to manage data and databases, and to provide additional security for your database.
Amazon RDS uses option groups to enable and configure these features. An option group can specify features, called options,
that are available for a particular Amazon RDS DB instance.

```python
# vpc: ec2.Vpc
# security_group: ec2.SecurityGroup


rds.OptionGroup(self, "Options",
    engine=rds.DatabaseInstanceEngine.oracle_se2(
        version=rds.OracleEngineVersion.VER_19
    ),
    configurations=[ec2.aws_rds.OptionConfiguration(
        name="OEM",
        port=5500,
        vpc=vpc,
        security_groups=[security_group]
    )
    ]
)
```

## Parameter Groups

Database parameters specify how the database is configured.
For example, database parameters can specify the amount of resources, such as memory, to allocate to a database.
You manage your database configuration by associating your DB instances with parameter groups.
Amazon RDS defines parameter groups with default settings.

You can create your own parameter group for your cluster or instance and associate it with your database:

```python
# vpc: ec2.Vpc


parameter_group = rds.ParameterGroup(self, "ParameterGroup",
    engine=rds.DatabaseInstanceEngine.sql_server_ee(
        version=rds.SqlServerEngineVersion.VER_11
    ),
    parameters={
        "locks": "100"
    }
)

rds.DatabaseInstance(self, "Database",
    engine=rds.DatabaseInstanceEngine.SQL_SERVER_EE,
    vpc=vpc,
    parameter_group=parameter_group
)
```

Another way to specify parameters is to use the inline field `parameters` that creates an RDS parameter group for you.
You can use this if you do not want to reuse the parameter group instance for different instances:

```python
# vpc: ec2.Vpc


rds.DatabaseInstance(self, "Database",
    engine=rds.DatabaseInstanceEngine.sql_server_ee(version=rds.SqlServerEngineVersion.VER_11),
    vpc=vpc,
    parameters={
        "locks": "100"
    }
)
```

You cannot specify a parameter map and a parameter group at the same time.

## Serverless

[Amazon Aurora Serverless](https://aws.amazon.com/rds/aurora/serverless/) is an on-demand, auto-scaling configuration for Amazon
Aurora. The database will automatically start up, shut down, and scale capacity
up or down based on your application's needs. It enables you to run your database
in the cloud without managing any database instances.

The following example initializes an Aurora Serverless PostgreSql cluster.
Aurora Serverless clusters can specify scaling properties which will be used to
automatically scale the database cluster seamlessly based on the workload.

```python
# vpc: ec2.Vpc


cluster = rds.ServerlessCluster(self, "AnotherCluster",
    engine=rds.DatabaseClusterEngine.AURORA_POSTGRESQL,
    parameter_group=rds.ParameterGroup.from_parameter_group_name(self, "ParameterGroup", "default.aurora-postgresql10"),
    vpc=vpc,
    scaling=ec2.aws_rds.ServerlessScalingOptions(
        auto_pause=Duration.minutes(10),  # default is to pause after 5 minutes of idle time
        min_capacity=rds.AuroraCapacityUnit.ACU_8,  # default is 2 Aurora capacity units (ACUs)
        max_capacity=rds.AuroraCapacityUnit.ACU_32
    )
)
```

Aurora Serverless Clusters do not support the following features:

* Loading data from an Amazon S3 bucket
* Saving data to an Amazon S3 bucket
* Invoking an AWS Lambda function with an Aurora MySQL native function
* Aurora replicas
* Backtracking
* Multi-master clusters
* Database cloning
* IAM database cloning
* IAM database authentication
* Restoring a snapshot from MySQL DB instance
* Performance Insights
* RDS Proxy

Read more about the [limitations of Aurora Serverless](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless.html#aurora-serverless.limitations)

Learn more about using Amazon Aurora Serverless by reading the [documentation](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless.html)

Use `ServerlessClusterFromSnapshot` to create a serverless cluster from a snapshot:

```python
# vpc: ec2.Vpc

rds.ServerlessClusterFromSnapshot(self, "Cluster",
    engine=rds.DatabaseClusterEngine.AURORA_MYSQL,
    vpc=vpc,
    snapshot_identifier="mySnapshot"
)
```

### Data API

You can access your Aurora Serverless DB cluster using the built-in Data API. The Data API doesn't require a persistent connection to the DB cluster. Instead, it provides a secure HTTP endpoint and integration with AWS SDKs.

The following example shows granting Data API access to a Lamba function.

```python
# vpc: ec2.Vpc

# code: lambda.Code


cluster = rds.ServerlessCluster(self, "AnotherCluster",
    engine=rds.DatabaseClusterEngine.AURORA_MYSQL,
    vpc=vpc,  # this parameter is optional for serverless Clusters
    enable_data_api=True
)
fn = lambda_.Function(self, "MyFunction",
    runtime=lambda_.Runtime.NODEJS_14_X,
    handler="index.handler",
    code=code,
    environment={
        "CLUSTER_ARN": cluster.cluster_arn,
        "SECRET_ARN": cluster.secret.secret_arn
    }
)
cluster.grant_data_api_access(fn)
```

**Note**: To invoke the Data API, the resource will need to read the secret associated with the cluster.

To learn more about using the Data API, see the [documentation](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/data-api.html).

### Default VPC

The `vpc` parameter is optional.

If not provided, the cluster will be created in the default VPC of the account and region.
As this VPC is not deployed with AWS CDK, you can't configure the `vpcSubnets`, `subnetGroup` or `securityGroups` of the Aurora Serverless Cluster.
If you want to provide one of `vpcSubnets`, `subnetGroup` or `securityGroups` parameter, please provide a `vpc`.
'''
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from .._jsii import *

import constructs as _constructs_77d1e7e8
from .. import (
    CfnResource as _CfnResource_e0a482dc,
    CfnTag as _CfnTag_95fbdc29,
    Construct as _Construct_e78e779f,
    Duration as _Duration_070aa057,
    IInspectable as _IInspectable_82c04a63,
    IResolvable as _IResolvable_a771d0ef,
    IResource as _IResource_8c1dbbbd,
    RemovalPolicy as _RemovalPolicy_c97e7a20,
    Resource as _Resource_abff4495,
    ResourceProps as _ResourceProps_9b554c0f,
    SecretValue as _SecretValue_c18506ef,
    TagManager as _TagManager_0b7ab120,
    TreeInspector as _TreeInspector_1cd1894e,
)
from ..aws_cloudwatch import (
    Metric as _Metric_5b2b8e58,
    MetricOptions as _MetricOptions_1c185ae8,
    Unit as _Unit_113c79f9,
)
from ..aws_ec2 import (
    Connections as _Connections_57ccbda9,
    IConnectable as _IConnectable_c1c0e72c,
    IInterfaceVpcEndpoint as _IInterfaceVpcEndpoint_6081623d,
    ISecurityGroup as _ISecurityGroup_cdbba9d3,
    IVpc as _IVpc_6d1f76c4,
    InstanceType as _InstanceType_072ad323,
    SubnetSelection as _SubnetSelection_1284e62c,
)
from ..aws_events import (
    EventPattern as _EventPattern_a23fbf37,
    IRuleTarget as _IRuleTarget_d45ec729,
    OnEventOptions as _OnEventOptions_d5081088,
    Rule as _Rule_6cfff189,
)
from ..aws_iam import (
    Grant as _Grant_bcb5eae7,
    IGrantable as _IGrantable_4c5a91d1,
    IRole as _IRole_59af6f50,
)
from ..aws_kms import IKey as _IKey_36930160
from ..aws_logs import RetentionDays as _RetentionDays_6c560d31
from ..aws_s3 import IBucket as _IBucket_73486e29
from ..aws_secretsmanager import (
    ISecret as _ISecret_22fb8757,
    ISecretAttachmentTarget as _ISecretAttachmentTarget_b6932462,
    ReplicaRegion as _ReplicaRegion_ad1a6d2e,
    Secret as _Secret_cb33d4cc,
    SecretAttachmentTargetProps as _SecretAttachmentTargetProps_ab8522eb,
    SecretRotation as _SecretRotation_e64158ad,
    SecretRotationApplication as _SecretRotationApplication_0ac7c5d5,
)


@jsii.enum(jsii_type="monocdk.aws_rds.AuroraCapacityUnit")
class AuroraCapacityUnit(enum.Enum):
    '''(experimental) Aurora capacity units (ACUs).

    Each ACU is a combination of processing and memory capacity.

    :see: https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless.how-it-works.html#aurora-serverless.architecture
    :stability: experimental
    :exampleMetadata: infused

    Example::

        # vpc: ec2.Vpc
        
        
        cluster = rds.ServerlessCluster(self, "AnotherCluster",
            engine=rds.DatabaseClusterEngine.AURORA_POSTGRESQL,
            parameter_group=rds.ParameterGroup.from_parameter_group_name(self, "ParameterGroup", "default.aurora-postgresql10"),
            vpc=vpc,
            scaling=ec2.aws_rds.ServerlessScalingOptions(
                auto_pause=Duration.minutes(10),  # default is to pause after 5 minutes of idle time
                min_capacity=rds.AuroraCapacityUnit.ACU_8,  # default is 2 Aurora capacity units (ACUs)
                max_capacity=rds.AuroraCapacityUnit.ACU_32
            )
        )
    '''

    ACU_1 = "ACU_1"
    '''(experimental) 1 Aurora Capacity Unit.

    :stability: experimental
    '''
    ACU_2 = "ACU_2"
    '''(experimental) 2 Aurora Capacity Units.

    :stability: experimental
    '''
    ACU_4 = "ACU_4"
    '''(experimental) 4 Aurora Capacity Units.

    :stability: experimental
    '''
    ACU_8 = "ACU_8"
    '''(experimental) 8 Aurora Capacity Units.

    :stability: experimental
    '''
    ACU_16 = "ACU_16"
    '''(experimental) 16 Aurora Capacity Units.

    :stability: experimental
    '''
    ACU_32 = "ACU_32"
    '''(experimental) 32 Aurora Capacity Units.

    :stability: experimental
    '''
    ACU_64 = "ACU_64"
    '''(experimental) 64 Aurora Capacity Units.

    :stability: experimental
    '''
    ACU_128 = "ACU_128"
    '''(experimental) 128 Aurora Capacity Units.

    :stability: experimental
    '''
    ACU_192 = "ACU_192"
    '''(experimental) 192 Aurora Capacity Units.

    :stability: experimental
    '''
    ACU_256 = "ACU_256"
    '''(experimental) 256 Aurora Capacity Units.

    :stability: experimental
    '''
    ACU_384 = "ACU_384"
    '''(experimental) 384 Aurora Capacity Units.

    :stability: experimental
    '''


@jsii.data_type(
    jsii_type="monocdk.aws_rds.AuroraClusterEngineProps",
    jsii_struct_bases=[],
    name_mapping={"version": "version"},
)
class AuroraClusterEngineProps:
    def __init__(self, *, version: "AuroraEngineVersion") -> None:
        '''(experimental) Creation properties of the plain Aurora database cluster engine.

        Used in {@link DatabaseClusterEngine.aurora}.

        :param version: (experimental) The version of the Aurora cluster engine.

        :stability: experimental
        :exampleMetadata: infused

        Example::

            # vpc: ec2.Vpc
            
            rds.DatabaseClusterFromSnapshot(self, "Database",
                engine=rds.DatabaseClusterEngine.aurora(version=rds.AuroraEngineVersion.VER_1_22_2),
                instance_props=ec2.aws_rds.InstanceProps(
                    vpc=vpc
                ),
                snapshot_identifier="mySnapshot"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a24f616650b60c72d873952ceffb6175e41b94be3e3f94a2e05e75b933c46812)
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "version": version,
        }

    @builtins.property
    def version(self) -> "AuroraEngineVersion":
        '''(experimental) The version of the Aurora cluster engine.

        :stability: experimental
        '''
        result = self._values.get("version")
        assert result is not None, "Required property 'version' is missing"
        return typing.cast("AuroraEngineVersion", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AuroraClusterEngineProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AuroraEngineVersion(
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_rds.AuroraEngineVersion",
):
    '''(experimental) The versions for the Aurora cluster engine (those returned by {@link DatabaseClusterEngine.aurora}).

    :stability: experimental
    :exampleMetadata: infused

    Example::

        # vpc: ec2.Vpc
        
        rds.DatabaseClusterFromSnapshot(self, "Database",
            engine=rds.DatabaseClusterEngine.aurora(version=rds.AuroraEngineVersion.VER_1_22_2),
            instance_props=ec2.aws_rds.InstanceProps(
                vpc=vpc
            ),
            snapshot_identifier="mySnapshot"
        )
    '''

    @jsii.member(jsii_name="of")
    @builtins.classmethod
    def of(
        cls,
        aurora_full_version: builtins.str,
        aurora_major_version: typing.Optional[builtins.str] = None,
    ) -> "AuroraEngineVersion":
        '''(experimental) Create a new AuroraEngineVersion with an arbitrary version.

        :param aurora_full_version: the full version string, for example "5.6.mysql_aurora.1.78.3.6".
        :param aurora_major_version: the major version of the engine, defaults to "5.6".

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ad3556ca07c3b906db5600dcaeea426eaa196043bd2dd62b15e131e1869f72e2)
            check_type(argname="argument aurora_full_version", value=aurora_full_version, expected_type=type_hints["aurora_full_version"])
            check_type(argname="argument aurora_major_version", value=aurora_major_version, expected_type=type_hints["aurora_major_version"])
        return typing.cast("AuroraEngineVersion", jsii.sinvoke(cls, "of", [aurora_full_version, aurora_major_version]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_1_17_9")
    def VER_1_17_9(cls) -> "AuroraEngineVersion":
        '''(experimental) Version "5.6.mysql_aurora.1.17.9".

        :stability: experimental
        '''
        return typing.cast("AuroraEngineVersion", jsii.sget(cls, "VER_1_17_9"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_1_19_0")
    def VER_1_19_0(cls) -> "AuroraEngineVersion":
        '''(experimental) Version "5.6.mysql_aurora.1.19.0".

        :stability: experimental
        '''
        return typing.cast("AuroraEngineVersion", jsii.sget(cls, "VER_1_19_0"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_1_19_1")
    def VER_1_19_1(cls) -> "AuroraEngineVersion":
        '''(experimental) Version "5.6.mysql_aurora.1.19.1".

        :stability: experimental
        '''
        return typing.cast("AuroraEngineVersion", jsii.sget(cls, "VER_1_19_1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_1_19_2")
    def VER_1_19_2(cls) -> "AuroraEngineVersion":
        '''(experimental) Version "5.6.mysql_aurora.1.19.2".

        :stability: experimental
        '''
        return typing.cast("AuroraEngineVersion", jsii.sget(cls, "VER_1_19_2"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_1_19_5")
    def VER_1_19_5(cls) -> "AuroraEngineVersion":
        '''(experimental) Version "5.6.mysql_aurora.1.19.5".

        :stability: experimental
        '''
        return typing.cast("AuroraEngineVersion", jsii.sget(cls, "VER_1_19_5"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_1_19_6")
    def VER_1_19_6(cls) -> "AuroraEngineVersion":
        '''(experimental) Version "5.6.mysql_aurora.1.19.6".

        :stability: experimental
        '''
        return typing.cast("AuroraEngineVersion", jsii.sget(cls, "VER_1_19_6"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_1_20_0")
    def VER_1_20_0(cls) -> "AuroraEngineVersion":
        '''(experimental) Version "5.6.mysql_aurora.1.20.0".

        :stability: experimental
        '''
        return typing.cast("AuroraEngineVersion", jsii.sget(cls, "VER_1_20_0"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_1_20_1")
    def VER_1_20_1(cls) -> "AuroraEngineVersion":
        '''(experimental) Version "5.6.mysql_aurora.1.20.1".

        :stability: experimental
        '''
        return typing.cast("AuroraEngineVersion", jsii.sget(cls, "VER_1_20_1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_1_21_0")
    def VER_1_21_0(cls) -> "AuroraEngineVersion":
        '''(experimental) Version "5.6.mysql_aurora.1.21.0".

        :stability: experimental
        '''
        return typing.cast("AuroraEngineVersion", jsii.sget(cls, "VER_1_21_0"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_1_22_0")
    def VER_1_22_0(cls) -> "AuroraEngineVersion":
        '''(experimental) Version "5.6.mysql_aurora.1.22.0".

        :stability: experimental
        '''
        return typing.cast("AuroraEngineVersion", jsii.sget(cls, "VER_1_22_0"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_1_22_1")
    def VER_1_22_1(cls) -> "AuroraEngineVersion":
        '''(experimental) Version "5.6.mysql_aurora.1.22.1".

        :stability: experimental
        '''
        return typing.cast("AuroraEngineVersion", jsii.sget(cls, "VER_1_22_1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_1_22_1_3")
    def VER_1_22_1_3(cls) -> "AuroraEngineVersion":
        '''(experimental) Version "5.6.mysql_aurora.1.22.1.3".

        :stability: experimental
        '''
        return typing.cast("AuroraEngineVersion", jsii.sget(cls, "VER_1_22_1_3"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_1_22_2")
    def VER_1_22_2(cls) -> "AuroraEngineVersion":
        '''(experimental) Version "5.6.mysql_aurora.1.22.2".

        :stability: experimental
        '''
        return typing.cast("AuroraEngineVersion", jsii.sget(cls, "VER_1_22_2"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10A")
    def VER_10_A(cls) -> "AuroraEngineVersion":
        '''(experimental) Version "5.6.10a".

        :stability: experimental
        '''
        return typing.cast("AuroraEngineVersion", jsii.sget(cls, "VER_10A"))

    @builtins.property
    @jsii.member(jsii_name="auroraFullVersion")
    def aurora_full_version(self) -> builtins.str:
        '''(experimental) The full version string, for example, "5.6.mysql_aurora.1.78.3.6".

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "auroraFullVersion"))

    @builtins.property
    @jsii.member(jsii_name="auroraMajorVersion")
    def aurora_major_version(self) -> builtins.str:
        '''(experimental) The major version of the engine.

        Currently, it's always "5.6".

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "auroraMajorVersion"))


@jsii.data_type(
    jsii_type="monocdk.aws_rds.AuroraMysqlClusterEngineProps",
    jsii_struct_bases=[],
    name_mapping={"version": "version"},
)
class AuroraMysqlClusterEngineProps:
    def __init__(self, *, version: "AuroraMysqlEngineVersion") -> None:
        '''(experimental) Creation properties of the Aurora MySQL database cluster engine.

        Used in {@link DatabaseClusterEngine.auroraMysql}.

        :param version: (experimental) The version of the Aurora MySQL cluster engine.

        :stability: experimental
        :exampleMetadata: infused

        Example::

            # vpc: ec2.Vpc
            
            cluster = rds.DatabaseCluster(self, "Database",
                engine=rds.DatabaseClusterEngine.aurora_mysql(version=rds.AuroraMysqlEngineVersion.VER_2_08_1),
                credentials=rds.Credentials.from_generated_secret("clusteradmin"),  # Optional - will default to 'admin' username and generated password
                instance_props=ec2.aws_rds.InstanceProps(
                    # optional , defaults to t3.medium
                    instance_type=ec2.InstanceType.of(ec2.InstanceClass.BURSTABLE2, ec2.InstanceSize.SMALL),
                    vpc_subnets=ec2.aws_ec2.SubnetSelection(
                        subnet_type=ec2.SubnetType.PRIVATE_WITH_NAT
                    ),
                    vpc=vpc
                )
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__787fcd68d6eae166bc9fd59f039099e11a193e71bf74e78042254065b2d76c45)
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "version": version,
        }

    @builtins.property
    def version(self) -> "AuroraMysqlEngineVersion":
        '''(experimental) The version of the Aurora MySQL cluster engine.

        :stability: experimental
        '''
        result = self._values.get("version")
        assert result is not None, "Required property 'version' is missing"
        return typing.cast("AuroraMysqlEngineVersion", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AuroraMysqlClusterEngineProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AuroraMysqlEngineVersion(
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_rds.AuroraMysqlEngineVersion",
):
    '''(experimental) The versions for the Aurora MySQL cluster engine (those returned by {@link DatabaseClusterEngine.auroraMysql}).

    :stability: experimental
    :exampleMetadata: infused

    Example::

        # vpc: ec2.Vpc
        
        cluster = rds.DatabaseCluster(self, "Database",
            engine=rds.DatabaseClusterEngine.aurora_mysql(version=rds.AuroraMysqlEngineVersion.VER_2_08_1),
            credentials=rds.Credentials.from_generated_secret("clusteradmin"),  # Optional - will default to 'admin' username and generated password
            instance_props=ec2.aws_rds.InstanceProps(
                # optional , defaults to t3.medium
                instance_type=ec2.InstanceType.of(ec2.InstanceClass.BURSTABLE2, ec2.InstanceSize.SMALL),
                vpc_subnets=ec2.aws_ec2.SubnetSelection(
                    subnet_type=ec2.SubnetType.PRIVATE_WITH_NAT
                ),
                vpc=vpc
            )
        )
    '''

    @jsii.member(jsii_name="of")
    @builtins.classmethod
    def of(
        cls,
        aurora_mysql_full_version: builtins.str,
        aurora_mysql_major_version: typing.Optional[builtins.str] = None,
    ) -> "AuroraMysqlEngineVersion":
        '''(experimental) Create a new AuroraMysqlEngineVersion with an arbitrary version.

        :param aurora_mysql_full_version: the full version string, for example "5.7.mysql_aurora.2.78.3.6".
        :param aurora_mysql_major_version: the major version of the engine, defaults to "5.7".

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3f909c95d19c3db62505d876444380e9b0ef8074e5fff25fcf8656ba3b1aada7)
            check_type(argname="argument aurora_mysql_full_version", value=aurora_mysql_full_version, expected_type=type_hints["aurora_mysql_full_version"])
            check_type(argname="argument aurora_mysql_major_version", value=aurora_mysql_major_version, expected_type=type_hints["aurora_mysql_major_version"])
        return typing.cast("AuroraMysqlEngineVersion", jsii.sinvoke(cls, "of", [aurora_mysql_full_version, aurora_mysql_major_version]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_2_03_2")
    def VER_2_03_2(cls) -> "AuroraMysqlEngineVersion":
        '''(experimental) Version "5.7.mysql_aurora.2.03.2".

        :stability: experimental
        '''
        return typing.cast("AuroraMysqlEngineVersion", jsii.sget(cls, "VER_2_03_2"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_2_03_3")
    def VER_2_03_3(cls) -> "AuroraMysqlEngineVersion":
        '''(experimental) Version "5.7.mysql_aurora.2.03.3".

        :stability: experimental
        '''
        return typing.cast("AuroraMysqlEngineVersion", jsii.sget(cls, "VER_2_03_3"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_2_03_4")
    def VER_2_03_4(cls) -> "AuroraMysqlEngineVersion":
        '''(experimental) Version "5.7.mysql_aurora.2.03.4".

        :stability: experimental
        '''
        return typing.cast("AuroraMysqlEngineVersion", jsii.sget(cls, "VER_2_03_4"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_2_04_0")
    def VER_2_04_0(cls) -> "AuroraMysqlEngineVersion":
        '''(experimental) Version "5.7.mysql_aurora.2.04.0".

        :stability: experimental
        '''
        return typing.cast("AuroraMysqlEngineVersion", jsii.sget(cls, "VER_2_04_0"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_2_04_1")
    def VER_2_04_1(cls) -> "AuroraMysqlEngineVersion":
        '''(experimental) Version "5.7.mysql_aurora.2.04.1".

        :stability: experimental
        '''
        return typing.cast("AuroraMysqlEngineVersion", jsii.sget(cls, "VER_2_04_1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_2_04_2")
    def VER_2_04_2(cls) -> "AuroraMysqlEngineVersion":
        '''(experimental) Version "5.7.mysql_aurora.2.04.2".

        :stability: experimental
        '''
        return typing.cast("AuroraMysqlEngineVersion", jsii.sget(cls, "VER_2_04_2"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_2_04_3")
    def VER_2_04_3(cls) -> "AuroraMysqlEngineVersion":
        '''(experimental) Version "5.7.mysql_aurora.2.04.3".

        :stability: experimental
        '''
        return typing.cast("AuroraMysqlEngineVersion", jsii.sget(cls, "VER_2_04_3"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_2_04_4")
    def VER_2_04_4(cls) -> "AuroraMysqlEngineVersion":
        '''(experimental) Version "5.7.mysql_aurora.2.04.4".

        :stability: experimental
        '''
        return typing.cast("AuroraMysqlEngineVersion", jsii.sget(cls, "VER_2_04_4"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_2_04_5")
    def VER_2_04_5(cls) -> "AuroraMysqlEngineVersion":
        '''(experimental) Version "5.7.mysql_aurora.2.04.5".

        :stability: experimental
        '''
        return typing.cast("AuroraMysqlEngineVersion", jsii.sget(cls, "VER_2_04_5"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_2_04_6")
    def VER_2_04_6(cls) -> "AuroraMysqlEngineVersion":
        '''(experimental) Version "5.7.mysql_aurora.2.04.6".

        :stability: experimental
        '''
        return typing.cast("AuroraMysqlEngineVersion", jsii.sget(cls, "VER_2_04_6"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_2_04_7")
    def VER_2_04_7(cls) -> "AuroraMysqlEngineVersion":
        '''(experimental) Version "5.7.mysql_aurora.2.04.7".

        :stability: experimental
        '''
        return typing.cast("AuroraMysqlEngineVersion", jsii.sget(cls, "VER_2_04_7"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_2_04_8")
    def VER_2_04_8(cls) -> "AuroraMysqlEngineVersion":
        '''(experimental) Version "5.7.mysql_aurora.2.04.8".

        :stability: experimental
        '''
        return typing.cast("AuroraMysqlEngineVersion", jsii.sget(cls, "VER_2_04_8"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_2_05_0")
    def VER_2_05_0(cls) -> "AuroraMysqlEngineVersion":
        '''(experimental) Version "5.7.mysql_aurora.2.05.0".

        :stability: experimental
        '''
        return typing.cast("AuroraMysqlEngineVersion", jsii.sget(cls, "VER_2_05_0"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_2_06_0")
    def VER_2_06_0(cls) -> "AuroraMysqlEngineVersion":
        '''(experimental) Version "5.7.mysql_aurora.2.06.0".

        :stability: experimental
        '''
        return typing.cast("AuroraMysqlEngineVersion", jsii.sget(cls, "VER_2_06_0"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_2_07_0")
    def VER_2_07_0(cls) -> "AuroraMysqlEngineVersion":
        '''(experimental) Version "5.7.mysql_aurora.2.07.0".

        :stability: experimental
        '''
        return typing.cast("AuroraMysqlEngineVersion", jsii.sget(cls, "VER_2_07_0"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_2_07_1")
    def VER_2_07_1(cls) -> "AuroraMysqlEngineVersion":
        '''(experimental) Version "5.7.mysql_aurora.2.07.1".

        :stability: experimental
        '''
        return typing.cast("AuroraMysqlEngineVersion", jsii.sget(cls, "VER_2_07_1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_2_07_2")
    def VER_2_07_2(cls) -> "AuroraMysqlEngineVersion":
        '''(experimental) Version "5.7.mysql_aurora.2.07.2".

        :stability: experimental
        '''
        return typing.cast("AuroraMysqlEngineVersion", jsii.sget(cls, "VER_2_07_2"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_2_08_0")
    def VER_2_08_0(cls) -> "AuroraMysqlEngineVersion":
        '''(experimental) Version "5.7.mysql_aurora.2.08.0".

        :stability: experimental
        '''
        return typing.cast("AuroraMysqlEngineVersion", jsii.sget(cls, "VER_2_08_0"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_2_08_1")
    def VER_2_08_1(cls) -> "AuroraMysqlEngineVersion":
        '''(experimental) Version "5.7.mysql_aurora.2.08.1".

        :stability: experimental
        '''
        return typing.cast("AuroraMysqlEngineVersion", jsii.sget(cls, "VER_2_08_1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_2_08_2")
    def VER_2_08_2(cls) -> "AuroraMysqlEngineVersion":
        '''(experimental) Version "5.7.mysql_aurora.2.08.2".

        :stability: experimental
        '''
        return typing.cast("AuroraMysqlEngineVersion", jsii.sget(cls, "VER_2_08_2"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_2_09_0")
    def VER_2_09_0(cls) -> "AuroraMysqlEngineVersion":
        '''(experimental) Version "5.7.mysql_aurora.2.09.0".

        :stability: experimental
        '''
        return typing.cast("AuroraMysqlEngineVersion", jsii.sget(cls, "VER_2_09_0"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_2_09_1")
    def VER_2_09_1(cls) -> "AuroraMysqlEngineVersion":
        '''(experimental) Version "5.7.mysql_aurora.2.09.1".

        :stability: experimental
        '''
        return typing.cast("AuroraMysqlEngineVersion", jsii.sget(cls, "VER_2_09_1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_2_09_2")
    def VER_2_09_2(cls) -> "AuroraMysqlEngineVersion":
        '''(experimental) Version "5.7.mysql_aurora.2.09.2".

        :stability: experimental
        '''
        return typing.cast("AuroraMysqlEngineVersion", jsii.sget(cls, "VER_2_09_2"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_2_09_3")
    def VER_2_09_3(cls) -> "AuroraMysqlEngineVersion":
        '''(experimental) Version "5.7.mysql_aurora.2.09.3".

        :stability: experimental
        '''
        return typing.cast("AuroraMysqlEngineVersion", jsii.sget(cls, "VER_2_09_3"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_2_10_0")
    def VER_2_10_0(cls) -> "AuroraMysqlEngineVersion":
        '''(experimental) Version "5.7.mysql_aurora.2.10.0".

        :stability: experimental
        '''
        return typing.cast("AuroraMysqlEngineVersion", jsii.sget(cls, "VER_2_10_0"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_2_10_1")
    def VER_2_10_1(cls) -> "AuroraMysqlEngineVersion":
        '''(experimental) Version "5.7.mysql_aurora.2.10.1".

        :stability: experimental
        '''
        return typing.cast("AuroraMysqlEngineVersion", jsii.sget(cls, "VER_2_10_1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_2_10_2")
    def VER_2_10_2(cls) -> "AuroraMysqlEngineVersion":
        '''(experimental) Version "5.7.mysql_aurora.2.10.2".

        :stability: experimental
        '''
        return typing.cast("AuroraMysqlEngineVersion", jsii.sget(cls, "VER_2_10_2"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_3_01_0")
    def VER_3_01_0(cls) -> "AuroraMysqlEngineVersion":
        '''(experimental) Version "8.0.mysql_aurora.3.01.0".

        :stability: experimental
        '''
        return typing.cast("AuroraMysqlEngineVersion", jsii.sget(cls, "VER_3_01_0"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_5_7_12")
    def VER_5_7_12(cls) -> "AuroraMysqlEngineVersion":
        '''(experimental) Version "5.7.12".

        :stability: experimental
        '''
        return typing.cast("AuroraMysqlEngineVersion", jsii.sget(cls, "VER_5_7_12"))

    @builtins.property
    @jsii.member(jsii_name="auroraMysqlFullVersion")
    def aurora_mysql_full_version(self) -> builtins.str:
        '''(experimental) The full version string, for example, "5.7.mysql_aurora.1.78.3.6".

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "auroraMysqlFullVersion"))

    @builtins.property
    @jsii.member(jsii_name="auroraMysqlMajorVersion")
    def aurora_mysql_major_version(self) -> builtins.str:
        '''(experimental) The major version of the engine.

        Currently, it's either "5.7", or "8.0".

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "auroraMysqlMajorVersion"))


@jsii.data_type(
    jsii_type="monocdk.aws_rds.AuroraPostgresClusterEngineProps",
    jsii_struct_bases=[],
    name_mapping={"version": "version"},
)
class AuroraPostgresClusterEngineProps:
    def __init__(self, *, version: "AuroraPostgresEngineVersion") -> None:
        '''(experimental) Creation properties of the Aurora PostgreSQL database cluster engine.

        Used in {@link DatabaseClusterEngine.auroraPostgres}.

        :param version: (experimental) The version of the Aurora PostgreSQL cluster engine.

        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_rds as rds
            
            # aurora_postgres_engine_version: rds.AuroraPostgresEngineVersion
            
            aurora_postgres_cluster_engine_props = rds.AuroraPostgresClusterEngineProps(
                version=aurora_postgres_engine_version
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2b4c629db41ee6de5308da377b29943bb89814a71ef45b451d5b51eac5419b18)
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "version": version,
        }

    @builtins.property
    def version(self) -> "AuroraPostgresEngineVersion":
        '''(experimental) The version of the Aurora PostgreSQL cluster engine.

        :stability: experimental
        '''
        result = self._values.get("version")
        assert result is not None, "Required property 'version' is missing"
        return typing.cast("AuroraPostgresEngineVersion", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AuroraPostgresClusterEngineProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_rds.AuroraPostgresEngineFeatures",
    jsii_struct_bases=[],
    name_mapping={"s3_export": "s3Export", "s3_import": "s3Import"},
)
class AuroraPostgresEngineFeatures:
    def __init__(
        self,
        *,
        s3_export: typing.Optional[builtins.bool] = None,
        s3_import: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''(experimental) Features supported by this version of the Aurora Postgres cluster engine.

        :param s3_export: (experimental) Whether this version of the Aurora Postgres cluster engine supports the S3 data export feature. Default: false
        :param s3_import: (experimental) Whether this version of the Aurora Postgres cluster engine supports the S3 data import feature. Default: false

        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_rds as rds
            
            aurora_postgres_engine_features = rds.AuroraPostgresEngineFeatures(
                s3_export=False,
                s3_import=False
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9085d942b8d590a04c16a5cf0a8ad801ddd5b18585bc31461eb73244c70afbb2)
            check_type(argname="argument s3_export", value=s3_export, expected_type=type_hints["s3_export"])
            check_type(argname="argument s3_import", value=s3_import, expected_type=type_hints["s3_import"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if s3_export is not None:
            self._values["s3_export"] = s3_export
        if s3_import is not None:
            self._values["s3_import"] = s3_import

    @builtins.property
    def s3_export(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Whether this version of the Aurora Postgres cluster engine supports the S3 data export feature.

        :default: false

        :stability: experimental
        '''
        result = self._values.get("s3_export")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def s3_import(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Whether this version of the Aurora Postgres cluster engine supports the S3 data import feature.

        :default: false

        :stability: experimental
        '''
        result = self._values.get("s3_import")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AuroraPostgresEngineFeatures(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AuroraPostgresEngineVersion(
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_rds.AuroraPostgresEngineVersion",
):
    '''(experimental) The versions for the Aurora PostgreSQL cluster engine (those returned by {@link DatabaseClusterEngine.auroraPostgres}).

    :stability: experimental
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from monocdk import aws_rds as rds
        
        aurora_postgres_engine_version = rds.AuroraPostgresEngineVersion.VER_10_11
    '''

    @jsii.member(jsii_name="of")
    @builtins.classmethod
    def of(
        cls,
        aurora_postgres_full_version: builtins.str,
        aurora_postgres_major_version: builtins.str,
        *,
        s3_export: typing.Optional[builtins.bool] = None,
        s3_import: typing.Optional[builtins.bool] = None,
    ) -> "AuroraPostgresEngineVersion":
        '''(experimental) Create a new AuroraPostgresEngineVersion with an arbitrary version.

        :param aurora_postgres_full_version: the full version string, for example "9.6.25.1".
        :param aurora_postgres_major_version: the major version of the engine, for example "9.6".
        :param s3_export: (experimental) Whether this version of the Aurora Postgres cluster engine supports the S3 data export feature. Default: false
        :param s3_import: (experimental) Whether this version of the Aurora Postgres cluster engine supports the S3 data import feature. Default: false

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a43f47cd31d05c8e2f0b7d7d37b2a2ef40c165192b1b895ae3d487142666f29d)
            check_type(argname="argument aurora_postgres_full_version", value=aurora_postgres_full_version, expected_type=type_hints["aurora_postgres_full_version"])
            check_type(argname="argument aurora_postgres_major_version", value=aurora_postgres_major_version, expected_type=type_hints["aurora_postgres_major_version"])
        aurora_postgres_features = AuroraPostgresEngineFeatures(
            s3_export=s3_export, s3_import=s3_import
        )

        return typing.cast("AuroraPostgresEngineVersion", jsii.sinvoke(cls, "of", [aurora_postgres_full_version, aurora_postgres_major_version, aurora_postgres_features]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_11")
    def VER_10_11(cls) -> "AuroraPostgresEngineVersion":
        '''(experimental) Version "10.11".

        :stability: experimental
        '''
        return typing.cast("AuroraPostgresEngineVersion", jsii.sget(cls, "VER_10_11"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_12")
    def VER_10_12(cls) -> "AuroraPostgresEngineVersion":
        '''(experimental) Version "10.12".

        :stability: experimental
        '''
        return typing.cast("AuroraPostgresEngineVersion", jsii.sget(cls, "VER_10_12"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_13")
    def VER_10_13(cls) -> "AuroraPostgresEngineVersion":
        '''(experimental) Version "10.13".

        :stability: experimental
        '''
        return typing.cast("AuroraPostgresEngineVersion", jsii.sget(cls, "VER_10_13"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_14")
    def VER_10_14(cls) -> "AuroraPostgresEngineVersion":
        '''(experimental) Version "10.14".

        :stability: experimental
        '''
        return typing.cast("AuroraPostgresEngineVersion", jsii.sget(cls, "VER_10_14"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_16")
    def VER_10_16(cls) -> "AuroraPostgresEngineVersion":
        '''(experimental) Version "10.16".

        :stability: experimental
        '''
        return typing.cast("AuroraPostgresEngineVersion", jsii.sget(cls, "VER_10_16"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_18")
    def VER_10_18(cls) -> "AuroraPostgresEngineVersion":
        '''(experimental) Version "10.18".

        :stability: experimental
        '''
        return typing.cast("AuroraPostgresEngineVersion", jsii.sget(cls, "VER_10_18"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_19")
    def VER_10_19(cls) -> "AuroraPostgresEngineVersion":
        '''(experimental) Version "10.19".

        :stability: experimental
        '''
        return typing.cast("AuroraPostgresEngineVersion", jsii.sget(cls, "VER_10_19"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_20")
    def VER_10_20(cls) -> "AuroraPostgresEngineVersion":
        '''(experimental) Version "10.20".

        :stability: experimental
        '''
        return typing.cast("AuroraPostgresEngineVersion", jsii.sget(cls, "VER_10_20"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_4")
    def VER_10_4(cls) -> "AuroraPostgresEngineVersion":
        '''(experimental) Version "10.4".

        :stability: experimental
        '''
        return typing.cast("AuroraPostgresEngineVersion", jsii.sget(cls, "VER_10_4"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_5")
    def VER_10_5(cls) -> "AuroraPostgresEngineVersion":
        '''(experimental) Version "10.5".

        :stability: experimental
        '''
        return typing.cast("AuroraPostgresEngineVersion", jsii.sget(cls, "VER_10_5"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_6")
    def VER_10_6(cls) -> "AuroraPostgresEngineVersion":
        '''(experimental) Version "10.6".

        :stability: experimental
        '''
        return typing.cast("AuroraPostgresEngineVersion", jsii.sget(cls, "VER_10_6"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_7")
    def VER_10_7(cls) -> "AuroraPostgresEngineVersion":
        '''(experimental) Version "10.7".

        :stability: experimental
        '''
        return typing.cast("AuroraPostgresEngineVersion", jsii.sget(cls, "VER_10_7"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_11")
    def VER_11_11(cls) -> "AuroraPostgresEngineVersion":
        '''(experimental) Version "11.11".

        :stability: experimental
        '''
        return typing.cast("AuroraPostgresEngineVersion", jsii.sget(cls, "VER_11_11"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_13")
    def VER_11_13(cls) -> "AuroraPostgresEngineVersion":
        '''(experimental) Version "11.13".

        :stability: experimental
        '''
        return typing.cast("AuroraPostgresEngineVersion", jsii.sget(cls, "VER_11_13"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_14")
    def VER_11_14(cls) -> "AuroraPostgresEngineVersion":
        '''(experimental) Version "11.14".

        :stability: experimental
        '''
        return typing.cast("AuroraPostgresEngineVersion", jsii.sget(cls, "VER_11_14"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_15")
    def VER_11_15(cls) -> "AuroraPostgresEngineVersion":
        '''(experimental) Version "11.15".

        :stability: experimental
        '''
        return typing.cast("AuroraPostgresEngineVersion", jsii.sget(cls, "VER_11_15"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_4")
    def VER_11_4(cls) -> "AuroraPostgresEngineVersion":
        '''(experimental) Version "11.4".

        :stability: experimental
        '''
        return typing.cast("AuroraPostgresEngineVersion", jsii.sget(cls, "VER_11_4"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_6")
    def VER_11_6(cls) -> "AuroraPostgresEngineVersion":
        '''(experimental) Version "11.6".

        :stability: experimental
        '''
        return typing.cast("AuroraPostgresEngineVersion", jsii.sget(cls, "VER_11_6"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_7")
    def VER_11_7(cls) -> "AuroraPostgresEngineVersion":
        '''(experimental) Version "11.7".

        :stability: experimental
        '''
        return typing.cast("AuroraPostgresEngineVersion", jsii.sget(cls, "VER_11_7"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_8")
    def VER_11_8(cls) -> "AuroraPostgresEngineVersion":
        '''(experimental) Version "11.8".

        :stability: experimental
        '''
        return typing.cast("AuroraPostgresEngineVersion", jsii.sget(cls, "VER_11_8"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_9")
    def VER_11_9(cls) -> "AuroraPostgresEngineVersion":
        '''(experimental) Version "11.9".

        :stability: experimental
        '''
        return typing.cast("AuroraPostgresEngineVersion", jsii.sget(cls, "VER_11_9"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_10")
    def VER_12_10(cls) -> "AuroraPostgresEngineVersion":
        '''(experimental) Version "12.10".

        :stability: experimental
        '''
        return typing.cast("AuroraPostgresEngineVersion", jsii.sget(cls, "VER_12_10"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_4")
    def VER_12_4(cls) -> "AuroraPostgresEngineVersion":
        '''(experimental) Version "12.4".

        :stability: experimental
        '''
        return typing.cast("AuroraPostgresEngineVersion", jsii.sget(cls, "VER_12_4"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_6")
    def VER_12_6(cls) -> "AuroraPostgresEngineVersion":
        '''(experimental) Version "12.6".

        :stability: experimental
        '''
        return typing.cast("AuroraPostgresEngineVersion", jsii.sget(cls, "VER_12_6"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_8")
    def VER_12_8(cls) -> "AuroraPostgresEngineVersion":
        '''(experimental) Version "12.8".

        :stability: experimental
        '''
        return typing.cast("AuroraPostgresEngineVersion", jsii.sget(cls, "VER_12_8"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_9")
    def VER_12_9(cls) -> "AuroraPostgresEngineVersion":
        '''(experimental) Version "12.8".

        :stability: experimental
        '''
        return typing.cast("AuroraPostgresEngineVersion", jsii.sget(cls, "VER_12_9"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_13_3")
    def VER_13_3(cls) -> "AuroraPostgresEngineVersion":
        '''(experimental) Version "13.3".

        :stability: experimental
        '''
        return typing.cast("AuroraPostgresEngineVersion", jsii.sget(cls, "VER_13_3"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_13_4")
    def VER_13_4(cls) -> "AuroraPostgresEngineVersion":
        '''(experimental) Version "13.4".

        :stability: experimental
        '''
        return typing.cast("AuroraPostgresEngineVersion", jsii.sget(cls, "VER_13_4"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_13_5")
    def VER_13_5(cls) -> "AuroraPostgresEngineVersion":
        '''(experimental) Version "13.5".

        :stability: experimental
        '''
        return typing.cast("AuroraPostgresEngineVersion", jsii.sget(cls, "VER_13_5"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_13_6")
    def VER_13_6(cls) -> "AuroraPostgresEngineVersion":
        '''(experimental) Version "13.6".

        :stability: experimental
        '''
        return typing.cast("AuroraPostgresEngineVersion", jsii.sget(cls, "VER_13_6"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_9_6_11")
    def VER_9_6_11(cls) -> "AuroraPostgresEngineVersion":
        '''(experimental) Version "9.6.11".

        :stability: experimental
        '''
        return typing.cast("AuroraPostgresEngineVersion", jsii.sget(cls, "VER_9_6_11"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_9_6_12")
    def VER_9_6_12(cls) -> "AuroraPostgresEngineVersion":
        '''(experimental) Version "9.6.12".

        :stability: experimental
        '''
        return typing.cast("AuroraPostgresEngineVersion", jsii.sget(cls, "VER_9_6_12"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_9_6_16")
    def VER_9_6_16(cls) -> "AuroraPostgresEngineVersion":
        '''(experimental) Version "9.6.16".

        :stability: experimental
        '''
        return typing.cast("AuroraPostgresEngineVersion", jsii.sget(cls, "VER_9_6_16"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_9_6_17")
    def VER_9_6_17(cls) -> "AuroraPostgresEngineVersion":
        '''(experimental) Version "9.6.17".

        :stability: experimental
        '''
        return typing.cast("AuroraPostgresEngineVersion", jsii.sget(cls, "VER_9_6_17"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_9_6_18")
    def VER_9_6_18(cls) -> "AuroraPostgresEngineVersion":
        '''(experimental) Version "9.6.18".

        :stability: experimental
        '''
        return typing.cast("AuroraPostgresEngineVersion", jsii.sget(cls, "VER_9_6_18"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_9_6_19")
    def VER_9_6_19(cls) -> "AuroraPostgresEngineVersion":
        '''(experimental) Version "9.6.19".

        :stability: experimental
        '''
        return typing.cast("AuroraPostgresEngineVersion", jsii.sget(cls, "VER_9_6_19"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_9_6_8")
    def VER_9_6_8(cls) -> "AuroraPostgresEngineVersion":
        '''(experimental) Version "9.6.8".

        :stability: experimental
        '''
        return typing.cast("AuroraPostgresEngineVersion", jsii.sget(cls, "VER_9_6_8"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_9_6_9")
    def VER_9_6_9(cls) -> "AuroraPostgresEngineVersion":
        '''(experimental) Version "9.6.9".

        :stability: experimental
        '''
        return typing.cast("AuroraPostgresEngineVersion", jsii.sget(cls, "VER_9_6_9"))

    @builtins.property
    @jsii.member(jsii_name="auroraPostgresFullVersion")
    def aurora_postgres_full_version(self) -> builtins.str:
        '''(experimental) The full version string, for example, "9.6.25.1".

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "auroraPostgresFullVersion"))

    @builtins.property
    @jsii.member(jsii_name="auroraPostgresMajorVersion")
    def aurora_postgres_major_version(self) -> builtins.str:
        '''(experimental) The major version of the engine, for example, "9.6".

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "auroraPostgresMajorVersion"))


@jsii.data_type(
    jsii_type="monocdk.aws_rds.BackupProps",
    jsii_struct_bases=[],
    name_mapping={"retention": "retention", "preferred_window": "preferredWindow"},
)
class BackupProps:
    def __init__(
        self,
        *,
        retention: _Duration_070aa057,
        preferred_window: typing.Optional[builtins.str] = None,
    ) -> None:
        '''(experimental) Backup configuration for RDS databases.

        :param retention: (experimental) How many days to retain the backup.
        :param preferred_window: (experimental) A daily time range in 24-hours UTC format in which backups preferably execute. Must be at least 30 minutes long. Example: '01:00-02:00' Default: - a 30-minute window selected at random from an 8-hour block of time for each AWS Region. To see the time blocks available, see https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithAutomatedBackups.html#USER_WorkingWithAutomatedBackups.BackupWindow

        :default:

        - The retention period for automated backups is 1 day.
        The preferred backup window will be a 30-minute window selected at random
        from an 8-hour block of time for each AWS Region.

        :see: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithAutomatedBackups.html#USER_WorkingWithAutomatedBackups.BackupWindow
        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            import monocdk as monocdk
            from monocdk import aws_rds as rds
            
            # duration: monocdk.Duration
            
            backup_props = rds.BackupProps(
                retention=duration,
            
                # the properties below are optional
                preferred_window="preferredWindow"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b5a1e24e3f8c4a56060780aab12ee63c3db9c83f06c19c6efb900be0b0ac673e)
            check_type(argname="argument retention", value=retention, expected_type=type_hints["retention"])
            check_type(argname="argument preferred_window", value=preferred_window, expected_type=type_hints["preferred_window"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "retention": retention,
        }
        if preferred_window is not None:
            self._values["preferred_window"] = preferred_window

    @builtins.property
    def retention(self) -> _Duration_070aa057:
        '''(experimental) How many days to retain the backup.

        :stability: experimental
        '''
        result = self._values.get("retention")
        assert result is not None, "Required property 'retention' is missing"
        return typing.cast(_Duration_070aa057, result)

    @builtins.property
    def preferred_window(self) -> typing.Optional[builtins.str]:
        '''(experimental) A daily time range in 24-hours UTC format in which backups preferably execute.

        Must be at least 30 minutes long.

        Example: '01:00-02:00'

        :default:

        - a 30-minute window selected at random from an 8-hour block of
        time for each AWS Region. To see the time blocks available, see
        https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithAutomatedBackups.html#USER_WorkingWithAutomatedBackups.BackupWindow

        :stability: experimental
        '''
        result = self._values.get("preferred_window")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "BackupProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_82c04a63)
class CfnDBCluster(
    _CfnResource_e0a482dc,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_rds.CfnDBCluster",
):
    '''A CloudFormation ``AWS::RDS::DBCluster``.

    The ``AWS::RDS::DBCluster`` resource creates an Amazon Aurora DB cluster or Multi-AZ DB cluster.

    For more information about creating an Aurora DB cluster, see `Creating an Amazon Aurora DB cluster <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.CreateInstance.html>`_ in the *Amazon Aurora User Guide* .

    For more information about creating a Multi-AZ DB cluster, see `Creating a Multi-AZ DB cluster <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/create-multi-az-db-cluster.html>`_ in the *Amazon RDS User Guide* .
    .. epigraph::

       You can only create this resource in AWS Regions where Amazon Aurora or Multi-AZ DB clusters are supported.

    *Updating DB clusters*

    When properties labeled " *Update requires:* `Replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ " are updated, AWS CloudFormation first creates a replacement DB cluster, then changes references from other dependent resources to point to the replacement DB cluster, and finally deletes the old DB cluster.
    .. epigraph::

       We highly recommend that you take a snapshot of the database before updating the stack. If you don't, you lose the data when AWS CloudFormation replaces your DB cluster. To preserve your data, perform the following procedure:

       - Deactivate any applications that are using the DB cluster so that there's no activity on the DB instance.
       - Create a snapshot of the DB cluster. For more information, see `Creating a DB Cluster Snapshot <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_CreateSnapshotCluster.html>`_ .
       - If you want to restore your DB cluster using a DB cluster snapshot, modify the updated template with your DB cluster changes and add the ``SnapshotIdentifier`` property with the ID of the DB cluster snapshot that you want to use.

       After you restore a DB cluster with a ``SnapshotIdentifier`` property, you must specify the same ``SnapshotIdentifier`` property for any future updates to the DB cluster. When you specify this property for an update, the DB cluster is not restored from the DB cluster snapshot again, and the data in the database is not changed. However, if you don't specify the ``SnapshotIdentifier`` property, an empty DB cluster is created, and the original DB cluster is deleted. If you specify a property that is different from the previous snapshot restore property, a new DB cluster is restored from the specified ``SnapshotIdentifier`` property, and the original DB cluster is deleted.

       - Update the stack.

    Currently, when you are updating the stack for an Aurora Serverless DB cluster, you can't include changes to any other properties when you specify one of the following properties: ``PreferredBackupWindow`` , ``PreferredMaintenanceWindow`` , and ``Port`` . This limitation doesn't apply to provisioned DB clusters.

    For more information about updating other properties of this resource, see ``[ModifyDBCluster](https://docs.aws.amazon.com//AmazonRDS/latest/APIReference/API_ModifyDBCluster.html)`` . For more information about updating stacks, see `AWS CloudFormation Stacks Updates <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks.html>`_ .

    *Deleting DB clusters*

    The default ``DeletionPolicy`` for ``AWS::RDS::DBCluster`` resources is ``Snapshot`` . For more information about how AWS CloudFormation deletes resources, see `DeletionPolicy Attribute <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html>`_ .

    :cloudformationResource: AWS::RDS::DBCluster
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from monocdk import aws_rds as rds
        
        cfn_dBCluster = rds.CfnDBCluster(self, "MyCfnDBCluster",
            allocated_storage=123,
            associated_roles=[rds.CfnDBCluster.DBClusterRoleProperty(
                role_arn="roleArn",
        
                # the properties below are optional
                feature_name="featureName"
            )],
            auto_minor_version_upgrade=False,
            availability_zones=["availabilityZones"],
            backtrack_window=123,
            backup_retention_period=123,
            copy_tags_to_snapshot=False,
            database_name="databaseName",
            db_cluster_identifier="dbClusterIdentifier",
            db_cluster_instance_class="dbClusterInstanceClass",
            db_cluster_parameter_group_name="dbClusterParameterGroupName",
            db_instance_parameter_group_name="dbInstanceParameterGroupName",
            db_subnet_group_name="dbSubnetGroupName",
            db_system_id="dbSystemId",
            deletion_protection=False,
            domain="domain",
            domain_iam_role_name="domainIamRoleName",
            enable_cloudwatch_logs_exports=["enableCloudwatchLogsExports"],
            enable_http_endpoint=False,
            enable_iam_database_authentication=False,
            engine="engine",
            engine_mode="engineMode",
            engine_version="engineVersion",
            global_cluster_identifier="globalClusterIdentifier",
            iops=123,
            kms_key_id="kmsKeyId",
            manage_master_user_password=False,
            master_username="masterUsername",
            master_user_password="masterUserPassword",
            master_user_secret=rds.CfnDBCluster.MasterUserSecretProperty(
                kms_key_id="kmsKeyId",
                secret_arn="secretArn"
            ),
            monitoring_interval=123,
            monitoring_role_arn="monitoringRoleArn",
            network_type="networkType",
            performance_insights_enabled=False,
            performance_insights_kms_key_id="performanceInsightsKmsKeyId",
            performance_insights_retention_period=123,
            port=123,
            preferred_backup_window="preferredBackupWindow",
            preferred_maintenance_window="preferredMaintenanceWindow",
            publicly_accessible=False,
            replication_source_identifier="replicationSourceIdentifier",
            restore_to_time="restoreToTime",
            restore_type="restoreType",
            scaling_configuration=rds.CfnDBCluster.ScalingConfigurationProperty(
                auto_pause=False,
                max_capacity=123,
                min_capacity=123,
                seconds_before_timeout=123,
                seconds_until_auto_pause=123,
                timeout_action="timeoutAction"
            ),
            serverless_v2_scaling_configuration=rds.CfnDBCluster.ServerlessV2ScalingConfigurationProperty(
                max_capacity=123,
                min_capacity=123
            ),
            snapshot_identifier="snapshotIdentifier",
            source_db_cluster_identifier="sourceDbClusterIdentifier",
            source_region="sourceRegion",
            storage_encrypted=False,
            storage_type="storageType",
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            use_latest_restorable_time=False,
            vpc_security_group_ids=["vpcSecurityGroupIds"]
        )
    '''

    def __init__(
        self,
        scope: _Construct_e78e779f,
        id: builtins.str,
        *,
        allocated_storage: typing.Optional[jsii.Number] = None,
        associated_roles: typing.Optional[typing.Union[_IResolvable_a771d0ef, typing.Sequence[typing.Union[typing.Union["CfnDBCluster.DBClusterRoleProperty", typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]]]] = None,
        auto_minor_version_upgrade: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        availability_zones: typing.Optional[typing.Sequence[builtins.str]] = None,
        backtrack_window: typing.Optional[jsii.Number] = None,
        backup_retention_period: typing.Optional[jsii.Number] = None,
        copy_tags_to_snapshot: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        database_name: typing.Optional[builtins.str] = None,
        db_cluster_identifier: typing.Optional[builtins.str] = None,
        db_cluster_instance_class: typing.Optional[builtins.str] = None,
        db_cluster_parameter_group_name: typing.Optional[builtins.str] = None,
        db_instance_parameter_group_name: typing.Optional[builtins.str] = None,
        db_subnet_group_name: typing.Optional[builtins.str] = None,
        db_system_id: typing.Optional[builtins.str] = None,
        deletion_protection: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        domain: typing.Optional[builtins.str] = None,
        domain_iam_role_name: typing.Optional[builtins.str] = None,
        enable_cloudwatch_logs_exports: typing.Optional[typing.Sequence[builtins.str]] = None,
        enable_http_endpoint: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        enable_iam_database_authentication: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        engine: typing.Optional[builtins.str] = None,
        engine_mode: typing.Optional[builtins.str] = None,
        engine_version: typing.Optional[builtins.str] = None,
        global_cluster_identifier: typing.Optional[builtins.str] = None,
        iops: typing.Optional[jsii.Number] = None,
        kms_key_id: typing.Optional[builtins.str] = None,
        manage_master_user_password: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        master_username: typing.Optional[builtins.str] = None,
        master_user_password: typing.Optional[builtins.str] = None,
        master_user_secret: typing.Optional[typing.Union[typing.Union["CfnDBCluster.MasterUserSecretProperty", typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]] = None,
        monitoring_interval: typing.Optional[jsii.Number] = None,
        monitoring_role_arn: typing.Optional[builtins.str] = None,
        network_type: typing.Optional[builtins.str] = None,
        performance_insights_enabled: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        performance_insights_kms_key_id: typing.Optional[builtins.str] = None,
        performance_insights_retention_period: typing.Optional[jsii.Number] = None,
        port: typing.Optional[jsii.Number] = None,
        preferred_backup_window: typing.Optional[builtins.str] = None,
        preferred_maintenance_window: typing.Optional[builtins.str] = None,
        publicly_accessible: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        replication_source_identifier: typing.Optional[builtins.str] = None,
        restore_to_time: typing.Optional[builtins.str] = None,
        restore_type: typing.Optional[builtins.str] = None,
        scaling_configuration: typing.Optional[typing.Union[typing.Union["CfnDBCluster.ScalingConfigurationProperty", typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]] = None,
        serverless_v2_scaling_configuration: typing.Optional[typing.Union[typing.Union["CfnDBCluster.ServerlessV2ScalingConfigurationProperty", typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]] = None,
        snapshot_identifier: typing.Optional[builtins.str] = None,
        source_db_cluster_identifier: typing.Optional[builtins.str] = None,
        source_region: typing.Optional[builtins.str] = None,
        storage_encrypted: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        storage_type: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union[_CfnTag_95fbdc29, typing.Dict[builtins.str, typing.Any]]]] = None,
        use_latest_restorable_time: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        vpc_security_group_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''Create a new ``AWS::RDS::DBCluster``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param allocated_storage: The amount of storage in gibibytes (GiB) to allocate to each DB instance in the Multi-AZ DB cluster. This setting is required to create a Multi-AZ DB cluster. Valid for: Multi-AZ DB clusters only
        :param associated_roles: Provides a list of the AWS Identity and Access Management (IAM) roles that are associated with the DB cluster. IAM roles that are associated with a DB cluster grant permission for the DB cluster to access other Amazon Web Services on your behalf. Valid for: Aurora DB clusters and Multi-AZ DB clusters
        :param auto_minor_version_upgrade: A value that indicates whether minor engine upgrades are applied automatically to the DB cluster during the maintenance window. By default, minor engine upgrades are applied automatically. Valid for: Multi-AZ DB clusters only
        :param availability_zones: A list of Availability Zones (AZs) where instances in the DB cluster can be created. For information on AWS Regions and Availability Zones, see `Choosing the Regions and Availability Zones <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Concepts.RegionsAndAvailabilityZones.html>`_ in the *Amazon Aurora User Guide* . Valid for: Aurora DB clusters only
        :param backtrack_window: The target backtrack window, in seconds. To disable backtracking, set this value to 0. .. epigraph:: Currently, Backtrack is only supported for Aurora MySQL DB clusters. Default: 0 Constraints: - If specified, this value must be set to a number from 0 to 259,200 (72 hours). Valid for: Aurora MySQL DB clusters only
        :param backup_retention_period: The number of days for which automated backups are retained. Default: 1 Constraints: - Must be a value from 1 to 35 Valid for: Aurora DB clusters and Multi-AZ DB clusters
        :param copy_tags_to_snapshot: A value that indicates whether to copy all tags from the DB cluster to snapshots of the DB cluster. The default is not to copy them. Valid for: Aurora DB clusters and Multi-AZ DB clusters
        :param database_name: The name of your database. If you don't provide a name, then Amazon RDS won't create a database in this DB cluster. For naming constraints, see `Naming Constraints <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/CHAP_Limits.html#RDS_Limits.Constraints>`_ in the *Amazon Aurora User Guide* . Valid for: Aurora DB clusters and Multi-AZ DB clusters
        :param db_cluster_identifier: The DB cluster identifier. This parameter is stored as a lowercase string. Constraints: - Must contain from 1 to 63 letters, numbers, or hyphens. - First character must be a letter. - Can't end with a hyphen or contain two consecutive hyphens. Example: ``my-cluster1`` Valid for: Aurora DB clusters and Multi-AZ DB clusters
        :param db_cluster_instance_class: The compute and memory capacity of each DB instance in the Multi-AZ DB cluster, for example db.m6gd.xlarge. Not all DB instance classes are available in all AWS Regions , or for all database engines. For the full list of DB instance classes and availability for your engine, see `DB instance class <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html>`_ in the *Amazon RDS User Guide* . This setting is required to create a Multi-AZ DB cluster. Valid for: Multi-AZ DB clusters only
        :param db_cluster_parameter_group_name: The name of the DB cluster parameter group to associate with this DB cluster. .. epigraph:: If you apply a parameter group to an existing DB cluster, then its DB instances might need to reboot. This can result in an outage while the DB instances are rebooting. If you apply a change to parameter group associated with a stopped DB cluster, then the update stack waits until the DB cluster is started. To list all of the available DB cluster parameter group names, use the following command: ``aws rds describe-db-cluster-parameter-groups --query "DBClusterParameterGroups[].DBClusterParameterGroupName" --output text`` Valid for: Aurora DB clusters and Multi-AZ DB clusters
        :param db_instance_parameter_group_name: The name of the DB parameter group to apply to all instances of the DB cluster. .. epigraph:: When you apply a parameter group using the ``DBInstanceParameterGroupName`` parameter, the DB cluster isn't rebooted automatically. Also, parameter changes are applied immediately rather than during the next maintenance window. Default: The existing name setting Constraints: - The DB parameter group must be in the same DB parameter group family as this DB cluster.
        :param db_subnet_group_name: A DB subnet group that you want to associate with this DB cluster. If you are restoring a DB cluster to a point in time with ``RestoreType`` set to ``copy-on-write`` , and don't specify a DB subnet group name, then the DB cluster is restored with a default DB subnet group. Valid for: Aurora DB clusters and Multi-AZ DB clusters
        :param db_system_id: Reserved for future use.
        :param deletion_protection: A value that indicates whether the DB cluster has deletion protection enabled. The database can't be deleted when deletion protection is enabled. By default, deletion protection is disabled. Valid for: Aurora DB clusters and Multi-AZ DB clusters
        :param domain: Indicates the directory ID of the Active Directory to create the DB cluster. For Amazon Aurora DB clusters, Amazon RDS can use Kerberos authentication to authenticate users that connect to the DB cluster. For more information, see `Kerberos authentication <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/kerberos-authentication.html>`_ in the *Amazon Aurora User Guide* . Valid for: Aurora DB clusters only
        :param domain_iam_role_name: Specifies the name of the IAM role to use when making API calls to the Directory Service. Valid for: Aurora DB clusters only
        :param enable_cloudwatch_logs_exports: The list of log types that need to be enabled for exporting to CloudWatch Logs. The values in the list depend on the DB engine being used. For more information, see `Publishing Database Logs to Amazon CloudWatch Logs <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_LogAccess.html#USER_LogAccess.Procedural.UploadtoCloudWatch>`_ in the *Amazon Aurora User Guide* . *Aurora MySQL* Valid values: ``audit`` , ``error`` , ``general`` , ``slowquery`` *Aurora PostgreSQL* Valid values: ``postgresql`` Valid for: Aurora DB clusters and Multi-AZ DB clusters
        :param enable_http_endpoint: A value that indicates whether to enable the HTTP endpoint for an Aurora Serverless DB cluster. By default, the HTTP endpoint is disabled. When enabled, the HTTP endpoint provides a connectionless web service API for running SQL queries on the Aurora Serverless DB cluster. You can also query your database from inside the RDS console with the query editor. For more information, see `Using the Data API for Aurora Serverless <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/data-api.html>`_ in the *Amazon Aurora User Guide* . Valid for: Aurora DB clusters only
        :param enable_iam_database_authentication: A value that indicates whether to enable mapping of AWS Identity and Access Management (IAM) accounts to database accounts. By default, mapping is disabled. For more information, see `IAM Database Authentication <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/UsingWithRDS.IAMDBAuth.html>`_ in the *Amazon Aurora User Guide.* Valid for: Aurora DB clusters only
        :param engine: The name of the database engine to be used for this DB cluster. Valid Values: - ``aurora-mysql`` - ``aurora-postgresql`` - ``mysql`` - ``postgres`` Valid for: Aurora DB clusters and Multi-AZ DB clusters
        :param engine_mode: The DB engine mode of the DB cluster, either ``provisioned`` or ``serverless`` . The ``serverless`` engine mode only supports Aurora Serverless v1. Currently, AWS CloudFormation doesn't support Aurora Serverless v2. Limitations and requirements apply to some DB engine modes. For more information, see the following sections in the *Amazon Aurora User Guide* : - `Limitations of Aurora Serverless v1 <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless.html#aurora-serverless.limitations>`_ - `Requirements for Aurora Serverless v2 <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless-v2.requirements.html>`_ - `Limitations of parallel query <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-mysql-parallel-query.html#aurora-mysql-parallel-query-limitations>`_ - `Limitations of Aurora global databases <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-global-database.html#aurora-global-database.limitations>`_ Valid for: Aurora DB clusters only
        :param engine_version: The version number of the database engine to use. To list all of the available engine versions for Aurora MySQL version 2 (5.7-compatible) and version 3 (8.0-compatible), use the following command: ``aws rds describe-db-engine-versions --engine aurora-mysql --query "DBEngineVersions[].EngineVersion"`` You can supply either ``5.7`` or ``8.0`` to use the default engine version for Aurora MySQL version 2 or version 3, respectively. To list all of the available engine versions for Aurora PostgreSQL, use the following command: ``aws rds describe-db-engine-versions --engine aurora-postgresql --query "DBEngineVersions[].EngineVersion"`` To list all of the available engine versions for RDS for MySQL, use the following command: ``aws rds describe-db-engine-versions --engine mysql --query "DBEngineVersions[].EngineVersion"`` To list all of the available engine versions for RDS for PostgreSQL, use the following command: ``aws rds describe-db-engine-versions --engine postgres --query "DBEngineVersions[].EngineVersion"`` *Aurora MySQL* For information, see `Database engine updates for Amazon Aurora MySQL <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/AuroraMySQL.Updates.html>`_ in the *Amazon Aurora User Guide* . *Aurora PostgreSQL* For information, see `Amazon Aurora PostgreSQL releases and engine versions <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/AuroraPostgreSQL.Updates.20180305.html>`_ in the *Amazon Aurora User Guide* . *MySQL* For information, see `Amazon RDS for MySQL <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_MySQL.html#MySQL.Concepts.VersionMgmt>`_ in the *Amazon RDS User Guide* . *PostgreSQL* For information, see `Amazon RDS for PostgreSQL <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_PostgreSQL.html#PostgreSQL.Concepts>`_ in the *Amazon RDS User Guide* . Valid for: Aurora DB clusters and Multi-AZ DB clusters
        :param global_cluster_identifier: If you are configuring an Aurora global database cluster and want your Aurora DB cluster to be a secondary member in the global database cluster, specify the global cluster ID of the global database cluster. To define the primary database cluster of the global cluster, use the `AWS::RDS::GlobalCluster <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-globalcluster.html>`_ resource. If you aren't configuring a global database cluster, don't specify this property. .. epigraph:: To remove the DB cluster from a global database cluster, specify an empty value for the ``GlobalClusterIdentifier`` property. For information about Aurora global databases, see `Working with Amazon Aurora Global Databases <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-global-database.html>`_ in the *Amazon Aurora User Guide* . Valid for: Aurora DB clusters only
        :param iops: The amount of Provisioned IOPS (input/output operations per second) to be initially allocated for each DB instance in the Multi-AZ DB cluster. For information about valid IOPS values, see `Provisioned IOPS storage <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Storage.html#USER_PIOPS>`_ in the *Amazon RDS User Guide* . This setting is required to create a Multi-AZ DB cluster. Constraints: Must be a multiple between .5 and 50 of the storage amount for the DB cluster. Valid for: Multi-AZ DB clusters only
        :param kms_key_id: The Amazon Resource Name (ARN) of the AWS KMS key that is used to encrypt the database instances in the DB cluster, such as ``arn:aws:kms:us-east-1:012345678910:key/abcd1234-a123-456a-a12b-a123b4cd56ef`` . If you enable the ``StorageEncrypted`` property but don't specify this property, the default KMS key is used. If you specify this property, you must set the ``StorageEncrypted`` property to ``true`` . If you specify the ``SnapshotIdentifier`` property, the ``StorageEncrypted`` property value is inherited from the snapshot, and if the DB cluster is encrypted, the specified ``KmsKeyId`` property is used. Valid for: Aurora DB clusters and Multi-AZ DB clusters
        :param manage_master_user_password: A value that indicates whether to manage the master user password with AWS Secrets Manager. For more information, see `Password management with AWS Secrets Manager <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-secrets-manager.html>`_ in the *Amazon RDS User Guide* and `Password management with AWS Secrets Manager <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/rds-secrets-manager.html>`_ in the *Amazon Aurora User Guide.* Constraints: - Can't manage the master user password with AWS Secrets Manager if ``MasterUserPassword`` is specified. Valid for: Aurora DB clusters and Multi-AZ DB clusters
        :param master_username: The name of the master user for the DB cluster. .. epigraph:: If you specify the ``SourceDBClusterIdentifier`` , ``SnapshotIdentifier`` , or ``GlobalClusterIdentifier`` property, don't specify this property. The value is inherited from the source DB cluster, the snapshot, or the primary DB cluster for the global database cluster, respectively. Valid for: Aurora DB clusters and Multi-AZ DB clusters
        :param master_user_password: The master password for the DB instance. .. epigraph:: If you specify the ``SourceDBClusterIdentifier`` , ``SnapshotIdentifier`` , or ``GlobalClusterIdentifier`` property, don't specify this property. The value is inherited from the source DB cluster, the snapshot, or the primary DB cluster for the global database cluster, respectively. Valid for: Aurora DB clusters and Multi-AZ DB clusters
        :param master_user_secret: Contains the secret managed by RDS in AWS Secrets Manager for the master user password. For more information, see `Password management with AWS Secrets Manager <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-secrets-manager.html>`_ in the *Amazon RDS User Guide* and `Password management with AWS Secrets Manager <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/rds-secrets-manager.html>`_ in the *Amazon Aurora User Guide.*
        :param monitoring_interval: The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the DB cluster. To turn off collecting Enhanced Monitoring metrics, specify 0. The default is 0. If ``MonitoringRoleArn`` is specified, also set ``MonitoringInterval`` to a value other than 0. Valid Values: ``0, 1, 5, 10, 15, 30, 60`` Valid for: Multi-AZ DB clusters only
        :param monitoring_role_arn: The Amazon Resource Name (ARN) for the IAM role that permits RDS to send Enhanced Monitoring metrics to Amazon CloudWatch Logs. An example is ``arn:aws:iam:123456789012:role/emaccess`` . For information on creating a monitoring role, see `Setting up and enabling Enhanced Monitoring <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Monitoring.OS.html#USER_Monitoring.OS.Enabling>`_ in the *Amazon RDS User Guide* . If ``MonitoringInterval`` is set to a value other than 0, supply a ``MonitoringRoleArn`` value. Valid for: Multi-AZ DB clusters only
        :param network_type: The network type of the DB cluster. Valid values: - ``IPV4`` - ``DUAL`` The network type is determined by the ``DBSubnetGroup`` specified for the DB cluster. A ``DBSubnetGroup`` can support only the IPv4 protocol or the IPv4 and IPv6 protocols ( ``DUAL`` ). For more information, see `Working with a DB instance in a VPC <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_VPC.WorkingWithRDSInstanceinaVPC.html>`_ in the *Amazon Aurora User Guide.* Valid for: Aurora DB clusters only
        :param performance_insights_enabled: A value that indicates whether to turn on Performance Insights for the DB cluster. For more information, see `Using Amazon Performance Insights <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PerfInsights.html>`_ in the *Amazon RDS User Guide* . Valid for: Multi-AZ DB clusters only
        :param performance_insights_kms_key_id: The AWS KMS key identifier for encryption of Performance Insights data. The AWS KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. If you don't specify a value for ``PerformanceInsightsKMSKeyId`` , then Amazon RDS uses your default KMS key. There is a default KMS key for your AWS account . Your AWS account has a different default KMS key for each AWS Region . Valid for: Multi-AZ DB clusters only
        :param performance_insights_retention_period: The number of days to retain Performance Insights data. The default is 7 days. The following values are valid:. - 7 - *month* * 31, where *month* is a number of months from 1-23 - 731 For example, the following values are valid: - 93 (3 months * 31) - 341 (11 months * 31) - 589 (19 months * 31) - 731 If you specify a retention period such as 94, which isn't a valid value, RDS issues an error. Valid for: Multi-AZ DB clusters only
        :param port: The port number on which the DB instances in the DB cluster accept connections. Default: - When ``EngineMode`` is ``provisioned`` , ``3306`` (for both Aurora MySQL and Aurora PostgreSQL) - When ``EngineMode`` is ``serverless`` : - ``3306`` when ``Engine`` is ``aurora`` or ``aurora-mysql`` - ``5432`` when ``Engine`` is ``aurora-postgresql`` .. epigraph:: The ``No interruption`` on update behavior only applies to DB clusters. If you are updating a DB instance, see `Port <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-database-instance.html#cfn-rds-dbinstance-port>`_ for the AWS::RDS::DBInstance resource. Valid for: Aurora DB clusters and Multi-AZ DB clusters
        :param preferred_backup_window: The daily time range during which automated backups are created. For more information, see `Backup Window <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.Managing.Backups.html#Aurora.Managing.Backups.BackupWindow>`_ in the *Amazon Aurora User Guide.* Constraints: - Must be in the format ``hh24:mi-hh24:mi`` . - Must be in Universal Coordinated Time (UTC). - Must not conflict with the preferred maintenance window. - Must be at least 30 minutes. Valid for: Aurora DB clusters and Multi-AZ DB clusters
        :param preferred_maintenance_window: The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC). Format: ``ddd:hh24:mi-ddd:hh24:mi`` The default is a 30-minute window selected at random from an 8-hour block of time for each AWS Region, occurring on a random day of the week. To see the time blocks available, see `Adjusting the Preferred DB Cluster Maintenance Window <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_UpgradeDBInstance.Maintenance.html#AdjustingTheMaintenanceWindow.Aurora>`_ in the *Amazon Aurora User Guide.* Valid Days: Mon, Tue, Wed, Thu, Fri, Sat, Sun. Constraints: Minimum 30-minute window. Valid for: Aurora DB clusters and Multi-AZ DB clusters
        :param publicly_accessible: A value that indicates whether the DB cluster is publicly accessible. When the DB cluster is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address from within the DB cluster's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB cluster's VPC. Access to the DB cluster is ultimately controlled by the security group it uses. That public access isn't permitted if the security group assigned to the DB cluster doesn't permit it. When the DB cluster isn't publicly accessible, it is an internal DB cluster with a DNS name that resolves to a private IP address. Default: The default behavior varies depending on whether ``DBSubnetGroupName`` is specified. If ``DBSubnetGroupName`` isn't specified, and ``PubliclyAccessible`` isn't specified, the following applies: - If the default VPC in the target Region doesnt have an internet gateway attached to it, the DB cluster is private. - If the default VPC in the target Region has an internet gateway attached to it, the DB cluster is public. If ``DBSubnetGroupName`` is specified, and ``PubliclyAccessible`` isn't specified, the following applies: - If the subnets are part of a VPC that doesnt have an internet gateway attached to it, the DB cluster is private. - If the subnets are part of a VPC that has an internet gateway attached to it, the DB cluster is public. Valid for: Multi-AZ DB clusters only
        :param replication_source_identifier: The Amazon Resource Name (ARN) of the source DB instance or DB cluster if this DB cluster is created as a read replica. Valid for: Aurora DB clusters only
        :param restore_to_time: The date and time to restore the DB cluster to. Valid Values: Value must be a time in Universal Coordinated Time (UTC) format Constraints: - Must be before the latest restorable time for the DB instance - Must be specified if ``UseLatestRestorableTime`` parameter isn't provided - Can't be specified if the ``UseLatestRestorableTime`` parameter is enabled - Can't be specified if the ``RestoreType`` parameter is ``copy-on-write`` Example: ``2015-03-07T23:45:00Z`` Valid for: Aurora DB clusters and Multi-AZ DB clusters
        :param restore_type: The type of restore to be performed. You can specify one of the following values:. - ``full-copy`` - The new DB cluster is restored as a full copy of the source DB cluster. - ``copy-on-write`` - The new DB cluster is restored as a clone of the source DB cluster. If you don't specify a ``RestoreType`` value, then the new DB cluster is restored as a full copy of the source DB cluster. Valid for: Aurora DB clusters and Multi-AZ DB clusters
        :param scaling_configuration: The ``ScalingConfiguration`` property type specifies the scaling configuration of an Aurora Serverless DB cluster. This property is only supported for Aurora Serverless v1. For Aurora Serverless v2, use ``ServerlessV2ScalingConfiguration`` property. Valid for: Aurora DB clusters only
        :param serverless_v2_scaling_configuration: The ``ServerlessV2ScalingConfiguration`` property type specifies the scaling configuration of an Aurora Serverless V2 DB cluster. This property is only supported for Aurora Serverless v2. For Aurora Serverless v1, use ``ScalingConfiguration`` property. Valid for: Aurora DB clusters only
        :param snapshot_identifier: The identifier for the DB snapshot or DB cluster snapshot to restore from. You can use either the name or the Amazon Resource Name (ARN) to specify a DB cluster snapshot. However, you can use only the ARN to specify a DB snapshot. After you restore a DB cluster with a ``SnapshotIdentifier`` property, you must specify the same ``SnapshotIdentifier`` property for any future updates to the DB cluster. When you specify this property for an update, the DB cluster is not restored from the snapshot again, and the data in the database is not changed. However, if you don't specify the ``SnapshotIdentifier`` property, an empty DB cluster is created, and the original DB cluster is deleted. If you specify a property that is different from the previous snapshot restore property, a new DB cluster is restored from the specified ``SnapshotIdentifier`` property, and the original DB cluster is deleted. If you specify the ``SnapshotIdentifier`` property to restore a DB cluster (as opposed to specifying it for DB cluster updates), then don't specify the following properties: - ``GlobalClusterIdentifier`` - ``MasterUsername`` - ``MasterUserPassword`` - ``ReplicationSourceIdentifier`` - ``RestoreType`` - ``SourceDBClusterIdentifier`` - ``SourceRegion`` - ``StorageEncrypted`` (for an encrypted snapshot) - ``UseLatestRestorableTime`` Constraints: - Must match the identifier of an existing Snapshot. Valid for: Aurora DB clusters and Multi-AZ DB clusters
        :param source_db_cluster_identifier: When restoring a DB cluster to a point in time, the identifier of the source DB cluster from which to restore. Constraints: - Must match the identifier of an existing DBCluster. Valid for: Aurora DB clusters and Multi-AZ DB clusters
        :param source_region: The AWS Region which contains the source DB cluster when replicating a DB cluster. For example, ``us-east-1`` . Valid for: Aurora DB clusters only
        :param storage_encrypted: Indicates whether the DB cluster is encrypted. If you specify the ``KmsKeyId`` property, then you must enable encryption. If you specify the ``SourceDBClusterIdentifier`` property, don't specify this property. The value is inherited from the source DB cluster, and if the DB cluster is encrypted, the specified ``KmsKeyId`` property is used. If you specify the ``SnapshotIdentifier`` and the specified snapshot is encrypted, don't specify this property. The value is inherited from the snapshot, and the specified ``KmsKeyId`` property is used. If you specify the ``SnapshotIdentifier`` and the specified snapshot isn't encrypted, you can use this property to specify that the restored DB cluster is encrypted. Specify the ``KmsKeyId`` property for the KMS key to use for encryption. If you don't want the restored DB cluster to be encrypted, then don't set this property or set it to ``false`` . Valid for: Aurora DB clusters and Multi-AZ DB clusters
        :param storage_type: Specifies the storage type to be associated with the DB cluster. This setting is required to create a Multi-AZ DB cluster. When specified for a Multi-AZ DB cluster, a value for the ``Iops`` parameter is required. Valid values: ``aurora`` , ``aurora-iopt1`` (Aurora DB clusters); ``io1`` (Multi-AZ DB clusters) Default: ``aurora`` (Aurora DB clusters); ``io1`` (Multi-AZ DB clusters) Valid for: Aurora DB clusters and Multi-AZ DB clusters For more information on storage types for Aurora DB clusters, see `Storage configurations for Amazon Aurora DB clusters <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.Overview.StorageReliability.html#aurora-storage-type>`_ . For more information on storage types for Multi-AZ DB clusters, see `Settings for creating Multi-AZ DB clusters <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/create-multi-az-db-cluster.html#create-multi-az-db-cluster-settings>`_ .
        :param tags: An optional array of key-value pairs to apply to this DB cluster. Valid for: Aurora DB clusters and Multi-AZ DB clusters
        :param use_latest_restorable_time: A value that indicates whether to restore the DB cluster to the latest restorable backup time. By default, the DB cluster is not restored to the latest restorable backup time. Valid for: Aurora DB clusters and Multi-AZ DB clusters
        :param vpc_security_group_ids: A list of EC2 VPC security groups to associate with this DB cluster. If you plan to update the resource, don't specify VPC security groups in a shared VPC. Valid for: Aurora DB clusters and Multi-AZ DB clusters
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fad3e37488adcfe432af638bddae1d023194b2867e142ecc7586dc9160ca1502)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = CfnDBClusterProps(
            allocated_storage=allocated_storage,
            associated_roles=associated_roles,
            auto_minor_version_upgrade=auto_minor_version_upgrade,
            availability_zones=availability_zones,
            backtrack_window=backtrack_window,
            backup_retention_period=backup_retention_period,
            copy_tags_to_snapshot=copy_tags_to_snapshot,
            database_name=database_name,
            db_cluster_identifier=db_cluster_identifier,
            db_cluster_instance_class=db_cluster_instance_class,
            db_cluster_parameter_group_name=db_cluster_parameter_group_name,
            db_instance_parameter_group_name=db_instance_parameter_group_name,
            db_subnet_group_name=db_subnet_group_name,
            db_system_id=db_system_id,
            deletion_protection=deletion_protection,
            domain=domain,
            domain_iam_role_name=domain_iam_role_name,
            enable_cloudwatch_logs_exports=enable_cloudwatch_logs_exports,
            enable_http_endpoint=enable_http_endpoint,
            enable_iam_database_authentication=enable_iam_database_authentication,
            engine=engine,
            engine_mode=engine_mode,
            engine_version=engine_version,
            global_cluster_identifier=global_cluster_identifier,
            iops=iops,
            kms_key_id=kms_key_id,
            manage_master_user_password=manage_master_user_password,
            master_username=master_username,
            master_user_password=master_user_password,
            master_user_secret=master_user_secret,
            monitoring_interval=monitoring_interval,
            monitoring_role_arn=monitoring_role_arn,
            network_type=network_type,
            performance_insights_enabled=performance_insights_enabled,
            performance_insights_kms_key_id=performance_insights_kms_key_id,
            performance_insights_retention_period=performance_insights_retention_period,
            port=port,
            preferred_backup_window=preferred_backup_window,
            preferred_maintenance_window=preferred_maintenance_window,
            publicly_accessible=publicly_accessible,
            replication_source_identifier=replication_source_identifier,
            restore_to_time=restore_to_time,
            restore_type=restore_type,
            scaling_configuration=scaling_configuration,
            serverless_v2_scaling_configuration=serverless_v2_scaling_configuration,
            snapshot_identifier=snapshot_identifier,
            source_db_cluster_identifier=source_db_cluster_identifier,
            source_region=source_region,
            storage_encrypted=storage_encrypted,
            storage_type=storage_type,
            tags=tags,
            use_latest_restorable_time=use_latest_restorable_time,
            vpc_security_group_ids=vpc_security_group_ids,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_1cd1894e) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8960c819422abc214366fa8fa8831fd2ea2a96fef89f73a9b865ca0cc4679224)
            check_type(argname="argument inspector", value=inspector, expected_type=type_hints["inspector"])
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6b27e5abf5e16a7e4d6239e5b71687492dff36a63ced8673d12f997ebadebd0f)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrDbClusterArn")
    def attr_db_cluster_arn(self) -> builtins.str:
        '''The Amazon Resource Name (ARN) for the DB cluster.

        :cloudformationAttribute: DBClusterArn
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrDbClusterArn"))

    @builtins.property
    @jsii.member(jsii_name="attrDbClusterResourceId")
    def attr_db_cluster_resource_id(self) -> builtins.str:
        '''The AWS Region -unique, immutable identifier for the DB cluster.

        This identifier is found in AWS CloudTrail log entries whenever the KMS key for the DB cluster is accessed.

        :cloudformationAttribute: DBClusterResourceId
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrDbClusterResourceId"))

    @builtins.property
    @jsii.member(jsii_name="attrEndpointAddress")
    def attr_endpoint_address(self) -> builtins.str:
        '''The connection endpoint for the DB cluster.

        For example: ``mystack-mydbcluster-123456789012.us-east-2.rds.amazonaws.com``

        :cloudformationAttribute: Endpoint.Address
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrEndpointAddress"))

    @builtins.property
    @jsii.member(jsii_name="attrEndpointPort")
    def attr_endpoint_port(self) -> builtins.str:
        '''The port number that will accept connections on this DB cluster.

        For example: ``3306``

        :cloudformationAttribute: Endpoint.Port
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrEndpointPort"))

    @builtins.property
    @jsii.member(jsii_name="attrMasterUserSecretSecretArn")
    def attr_master_user_secret_secret_arn(self) -> builtins.str:
        '''The Amazon Resource Name (ARN) of the secret.

        :cloudformationAttribute: MasterUserSecret.SecretArn
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrMasterUserSecretSecretArn"))

    @builtins.property
    @jsii.member(jsii_name="attrReadEndpointAddress")
    def attr_read_endpoint_address(self) -> builtins.str:
        '''The reader endpoint for the DB cluster.

        For example: ``mystack-mydbcluster-ro-123456789012.us-east-2.rds.amazonaws.com``

        :cloudformationAttribute: ReadEndpoint.Address
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrReadEndpointAddress"))

    @builtins.property
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property
    @jsii.member(jsii_name="tags")
    def tags(self) -> _TagManager_0b7ab120:
        '''An optional array of key-value pairs to apply to this DB cluster.

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-tags
        '''
        return typing.cast(_TagManager_0b7ab120, jsii.get(self, "tags"))

    @builtins.property
    @jsii.member(jsii_name="allocatedStorage")
    def allocated_storage(self) -> typing.Optional[jsii.Number]:
        '''The amount of storage in gibibytes (GiB) to allocate to each DB instance in the Multi-AZ DB cluster.

        This setting is required to create a Multi-AZ DB cluster.

        Valid for: Multi-AZ DB clusters only

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-allocatedstorage
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "allocatedStorage"))

    @allocated_storage.setter
    def allocated_storage(self, value: typing.Optional[jsii.Number]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__386b040cbe6f3c10c54bea81e83ebd5be3ae5d5b94c43825de9227f29bda129d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "allocatedStorage", value)

    @builtins.property
    @jsii.member(jsii_name="associatedRoles")
    def associated_roles(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_a771d0ef, typing.List[typing.Union["CfnDBCluster.DBClusterRoleProperty", _IResolvable_a771d0ef]]]]:
        '''Provides a list of the AWS Identity and Access Management (IAM) roles that are associated with the DB cluster.

        IAM roles that are associated with a DB cluster grant permission for the DB cluster to access other Amazon Web Services on your behalf.

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-associatedroles
        '''
        return typing.cast(typing.Optional[typing.Union[_IResolvable_a771d0ef, typing.List[typing.Union["CfnDBCluster.DBClusterRoleProperty", _IResolvable_a771d0ef]]]], jsii.get(self, "associatedRoles"))

    @associated_roles.setter
    def associated_roles(
        self,
        value: typing.Optional[typing.Union[_IResolvable_a771d0ef, typing.List[typing.Union["CfnDBCluster.DBClusterRoleProperty", _IResolvable_a771d0ef]]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dd8fb8bda40030a7a1013e4e6ea5e7095b69673294f8045a9de98c9e84376ca8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "associatedRoles", value)

    @builtins.property
    @jsii.member(jsii_name="autoMinorVersionUpgrade")
    def auto_minor_version_upgrade(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''A value that indicates whether minor engine upgrades are applied automatically to the DB cluster during the maintenance window.

        By default, minor engine upgrades are applied automatically.

        Valid for: Multi-AZ DB clusters only

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-autominorversionupgrade
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], jsii.get(self, "autoMinorVersionUpgrade"))

    @auto_minor_version_upgrade.setter
    def auto_minor_version_upgrade(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3771cd695e45fe4fd034db09b990167f3573c2d96699da6e172a2c3ffc8b00cf)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "autoMinorVersionUpgrade", value)

    @builtins.property
    @jsii.member(jsii_name="availabilityZones")
    def availability_zones(self) -> typing.Optional[typing.List[builtins.str]]:
        '''A list of Availability Zones (AZs) where instances in the DB cluster can be created.

        For information on AWS Regions and Availability Zones, see `Choosing the Regions and Availability Zones <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Concepts.RegionsAndAvailabilityZones.html>`_ in the *Amazon Aurora User Guide* .

        Valid for: Aurora DB clusters only

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-availabilityzones
        '''
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "availabilityZones"))

    @availability_zones.setter
    def availability_zones(
        self,
        value: typing.Optional[typing.List[builtins.str]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__408f422a31dd55d1c4d71cd9c37f56c30e171aa7b3bf032caffc6e1e24faa79a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "availabilityZones", value)

    @builtins.property
    @jsii.member(jsii_name="backtrackWindow")
    def backtrack_window(self) -> typing.Optional[jsii.Number]:
        '''The target backtrack window, in seconds. To disable backtracking, set this value to 0.

        .. epigraph::

           Currently, Backtrack is only supported for Aurora MySQL DB clusters.

        Default: 0

        Constraints:

        - If specified, this value must be set to a number from 0 to 259,200 (72 hours).

        Valid for: Aurora MySQL DB clusters only

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-backtrackwindow
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "backtrackWindow"))

    @backtrack_window.setter
    def backtrack_window(self, value: typing.Optional[jsii.Number]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__114e6ca764e3c5709ac3ea154a41e503ca665aedde4e6467d03158224c1085cd)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "backtrackWindow", value)

    @builtins.property
    @jsii.member(jsii_name="backupRetentionPeriod")
    def backup_retention_period(self) -> typing.Optional[jsii.Number]:
        '''The number of days for which automated backups are retained.

        Default: 1

        Constraints:

        - Must be a value from 1 to 35

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-backupretentionperiod
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "backupRetentionPeriod"))

    @backup_retention_period.setter
    def backup_retention_period(self, value: typing.Optional[jsii.Number]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__84a87d33782031b8f18d5c5cbf42a71ce8a900cfa7a211eb1d87e4eead8e37bd)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "backupRetentionPeriod", value)

    @builtins.property
    @jsii.member(jsii_name="copyTagsToSnapshot")
    def copy_tags_to_snapshot(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''A value that indicates whether to copy all tags from the DB cluster to snapshots of the DB cluster.

        The default is not to copy them.

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-copytagstosnapshot
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], jsii.get(self, "copyTagsToSnapshot"))

    @copy_tags_to_snapshot.setter
    def copy_tags_to_snapshot(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9c5af09150d5eb3c46e3271d3c2507f1752387c7c6a38d78ea1d8ed345d31593)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "copyTagsToSnapshot", value)

    @builtins.property
    @jsii.member(jsii_name="databaseName")
    def database_name(self) -> typing.Optional[builtins.str]:
        '''The name of your database.

        If you don't provide a name, then Amazon RDS won't create a database in this DB cluster. For naming constraints, see `Naming Constraints <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/CHAP_Limits.html#RDS_Limits.Constraints>`_ in the *Amazon Aurora User Guide* .

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-databasename
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "databaseName"))

    @database_name.setter
    def database_name(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__df9c79471b7452019fd10772162b00ba6c1a77aabc4f50f3537cf0f1f6c3b087)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "databaseName", value)

    @builtins.property
    @jsii.member(jsii_name="dbClusterIdentifier")
    def db_cluster_identifier(self) -> typing.Optional[builtins.str]:
        '''The DB cluster identifier. This parameter is stored as a lowercase string.

        Constraints:

        - Must contain from 1 to 63 letters, numbers, or hyphens.
        - First character must be a letter.
        - Can't end with a hyphen or contain two consecutive hyphens.

        Example: ``my-cluster1``

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-dbclusteridentifier
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "dbClusterIdentifier"))

    @db_cluster_identifier.setter
    def db_cluster_identifier(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__20ae20303ba62c81daa1973cf3e8b55d1a437c5e4a0f77a5583e04b674a2a258)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dbClusterIdentifier", value)

    @builtins.property
    @jsii.member(jsii_name="dbClusterInstanceClass")
    def db_cluster_instance_class(self) -> typing.Optional[builtins.str]:
        '''The compute and memory capacity of each DB instance in the Multi-AZ DB cluster, for example db.m6gd.xlarge. Not all DB instance classes are available in all AWS Regions , or for all database engines.

        For the full list of DB instance classes and availability for your engine, see `DB instance class <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html>`_ in the *Amazon RDS User Guide* .

        This setting is required to create a Multi-AZ DB cluster.

        Valid for: Multi-AZ DB clusters only

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-dbclusterinstanceclass
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "dbClusterInstanceClass"))

    @db_cluster_instance_class.setter
    def db_cluster_instance_class(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a11ea5e9c0290b309ed3f8e5b79b20926eb9f161c140bd9573747d6be33a2546)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dbClusterInstanceClass", value)

    @builtins.property
    @jsii.member(jsii_name="dbClusterParameterGroupName")
    def db_cluster_parameter_group_name(self) -> typing.Optional[builtins.str]:
        '''The name of the DB cluster parameter group to associate with this DB cluster.

        .. epigraph::

           If you apply a parameter group to an existing DB cluster, then its DB instances might need to reboot. This can result in an outage while the DB instances are rebooting.

           If you apply a change to parameter group associated with a stopped DB cluster, then the update stack waits until the DB cluster is started.

        To list all of the available DB cluster parameter group names, use the following command:

        ``aws rds describe-db-cluster-parameter-groups --query "DBClusterParameterGroups[].DBClusterParameterGroupName" --output text``

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-dbclusterparametergroupname
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "dbClusterParameterGroupName"))

    @db_cluster_parameter_group_name.setter
    def db_cluster_parameter_group_name(
        self,
        value: typing.Optional[builtins.str],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0bd0cc3b48b2769856c7269df2d44fb64c3a11dfa3fa4cb9bb7a96ca5272bfde)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dbClusterParameterGroupName", value)

    @builtins.property
    @jsii.member(jsii_name="dbInstanceParameterGroupName")
    def db_instance_parameter_group_name(self) -> typing.Optional[builtins.str]:
        '''The name of the DB parameter group to apply to all instances of the DB cluster.

        .. epigraph::

           When you apply a parameter group using the ``DBInstanceParameterGroupName`` parameter, the DB cluster isn't rebooted automatically. Also, parameter changes are applied immediately rather than during the next maintenance window.

        Default: The existing name setting

        Constraints:

        - The DB parameter group must be in the same DB parameter group family as this DB cluster.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-dbinstanceparametergroupname
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "dbInstanceParameterGroupName"))

    @db_instance_parameter_group_name.setter
    def db_instance_parameter_group_name(
        self,
        value: typing.Optional[builtins.str],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__12397ce7c2ed833d0cadb856189d10d17d9fafa20d79a1ed9b817d7cf585ca6a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dbInstanceParameterGroupName", value)

    @builtins.property
    @jsii.member(jsii_name="dbSubnetGroupName")
    def db_subnet_group_name(self) -> typing.Optional[builtins.str]:
        '''A DB subnet group that you want to associate with this DB cluster.

        If you are restoring a DB cluster to a point in time with ``RestoreType`` set to ``copy-on-write`` , and don't specify a DB subnet group name, then the DB cluster is restored with a default DB subnet group.

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-dbsubnetgroupname
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "dbSubnetGroupName"))

    @db_subnet_group_name.setter
    def db_subnet_group_name(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a8aa1d06b3abd55c08a15d1077d14e9e220d661551c8bf82d6fd271ebe7012ce)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dbSubnetGroupName", value)

    @builtins.property
    @jsii.member(jsii_name="dbSystemId")
    def db_system_id(self) -> typing.Optional[builtins.str]:
        '''Reserved for future use.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-dbsystemid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "dbSystemId"))

    @db_system_id.setter
    def db_system_id(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e16319c747203d89c13edef5a1628f68635e5a425f15c9aea47c9eb6dd9e67c1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dbSystemId", value)

    @builtins.property
    @jsii.member(jsii_name="deletionProtection")
    def deletion_protection(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''A value that indicates whether the DB cluster has deletion protection enabled.

        The database can't be deleted when deletion protection is enabled. By default, deletion protection is disabled.

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-deletionprotection
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], jsii.get(self, "deletionProtection"))

    @deletion_protection.setter
    def deletion_protection(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__72dd2ca3ca9fcc3cb0f3e30850f1756f5c3b14794ab3e1f47dbb66dafa66408f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "deletionProtection", value)

    @builtins.property
    @jsii.member(jsii_name="domain")
    def domain(self) -> typing.Optional[builtins.str]:
        '''Indicates the directory ID of the Active Directory to create the DB cluster.

        For Amazon Aurora DB clusters, Amazon RDS can use Kerberos authentication to authenticate users that connect to the DB cluster.

        For more information, see `Kerberos authentication <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/kerberos-authentication.html>`_ in the *Amazon Aurora User Guide* .

        Valid for: Aurora DB clusters only

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-domain
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "domain"))

    @domain.setter
    def domain(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c59094c7379b5e083bbb69f6b969b695cc35d99bae34da1faed0223c1e59acd9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "domain", value)

    @builtins.property
    @jsii.member(jsii_name="domainIamRoleName")
    def domain_iam_role_name(self) -> typing.Optional[builtins.str]:
        '''Specifies the name of the IAM role to use when making API calls to the Directory Service.

        Valid for: Aurora DB clusters only

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-domainiamrolename
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "domainIamRoleName"))

    @domain_iam_role_name.setter
    def domain_iam_role_name(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ba24cb5abbab23e15417f0662c332f6e5d4792db4d794638200b8d5ed50581d0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "domainIamRoleName", value)

    @builtins.property
    @jsii.member(jsii_name="enableCloudwatchLogsExports")
    def enable_cloudwatch_logs_exports(
        self,
    ) -> typing.Optional[typing.List[builtins.str]]:
        '''The list of log types that need to be enabled for exporting to CloudWatch Logs.

        The values in the list depend on the DB engine being used. For more information, see `Publishing Database Logs to Amazon CloudWatch Logs <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_LogAccess.html#USER_LogAccess.Procedural.UploadtoCloudWatch>`_ in the *Amazon Aurora User Guide* .

        *Aurora MySQL*

        Valid values: ``audit`` , ``error`` , ``general`` , ``slowquery``

        *Aurora PostgreSQL*

        Valid values: ``postgresql``

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-enablecloudwatchlogsexports
        '''
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "enableCloudwatchLogsExports"))

    @enable_cloudwatch_logs_exports.setter
    def enable_cloudwatch_logs_exports(
        self,
        value: typing.Optional[typing.List[builtins.str]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b1ead7f2500eb97a44fa14256da4b1d83734d3ca2be89eabe6899412a23d5220)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableCloudwatchLogsExports", value)

    @builtins.property
    @jsii.member(jsii_name="enableHttpEndpoint")
    def enable_http_endpoint(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''A value that indicates whether to enable the HTTP endpoint for an Aurora Serverless DB cluster.

        By default, the HTTP endpoint is disabled.

        When enabled, the HTTP endpoint provides a connectionless web service API for running SQL queries on the Aurora Serverless DB cluster. You can also query your database from inside the RDS console with the query editor.

        For more information, see `Using the Data API for Aurora Serverless <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/data-api.html>`_ in the *Amazon Aurora User Guide* .

        Valid for: Aurora DB clusters only

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-enablehttpendpoint
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], jsii.get(self, "enableHttpEndpoint"))

    @enable_http_endpoint.setter
    def enable_http_endpoint(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0270d35e3d2e3a58c10f541c4061c4559e97e31df15ad87e24167c588e2a7dda)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableHttpEndpoint", value)

    @builtins.property
    @jsii.member(jsii_name="enableIamDatabaseAuthentication")
    def enable_iam_database_authentication(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''A value that indicates whether to enable mapping of AWS Identity and Access Management (IAM) accounts to database accounts.

        By default, mapping is disabled.

        For more information, see `IAM Database Authentication <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/UsingWithRDS.IAMDBAuth.html>`_ in the *Amazon Aurora User Guide.*

        Valid for: Aurora DB clusters only

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-enableiamdatabaseauthentication
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], jsii.get(self, "enableIamDatabaseAuthentication"))

    @enable_iam_database_authentication.setter
    def enable_iam_database_authentication(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5e1fb594581cfc2ca49d5a581f5876986dd2dc69d697b73a97a816c4c5226927)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableIamDatabaseAuthentication", value)

    @builtins.property
    @jsii.member(jsii_name="engine")
    def engine(self) -> typing.Optional[builtins.str]:
        '''The name of the database engine to be used for this DB cluster.

        Valid Values:

        - ``aurora-mysql``
        - ``aurora-postgresql``
        - ``mysql``
        - ``postgres``

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-engine
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "engine"))

    @engine.setter
    def engine(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__148c55704718e7b4e3ba61ca286080a4408f46132e485121a44a13af56a72bab)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "engine", value)

    @builtins.property
    @jsii.member(jsii_name="engineMode")
    def engine_mode(self) -> typing.Optional[builtins.str]:
        '''The DB engine mode of the DB cluster, either ``provisioned`` or ``serverless`` .

        The ``serverless`` engine mode only supports Aurora Serverless v1. Currently, AWS CloudFormation doesn't support Aurora Serverless v2.

        Limitations and requirements apply to some DB engine modes. For more information, see the following sections in the *Amazon Aurora User Guide* :

        - `Limitations of Aurora Serverless v1 <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless.html#aurora-serverless.limitations>`_
        - `Requirements for Aurora Serverless v2 <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless-v2.requirements.html>`_
        - `Limitations of parallel query <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-mysql-parallel-query.html#aurora-mysql-parallel-query-limitations>`_
        - `Limitations of Aurora global databases <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-global-database.html#aurora-global-database.limitations>`_

        Valid for: Aurora DB clusters only

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-enginemode
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "engineMode"))

    @engine_mode.setter
    def engine_mode(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2d2154d2777906fe3dde181298bd3f87336e9cd6d203c50a7362c8f3c5fbbc06)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "engineMode", value)

    @builtins.property
    @jsii.member(jsii_name="engineVersion")
    def engine_version(self) -> typing.Optional[builtins.str]:
        '''The version number of the database engine to use.

        To list all of the available engine versions for Aurora MySQL version 2 (5.7-compatible) and version 3 (8.0-compatible), use the following command:

        ``aws rds describe-db-engine-versions --engine aurora-mysql --query "DBEngineVersions[].EngineVersion"``

        You can supply either ``5.7`` or ``8.0`` to use the default engine version for Aurora MySQL version 2 or version 3, respectively.

        To list all of the available engine versions for Aurora PostgreSQL, use the following command:

        ``aws rds describe-db-engine-versions --engine aurora-postgresql --query "DBEngineVersions[].EngineVersion"``

        To list all of the available engine versions for RDS for MySQL, use the following command:

        ``aws rds describe-db-engine-versions --engine mysql --query "DBEngineVersions[].EngineVersion"``

        To list all of the available engine versions for RDS for PostgreSQL, use the following command:

        ``aws rds describe-db-engine-versions --engine postgres --query "DBEngineVersions[].EngineVersion"``

        *Aurora MySQL*

        For information, see `Database engine updates for Amazon Aurora MySQL <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/AuroraMySQL.Updates.html>`_ in the *Amazon Aurora User Guide* .

        *Aurora PostgreSQL*

        For information, see `Amazon Aurora PostgreSQL releases and engine versions <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/AuroraPostgreSQL.Updates.20180305.html>`_ in the *Amazon Aurora User Guide* .

        *MySQL*

        For information, see `Amazon RDS for MySQL <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_MySQL.html#MySQL.Concepts.VersionMgmt>`_ in the *Amazon RDS User Guide* .

        *PostgreSQL*

        For information, see `Amazon RDS for PostgreSQL <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_PostgreSQL.html#PostgreSQL.Concepts>`_ in the *Amazon RDS User Guide* .

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-engineversion
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "engineVersion"))

    @engine_version.setter
    def engine_version(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__07749311fb91af0947ebd82280930fde0166cea86133118187a7f5f454c24f89)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "engineVersion", value)

    @builtins.property
    @jsii.member(jsii_name="globalClusterIdentifier")
    def global_cluster_identifier(self) -> typing.Optional[builtins.str]:
        '''If you are configuring an Aurora global database cluster and want your Aurora DB cluster to be a secondary member in the global database cluster, specify the global cluster ID of the global database cluster.

        To define the primary database cluster of the global cluster, use the `AWS::RDS::GlobalCluster <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-globalcluster.html>`_ resource.

        If you aren't configuring a global database cluster, don't specify this property.
        .. epigraph::

           To remove the DB cluster from a global database cluster, specify an empty value for the ``GlobalClusterIdentifier`` property.

        For information about Aurora global databases, see `Working with Amazon Aurora Global Databases <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-global-database.html>`_ in the *Amazon Aurora User Guide* .

        Valid for: Aurora DB clusters only

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-globalclusteridentifier
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "globalClusterIdentifier"))

    @global_cluster_identifier.setter
    def global_cluster_identifier(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__44a736c76227233dd1a9533f7c0cca275ff40a6685f7aa108bc015ff87ce90a2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "globalClusterIdentifier", value)

    @builtins.property
    @jsii.member(jsii_name="iops")
    def iops(self) -> typing.Optional[jsii.Number]:
        '''The amount of Provisioned IOPS (input/output operations per second) to be initially allocated for each DB instance in the Multi-AZ DB cluster.

        For information about valid IOPS values, see `Provisioned IOPS storage <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Storage.html#USER_PIOPS>`_ in the *Amazon RDS User Guide* .

        This setting is required to create a Multi-AZ DB cluster.

        Constraints: Must be a multiple between .5 and 50 of the storage amount for the DB cluster.

        Valid for: Multi-AZ DB clusters only

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-iops
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "iops"))

    @iops.setter
    def iops(self, value: typing.Optional[jsii.Number]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a573b9ee6a3ac0f71281d75363b1bb68c4019aaa71b78645630d3a5667ba3a68)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "iops", value)

    @builtins.property
    @jsii.member(jsii_name="kmsKeyId")
    def kms_key_id(self) -> typing.Optional[builtins.str]:
        '''The Amazon Resource Name (ARN) of the AWS KMS key that is used to encrypt the database instances in the DB cluster, such as ``arn:aws:kms:us-east-1:012345678910:key/abcd1234-a123-456a-a12b-a123b4cd56ef`` .

        If you enable the ``StorageEncrypted`` property but don't specify this property, the default KMS key is used. If you specify this property, you must set the ``StorageEncrypted`` property to ``true`` .

        If you specify the ``SnapshotIdentifier`` property, the ``StorageEncrypted`` property value is inherited from the snapshot, and if the DB cluster is encrypted, the specified ``KmsKeyId`` property is used.

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-kmskeyid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "kmsKeyId"))

    @kms_key_id.setter
    def kms_key_id(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__00bda67b879fd009a11852793d768843d458cef98e88c1524db1dd6cc44b054a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "kmsKeyId", value)

    @builtins.property
    @jsii.member(jsii_name="manageMasterUserPassword")
    def manage_master_user_password(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''A value that indicates whether to manage the master user password with AWS Secrets Manager.

        For more information, see `Password management with AWS Secrets Manager <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-secrets-manager.html>`_ in the *Amazon RDS User Guide* and `Password management with AWS Secrets Manager <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/rds-secrets-manager.html>`_ in the *Amazon Aurora User Guide.*

        Constraints:

        - Can't manage the master user password with AWS Secrets Manager if ``MasterUserPassword`` is specified.

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-managemasteruserpassword
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], jsii.get(self, "manageMasterUserPassword"))

    @manage_master_user_password.setter
    def manage_master_user_password(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__453f45f621105ed50d3c78817690ccc87928e6193281304a3244ab65d0a0e7d8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "manageMasterUserPassword", value)

    @builtins.property
    @jsii.member(jsii_name="masterUsername")
    def master_username(self) -> typing.Optional[builtins.str]:
        '''The name of the master user for the DB cluster.

        .. epigraph::

           If you specify the ``SourceDBClusterIdentifier`` , ``SnapshotIdentifier`` , or ``GlobalClusterIdentifier`` property, don't specify this property. The value is inherited from the source DB cluster, the snapshot, or the primary DB cluster for the global database cluster, respectively.

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-masterusername
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "masterUsername"))

    @master_username.setter
    def master_username(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8d0c16557722ac1479cd861a74288942351f74633a0e1b0aee562ae44e9a7116)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "masterUsername", value)

    @builtins.property
    @jsii.member(jsii_name="masterUserPassword")
    def master_user_password(self) -> typing.Optional[builtins.str]:
        '''The master password for the DB instance.

        .. epigraph::

           If you specify the ``SourceDBClusterIdentifier`` , ``SnapshotIdentifier`` , or ``GlobalClusterIdentifier`` property, don't specify this property. The value is inherited from the source DB cluster, the snapshot, or the primary DB cluster for the global database cluster, respectively.

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-masteruserpassword
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "masterUserPassword"))

    @master_user_password.setter
    def master_user_password(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4371836148f08a2eece0d79f54c1adcd9f1ed61cdc765dbdf9f6e01e614e2aab)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "masterUserPassword", value)

    @builtins.property
    @jsii.member(jsii_name="masterUserSecret")
    def master_user_secret(
        self,
    ) -> typing.Optional[typing.Union["CfnDBCluster.MasterUserSecretProperty", _IResolvable_a771d0ef]]:
        '''Contains the secret managed by RDS in AWS Secrets Manager for the master user password.

        For more information, see `Password management with AWS Secrets Manager <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-secrets-manager.html>`_ in the *Amazon RDS User Guide* and `Password management with AWS Secrets Manager <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/rds-secrets-manager.html>`_ in the *Amazon Aurora User Guide.*

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-masterusersecret
        '''
        return typing.cast(typing.Optional[typing.Union["CfnDBCluster.MasterUserSecretProperty", _IResolvable_a771d0ef]], jsii.get(self, "masterUserSecret"))

    @master_user_secret.setter
    def master_user_secret(
        self,
        value: typing.Optional[typing.Union["CfnDBCluster.MasterUserSecretProperty", _IResolvable_a771d0ef]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__29ff472ecec59bf036f2f1495c401a191690c8e19c31cab3150e21e49c621412)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "masterUserSecret", value)

    @builtins.property
    @jsii.member(jsii_name="monitoringInterval")
    def monitoring_interval(self) -> typing.Optional[jsii.Number]:
        '''The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the DB cluster.

        To turn off collecting Enhanced Monitoring metrics, specify 0. The default is 0.

        If ``MonitoringRoleArn`` is specified, also set ``MonitoringInterval`` to a value other than 0.

        Valid Values: ``0, 1, 5, 10, 15, 30, 60``

        Valid for: Multi-AZ DB clusters only

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-monitoringinterval
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "monitoringInterval"))

    @monitoring_interval.setter
    def monitoring_interval(self, value: typing.Optional[jsii.Number]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8a468cc2821ed6fdd252a8afa3c095fcdeadafa0e2ad663701dd7c53b662757d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "monitoringInterval", value)

    @builtins.property
    @jsii.member(jsii_name="monitoringRoleArn")
    def monitoring_role_arn(self) -> typing.Optional[builtins.str]:
        '''The Amazon Resource Name (ARN) for the IAM role that permits RDS to send Enhanced Monitoring metrics to Amazon CloudWatch Logs.

        An example is ``arn:aws:iam:123456789012:role/emaccess`` . For information on creating a monitoring role, see `Setting up and enabling Enhanced Monitoring <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Monitoring.OS.html#USER_Monitoring.OS.Enabling>`_ in the *Amazon RDS User Guide* .

        If ``MonitoringInterval`` is set to a value other than 0, supply a ``MonitoringRoleArn`` value.

        Valid for: Multi-AZ DB clusters only

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-monitoringrolearn
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "monitoringRoleArn"))

    @monitoring_role_arn.setter
    def monitoring_role_arn(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d2a15e35ddf564864bf7315f58d6ec6beac59f36768c4b5e56d5b14fcd3b5662)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "monitoringRoleArn", value)

    @builtins.property
    @jsii.member(jsii_name="networkType")
    def network_type(self) -> typing.Optional[builtins.str]:
        '''The network type of the DB cluster.

        Valid values:

        - ``IPV4``
        - ``DUAL``

        The network type is determined by the ``DBSubnetGroup`` specified for the DB cluster. A ``DBSubnetGroup`` can support only the IPv4 protocol or the IPv4 and IPv6 protocols ( ``DUAL`` ).

        For more information, see `Working with a DB instance in a VPC <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_VPC.WorkingWithRDSInstanceinaVPC.html>`_ in the *Amazon Aurora User Guide.*

        Valid for: Aurora DB clusters only

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-networktype
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "networkType"))

    @network_type.setter
    def network_type(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e6fabbb8dc8272780aa60766b54df3062970f757d0293869f6d3968ed6dbc51e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "networkType", value)

    @builtins.property
    @jsii.member(jsii_name="performanceInsightsEnabled")
    def performance_insights_enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''A value that indicates whether to turn on Performance Insights for the DB cluster.

        For more information, see `Using Amazon Performance Insights <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PerfInsights.html>`_ in the *Amazon RDS User Guide* .

        Valid for: Multi-AZ DB clusters only

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-performanceinsightsenabled
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], jsii.get(self, "performanceInsightsEnabled"))

    @performance_insights_enabled.setter
    def performance_insights_enabled(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__de08b9e379e2bdee9e21b59affbec238cd47fe7e3745bb32c52430e950387a3d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "performanceInsightsEnabled", value)

    @builtins.property
    @jsii.member(jsii_name="performanceInsightsKmsKeyId")
    def performance_insights_kms_key_id(self) -> typing.Optional[builtins.str]:
        '''The AWS KMS key identifier for encryption of Performance Insights data.

        The AWS KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key.

        If you don't specify a value for ``PerformanceInsightsKMSKeyId`` , then Amazon RDS uses your default KMS key. There is a default KMS key for your AWS account . Your AWS account has a different default KMS key for each AWS Region .

        Valid for: Multi-AZ DB clusters only

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-performanceinsightskmskeyid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "performanceInsightsKmsKeyId"))

    @performance_insights_kms_key_id.setter
    def performance_insights_kms_key_id(
        self,
        value: typing.Optional[builtins.str],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bb1ba1a4b3f1356b6202b26b9f7d1237c5ffd81c9aa2e16e75f1d26c865a03ac)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "performanceInsightsKmsKeyId", value)

    @builtins.property
    @jsii.member(jsii_name="performanceInsightsRetentionPeriod")
    def performance_insights_retention_period(self) -> typing.Optional[jsii.Number]:
        '''The number of days to retain Performance Insights data. The default is 7 days. The following values are valid:.

        - 7
        - *month* * 31, where *month* is a number of months from 1-23
        - 731

        For example, the following values are valid:

        - 93 (3 months * 31)
        - 341 (11 months * 31)
        - 589 (19 months * 31)
        - 731

        If you specify a retention period such as 94, which isn't a valid value, RDS issues an error.

        Valid for: Multi-AZ DB clusters only

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-performanceinsightsretentionperiod
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "performanceInsightsRetentionPeriod"))

    @performance_insights_retention_period.setter
    def performance_insights_retention_period(
        self,
        value: typing.Optional[jsii.Number],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6dbf06247962dc081e59ef9a011004bc79dbb60a3ca535edd6c7468e21460195)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "performanceInsightsRetentionPeriod", value)

    @builtins.property
    @jsii.member(jsii_name="port")
    def port(self) -> typing.Optional[jsii.Number]:
        '''The port number on which the DB instances in the DB cluster accept connections.

        Default:

        - When ``EngineMode`` is ``provisioned`` , ``3306`` (for both Aurora MySQL and Aurora PostgreSQL)
        - When ``EngineMode`` is ``serverless`` :
        - ``3306`` when ``Engine`` is ``aurora`` or ``aurora-mysql``
        - ``5432`` when ``Engine`` is ``aurora-postgresql``

        .. epigraph::

           The ``No interruption`` on update behavior only applies to DB clusters. If you are updating a DB instance, see `Port <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-database-instance.html#cfn-rds-dbinstance-port>`_ for the AWS::RDS::DBInstance resource.

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-port
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "port"))

    @port.setter
    def port(self, value: typing.Optional[jsii.Number]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3a1b3eedb4a4e2c1c301c73ee1a665639e00c4ff5c05c157ca57e0c3be1e40b6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "port", value)

    @builtins.property
    @jsii.member(jsii_name="preferredBackupWindow")
    def preferred_backup_window(self) -> typing.Optional[builtins.str]:
        '''The daily time range during which automated backups are created.

        For more information, see `Backup Window <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.Managing.Backups.html#Aurora.Managing.Backups.BackupWindow>`_ in the *Amazon Aurora User Guide.*

        Constraints:

        - Must be in the format ``hh24:mi-hh24:mi`` .
        - Must be in Universal Coordinated Time (UTC).
        - Must not conflict with the preferred maintenance window.
        - Must be at least 30 minutes.

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-preferredbackupwindow
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "preferredBackupWindow"))

    @preferred_backup_window.setter
    def preferred_backup_window(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4fadef388e1ac8d5fbfaf98b8fa6a9859b82137981e9489dcb412bb1a12ca835)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "preferredBackupWindow", value)

    @builtins.property
    @jsii.member(jsii_name="preferredMaintenanceWindow")
    def preferred_maintenance_window(self) -> typing.Optional[builtins.str]:
        '''The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC).

        Format: ``ddd:hh24:mi-ddd:hh24:mi``

        The default is a 30-minute window selected at random from an 8-hour block of time for each AWS Region, occurring on a random day of the week. To see the time blocks available, see `Adjusting the Preferred DB Cluster Maintenance Window <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_UpgradeDBInstance.Maintenance.html#AdjustingTheMaintenanceWindow.Aurora>`_ in the *Amazon Aurora User Guide.*

        Valid Days: Mon, Tue, Wed, Thu, Fri, Sat, Sun.

        Constraints: Minimum 30-minute window.

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-preferredmaintenancewindow
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "preferredMaintenanceWindow"))

    @preferred_maintenance_window.setter
    def preferred_maintenance_window(
        self,
        value: typing.Optional[builtins.str],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__97429d6598b4df7a9dca7adc6cec55deec1573eaa478729342dfa07996594532)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "preferredMaintenanceWindow", value)

    @builtins.property
    @jsii.member(jsii_name="publiclyAccessible")
    def publicly_accessible(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''A value that indicates whether the DB cluster is publicly accessible.

        When the DB cluster is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address from within the DB cluster's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB cluster's VPC. Access to the DB cluster is ultimately controlled by the security group it uses. That public access isn't permitted if the security group assigned to the DB cluster doesn't permit it.

        When the DB cluster isn't publicly accessible, it is an internal DB cluster with a DNS name that resolves to a private IP address.

        Default: The default behavior varies depending on whether ``DBSubnetGroupName`` is specified.

        If ``DBSubnetGroupName`` isn't specified, and ``PubliclyAccessible`` isn't specified, the following applies:

        - If the default VPC in the target Region doesnt have an internet gateway attached to it, the DB cluster is private.
        - If the default VPC in the target Region has an internet gateway attached to it, the DB cluster is public.

        If ``DBSubnetGroupName`` is specified, and ``PubliclyAccessible`` isn't specified, the following applies:

        - If the subnets are part of a VPC that doesnt have an internet gateway attached to it, the DB cluster is private.
        - If the subnets are part of a VPC that has an internet gateway attached to it, the DB cluster is public.

        Valid for: Multi-AZ DB clusters only

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-publiclyaccessible
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], jsii.get(self, "publiclyAccessible"))

    @publicly_accessible.setter
    def publicly_accessible(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0a106465b4c25a4b554a430dacd97283e5589f9726f3860d90ed4395a83e0574)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "publiclyAccessible", value)

    @builtins.property
    @jsii.member(jsii_name="replicationSourceIdentifier")
    def replication_source_identifier(self) -> typing.Optional[builtins.str]:
        '''The Amazon Resource Name (ARN) of the source DB instance or DB cluster if this DB cluster is created as a read replica.

        Valid for: Aurora DB clusters only

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-replicationsourceidentifier
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "replicationSourceIdentifier"))

    @replication_source_identifier.setter
    def replication_source_identifier(
        self,
        value: typing.Optional[builtins.str],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2d03d272f3ef0a29114fae2c7eeb77ba3fc96fa4eea5c6c1ae2bf733d11cbf26)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "replicationSourceIdentifier", value)

    @builtins.property
    @jsii.member(jsii_name="restoreToTime")
    def restore_to_time(self) -> typing.Optional[builtins.str]:
        '''The date and time to restore the DB cluster to.

        Valid Values: Value must be a time in Universal Coordinated Time (UTC) format

        Constraints:

        - Must be before the latest restorable time for the DB instance
        - Must be specified if ``UseLatestRestorableTime`` parameter isn't provided
        - Can't be specified if the ``UseLatestRestorableTime`` parameter is enabled
        - Can't be specified if the ``RestoreType`` parameter is ``copy-on-write``

        Example: ``2015-03-07T23:45:00Z``

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-restoretotime
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "restoreToTime"))

    @restore_to_time.setter
    def restore_to_time(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9f477e0b738f2cbec17e7e89664eca498f31ea6ff032ada0cdeabc8bf0d807c3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "restoreToTime", value)

    @builtins.property
    @jsii.member(jsii_name="restoreType")
    def restore_type(self) -> typing.Optional[builtins.str]:
        '''The type of restore to be performed. You can specify one of the following values:.

        - ``full-copy`` - The new DB cluster is restored as a full copy of the source DB cluster.
        - ``copy-on-write`` - The new DB cluster is restored as a clone of the source DB cluster.

        If you don't specify a ``RestoreType`` value, then the new DB cluster is restored as a full copy of the source DB cluster.

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-restoretype
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "restoreType"))

    @restore_type.setter
    def restore_type(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f2aa8afa0934a08d35fb27de6e01a6a913b7e3985a3381fb2a8dafc2afe55a6c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "restoreType", value)

    @builtins.property
    @jsii.member(jsii_name="scalingConfiguration")
    def scaling_configuration(
        self,
    ) -> typing.Optional[typing.Union["CfnDBCluster.ScalingConfigurationProperty", _IResolvable_a771d0ef]]:
        '''The ``ScalingConfiguration`` property type specifies the scaling configuration of an Aurora Serverless DB cluster.

        This property is only supported for Aurora Serverless v1. For Aurora Serverless v2, use ``ServerlessV2ScalingConfiguration`` property.

        Valid for: Aurora DB clusters only

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-scalingconfiguration
        '''
        return typing.cast(typing.Optional[typing.Union["CfnDBCluster.ScalingConfigurationProperty", _IResolvable_a771d0ef]], jsii.get(self, "scalingConfiguration"))

    @scaling_configuration.setter
    def scaling_configuration(
        self,
        value: typing.Optional[typing.Union["CfnDBCluster.ScalingConfigurationProperty", _IResolvable_a771d0ef]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cef7ff1673a16c0f52002910e0c1858140ba7a4e607c81aab5a8add5b1e0bafe)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "scalingConfiguration", value)

    @builtins.property
    @jsii.member(jsii_name="serverlessV2ScalingConfiguration")
    def serverless_v2_scaling_configuration(
        self,
    ) -> typing.Optional[typing.Union["CfnDBCluster.ServerlessV2ScalingConfigurationProperty", _IResolvable_a771d0ef]]:
        '''The ``ServerlessV2ScalingConfiguration`` property type specifies the scaling configuration of an Aurora Serverless V2 DB cluster.

        This property is only supported for Aurora Serverless v2. For Aurora Serverless v1, use ``ScalingConfiguration`` property.

        Valid for: Aurora DB clusters only

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-serverlessv2scalingconfiguration
        '''
        return typing.cast(typing.Optional[typing.Union["CfnDBCluster.ServerlessV2ScalingConfigurationProperty", _IResolvable_a771d0ef]], jsii.get(self, "serverlessV2ScalingConfiguration"))

    @serverless_v2_scaling_configuration.setter
    def serverless_v2_scaling_configuration(
        self,
        value: typing.Optional[typing.Union["CfnDBCluster.ServerlessV2ScalingConfigurationProperty", _IResolvable_a771d0ef]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bb1866869d8ec723b9a016209cb635f88fe388d40cab68ca4ec6730103444c2a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "serverlessV2ScalingConfiguration", value)

    @builtins.property
    @jsii.member(jsii_name="snapshotIdentifier")
    def snapshot_identifier(self) -> typing.Optional[builtins.str]:
        '''The identifier for the DB snapshot or DB cluster snapshot to restore from.

        You can use either the name or the Amazon Resource Name (ARN) to specify a DB cluster snapshot. However, you can use only the ARN to specify a DB snapshot.

        After you restore a DB cluster with a ``SnapshotIdentifier`` property, you must specify the same ``SnapshotIdentifier`` property for any future updates to the DB cluster. When you specify this property for an update, the DB cluster is not restored from the snapshot again, and the data in the database is not changed. However, if you don't specify the ``SnapshotIdentifier`` property, an empty DB cluster is created, and the original DB cluster is deleted. If you specify a property that is different from the previous snapshot restore property, a new DB cluster is restored from the specified ``SnapshotIdentifier`` property, and the original DB cluster is deleted.

        If you specify the ``SnapshotIdentifier`` property to restore a DB cluster (as opposed to specifying it for DB cluster updates), then don't specify the following properties:

        - ``GlobalClusterIdentifier``
        - ``MasterUsername``
        - ``MasterUserPassword``
        - ``ReplicationSourceIdentifier``
        - ``RestoreType``
        - ``SourceDBClusterIdentifier``
        - ``SourceRegion``
        - ``StorageEncrypted`` (for an encrypted snapshot)
        - ``UseLatestRestorableTime``

        Constraints:

        - Must match the identifier of an existing Snapshot.

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-snapshotidentifier
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "snapshotIdentifier"))

    @snapshot_identifier.setter
    def snapshot_identifier(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e9049af093eab4c1a115b792a8bf8a2f598eddbd67cec4a7f9a8d963d8223ad2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "snapshotIdentifier", value)

    @builtins.property
    @jsii.member(jsii_name="sourceDbClusterIdentifier")
    def source_db_cluster_identifier(self) -> typing.Optional[builtins.str]:
        '''When restoring a DB cluster to a point in time, the identifier of the source DB cluster from which to restore.

        Constraints:

        - Must match the identifier of an existing DBCluster.

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-sourcedbclusteridentifier
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "sourceDbClusterIdentifier"))

    @source_db_cluster_identifier.setter
    def source_db_cluster_identifier(
        self,
        value: typing.Optional[builtins.str],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5d4c9e9bf842efee34076c204edadcd4caffdcbcfba1dc34f3dd54708a147b1f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "sourceDbClusterIdentifier", value)

    @builtins.property
    @jsii.member(jsii_name="sourceRegion")
    def source_region(self) -> typing.Optional[builtins.str]:
        '''The AWS Region which contains the source DB cluster when replicating a DB cluster. For example, ``us-east-1`` .

        Valid for: Aurora DB clusters only

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-sourceregion
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "sourceRegion"))

    @source_region.setter
    def source_region(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2b624b0a4d2407d68684234af1dd0b66e49d527bd2cf36167bb6337a98405368)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "sourceRegion", value)

    @builtins.property
    @jsii.member(jsii_name="storageEncrypted")
    def storage_encrypted(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''Indicates whether the DB cluster is encrypted.

        If you specify the ``KmsKeyId`` property, then you must enable encryption.

        If you specify the ``SourceDBClusterIdentifier`` property, don't specify this property. The value is inherited from the source DB cluster, and if the DB cluster is encrypted, the specified ``KmsKeyId`` property is used.

        If you specify the ``SnapshotIdentifier`` and the specified snapshot is encrypted, don't specify this property. The value is inherited from the snapshot, and the specified ``KmsKeyId`` property is used.

        If you specify the ``SnapshotIdentifier`` and the specified snapshot isn't encrypted, you can use this property to specify that the restored DB cluster is encrypted. Specify the ``KmsKeyId`` property for the KMS key to use for encryption. If you don't want the restored DB cluster to be encrypted, then don't set this property or set it to ``false`` .

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-storageencrypted
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], jsii.get(self, "storageEncrypted"))

    @storage_encrypted.setter
    def storage_encrypted(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__64b093eeea2386185a4c62bb2ac9ddbb55209d26811b2f25c7d19972f2cabcfc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "storageEncrypted", value)

    @builtins.property
    @jsii.member(jsii_name="storageType")
    def storage_type(self) -> typing.Optional[builtins.str]:
        '''Specifies the storage type to be associated with the DB cluster.

        This setting is required to create a Multi-AZ DB cluster.

        When specified for a Multi-AZ DB cluster, a value for the ``Iops`` parameter is required.

        Valid values: ``aurora`` , ``aurora-iopt1`` (Aurora DB clusters); ``io1`` (Multi-AZ DB clusters)

        Default: ``aurora`` (Aurora DB clusters); ``io1`` (Multi-AZ DB clusters)

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        For more information on storage types for Aurora DB clusters, see `Storage configurations for Amazon Aurora DB clusters <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.Overview.StorageReliability.html#aurora-storage-type>`_ . For more information on storage types for Multi-AZ DB clusters, see `Settings for creating Multi-AZ DB clusters <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/create-multi-az-db-cluster.html#create-multi-az-db-cluster-settings>`_ .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-storagetype
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "storageType"))

    @storage_type.setter
    def storage_type(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a0e3bae34afb8086514d6ecb2801e23dd3d2d97fee4e8a2508c69c92922a1f79)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "storageType", value)

    @builtins.property
    @jsii.member(jsii_name="useLatestRestorableTime")
    def use_latest_restorable_time(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''A value that indicates whether to restore the DB cluster to the latest restorable backup time.

        By default, the DB cluster is not restored to the latest restorable backup time.

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-uselatestrestorabletime
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], jsii.get(self, "useLatestRestorableTime"))

    @use_latest_restorable_time.setter
    def use_latest_restorable_time(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ad0f13f7485acfac4b30acad3d9831426f014a998dd04c63dc00681b719292a5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "useLatestRestorableTime", value)

    @builtins.property
    @jsii.member(jsii_name="vpcSecurityGroupIds")
    def vpc_security_group_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''A list of EC2 VPC security groups to associate with this DB cluster.

        If you plan to update the resource, don't specify VPC security groups in a shared VPC.

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-vpcsecuritygroupids
        '''
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "vpcSecurityGroupIds"))

    @vpc_security_group_ids.setter
    def vpc_security_group_ids(
        self,
        value: typing.Optional[typing.List[builtins.str]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dc20847e8f144ebe68a3d5713cdc707a24866e4c5debc8775b6b2644afe1a150)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "vpcSecurityGroupIds", value)

    @jsii.data_type(
        jsii_type="monocdk.aws_rds.CfnDBCluster.DBClusterRoleProperty",
        jsii_struct_bases=[],
        name_mapping={"role_arn": "roleArn", "feature_name": "featureName"},
    )
    class DBClusterRoleProperty:
        def __init__(
            self,
            *,
            role_arn: builtins.str,
            feature_name: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes an AWS Identity and Access Management (IAM) role that is associated with a DB cluster.

            :param role_arn: The Amazon Resource Name (ARN) of the IAM role that is associated with the DB cluster.
            :param feature_name: The name of the feature associated with the AWS Identity and Access Management (IAM) role. IAM roles that are associated with a DB cluster grant permission for the DB cluster to access other AWS services on your behalf. For the list of supported feature names, see the ``SupportedFeatureNames`` description in `DBEngineVersion <https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_DBEngineVersion.html>`_ in the *Amazon RDS API Reference* .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbcluster-dbclusterrole.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from monocdk import aws_rds as rds
                
                d_bCluster_role_property = rds.CfnDBCluster.DBClusterRoleProperty(
                    role_arn="roleArn",
                
                    # the properties below are optional
                    feature_name="featureName"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__8921a8dd496922707438c02c3380215f4fa5433c121989962eba74d3d8a1e657)
                check_type(argname="argument role_arn", value=role_arn, expected_type=type_hints["role_arn"])
                check_type(argname="argument feature_name", value=feature_name, expected_type=type_hints["feature_name"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "role_arn": role_arn,
            }
            if feature_name is not None:
                self._values["feature_name"] = feature_name

        @builtins.property
        def role_arn(self) -> builtins.str:
            '''The Amazon Resource Name (ARN) of the IAM role that is associated with the DB cluster.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbcluster-dbclusterrole.html#cfn-rds-dbcluster-dbclusterrole-rolearn
            '''
            result = self._values.get("role_arn")
            assert result is not None, "Required property 'role_arn' is missing"
            return typing.cast(builtins.str, result)

        @builtins.property
        def feature_name(self) -> typing.Optional[builtins.str]:
            '''The name of the feature associated with the AWS Identity and Access Management (IAM) role.

            IAM roles that are associated with a DB cluster grant permission for the DB cluster to access other AWS services on your behalf. For the list of supported feature names, see the ``SupportedFeatureNames`` description in `DBEngineVersion <https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_DBEngineVersion.html>`_ in the *Amazon RDS API Reference* .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbcluster-dbclusterrole.html#cfn-rds-dbcluster-dbclusterrole-featurename
            '''
            result = self._values.get("feature_name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "DBClusterRoleProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="monocdk.aws_rds.CfnDBCluster.EndpointProperty",
        jsii_struct_bases=[],
        name_mapping={"address": "address", "port": "port"},
    )
    class EndpointProperty:
        def __init__(
            self,
            *,
            address: typing.Optional[builtins.str] = None,
            port: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The ``Endpoint`` return value specifies the connection endpoint for the primary instance of the DB cluster.

            :param address: Specifies the connection endpoint for the primary instance of the DB cluster.
            :param port: Specifies the port that the database engine is listening on.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbcluster-endpoint.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from monocdk import aws_rds as rds
                
                endpoint_property = rds.CfnDBCluster.EndpointProperty(
                    address="address",
                    port="port"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__3de0068107923a6303476d31af027f180baca0719689cde5e9bcae3c626c8cea)
                check_type(argname="argument address", value=address, expected_type=type_hints["address"])
                check_type(argname="argument port", value=port, expected_type=type_hints["port"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if address is not None:
                self._values["address"] = address
            if port is not None:
                self._values["port"] = port

        @builtins.property
        def address(self) -> typing.Optional[builtins.str]:
            '''Specifies the connection endpoint for the primary instance of the DB cluster.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbcluster-endpoint.html#cfn-rds-dbcluster-endpoint-address
            '''
            result = self._values.get("address")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def port(self) -> typing.Optional[builtins.str]:
            '''Specifies the port that the database engine is listening on.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbcluster-endpoint.html#cfn-rds-dbcluster-endpoint-port
            '''
            result = self._values.get("port")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "EndpointProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="monocdk.aws_rds.CfnDBCluster.MasterUserSecretProperty",
        jsii_struct_bases=[],
        name_mapping={"kms_key_id": "kmsKeyId", "secret_arn": "secretArn"},
    )
    class MasterUserSecretProperty:
        def __init__(
            self,
            *,
            kms_key_id: typing.Optional[builtins.str] = None,
            secret_arn: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The ``MasterUserSecret`` return value specifies the secret managed by RDS in AWS Secrets Manager for the master user password.

            For more information, see `Password management with AWS Secrets Manager <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-secrets-manager.html>`_ in the *Amazon RDS User Guide* and `Password management with AWS Secrets Manager <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/rds-secrets-manager.html>`_ in the *Amazon Aurora User Guide.*

            :param kms_key_id: The AWS KMS key identifier that is used to encrypt the secret.
            :param secret_arn: The Amazon Resource Name (ARN) of the secret.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbcluster-masterusersecret.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from monocdk import aws_rds as rds
                
                master_user_secret_property = rds.CfnDBCluster.MasterUserSecretProperty(
                    kms_key_id="kmsKeyId",
                    secret_arn="secretArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__0cd79980e3b22b943962d000c5ab85d20465814cc9fd11e01b1cb76f56c662b9)
                check_type(argname="argument kms_key_id", value=kms_key_id, expected_type=type_hints["kms_key_id"])
                check_type(argname="argument secret_arn", value=secret_arn, expected_type=type_hints["secret_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if kms_key_id is not None:
                self._values["kms_key_id"] = kms_key_id
            if secret_arn is not None:
                self._values["secret_arn"] = secret_arn

        @builtins.property
        def kms_key_id(self) -> typing.Optional[builtins.str]:
            '''The AWS KMS key identifier that is used to encrypt the secret.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbcluster-masterusersecret.html#cfn-rds-dbcluster-masterusersecret-kmskeyid
            '''
            result = self._values.get("kms_key_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def secret_arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the secret.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbcluster-masterusersecret.html#cfn-rds-dbcluster-masterusersecret-secretarn
            '''
            result = self._values.get("secret_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "MasterUserSecretProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="monocdk.aws_rds.CfnDBCluster.ReadEndpointProperty",
        jsii_struct_bases=[],
        name_mapping={"address": "address"},
    )
    class ReadEndpointProperty:
        def __init__(self, *, address: typing.Optional[builtins.str] = None) -> None:
            '''The ``ReadEndpoint`` return value specifies the reader endpoint for the DB cluster.

            The reader endpoint for a DB cluster load-balances connections across the Aurora Replicas that are available in a DB cluster. As clients request new connections to the reader endpoint, Aurora distributes the connection requests among the Aurora Replicas in the DB cluster. This functionality can help balance your read workload across multiple Aurora Replicas in your DB cluster.

            If a failover occurs, and the Aurora Replica that you are connected to is promoted to be the primary instance, your connection is dropped. To continue sending your read workload to other Aurora Replicas in the cluster, you can then reconnect to the reader endpoint.

            For more information about Aurora endpoints, see `Amazon Aurora connection management <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.Overview.Endpoints.html>`_ in the *Amazon Aurora User Guide* .

            :param address: The host address of the reader endpoint.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbcluster-readendpoint.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from monocdk import aws_rds as rds
                
                read_endpoint_property = rds.CfnDBCluster.ReadEndpointProperty(
                    address="address"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__5272855c20351f3f7704bf57212fa4962e30e2266ba267596c087afc0c189216)
                check_type(argname="argument address", value=address, expected_type=type_hints["address"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if address is not None:
                self._values["address"] = address

        @builtins.property
        def address(self) -> typing.Optional[builtins.str]:
            '''The host address of the reader endpoint.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbcluster-readendpoint.html#cfn-rds-dbcluster-readendpoint-address
            '''
            result = self._values.get("address")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ReadEndpointProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="monocdk.aws_rds.CfnDBCluster.ScalingConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "auto_pause": "autoPause",
            "max_capacity": "maxCapacity",
            "min_capacity": "minCapacity",
            "seconds_before_timeout": "secondsBeforeTimeout",
            "seconds_until_auto_pause": "secondsUntilAutoPause",
            "timeout_action": "timeoutAction",
        },
    )
    class ScalingConfigurationProperty:
        def __init__(
            self,
            *,
            auto_pause: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
            max_capacity: typing.Optional[jsii.Number] = None,
            min_capacity: typing.Optional[jsii.Number] = None,
            seconds_before_timeout: typing.Optional[jsii.Number] = None,
            seconds_until_auto_pause: typing.Optional[jsii.Number] = None,
            timeout_action: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The ``ScalingConfiguration`` property type specifies the scaling configuration of an Aurora Serverless DB cluster.

            For more information, see `Using Amazon Aurora Serverless <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless.html>`_ in the *Amazon Aurora User Guide* .

            This property is only supported for Aurora Serverless v1. For Aurora Serverless v2, use ``ServerlessV2ScalingConfiguration`` property.

            Valid for: Aurora DB clusters only

            :param auto_pause: A value that indicates whether to allow or disallow automatic pause for an Aurora DB cluster in ``serverless`` DB engine mode. A DB cluster can be paused only when it's idle (it has no connections). .. epigraph:: If a DB cluster is paused for more than seven days, the DB cluster might be backed up with a snapshot. In this case, the DB cluster is restored when there is a request to connect to it.
            :param max_capacity: The maximum capacity for an Aurora DB cluster in ``serverless`` DB engine mode. For Aurora MySQL, valid capacity values are ``1`` , ``2`` , ``4`` , ``8`` , ``16`` , ``32`` , ``64`` , ``128`` , and ``256`` . For Aurora PostgreSQL, valid capacity values are ``2`` , ``4`` , ``8`` , ``16`` , ``32`` , ``64`` , ``192`` , and ``384`` . The maximum capacity must be greater than or equal to the minimum capacity.
            :param min_capacity: The minimum capacity for an Aurora DB cluster in ``serverless`` DB engine mode. For Aurora MySQL, valid capacity values are ``1`` , ``2`` , ``4`` , ``8`` , ``16`` , ``32`` , ``64`` , ``128`` , and ``256`` . For Aurora PostgreSQL, valid capacity values are ``2`` , ``4`` , ``8`` , ``16`` , ``32`` , ``64`` , ``192`` , and ``384`` . The minimum capacity must be less than or equal to the maximum capacity.
            :param seconds_before_timeout: The amount of time, in seconds, that Aurora Serverless v1 tries to find a scaling point to perform seamless scaling before enforcing the timeout action. The default is 300. Specify a value between 60 and 600 seconds.
            :param seconds_until_auto_pause: The time, in seconds, before an Aurora DB cluster in ``serverless`` mode is paused. Specify a value between 300 and 86,400 seconds.
            :param timeout_action: The action to take when the timeout is reached, either ``ForceApplyCapacityChange`` or ``RollbackCapacityChange`` . ``ForceApplyCapacityChange`` sets the capacity to the specified value as soon as possible. ``RollbackCapacityChange`` , the default, ignores the capacity change if a scaling point isn't found in the timeout period. .. epigraph:: If you specify ``ForceApplyCapacityChange`` , connections that prevent Aurora Serverless v1 from finding a scaling point might be dropped. For more information, see `Autoscaling for Aurora Serverless v1 <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless.how-it-works.html#aurora-serverless.how-it-works.auto-scaling>`_ in the *Amazon Aurora User Guide* .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbcluster-scalingconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from monocdk import aws_rds as rds
                
                scaling_configuration_property = rds.CfnDBCluster.ScalingConfigurationProperty(
                    auto_pause=False,
                    max_capacity=123,
                    min_capacity=123,
                    seconds_before_timeout=123,
                    seconds_until_auto_pause=123,
                    timeout_action="timeoutAction"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__ace7122a90628da035871b4bb7569ff6f4b16fd1cc2e1c17fabf135fe4908ad2)
                check_type(argname="argument auto_pause", value=auto_pause, expected_type=type_hints["auto_pause"])
                check_type(argname="argument max_capacity", value=max_capacity, expected_type=type_hints["max_capacity"])
                check_type(argname="argument min_capacity", value=min_capacity, expected_type=type_hints["min_capacity"])
                check_type(argname="argument seconds_before_timeout", value=seconds_before_timeout, expected_type=type_hints["seconds_before_timeout"])
                check_type(argname="argument seconds_until_auto_pause", value=seconds_until_auto_pause, expected_type=type_hints["seconds_until_auto_pause"])
                check_type(argname="argument timeout_action", value=timeout_action, expected_type=type_hints["timeout_action"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if auto_pause is not None:
                self._values["auto_pause"] = auto_pause
            if max_capacity is not None:
                self._values["max_capacity"] = max_capacity
            if min_capacity is not None:
                self._values["min_capacity"] = min_capacity
            if seconds_before_timeout is not None:
                self._values["seconds_before_timeout"] = seconds_before_timeout
            if seconds_until_auto_pause is not None:
                self._values["seconds_until_auto_pause"] = seconds_until_auto_pause
            if timeout_action is not None:
                self._values["timeout_action"] = timeout_action

        @builtins.property
        def auto_pause(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
            '''A value that indicates whether to allow or disallow automatic pause for an Aurora DB cluster in ``serverless`` DB engine mode.

            A DB cluster can be paused only when it's idle (it has no connections).
            .. epigraph::

               If a DB cluster is paused for more than seven days, the DB cluster might be backed up with a snapshot. In this case, the DB cluster is restored when there is a request to connect to it.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbcluster-scalingconfiguration.html#cfn-rds-dbcluster-scalingconfiguration-autopause
            '''
            result = self._values.get("auto_pause")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], result)

        @builtins.property
        def max_capacity(self) -> typing.Optional[jsii.Number]:
            '''The maximum capacity for an Aurora DB cluster in ``serverless`` DB engine mode.

            For Aurora MySQL, valid capacity values are ``1`` , ``2`` , ``4`` , ``8`` , ``16`` , ``32`` , ``64`` , ``128`` , and ``256`` .

            For Aurora PostgreSQL, valid capacity values are ``2`` , ``4`` , ``8`` , ``16`` , ``32`` , ``64`` , ``192`` , and ``384`` .

            The maximum capacity must be greater than or equal to the minimum capacity.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbcluster-scalingconfiguration.html#cfn-rds-dbcluster-scalingconfiguration-maxcapacity
            '''
            result = self._values.get("max_capacity")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min_capacity(self) -> typing.Optional[jsii.Number]:
            '''The minimum capacity for an Aurora DB cluster in ``serverless`` DB engine mode.

            For Aurora MySQL, valid capacity values are ``1`` , ``2`` , ``4`` , ``8`` , ``16`` , ``32`` , ``64`` , ``128`` , and ``256`` .

            For Aurora PostgreSQL, valid capacity values are ``2`` , ``4`` , ``8`` , ``16`` , ``32`` , ``64`` , ``192`` , and ``384`` .

            The minimum capacity must be less than or equal to the maximum capacity.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbcluster-scalingconfiguration.html#cfn-rds-dbcluster-scalingconfiguration-mincapacity
            '''
            result = self._values.get("min_capacity")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def seconds_before_timeout(self) -> typing.Optional[jsii.Number]:
            '''The amount of time, in seconds, that Aurora Serverless v1 tries to find a scaling point to perform seamless scaling before enforcing the timeout action.

            The default is 300.

            Specify a value between 60 and 600 seconds.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbcluster-scalingconfiguration.html#cfn-rds-dbcluster-scalingconfiguration-secondsbeforetimeout
            '''
            result = self._values.get("seconds_before_timeout")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def seconds_until_auto_pause(self) -> typing.Optional[jsii.Number]:
            '''The time, in seconds, before an Aurora DB cluster in ``serverless`` mode is paused.

            Specify a value between 300 and 86,400 seconds.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbcluster-scalingconfiguration.html#cfn-rds-dbcluster-scalingconfiguration-secondsuntilautopause
            '''
            result = self._values.get("seconds_until_auto_pause")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def timeout_action(self) -> typing.Optional[builtins.str]:
            '''The action to take when the timeout is reached, either ``ForceApplyCapacityChange`` or ``RollbackCapacityChange`` .

            ``ForceApplyCapacityChange`` sets the capacity to the specified value as soon as possible.

            ``RollbackCapacityChange`` , the default, ignores the capacity change if a scaling point isn't found in the timeout period.
            .. epigraph::

               If you specify ``ForceApplyCapacityChange`` , connections that prevent Aurora Serverless v1 from finding a scaling point might be dropped.

            For more information, see `Autoscaling for Aurora Serverless v1 <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless.how-it-works.html#aurora-serverless.how-it-works.auto-scaling>`_ in the *Amazon Aurora User Guide* .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbcluster-scalingconfiguration.html#cfn-rds-dbcluster-scalingconfiguration-timeoutaction
            '''
            result = self._values.get("timeout_action")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ScalingConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="monocdk.aws_rds.CfnDBCluster.ServerlessV2ScalingConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={"max_capacity": "maxCapacity", "min_capacity": "minCapacity"},
    )
    class ServerlessV2ScalingConfigurationProperty:
        def __init__(
            self,
            *,
            max_capacity: typing.Optional[jsii.Number] = None,
            min_capacity: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The ``ServerlessV2ScalingConfiguration`` property type specifies the scaling configuration of an Aurora Serverless V2 DB cluster.

            For more information, see `Using Amazon Aurora Serverless v2 <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless-v2.html>`_ in the *Amazon Aurora User Guide* .

            If you have an Aurora cluster, you must set the ``ScalingConfigurationInfo`` attribute before you add a DB instance that uses the ``db.serverless`` DB instance class. For more information, see `Clusters that use Aurora Serverless v2 must have a capacity range specified <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless-v2.requirements.html#aurora-serverless-v2.requirements.capacity-range>`_ in the *Amazon Aurora User Guide* .

            This property is only supported for Aurora Serverless v2. For Aurora Serverless v1, use ``ScalingConfiguration`` property.

            :param max_capacity: The maximum number of Aurora capacity units (ACUs) for a DB instance in an Aurora Serverless v2 cluster. You can specify ACU values in half-step increments, such as 40, 40.5, 41, and so on. The largest value that you can use is 128. The maximum capacity must be higher than 0.5 ACUs. For more information, see `Choosing the maximum Aurora Serverless v2 capacity setting for a cluster <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless-v2.setting-capacity.html#aurora-serverless-v2.max_capacity_considerations>`_ in the *Amazon Aurora User Guide* .
            :param min_capacity: The minimum number of Aurora capacity units (ACUs) for a DB instance in an Aurora Serverless v2 cluster. You can specify ACU values in half-step increments, such as 8, 8.5, 9, and so on. The smallest value that you can use is 0.5.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbcluster-serverlessv2scalingconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from monocdk import aws_rds as rds
                
                serverless_v2_scaling_configuration_property = rds.CfnDBCluster.ServerlessV2ScalingConfigurationProperty(
                    max_capacity=123,
                    min_capacity=123
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__976a781e9288a5f8ae5a7857bc196a62899d4c09c197dd1f79b4a50e7e848805)
                check_type(argname="argument max_capacity", value=max_capacity, expected_type=type_hints["max_capacity"])
                check_type(argname="argument min_capacity", value=min_capacity, expected_type=type_hints["min_capacity"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if max_capacity is not None:
                self._values["max_capacity"] = max_capacity
            if min_capacity is not None:
                self._values["min_capacity"] = min_capacity

        @builtins.property
        def max_capacity(self) -> typing.Optional[jsii.Number]:
            '''The maximum number of Aurora capacity units (ACUs) for a DB instance in an Aurora Serverless v2 cluster.

            You can specify ACU values in half-step increments, such as 40, 40.5, 41, and so on. The largest value that you can use is 128.

            The maximum capacity must be higher than 0.5 ACUs. For more information, see `Choosing the maximum Aurora Serverless v2 capacity setting for a cluster <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless-v2.setting-capacity.html#aurora-serverless-v2.max_capacity_considerations>`_ in the *Amazon Aurora User Guide* .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbcluster-serverlessv2scalingconfiguration.html#cfn-rds-dbcluster-serverlessv2scalingconfiguration-maxcapacity
            '''
            result = self._values.get("max_capacity")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min_capacity(self) -> typing.Optional[jsii.Number]:
            '''The minimum number of Aurora capacity units (ACUs) for a DB instance in an Aurora Serverless v2 cluster.

            You can specify ACU values in half-step increments, such as 8, 8.5, 9, and so on. The smallest value that you can use is 0.5.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbcluster-serverlessv2scalingconfiguration.html#cfn-rds-dbcluster-serverlessv2scalingconfiguration-mincapacity
            '''
            result = self._values.get("min_capacity")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ServerlessV2ScalingConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.implements(_IInspectable_82c04a63)
class CfnDBClusterParameterGroup(
    _CfnResource_e0a482dc,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_rds.CfnDBClusterParameterGroup",
):
    '''A CloudFormation ``AWS::RDS::DBClusterParameterGroup``.

    The ``AWS::RDS::DBClusterParameterGroup`` resource creates a new Amazon RDS DB cluster parameter group.

    For information about configuring parameters for Amazon Aurora DB clusters, see `Working with parameter groups <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_WorkingWithParamGroups.html>`_ in the *Amazon Aurora User Guide* .
    .. epigraph::

       If you apply a parameter group to a DB cluster, then its DB instances might need to reboot. This can result in an outage while the DB instances are rebooting.

       If you apply a change to parameter group associated with a stopped DB cluster, then the update stack waits until the DB cluster is started.

    :cloudformationResource: AWS::RDS::DBClusterParameterGroup
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbclusterparametergroup.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from monocdk import aws_rds as rds
        
        # parameters: Any
        
        cfn_dBCluster_parameter_group = rds.CfnDBClusterParameterGroup(self, "MyCfnDBClusterParameterGroup",
            description="description",
            family="family",
            parameters=parameters,
        
            # the properties below are optional
            db_cluster_parameter_group_name="dbClusterParameterGroupName",
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        )
    '''

    def __init__(
        self,
        scope: _Construct_e78e779f,
        id: builtins.str,
        *,
        description: builtins.str,
        family: builtins.str,
        parameters: typing.Any,
        db_cluster_parameter_group_name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union[_CfnTag_95fbdc29, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Create a new ``AWS::RDS::DBClusterParameterGroup``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param description: A friendly description for this DB cluster parameter group.
        :param family: The DB cluster parameter group family name. A DB cluster parameter group can be associated with one and only one DB cluster parameter group family, and can be applied only to a DB cluster running a DB engine and engine version compatible with that DB cluster parameter group family. .. epigraph:: The DB cluster parameter group family can't be changed when updating a DB cluster parameter group. To list all of the available parameter group families, use the following command: ``aws rds describe-db-engine-versions --query "DBEngineVersions[].DBParameterGroupFamily"`` The output contains duplicates. For more information, see ``[CreateDBClusterParameterGroup](https://docs.aws.amazon.com//AmazonRDS/latest/APIReference/API_CreateDBClusterParameterGroup.html)`` .
        :param parameters: Provides a list of parameters for the DB cluster parameter group.
        :param db_cluster_parameter_group_name: The name of the DB cluster parameter group. Constraints: - Must not match the name of an existing DB cluster parameter group. If you don't specify a value for ``DBClusterParameterGroupName`` property, a name is automatically created for the DB cluster parameter group. .. epigraph:: This value is stored as a lowercase string.
        :param tags: An optional array of key-value pairs to apply to this DB cluster parameter group.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9d40a6672126306ea0513fe149015f5f521c3a1854bcf15f8867b0f15d156dd7)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = CfnDBClusterParameterGroupProps(
            description=description,
            family=family,
            parameters=parameters,
            db_cluster_parameter_group_name=db_cluster_parameter_group_name,
            tags=tags,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_1cd1894e) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f65ea0c4f542c8675b154afd9c3185e1111643e01fb948e321c88d6206faafa7)
            check_type(argname="argument inspector", value=inspector, expected_type=type_hints["inspector"])
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__30d0dce115283c1c378440f13c8f6e5c740fe2789adbe45ee7df8c3863e4aa4d)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property
    @jsii.member(jsii_name="tags")
    def tags(self) -> _TagManager_0b7ab120:
        '''An optional array of key-value pairs to apply to this DB cluster parameter group.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbclusterparametergroup.html#cfn-rds-dbclusterparametergroup-tags
        '''
        return typing.cast(_TagManager_0b7ab120, jsii.get(self, "tags"))

    @builtins.property
    @jsii.member(jsii_name="description")
    def description(self) -> builtins.str:
        '''A friendly description for this DB cluster parameter group.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbclusterparametergroup.html#cfn-rds-dbclusterparametergroup-description
        '''
        return typing.cast(builtins.str, jsii.get(self, "description"))

    @description.setter
    def description(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dac7c65ac9efeba0a1233424235cf8013e53bce8f6e642fe8096639e1e75df57)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "description", value)

    @builtins.property
    @jsii.member(jsii_name="family")
    def family(self) -> builtins.str:
        '''The DB cluster parameter group family name.

        A DB cluster parameter group can be associated with one and only one DB cluster parameter group family, and can be applied only to a DB cluster running a DB engine and engine version compatible with that DB cluster parameter group family.
        .. epigraph::

           The DB cluster parameter group family can't be changed when updating a DB cluster parameter group.

        To list all of the available parameter group families, use the following command:

        ``aws rds describe-db-engine-versions --query "DBEngineVersions[].DBParameterGroupFamily"``

        The output contains duplicates.

        For more information, see ``[CreateDBClusterParameterGroup](https://docs.aws.amazon.com//AmazonRDS/latest/APIReference/API_CreateDBClusterParameterGroup.html)`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbclusterparametergroup.html#cfn-rds-dbclusterparametergroup-family
        '''
        return typing.cast(builtins.str, jsii.get(self, "family"))

    @family.setter
    def family(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__115a45bf8215317dbe8457c488263675a9979c7606b227bc23755aa38c5ea7e5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "family", value)

    @builtins.property
    @jsii.member(jsii_name="parameters")
    def parameters(self) -> typing.Any:
        '''Provides a list of parameters for the DB cluster parameter group.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbclusterparametergroup.html#cfn-rds-dbclusterparametergroup-parameters
        '''
        return typing.cast(typing.Any, jsii.get(self, "parameters"))

    @parameters.setter
    def parameters(self, value: typing.Any) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__47f110e264ec4e3b6bbec842a3f0cf73cecd993c08745480997ef5e699ef91be)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "parameters", value)

    @builtins.property
    @jsii.member(jsii_name="dbClusterParameterGroupName")
    def db_cluster_parameter_group_name(self) -> typing.Optional[builtins.str]:
        '''The name of the DB cluster parameter group.

        Constraints:

        - Must not match the name of an existing DB cluster parameter group.

        If you don't specify a value for ``DBClusterParameterGroupName`` property, a name is automatically created for the DB cluster parameter group.
        .. epigraph::

           This value is stored as a lowercase string.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbclusterparametergroup.html#cfn-rds-dbclusterparametergroup-dbclusterparametergroupname
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "dbClusterParameterGroupName"))

    @db_cluster_parameter_group_name.setter
    def db_cluster_parameter_group_name(
        self,
        value: typing.Optional[builtins.str],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b8bb28b98f764e213c5fbc10415083fe44cfe8d270cdac2fba7d1d49462980eb)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dbClusterParameterGroupName", value)


@jsii.data_type(
    jsii_type="monocdk.aws_rds.CfnDBClusterParameterGroupProps",
    jsii_struct_bases=[],
    name_mapping={
        "description": "description",
        "family": "family",
        "parameters": "parameters",
        "db_cluster_parameter_group_name": "dbClusterParameterGroupName",
        "tags": "tags",
    },
)
class CfnDBClusterParameterGroupProps:
    def __init__(
        self,
        *,
        description: builtins.str,
        family: builtins.str,
        parameters: typing.Any,
        db_cluster_parameter_group_name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union[_CfnTag_95fbdc29, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for defining a ``CfnDBClusterParameterGroup``.

        :param description: A friendly description for this DB cluster parameter group.
        :param family: The DB cluster parameter group family name. A DB cluster parameter group can be associated with one and only one DB cluster parameter group family, and can be applied only to a DB cluster running a DB engine and engine version compatible with that DB cluster parameter group family. .. epigraph:: The DB cluster parameter group family can't be changed when updating a DB cluster parameter group. To list all of the available parameter group families, use the following command: ``aws rds describe-db-engine-versions --query "DBEngineVersions[].DBParameterGroupFamily"`` The output contains duplicates. For more information, see ``[CreateDBClusterParameterGroup](https://docs.aws.amazon.com//AmazonRDS/latest/APIReference/API_CreateDBClusterParameterGroup.html)`` .
        :param parameters: Provides a list of parameters for the DB cluster parameter group.
        :param db_cluster_parameter_group_name: The name of the DB cluster parameter group. Constraints: - Must not match the name of an existing DB cluster parameter group. If you don't specify a value for ``DBClusterParameterGroupName`` property, a name is automatically created for the DB cluster parameter group. .. epigraph:: This value is stored as a lowercase string.
        :param tags: An optional array of key-value pairs to apply to this DB cluster parameter group.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbclusterparametergroup.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_rds as rds
            
            # parameters: Any
            
            cfn_dBCluster_parameter_group_props = rds.CfnDBClusterParameterGroupProps(
                description="description",
                family="family",
                parameters=parameters,
            
                # the properties below are optional
                db_cluster_parameter_group_name="dbClusterParameterGroupName",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__238115cdc22754dbd716961ecfe9bb9732621e81ab75d49a93c10e743a41a7ea)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument family", value=family, expected_type=type_hints["family"])
            check_type(argname="argument parameters", value=parameters, expected_type=type_hints["parameters"])
            check_type(argname="argument db_cluster_parameter_group_name", value=db_cluster_parameter_group_name, expected_type=type_hints["db_cluster_parameter_group_name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "description": description,
            "family": family,
            "parameters": parameters,
        }
        if db_cluster_parameter_group_name is not None:
            self._values["db_cluster_parameter_group_name"] = db_cluster_parameter_group_name
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def description(self) -> builtins.str:
        '''A friendly description for this DB cluster parameter group.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbclusterparametergroup.html#cfn-rds-dbclusterparametergroup-description
        '''
        result = self._values.get("description")
        assert result is not None, "Required property 'description' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def family(self) -> builtins.str:
        '''The DB cluster parameter group family name.

        A DB cluster parameter group can be associated with one and only one DB cluster parameter group family, and can be applied only to a DB cluster running a DB engine and engine version compatible with that DB cluster parameter group family.
        .. epigraph::

           The DB cluster parameter group family can't be changed when updating a DB cluster parameter group.

        To list all of the available parameter group families, use the following command:

        ``aws rds describe-db-engine-versions --query "DBEngineVersions[].DBParameterGroupFamily"``

        The output contains duplicates.

        For more information, see ``[CreateDBClusterParameterGroup](https://docs.aws.amazon.com//AmazonRDS/latest/APIReference/API_CreateDBClusterParameterGroup.html)`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbclusterparametergroup.html#cfn-rds-dbclusterparametergroup-family
        '''
        result = self._values.get("family")
        assert result is not None, "Required property 'family' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def parameters(self) -> typing.Any:
        '''Provides a list of parameters for the DB cluster parameter group.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbclusterparametergroup.html#cfn-rds-dbclusterparametergroup-parameters
        '''
        result = self._values.get("parameters")
        assert result is not None, "Required property 'parameters' is missing"
        return typing.cast(typing.Any, result)

    @builtins.property
    def db_cluster_parameter_group_name(self) -> typing.Optional[builtins.str]:
        '''The name of the DB cluster parameter group.

        Constraints:

        - Must not match the name of an existing DB cluster parameter group.

        If you don't specify a value for ``DBClusterParameterGroupName`` property, a name is automatically created for the DB cluster parameter group.
        .. epigraph::

           This value is stored as a lowercase string.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbclusterparametergroup.html#cfn-rds-dbclusterparametergroup-dbclusterparametergroupname
        '''
        result = self._values.get("db_cluster_parameter_group_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[_CfnTag_95fbdc29]]:
        '''An optional array of key-value pairs to apply to this DB cluster parameter group.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbclusterparametergroup.html#cfn-rds-dbclusterparametergroup-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[_CfnTag_95fbdc29]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnDBClusterParameterGroupProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_rds.CfnDBClusterProps",
    jsii_struct_bases=[],
    name_mapping={
        "allocated_storage": "allocatedStorage",
        "associated_roles": "associatedRoles",
        "auto_minor_version_upgrade": "autoMinorVersionUpgrade",
        "availability_zones": "availabilityZones",
        "backtrack_window": "backtrackWindow",
        "backup_retention_period": "backupRetentionPeriod",
        "copy_tags_to_snapshot": "copyTagsToSnapshot",
        "database_name": "databaseName",
        "db_cluster_identifier": "dbClusterIdentifier",
        "db_cluster_instance_class": "dbClusterInstanceClass",
        "db_cluster_parameter_group_name": "dbClusterParameterGroupName",
        "db_instance_parameter_group_name": "dbInstanceParameterGroupName",
        "db_subnet_group_name": "dbSubnetGroupName",
        "db_system_id": "dbSystemId",
        "deletion_protection": "deletionProtection",
        "domain": "domain",
        "domain_iam_role_name": "domainIamRoleName",
        "enable_cloudwatch_logs_exports": "enableCloudwatchLogsExports",
        "enable_http_endpoint": "enableHttpEndpoint",
        "enable_iam_database_authentication": "enableIamDatabaseAuthentication",
        "engine": "engine",
        "engine_mode": "engineMode",
        "engine_version": "engineVersion",
        "global_cluster_identifier": "globalClusterIdentifier",
        "iops": "iops",
        "kms_key_id": "kmsKeyId",
        "manage_master_user_password": "manageMasterUserPassword",
        "master_username": "masterUsername",
        "master_user_password": "masterUserPassword",
        "master_user_secret": "masterUserSecret",
        "monitoring_interval": "monitoringInterval",
        "monitoring_role_arn": "monitoringRoleArn",
        "network_type": "networkType",
        "performance_insights_enabled": "performanceInsightsEnabled",
        "performance_insights_kms_key_id": "performanceInsightsKmsKeyId",
        "performance_insights_retention_period": "performanceInsightsRetentionPeriod",
        "port": "port",
        "preferred_backup_window": "preferredBackupWindow",
        "preferred_maintenance_window": "preferredMaintenanceWindow",
        "publicly_accessible": "publiclyAccessible",
        "replication_source_identifier": "replicationSourceIdentifier",
        "restore_to_time": "restoreToTime",
        "restore_type": "restoreType",
        "scaling_configuration": "scalingConfiguration",
        "serverless_v2_scaling_configuration": "serverlessV2ScalingConfiguration",
        "snapshot_identifier": "snapshotIdentifier",
        "source_db_cluster_identifier": "sourceDbClusterIdentifier",
        "source_region": "sourceRegion",
        "storage_encrypted": "storageEncrypted",
        "storage_type": "storageType",
        "tags": "tags",
        "use_latest_restorable_time": "useLatestRestorableTime",
        "vpc_security_group_ids": "vpcSecurityGroupIds",
    },
)
class CfnDBClusterProps:
    def __init__(
        self,
        *,
        allocated_storage: typing.Optional[jsii.Number] = None,
        associated_roles: typing.Optional[typing.Union[_IResolvable_a771d0ef, typing.Sequence[typing.Union[typing.Union[CfnDBCluster.DBClusterRoleProperty, typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]]]] = None,
        auto_minor_version_upgrade: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        availability_zones: typing.Optional[typing.Sequence[builtins.str]] = None,
        backtrack_window: typing.Optional[jsii.Number] = None,
        backup_retention_period: typing.Optional[jsii.Number] = None,
        copy_tags_to_snapshot: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        database_name: typing.Optional[builtins.str] = None,
        db_cluster_identifier: typing.Optional[builtins.str] = None,
        db_cluster_instance_class: typing.Optional[builtins.str] = None,
        db_cluster_parameter_group_name: typing.Optional[builtins.str] = None,
        db_instance_parameter_group_name: typing.Optional[builtins.str] = None,
        db_subnet_group_name: typing.Optional[builtins.str] = None,
        db_system_id: typing.Optional[builtins.str] = None,
        deletion_protection: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        domain: typing.Optional[builtins.str] = None,
        domain_iam_role_name: typing.Optional[builtins.str] = None,
        enable_cloudwatch_logs_exports: typing.Optional[typing.Sequence[builtins.str]] = None,
        enable_http_endpoint: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        enable_iam_database_authentication: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        engine: typing.Optional[builtins.str] = None,
        engine_mode: typing.Optional[builtins.str] = None,
        engine_version: typing.Optional[builtins.str] = None,
        global_cluster_identifier: typing.Optional[builtins.str] = None,
        iops: typing.Optional[jsii.Number] = None,
        kms_key_id: typing.Optional[builtins.str] = None,
        manage_master_user_password: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        master_username: typing.Optional[builtins.str] = None,
        master_user_password: typing.Optional[builtins.str] = None,
        master_user_secret: typing.Optional[typing.Union[typing.Union[CfnDBCluster.MasterUserSecretProperty, typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]] = None,
        monitoring_interval: typing.Optional[jsii.Number] = None,
        monitoring_role_arn: typing.Optional[builtins.str] = None,
        network_type: typing.Optional[builtins.str] = None,
        performance_insights_enabled: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        performance_insights_kms_key_id: typing.Optional[builtins.str] = None,
        performance_insights_retention_period: typing.Optional[jsii.Number] = None,
        port: typing.Optional[jsii.Number] = None,
        preferred_backup_window: typing.Optional[builtins.str] = None,
        preferred_maintenance_window: typing.Optional[builtins.str] = None,
        publicly_accessible: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        replication_source_identifier: typing.Optional[builtins.str] = None,
        restore_to_time: typing.Optional[builtins.str] = None,
        restore_type: typing.Optional[builtins.str] = None,
        scaling_configuration: typing.Optional[typing.Union[typing.Union[CfnDBCluster.ScalingConfigurationProperty, typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]] = None,
        serverless_v2_scaling_configuration: typing.Optional[typing.Union[typing.Union[CfnDBCluster.ServerlessV2ScalingConfigurationProperty, typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]] = None,
        snapshot_identifier: typing.Optional[builtins.str] = None,
        source_db_cluster_identifier: typing.Optional[builtins.str] = None,
        source_region: typing.Optional[builtins.str] = None,
        storage_encrypted: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        storage_type: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union[_CfnTag_95fbdc29, typing.Dict[builtins.str, typing.Any]]]] = None,
        use_latest_restorable_time: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        vpc_security_group_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''Properties for defining a ``CfnDBCluster``.

        :param allocated_storage: The amount of storage in gibibytes (GiB) to allocate to each DB instance in the Multi-AZ DB cluster. This setting is required to create a Multi-AZ DB cluster. Valid for: Multi-AZ DB clusters only
        :param associated_roles: Provides a list of the AWS Identity and Access Management (IAM) roles that are associated with the DB cluster. IAM roles that are associated with a DB cluster grant permission for the DB cluster to access other Amazon Web Services on your behalf. Valid for: Aurora DB clusters and Multi-AZ DB clusters
        :param auto_minor_version_upgrade: A value that indicates whether minor engine upgrades are applied automatically to the DB cluster during the maintenance window. By default, minor engine upgrades are applied automatically. Valid for: Multi-AZ DB clusters only
        :param availability_zones: A list of Availability Zones (AZs) where instances in the DB cluster can be created. For information on AWS Regions and Availability Zones, see `Choosing the Regions and Availability Zones <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Concepts.RegionsAndAvailabilityZones.html>`_ in the *Amazon Aurora User Guide* . Valid for: Aurora DB clusters only
        :param backtrack_window: The target backtrack window, in seconds. To disable backtracking, set this value to 0. .. epigraph:: Currently, Backtrack is only supported for Aurora MySQL DB clusters. Default: 0 Constraints: - If specified, this value must be set to a number from 0 to 259,200 (72 hours). Valid for: Aurora MySQL DB clusters only
        :param backup_retention_period: The number of days for which automated backups are retained. Default: 1 Constraints: - Must be a value from 1 to 35 Valid for: Aurora DB clusters and Multi-AZ DB clusters
        :param copy_tags_to_snapshot: A value that indicates whether to copy all tags from the DB cluster to snapshots of the DB cluster. The default is not to copy them. Valid for: Aurora DB clusters and Multi-AZ DB clusters
        :param database_name: The name of your database. If you don't provide a name, then Amazon RDS won't create a database in this DB cluster. For naming constraints, see `Naming Constraints <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/CHAP_Limits.html#RDS_Limits.Constraints>`_ in the *Amazon Aurora User Guide* . Valid for: Aurora DB clusters and Multi-AZ DB clusters
        :param db_cluster_identifier: The DB cluster identifier. This parameter is stored as a lowercase string. Constraints: - Must contain from 1 to 63 letters, numbers, or hyphens. - First character must be a letter. - Can't end with a hyphen or contain two consecutive hyphens. Example: ``my-cluster1`` Valid for: Aurora DB clusters and Multi-AZ DB clusters
        :param db_cluster_instance_class: The compute and memory capacity of each DB instance in the Multi-AZ DB cluster, for example db.m6gd.xlarge. Not all DB instance classes are available in all AWS Regions , or for all database engines. For the full list of DB instance classes and availability for your engine, see `DB instance class <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html>`_ in the *Amazon RDS User Guide* . This setting is required to create a Multi-AZ DB cluster. Valid for: Multi-AZ DB clusters only
        :param db_cluster_parameter_group_name: The name of the DB cluster parameter group to associate with this DB cluster. .. epigraph:: If you apply a parameter group to an existing DB cluster, then its DB instances might need to reboot. This can result in an outage while the DB instances are rebooting. If you apply a change to parameter group associated with a stopped DB cluster, then the update stack waits until the DB cluster is started. To list all of the available DB cluster parameter group names, use the following command: ``aws rds describe-db-cluster-parameter-groups --query "DBClusterParameterGroups[].DBClusterParameterGroupName" --output text`` Valid for: Aurora DB clusters and Multi-AZ DB clusters
        :param db_instance_parameter_group_name: The name of the DB parameter group to apply to all instances of the DB cluster. .. epigraph:: When you apply a parameter group using the ``DBInstanceParameterGroupName`` parameter, the DB cluster isn't rebooted automatically. Also, parameter changes are applied immediately rather than during the next maintenance window. Default: The existing name setting Constraints: - The DB parameter group must be in the same DB parameter group family as this DB cluster.
        :param db_subnet_group_name: A DB subnet group that you want to associate with this DB cluster. If you are restoring a DB cluster to a point in time with ``RestoreType`` set to ``copy-on-write`` , and don't specify a DB subnet group name, then the DB cluster is restored with a default DB subnet group. Valid for: Aurora DB clusters and Multi-AZ DB clusters
        :param db_system_id: Reserved for future use.
        :param deletion_protection: A value that indicates whether the DB cluster has deletion protection enabled. The database can't be deleted when deletion protection is enabled. By default, deletion protection is disabled. Valid for: Aurora DB clusters and Multi-AZ DB clusters
        :param domain: Indicates the directory ID of the Active Directory to create the DB cluster. For Amazon Aurora DB clusters, Amazon RDS can use Kerberos authentication to authenticate users that connect to the DB cluster. For more information, see `Kerberos authentication <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/kerberos-authentication.html>`_ in the *Amazon Aurora User Guide* . Valid for: Aurora DB clusters only
        :param domain_iam_role_name: Specifies the name of the IAM role to use when making API calls to the Directory Service. Valid for: Aurora DB clusters only
        :param enable_cloudwatch_logs_exports: The list of log types that need to be enabled for exporting to CloudWatch Logs. The values in the list depend on the DB engine being used. For more information, see `Publishing Database Logs to Amazon CloudWatch Logs <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_LogAccess.html#USER_LogAccess.Procedural.UploadtoCloudWatch>`_ in the *Amazon Aurora User Guide* . *Aurora MySQL* Valid values: ``audit`` , ``error`` , ``general`` , ``slowquery`` *Aurora PostgreSQL* Valid values: ``postgresql`` Valid for: Aurora DB clusters and Multi-AZ DB clusters
        :param enable_http_endpoint: A value that indicates whether to enable the HTTP endpoint for an Aurora Serverless DB cluster. By default, the HTTP endpoint is disabled. When enabled, the HTTP endpoint provides a connectionless web service API for running SQL queries on the Aurora Serverless DB cluster. You can also query your database from inside the RDS console with the query editor. For more information, see `Using the Data API for Aurora Serverless <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/data-api.html>`_ in the *Amazon Aurora User Guide* . Valid for: Aurora DB clusters only
        :param enable_iam_database_authentication: A value that indicates whether to enable mapping of AWS Identity and Access Management (IAM) accounts to database accounts. By default, mapping is disabled. For more information, see `IAM Database Authentication <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/UsingWithRDS.IAMDBAuth.html>`_ in the *Amazon Aurora User Guide.* Valid for: Aurora DB clusters only
        :param engine: The name of the database engine to be used for this DB cluster. Valid Values: - ``aurora-mysql`` - ``aurora-postgresql`` - ``mysql`` - ``postgres`` Valid for: Aurora DB clusters and Multi-AZ DB clusters
        :param engine_mode: The DB engine mode of the DB cluster, either ``provisioned`` or ``serverless`` . The ``serverless`` engine mode only supports Aurora Serverless v1. Currently, AWS CloudFormation doesn't support Aurora Serverless v2. Limitations and requirements apply to some DB engine modes. For more information, see the following sections in the *Amazon Aurora User Guide* : - `Limitations of Aurora Serverless v1 <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless.html#aurora-serverless.limitations>`_ - `Requirements for Aurora Serverless v2 <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless-v2.requirements.html>`_ - `Limitations of parallel query <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-mysql-parallel-query.html#aurora-mysql-parallel-query-limitations>`_ - `Limitations of Aurora global databases <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-global-database.html#aurora-global-database.limitations>`_ Valid for: Aurora DB clusters only
        :param engine_version: The version number of the database engine to use. To list all of the available engine versions for Aurora MySQL version 2 (5.7-compatible) and version 3 (8.0-compatible), use the following command: ``aws rds describe-db-engine-versions --engine aurora-mysql --query "DBEngineVersions[].EngineVersion"`` You can supply either ``5.7`` or ``8.0`` to use the default engine version for Aurora MySQL version 2 or version 3, respectively. To list all of the available engine versions for Aurora PostgreSQL, use the following command: ``aws rds describe-db-engine-versions --engine aurora-postgresql --query "DBEngineVersions[].EngineVersion"`` To list all of the available engine versions for RDS for MySQL, use the following command: ``aws rds describe-db-engine-versions --engine mysql --query "DBEngineVersions[].EngineVersion"`` To list all of the available engine versions for RDS for PostgreSQL, use the following command: ``aws rds describe-db-engine-versions --engine postgres --query "DBEngineVersions[].EngineVersion"`` *Aurora MySQL* For information, see `Database engine updates for Amazon Aurora MySQL <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/AuroraMySQL.Updates.html>`_ in the *Amazon Aurora User Guide* . *Aurora PostgreSQL* For information, see `Amazon Aurora PostgreSQL releases and engine versions <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/AuroraPostgreSQL.Updates.20180305.html>`_ in the *Amazon Aurora User Guide* . *MySQL* For information, see `Amazon RDS for MySQL <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_MySQL.html#MySQL.Concepts.VersionMgmt>`_ in the *Amazon RDS User Guide* . *PostgreSQL* For information, see `Amazon RDS for PostgreSQL <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_PostgreSQL.html#PostgreSQL.Concepts>`_ in the *Amazon RDS User Guide* . Valid for: Aurora DB clusters and Multi-AZ DB clusters
        :param global_cluster_identifier: If you are configuring an Aurora global database cluster and want your Aurora DB cluster to be a secondary member in the global database cluster, specify the global cluster ID of the global database cluster. To define the primary database cluster of the global cluster, use the `AWS::RDS::GlobalCluster <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-globalcluster.html>`_ resource. If you aren't configuring a global database cluster, don't specify this property. .. epigraph:: To remove the DB cluster from a global database cluster, specify an empty value for the ``GlobalClusterIdentifier`` property. For information about Aurora global databases, see `Working with Amazon Aurora Global Databases <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-global-database.html>`_ in the *Amazon Aurora User Guide* . Valid for: Aurora DB clusters only
        :param iops: The amount of Provisioned IOPS (input/output operations per second) to be initially allocated for each DB instance in the Multi-AZ DB cluster. For information about valid IOPS values, see `Provisioned IOPS storage <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Storage.html#USER_PIOPS>`_ in the *Amazon RDS User Guide* . This setting is required to create a Multi-AZ DB cluster. Constraints: Must be a multiple between .5 and 50 of the storage amount for the DB cluster. Valid for: Multi-AZ DB clusters only
        :param kms_key_id: The Amazon Resource Name (ARN) of the AWS KMS key that is used to encrypt the database instances in the DB cluster, such as ``arn:aws:kms:us-east-1:012345678910:key/abcd1234-a123-456a-a12b-a123b4cd56ef`` . If you enable the ``StorageEncrypted`` property but don't specify this property, the default KMS key is used. If you specify this property, you must set the ``StorageEncrypted`` property to ``true`` . If you specify the ``SnapshotIdentifier`` property, the ``StorageEncrypted`` property value is inherited from the snapshot, and if the DB cluster is encrypted, the specified ``KmsKeyId`` property is used. Valid for: Aurora DB clusters and Multi-AZ DB clusters
        :param manage_master_user_password: A value that indicates whether to manage the master user password with AWS Secrets Manager. For more information, see `Password management with AWS Secrets Manager <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-secrets-manager.html>`_ in the *Amazon RDS User Guide* and `Password management with AWS Secrets Manager <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/rds-secrets-manager.html>`_ in the *Amazon Aurora User Guide.* Constraints: - Can't manage the master user password with AWS Secrets Manager if ``MasterUserPassword`` is specified. Valid for: Aurora DB clusters and Multi-AZ DB clusters
        :param master_username: The name of the master user for the DB cluster. .. epigraph:: If you specify the ``SourceDBClusterIdentifier`` , ``SnapshotIdentifier`` , or ``GlobalClusterIdentifier`` property, don't specify this property. The value is inherited from the source DB cluster, the snapshot, or the primary DB cluster for the global database cluster, respectively. Valid for: Aurora DB clusters and Multi-AZ DB clusters
        :param master_user_password: The master password for the DB instance. .. epigraph:: If you specify the ``SourceDBClusterIdentifier`` , ``SnapshotIdentifier`` , or ``GlobalClusterIdentifier`` property, don't specify this property. The value is inherited from the source DB cluster, the snapshot, or the primary DB cluster for the global database cluster, respectively. Valid for: Aurora DB clusters and Multi-AZ DB clusters
        :param master_user_secret: Contains the secret managed by RDS in AWS Secrets Manager for the master user password. For more information, see `Password management with AWS Secrets Manager <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-secrets-manager.html>`_ in the *Amazon RDS User Guide* and `Password management with AWS Secrets Manager <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/rds-secrets-manager.html>`_ in the *Amazon Aurora User Guide.*
        :param monitoring_interval: The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the DB cluster. To turn off collecting Enhanced Monitoring metrics, specify 0. The default is 0. If ``MonitoringRoleArn`` is specified, also set ``MonitoringInterval`` to a value other than 0. Valid Values: ``0, 1, 5, 10, 15, 30, 60`` Valid for: Multi-AZ DB clusters only
        :param monitoring_role_arn: The Amazon Resource Name (ARN) for the IAM role that permits RDS to send Enhanced Monitoring metrics to Amazon CloudWatch Logs. An example is ``arn:aws:iam:123456789012:role/emaccess`` . For information on creating a monitoring role, see `Setting up and enabling Enhanced Monitoring <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Monitoring.OS.html#USER_Monitoring.OS.Enabling>`_ in the *Amazon RDS User Guide* . If ``MonitoringInterval`` is set to a value other than 0, supply a ``MonitoringRoleArn`` value. Valid for: Multi-AZ DB clusters only
        :param network_type: The network type of the DB cluster. Valid values: - ``IPV4`` - ``DUAL`` The network type is determined by the ``DBSubnetGroup`` specified for the DB cluster. A ``DBSubnetGroup`` can support only the IPv4 protocol or the IPv4 and IPv6 protocols ( ``DUAL`` ). For more information, see `Working with a DB instance in a VPC <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_VPC.WorkingWithRDSInstanceinaVPC.html>`_ in the *Amazon Aurora User Guide.* Valid for: Aurora DB clusters only
        :param performance_insights_enabled: A value that indicates whether to turn on Performance Insights for the DB cluster. For more information, see `Using Amazon Performance Insights <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PerfInsights.html>`_ in the *Amazon RDS User Guide* . Valid for: Multi-AZ DB clusters only
        :param performance_insights_kms_key_id: The AWS KMS key identifier for encryption of Performance Insights data. The AWS KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. If you don't specify a value for ``PerformanceInsightsKMSKeyId`` , then Amazon RDS uses your default KMS key. There is a default KMS key for your AWS account . Your AWS account has a different default KMS key for each AWS Region . Valid for: Multi-AZ DB clusters only
        :param performance_insights_retention_period: The number of days to retain Performance Insights data. The default is 7 days. The following values are valid:. - 7 - *month* * 31, where *month* is a number of months from 1-23 - 731 For example, the following values are valid: - 93 (3 months * 31) - 341 (11 months * 31) - 589 (19 months * 31) - 731 If you specify a retention period such as 94, which isn't a valid value, RDS issues an error. Valid for: Multi-AZ DB clusters only
        :param port: The port number on which the DB instances in the DB cluster accept connections. Default: - When ``EngineMode`` is ``provisioned`` , ``3306`` (for both Aurora MySQL and Aurora PostgreSQL) - When ``EngineMode`` is ``serverless`` : - ``3306`` when ``Engine`` is ``aurora`` or ``aurora-mysql`` - ``5432`` when ``Engine`` is ``aurora-postgresql`` .. epigraph:: The ``No interruption`` on update behavior only applies to DB clusters. If you are updating a DB instance, see `Port <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-database-instance.html#cfn-rds-dbinstance-port>`_ for the AWS::RDS::DBInstance resource. Valid for: Aurora DB clusters and Multi-AZ DB clusters
        :param preferred_backup_window: The daily time range during which automated backups are created. For more information, see `Backup Window <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.Managing.Backups.html#Aurora.Managing.Backups.BackupWindow>`_ in the *Amazon Aurora User Guide.* Constraints: - Must be in the format ``hh24:mi-hh24:mi`` . - Must be in Universal Coordinated Time (UTC). - Must not conflict with the preferred maintenance window. - Must be at least 30 minutes. Valid for: Aurora DB clusters and Multi-AZ DB clusters
        :param preferred_maintenance_window: The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC). Format: ``ddd:hh24:mi-ddd:hh24:mi`` The default is a 30-minute window selected at random from an 8-hour block of time for each AWS Region, occurring on a random day of the week. To see the time blocks available, see `Adjusting the Preferred DB Cluster Maintenance Window <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_UpgradeDBInstance.Maintenance.html#AdjustingTheMaintenanceWindow.Aurora>`_ in the *Amazon Aurora User Guide.* Valid Days: Mon, Tue, Wed, Thu, Fri, Sat, Sun. Constraints: Minimum 30-minute window. Valid for: Aurora DB clusters and Multi-AZ DB clusters
        :param publicly_accessible: A value that indicates whether the DB cluster is publicly accessible. When the DB cluster is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address from within the DB cluster's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB cluster's VPC. Access to the DB cluster is ultimately controlled by the security group it uses. That public access isn't permitted if the security group assigned to the DB cluster doesn't permit it. When the DB cluster isn't publicly accessible, it is an internal DB cluster with a DNS name that resolves to a private IP address. Default: The default behavior varies depending on whether ``DBSubnetGroupName`` is specified. If ``DBSubnetGroupName`` isn't specified, and ``PubliclyAccessible`` isn't specified, the following applies: - If the default VPC in the target Region doesnt have an internet gateway attached to it, the DB cluster is private. - If the default VPC in the target Region has an internet gateway attached to it, the DB cluster is public. If ``DBSubnetGroupName`` is specified, and ``PubliclyAccessible`` isn't specified, the following applies: - If the subnets are part of a VPC that doesnt have an internet gateway attached to it, the DB cluster is private. - If the subnets are part of a VPC that has an internet gateway attached to it, the DB cluster is public. Valid for: Multi-AZ DB clusters only
        :param replication_source_identifier: The Amazon Resource Name (ARN) of the source DB instance or DB cluster if this DB cluster is created as a read replica. Valid for: Aurora DB clusters only
        :param restore_to_time: The date and time to restore the DB cluster to. Valid Values: Value must be a time in Universal Coordinated Time (UTC) format Constraints: - Must be before the latest restorable time for the DB instance - Must be specified if ``UseLatestRestorableTime`` parameter isn't provided - Can't be specified if the ``UseLatestRestorableTime`` parameter is enabled - Can't be specified if the ``RestoreType`` parameter is ``copy-on-write`` Example: ``2015-03-07T23:45:00Z`` Valid for: Aurora DB clusters and Multi-AZ DB clusters
        :param restore_type: The type of restore to be performed. You can specify one of the following values:. - ``full-copy`` - The new DB cluster is restored as a full copy of the source DB cluster. - ``copy-on-write`` - The new DB cluster is restored as a clone of the source DB cluster. If you don't specify a ``RestoreType`` value, then the new DB cluster is restored as a full copy of the source DB cluster. Valid for: Aurora DB clusters and Multi-AZ DB clusters
        :param scaling_configuration: The ``ScalingConfiguration`` property type specifies the scaling configuration of an Aurora Serverless DB cluster. This property is only supported for Aurora Serverless v1. For Aurora Serverless v2, use ``ServerlessV2ScalingConfiguration`` property. Valid for: Aurora DB clusters only
        :param serverless_v2_scaling_configuration: The ``ServerlessV2ScalingConfiguration`` property type specifies the scaling configuration of an Aurora Serverless V2 DB cluster. This property is only supported for Aurora Serverless v2. For Aurora Serverless v1, use ``ScalingConfiguration`` property. Valid for: Aurora DB clusters only
        :param snapshot_identifier: The identifier for the DB snapshot or DB cluster snapshot to restore from. You can use either the name or the Amazon Resource Name (ARN) to specify a DB cluster snapshot. However, you can use only the ARN to specify a DB snapshot. After you restore a DB cluster with a ``SnapshotIdentifier`` property, you must specify the same ``SnapshotIdentifier`` property for any future updates to the DB cluster. When you specify this property for an update, the DB cluster is not restored from the snapshot again, and the data in the database is not changed. However, if you don't specify the ``SnapshotIdentifier`` property, an empty DB cluster is created, and the original DB cluster is deleted. If you specify a property that is different from the previous snapshot restore property, a new DB cluster is restored from the specified ``SnapshotIdentifier`` property, and the original DB cluster is deleted. If you specify the ``SnapshotIdentifier`` property to restore a DB cluster (as opposed to specifying it for DB cluster updates), then don't specify the following properties: - ``GlobalClusterIdentifier`` - ``MasterUsername`` - ``MasterUserPassword`` - ``ReplicationSourceIdentifier`` - ``RestoreType`` - ``SourceDBClusterIdentifier`` - ``SourceRegion`` - ``StorageEncrypted`` (for an encrypted snapshot) - ``UseLatestRestorableTime`` Constraints: - Must match the identifier of an existing Snapshot. Valid for: Aurora DB clusters and Multi-AZ DB clusters
        :param source_db_cluster_identifier: When restoring a DB cluster to a point in time, the identifier of the source DB cluster from which to restore. Constraints: - Must match the identifier of an existing DBCluster. Valid for: Aurora DB clusters and Multi-AZ DB clusters
        :param source_region: The AWS Region which contains the source DB cluster when replicating a DB cluster. For example, ``us-east-1`` . Valid for: Aurora DB clusters only
        :param storage_encrypted: Indicates whether the DB cluster is encrypted. If you specify the ``KmsKeyId`` property, then you must enable encryption. If you specify the ``SourceDBClusterIdentifier`` property, don't specify this property. The value is inherited from the source DB cluster, and if the DB cluster is encrypted, the specified ``KmsKeyId`` property is used. If you specify the ``SnapshotIdentifier`` and the specified snapshot is encrypted, don't specify this property. The value is inherited from the snapshot, and the specified ``KmsKeyId`` property is used. If you specify the ``SnapshotIdentifier`` and the specified snapshot isn't encrypted, you can use this property to specify that the restored DB cluster is encrypted. Specify the ``KmsKeyId`` property for the KMS key to use for encryption. If you don't want the restored DB cluster to be encrypted, then don't set this property or set it to ``false`` . Valid for: Aurora DB clusters and Multi-AZ DB clusters
        :param storage_type: Specifies the storage type to be associated with the DB cluster. This setting is required to create a Multi-AZ DB cluster. When specified for a Multi-AZ DB cluster, a value for the ``Iops`` parameter is required. Valid values: ``aurora`` , ``aurora-iopt1`` (Aurora DB clusters); ``io1`` (Multi-AZ DB clusters) Default: ``aurora`` (Aurora DB clusters); ``io1`` (Multi-AZ DB clusters) Valid for: Aurora DB clusters and Multi-AZ DB clusters For more information on storage types for Aurora DB clusters, see `Storage configurations for Amazon Aurora DB clusters <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.Overview.StorageReliability.html#aurora-storage-type>`_ . For more information on storage types for Multi-AZ DB clusters, see `Settings for creating Multi-AZ DB clusters <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/create-multi-az-db-cluster.html#create-multi-az-db-cluster-settings>`_ .
        :param tags: An optional array of key-value pairs to apply to this DB cluster. Valid for: Aurora DB clusters and Multi-AZ DB clusters
        :param use_latest_restorable_time: A value that indicates whether to restore the DB cluster to the latest restorable backup time. By default, the DB cluster is not restored to the latest restorable backup time. Valid for: Aurora DB clusters and Multi-AZ DB clusters
        :param vpc_security_group_ids: A list of EC2 VPC security groups to associate with this DB cluster. If you plan to update the resource, don't specify VPC security groups in a shared VPC. Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_rds as rds
            
            cfn_dBCluster_props = rds.CfnDBClusterProps(
                allocated_storage=123,
                associated_roles=[rds.CfnDBCluster.DBClusterRoleProperty(
                    role_arn="roleArn",
            
                    # the properties below are optional
                    feature_name="featureName"
                )],
                auto_minor_version_upgrade=False,
                availability_zones=["availabilityZones"],
                backtrack_window=123,
                backup_retention_period=123,
                copy_tags_to_snapshot=False,
                database_name="databaseName",
                db_cluster_identifier="dbClusterIdentifier",
                db_cluster_instance_class="dbClusterInstanceClass",
                db_cluster_parameter_group_name="dbClusterParameterGroupName",
                db_instance_parameter_group_name="dbInstanceParameterGroupName",
                db_subnet_group_name="dbSubnetGroupName",
                db_system_id="dbSystemId",
                deletion_protection=False,
                domain="domain",
                domain_iam_role_name="domainIamRoleName",
                enable_cloudwatch_logs_exports=["enableCloudwatchLogsExports"],
                enable_http_endpoint=False,
                enable_iam_database_authentication=False,
                engine="engine",
                engine_mode="engineMode",
                engine_version="engineVersion",
                global_cluster_identifier="globalClusterIdentifier",
                iops=123,
                kms_key_id="kmsKeyId",
                manage_master_user_password=False,
                master_username="masterUsername",
                master_user_password="masterUserPassword",
                master_user_secret=rds.CfnDBCluster.MasterUserSecretProperty(
                    kms_key_id="kmsKeyId",
                    secret_arn="secretArn"
                ),
                monitoring_interval=123,
                monitoring_role_arn="monitoringRoleArn",
                network_type="networkType",
                performance_insights_enabled=False,
                performance_insights_kms_key_id="performanceInsightsKmsKeyId",
                performance_insights_retention_period=123,
                port=123,
                preferred_backup_window="preferredBackupWindow",
                preferred_maintenance_window="preferredMaintenanceWindow",
                publicly_accessible=False,
                replication_source_identifier="replicationSourceIdentifier",
                restore_to_time="restoreToTime",
                restore_type="restoreType",
                scaling_configuration=rds.CfnDBCluster.ScalingConfigurationProperty(
                    auto_pause=False,
                    max_capacity=123,
                    min_capacity=123,
                    seconds_before_timeout=123,
                    seconds_until_auto_pause=123,
                    timeout_action="timeoutAction"
                ),
                serverless_v2_scaling_configuration=rds.CfnDBCluster.ServerlessV2ScalingConfigurationProperty(
                    max_capacity=123,
                    min_capacity=123
                ),
                snapshot_identifier="snapshotIdentifier",
                source_db_cluster_identifier="sourceDbClusterIdentifier",
                source_region="sourceRegion",
                storage_encrypted=False,
                storage_type="storageType",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                use_latest_restorable_time=False,
                vpc_security_group_ids=["vpcSecurityGroupIds"]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__df1cb8073776f728073689f404524b014453b318d53b641d003dc64b88bd7cfa)
            check_type(argname="argument allocated_storage", value=allocated_storage, expected_type=type_hints["allocated_storage"])
            check_type(argname="argument associated_roles", value=associated_roles, expected_type=type_hints["associated_roles"])
            check_type(argname="argument auto_minor_version_upgrade", value=auto_minor_version_upgrade, expected_type=type_hints["auto_minor_version_upgrade"])
            check_type(argname="argument availability_zones", value=availability_zones, expected_type=type_hints["availability_zones"])
            check_type(argname="argument backtrack_window", value=backtrack_window, expected_type=type_hints["backtrack_window"])
            check_type(argname="argument backup_retention_period", value=backup_retention_period, expected_type=type_hints["backup_retention_period"])
            check_type(argname="argument copy_tags_to_snapshot", value=copy_tags_to_snapshot, expected_type=type_hints["copy_tags_to_snapshot"])
            check_type(argname="argument database_name", value=database_name, expected_type=type_hints["database_name"])
            check_type(argname="argument db_cluster_identifier", value=db_cluster_identifier, expected_type=type_hints["db_cluster_identifier"])
            check_type(argname="argument db_cluster_instance_class", value=db_cluster_instance_class, expected_type=type_hints["db_cluster_instance_class"])
            check_type(argname="argument db_cluster_parameter_group_name", value=db_cluster_parameter_group_name, expected_type=type_hints["db_cluster_parameter_group_name"])
            check_type(argname="argument db_instance_parameter_group_name", value=db_instance_parameter_group_name, expected_type=type_hints["db_instance_parameter_group_name"])
            check_type(argname="argument db_subnet_group_name", value=db_subnet_group_name, expected_type=type_hints["db_subnet_group_name"])
            check_type(argname="argument db_system_id", value=db_system_id, expected_type=type_hints["db_system_id"])
            check_type(argname="argument deletion_protection", value=deletion_protection, expected_type=type_hints["deletion_protection"])
            check_type(argname="argument domain", value=domain, expected_type=type_hints["domain"])
            check_type(argname="argument domain_iam_role_name", value=domain_iam_role_name, expected_type=type_hints["domain_iam_role_name"])
            check_type(argname="argument enable_cloudwatch_logs_exports", value=enable_cloudwatch_logs_exports, expected_type=type_hints["enable_cloudwatch_logs_exports"])
            check_type(argname="argument enable_http_endpoint", value=enable_http_endpoint, expected_type=type_hints["enable_http_endpoint"])
            check_type(argname="argument enable_iam_database_authentication", value=enable_iam_database_authentication, expected_type=type_hints["enable_iam_database_authentication"])
            check_type(argname="argument engine", value=engine, expected_type=type_hints["engine"])
            check_type(argname="argument engine_mode", value=engine_mode, expected_type=type_hints["engine_mode"])
            check_type(argname="argument engine_version", value=engine_version, expected_type=type_hints["engine_version"])
            check_type(argname="argument global_cluster_identifier", value=global_cluster_identifier, expected_type=type_hints["global_cluster_identifier"])
            check_type(argname="argument iops", value=iops, expected_type=type_hints["iops"])
            check_type(argname="argument kms_key_id", value=kms_key_id, expected_type=type_hints["kms_key_id"])
            check_type(argname="argument manage_master_user_password", value=manage_master_user_password, expected_type=type_hints["manage_master_user_password"])
            check_type(argname="argument master_username", value=master_username, expected_type=type_hints["master_username"])
            check_type(argname="argument master_user_password", value=master_user_password, expected_type=type_hints["master_user_password"])
            check_type(argname="argument master_user_secret", value=master_user_secret, expected_type=type_hints["master_user_secret"])
            check_type(argname="argument monitoring_interval", value=monitoring_interval, expected_type=type_hints["monitoring_interval"])
            check_type(argname="argument monitoring_role_arn", value=monitoring_role_arn, expected_type=type_hints["monitoring_role_arn"])
            check_type(argname="argument network_type", value=network_type, expected_type=type_hints["network_type"])
            check_type(argname="argument performance_insights_enabled", value=performance_insights_enabled, expected_type=type_hints["performance_insights_enabled"])
            check_type(argname="argument performance_insights_kms_key_id", value=performance_insights_kms_key_id, expected_type=type_hints["performance_insights_kms_key_id"])
            check_type(argname="argument performance_insights_retention_period", value=performance_insights_retention_period, expected_type=type_hints["performance_insights_retention_period"])
            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
            check_type(argname="argument preferred_backup_window", value=preferred_backup_window, expected_type=type_hints["preferred_backup_window"])
            check_type(argname="argument preferred_maintenance_window", value=preferred_maintenance_window, expected_type=type_hints["preferred_maintenance_window"])
            check_type(argname="argument publicly_accessible", value=publicly_accessible, expected_type=type_hints["publicly_accessible"])
            check_type(argname="argument replication_source_identifier", value=replication_source_identifier, expected_type=type_hints["replication_source_identifier"])
            check_type(argname="argument restore_to_time", value=restore_to_time, expected_type=type_hints["restore_to_time"])
            check_type(argname="argument restore_type", value=restore_type, expected_type=type_hints["restore_type"])
            check_type(argname="argument scaling_configuration", value=scaling_configuration, expected_type=type_hints["scaling_configuration"])
            check_type(argname="argument serverless_v2_scaling_configuration", value=serverless_v2_scaling_configuration, expected_type=type_hints["serverless_v2_scaling_configuration"])
            check_type(argname="argument snapshot_identifier", value=snapshot_identifier, expected_type=type_hints["snapshot_identifier"])
            check_type(argname="argument source_db_cluster_identifier", value=source_db_cluster_identifier, expected_type=type_hints["source_db_cluster_identifier"])
            check_type(argname="argument source_region", value=source_region, expected_type=type_hints["source_region"])
            check_type(argname="argument storage_encrypted", value=storage_encrypted, expected_type=type_hints["storage_encrypted"])
            check_type(argname="argument storage_type", value=storage_type, expected_type=type_hints["storage_type"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument use_latest_restorable_time", value=use_latest_restorable_time, expected_type=type_hints["use_latest_restorable_time"])
            check_type(argname="argument vpc_security_group_ids", value=vpc_security_group_ids, expected_type=type_hints["vpc_security_group_ids"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if allocated_storage is not None:
            self._values["allocated_storage"] = allocated_storage
        if associated_roles is not None:
            self._values["associated_roles"] = associated_roles
        if auto_minor_version_upgrade is not None:
            self._values["auto_minor_version_upgrade"] = auto_minor_version_upgrade
        if availability_zones is not None:
            self._values["availability_zones"] = availability_zones
        if backtrack_window is not None:
            self._values["backtrack_window"] = backtrack_window
        if backup_retention_period is not None:
            self._values["backup_retention_period"] = backup_retention_period
        if copy_tags_to_snapshot is not None:
            self._values["copy_tags_to_snapshot"] = copy_tags_to_snapshot
        if database_name is not None:
            self._values["database_name"] = database_name
        if db_cluster_identifier is not None:
            self._values["db_cluster_identifier"] = db_cluster_identifier
        if db_cluster_instance_class is not None:
            self._values["db_cluster_instance_class"] = db_cluster_instance_class
        if db_cluster_parameter_group_name is not None:
            self._values["db_cluster_parameter_group_name"] = db_cluster_parameter_group_name
        if db_instance_parameter_group_name is not None:
            self._values["db_instance_parameter_group_name"] = db_instance_parameter_group_name
        if db_subnet_group_name is not None:
            self._values["db_subnet_group_name"] = db_subnet_group_name
        if db_system_id is not None:
            self._values["db_system_id"] = db_system_id
        if deletion_protection is not None:
            self._values["deletion_protection"] = deletion_protection
        if domain is not None:
            self._values["domain"] = domain
        if domain_iam_role_name is not None:
            self._values["domain_iam_role_name"] = domain_iam_role_name
        if enable_cloudwatch_logs_exports is not None:
            self._values["enable_cloudwatch_logs_exports"] = enable_cloudwatch_logs_exports
        if enable_http_endpoint is not None:
            self._values["enable_http_endpoint"] = enable_http_endpoint
        if enable_iam_database_authentication is not None:
            self._values["enable_iam_database_authentication"] = enable_iam_database_authentication
        if engine is not None:
            self._values["engine"] = engine
        if engine_mode is not None:
            self._values["engine_mode"] = engine_mode
        if engine_version is not None:
            self._values["engine_version"] = engine_version
        if global_cluster_identifier is not None:
            self._values["global_cluster_identifier"] = global_cluster_identifier
        if iops is not None:
            self._values["iops"] = iops
        if kms_key_id is not None:
            self._values["kms_key_id"] = kms_key_id
        if manage_master_user_password is not None:
            self._values["manage_master_user_password"] = manage_master_user_password
        if master_username is not None:
            self._values["master_username"] = master_username
        if master_user_password is not None:
            self._values["master_user_password"] = master_user_password
        if master_user_secret is not None:
            self._values["master_user_secret"] = master_user_secret
        if monitoring_interval is not None:
            self._values["monitoring_interval"] = monitoring_interval
        if monitoring_role_arn is not None:
            self._values["monitoring_role_arn"] = monitoring_role_arn
        if network_type is not None:
            self._values["network_type"] = network_type
        if performance_insights_enabled is not None:
            self._values["performance_insights_enabled"] = performance_insights_enabled
        if performance_insights_kms_key_id is not None:
            self._values["performance_insights_kms_key_id"] = performance_insights_kms_key_id
        if performance_insights_retention_period is not None:
            self._values["performance_insights_retention_period"] = performance_insights_retention_period
        if port is not None:
            self._values["port"] = port
        if preferred_backup_window is not None:
            self._values["preferred_backup_window"] = preferred_backup_window
        if preferred_maintenance_window is not None:
            self._values["preferred_maintenance_window"] = preferred_maintenance_window
        if publicly_accessible is not None:
            self._values["publicly_accessible"] = publicly_accessible
        if replication_source_identifier is not None:
            self._values["replication_source_identifier"] = replication_source_identifier
        if restore_to_time is not None:
            self._values["restore_to_time"] = restore_to_time
        if restore_type is not None:
            self._values["restore_type"] = restore_type
        if scaling_configuration is not None:
            self._values["scaling_configuration"] = scaling_configuration
        if serverless_v2_scaling_configuration is not None:
            self._values["serverless_v2_scaling_configuration"] = serverless_v2_scaling_configuration
        if snapshot_identifier is not None:
            self._values["snapshot_identifier"] = snapshot_identifier
        if source_db_cluster_identifier is not None:
            self._values["source_db_cluster_identifier"] = source_db_cluster_identifier
        if source_region is not None:
            self._values["source_region"] = source_region
        if storage_encrypted is not None:
            self._values["storage_encrypted"] = storage_encrypted
        if storage_type is not None:
            self._values["storage_type"] = storage_type
        if tags is not None:
            self._values["tags"] = tags
        if use_latest_restorable_time is not None:
            self._values["use_latest_restorable_time"] = use_latest_restorable_time
        if vpc_security_group_ids is not None:
            self._values["vpc_security_group_ids"] = vpc_security_group_ids

    @builtins.property
    def allocated_storage(self) -> typing.Optional[jsii.Number]:
        '''The amount of storage in gibibytes (GiB) to allocate to each DB instance in the Multi-AZ DB cluster.

        This setting is required to create a Multi-AZ DB cluster.

        Valid for: Multi-AZ DB clusters only

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-allocatedstorage
        '''
        result = self._values.get("allocated_storage")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def associated_roles(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_a771d0ef, typing.List[typing.Union[CfnDBCluster.DBClusterRoleProperty, _IResolvable_a771d0ef]]]]:
        '''Provides a list of the AWS Identity and Access Management (IAM) roles that are associated with the DB cluster.

        IAM roles that are associated with a DB cluster grant permission for the DB cluster to access other Amazon Web Services on your behalf.

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-associatedroles
        '''
        result = self._values.get("associated_roles")
        return typing.cast(typing.Optional[typing.Union[_IResolvable_a771d0ef, typing.List[typing.Union[CfnDBCluster.DBClusterRoleProperty, _IResolvable_a771d0ef]]]], result)

    @builtins.property
    def auto_minor_version_upgrade(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''A value that indicates whether minor engine upgrades are applied automatically to the DB cluster during the maintenance window.

        By default, minor engine upgrades are applied automatically.

        Valid for: Multi-AZ DB clusters only

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-autominorversionupgrade
        '''
        result = self._values.get("auto_minor_version_upgrade")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], result)

    @builtins.property
    def availability_zones(self) -> typing.Optional[typing.List[builtins.str]]:
        '''A list of Availability Zones (AZs) where instances in the DB cluster can be created.

        For information on AWS Regions and Availability Zones, see `Choosing the Regions and Availability Zones <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Concepts.RegionsAndAvailabilityZones.html>`_ in the *Amazon Aurora User Guide* .

        Valid for: Aurora DB clusters only

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-availabilityzones
        '''
        result = self._values.get("availability_zones")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def backtrack_window(self) -> typing.Optional[jsii.Number]:
        '''The target backtrack window, in seconds. To disable backtracking, set this value to 0.

        .. epigraph::

           Currently, Backtrack is only supported for Aurora MySQL DB clusters.

        Default: 0

        Constraints:

        - If specified, this value must be set to a number from 0 to 259,200 (72 hours).

        Valid for: Aurora MySQL DB clusters only

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-backtrackwindow
        '''
        result = self._values.get("backtrack_window")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def backup_retention_period(self) -> typing.Optional[jsii.Number]:
        '''The number of days for which automated backups are retained.

        Default: 1

        Constraints:

        - Must be a value from 1 to 35

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-backupretentionperiod
        '''
        result = self._values.get("backup_retention_period")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def copy_tags_to_snapshot(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''A value that indicates whether to copy all tags from the DB cluster to snapshots of the DB cluster.

        The default is not to copy them.

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-copytagstosnapshot
        '''
        result = self._values.get("copy_tags_to_snapshot")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], result)

    @builtins.property
    def database_name(self) -> typing.Optional[builtins.str]:
        '''The name of your database.

        If you don't provide a name, then Amazon RDS won't create a database in this DB cluster. For naming constraints, see `Naming Constraints <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/CHAP_Limits.html#RDS_Limits.Constraints>`_ in the *Amazon Aurora User Guide* .

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-databasename
        '''
        result = self._values.get("database_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def db_cluster_identifier(self) -> typing.Optional[builtins.str]:
        '''The DB cluster identifier. This parameter is stored as a lowercase string.

        Constraints:

        - Must contain from 1 to 63 letters, numbers, or hyphens.
        - First character must be a letter.
        - Can't end with a hyphen or contain two consecutive hyphens.

        Example: ``my-cluster1``

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-dbclusteridentifier
        '''
        result = self._values.get("db_cluster_identifier")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def db_cluster_instance_class(self) -> typing.Optional[builtins.str]:
        '''The compute and memory capacity of each DB instance in the Multi-AZ DB cluster, for example db.m6gd.xlarge. Not all DB instance classes are available in all AWS Regions , or for all database engines.

        For the full list of DB instance classes and availability for your engine, see `DB instance class <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html>`_ in the *Amazon RDS User Guide* .

        This setting is required to create a Multi-AZ DB cluster.

        Valid for: Multi-AZ DB clusters only

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-dbclusterinstanceclass
        '''
        result = self._values.get("db_cluster_instance_class")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def db_cluster_parameter_group_name(self) -> typing.Optional[builtins.str]:
        '''The name of the DB cluster parameter group to associate with this DB cluster.

        .. epigraph::

           If you apply a parameter group to an existing DB cluster, then its DB instances might need to reboot. This can result in an outage while the DB instances are rebooting.

           If you apply a change to parameter group associated with a stopped DB cluster, then the update stack waits until the DB cluster is started.

        To list all of the available DB cluster parameter group names, use the following command:

        ``aws rds describe-db-cluster-parameter-groups --query "DBClusterParameterGroups[].DBClusterParameterGroupName" --output text``

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-dbclusterparametergroupname
        '''
        result = self._values.get("db_cluster_parameter_group_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def db_instance_parameter_group_name(self) -> typing.Optional[builtins.str]:
        '''The name of the DB parameter group to apply to all instances of the DB cluster.

        .. epigraph::

           When you apply a parameter group using the ``DBInstanceParameterGroupName`` parameter, the DB cluster isn't rebooted automatically. Also, parameter changes are applied immediately rather than during the next maintenance window.

        Default: The existing name setting

        Constraints:

        - The DB parameter group must be in the same DB parameter group family as this DB cluster.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-dbinstanceparametergroupname
        '''
        result = self._values.get("db_instance_parameter_group_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def db_subnet_group_name(self) -> typing.Optional[builtins.str]:
        '''A DB subnet group that you want to associate with this DB cluster.

        If you are restoring a DB cluster to a point in time with ``RestoreType`` set to ``copy-on-write`` , and don't specify a DB subnet group name, then the DB cluster is restored with a default DB subnet group.

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-dbsubnetgroupname
        '''
        result = self._values.get("db_subnet_group_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def db_system_id(self) -> typing.Optional[builtins.str]:
        '''Reserved for future use.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-dbsystemid
        '''
        result = self._values.get("db_system_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def deletion_protection(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''A value that indicates whether the DB cluster has deletion protection enabled.

        The database can't be deleted when deletion protection is enabled. By default, deletion protection is disabled.

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-deletionprotection
        '''
        result = self._values.get("deletion_protection")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], result)

    @builtins.property
    def domain(self) -> typing.Optional[builtins.str]:
        '''Indicates the directory ID of the Active Directory to create the DB cluster.

        For Amazon Aurora DB clusters, Amazon RDS can use Kerberos authentication to authenticate users that connect to the DB cluster.

        For more information, see `Kerberos authentication <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/kerberos-authentication.html>`_ in the *Amazon Aurora User Guide* .

        Valid for: Aurora DB clusters only

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-domain
        '''
        result = self._values.get("domain")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def domain_iam_role_name(self) -> typing.Optional[builtins.str]:
        '''Specifies the name of the IAM role to use when making API calls to the Directory Service.

        Valid for: Aurora DB clusters only

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-domainiamrolename
        '''
        result = self._values.get("domain_iam_role_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_cloudwatch_logs_exports(
        self,
    ) -> typing.Optional[typing.List[builtins.str]]:
        '''The list of log types that need to be enabled for exporting to CloudWatch Logs.

        The values in the list depend on the DB engine being used. For more information, see `Publishing Database Logs to Amazon CloudWatch Logs <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_LogAccess.html#USER_LogAccess.Procedural.UploadtoCloudWatch>`_ in the *Amazon Aurora User Guide* .

        *Aurora MySQL*

        Valid values: ``audit`` , ``error`` , ``general`` , ``slowquery``

        *Aurora PostgreSQL*

        Valid values: ``postgresql``

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-enablecloudwatchlogsexports
        '''
        result = self._values.get("enable_cloudwatch_logs_exports")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def enable_http_endpoint(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''A value that indicates whether to enable the HTTP endpoint for an Aurora Serverless DB cluster.

        By default, the HTTP endpoint is disabled.

        When enabled, the HTTP endpoint provides a connectionless web service API for running SQL queries on the Aurora Serverless DB cluster. You can also query your database from inside the RDS console with the query editor.

        For more information, see `Using the Data API for Aurora Serverless <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/data-api.html>`_ in the *Amazon Aurora User Guide* .

        Valid for: Aurora DB clusters only

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-enablehttpendpoint
        '''
        result = self._values.get("enable_http_endpoint")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], result)

    @builtins.property
    def enable_iam_database_authentication(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''A value that indicates whether to enable mapping of AWS Identity and Access Management (IAM) accounts to database accounts.

        By default, mapping is disabled.

        For more information, see `IAM Database Authentication <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/UsingWithRDS.IAMDBAuth.html>`_ in the *Amazon Aurora User Guide.*

        Valid for: Aurora DB clusters only

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-enableiamdatabaseauthentication
        '''
        result = self._values.get("enable_iam_database_authentication")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], result)

    @builtins.property
    def engine(self) -> typing.Optional[builtins.str]:
        '''The name of the database engine to be used for this DB cluster.

        Valid Values:

        - ``aurora-mysql``
        - ``aurora-postgresql``
        - ``mysql``
        - ``postgres``

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-engine
        '''
        result = self._values.get("engine")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def engine_mode(self) -> typing.Optional[builtins.str]:
        '''The DB engine mode of the DB cluster, either ``provisioned`` or ``serverless`` .

        The ``serverless`` engine mode only supports Aurora Serverless v1. Currently, AWS CloudFormation doesn't support Aurora Serverless v2.

        Limitations and requirements apply to some DB engine modes. For more information, see the following sections in the *Amazon Aurora User Guide* :

        - `Limitations of Aurora Serverless v1 <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless.html#aurora-serverless.limitations>`_
        - `Requirements for Aurora Serverless v2 <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless-v2.requirements.html>`_
        - `Limitations of parallel query <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-mysql-parallel-query.html#aurora-mysql-parallel-query-limitations>`_
        - `Limitations of Aurora global databases <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-global-database.html#aurora-global-database.limitations>`_

        Valid for: Aurora DB clusters only

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-enginemode
        '''
        result = self._values.get("engine_mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def engine_version(self) -> typing.Optional[builtins.str]:
        '''The version number of the database engine to use.

        To list all of the available engine versions for Aurora MySQL version 2 (5.7-compatible) and version 3 (8.0-compatible), use the following command:

        ``aws rds describe-db-engine-versions --engine aurora-mysql --query "DBEngineVersions[].EngineVersion"``

        You can supply either ``5.7`` or ``8.0`` to use the default engine version for Aurora MySQL version 2 or version 3, respectively.

        To list all of the available engine versions for Aurora PostgreSQL, use the following command:

        ``aws rds describe-db-engine-versions --engine aurora-postgresql --query "DBEngineVersions[].EngineVersion"``

        To list all of the available engine versions for RDS for MySQL, use the following command:

        ``aws rds describe-db-engine-versions --engine mysql --query "DBEngineVersions[].EngineVersion"``

        To list all of the available engine versions for RDS for PostgreSQL, use the following command:

        ``aws rds describe-db-engine-versions --engine postgres --query "DBEngineVersions[].EngineVersion"``

        *Aurora MySQL*

        For information, see `Database engine updates for Amazon Aurora MySQL <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/AuroraMySQL.Updates.html>`_ in the *Amazon Aurora User Guide* .

        *Aurora PostgreSQL*

        For information, see `Amazon Aurora PostgreSQL releases and engine versions <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/AuroraPostgreSQL.Updates.20180305.html>`_ in the *Amazon Aurora User Guide* .

        *MySQL*

        For information, see `Amazon RDS for MySQL <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_MySQL.html#MySQL.Concepts.VersionMgmt>`_ in the *Amazon RDS User Guide* .

        *PostgreSQL*

        For information, see `Amazon RDS for PostgreSQL <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_PostgreSQL.html#PostgreSQL.Concepts>`_ in the *Amazon RDS User Guide* .

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-engineversion
        '''
        result = self._values.get("engine_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def global_cluster_identifier(self) -> typing.Optional[builtins.str]:
        '''If you are configuring an Aurora global database cluster and want your Aurora DB cluster to be a secondary member in the global database cluster, specify the global cluster ID of the global database cluster.

        To define the primary database cluster of the global cluster, use the `AWS::RDS::GlobalCluster <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-globalcluster.html>`_ resource.

        If you aren't configuring a global database cluster, don't specify this property.
        .. epigraph::

           To remove the DB cluster from a global database cluster, specify an empty value for the ``GlobalClusterIdentifier`` property.

        For information about Aurora global databases, see `Working with Amazon Aurora Global Databases <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-global-database.html>`_ in the *Amazon Aurora User Guide* .

        Valid for: Aurora DB clusters only

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-globalclusteridentifier
        '''
        result = self._values.get("global_cluster_identifier")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def iops(self) -> typing.Optional[jsii.Number]:
        '''The amount of Provisioned IOPS (input/output operations per second) to be initially allocated for each DB instance in the Multi-AZ DB cluster.

        For information about valid IOPS values, see `Provisioned IOPS storage <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Storage.html#USER_PIOPS>`_ in the *Amazon RDS User Guide* .

        This setting is required to create a Multi-AZ DB cluster.

        Constraints: Must be a multiple between .5 and 50 of the storage amount for the DB cluster.

        Valid for: Multi-AZ DB clusters only

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-iops
        '''
        result = self._values.get("iops")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def kms_key_id(self) -> typing.Optional[builtins.str]:
        '''The Amazon Resource Name (ARN) of the AWS KMS key that is used to encrypt the database instances in the DB cluster, such as ``arn:aws:kms:us-east-1:012345678910:key/abcd1234-a123-456a-a12b-a123b4cd56ef`` .

        If you enable the ``StorageEncrypted`` property but don't specify this property, the default KMS key is used. If you specify this property, you must set the ``StorageEncrypted`` property to ``true`` .

        If you specify the ``SnapshotIdentifier`` property, the ``StorageEncrypted`` property value is inherited from the snapshot, and if the DB cluster is encrypted, the specified ``KmsKeyId`` property is used.

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-kmskeyid
        '''
        result = self._values.get("kms_key_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def manage_master_user_password(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''A value that indicates whether to manage the master user password with AWS Secrets Manager.

        For more information, see `Password management with AWS Secrets Manager <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-secrets-manager.html>`_ in the *Amazon RDS User Guide* and `Password management with AWS Secrets Manager <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/rds-secrets-manager.html>`_ in the *Amazon Aurora User Guide.*

        Constraints:

        - Can't manage the master user password with AWS Secrets Manager if ``MasterUserPassword`` is specified.

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-managemasteruserpassword
        '''
        result = self._values.get("manage_master_user_password")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], result)

    @builtins.property
    def master_username(self) -> typing.Optional[builtins.str]:
        '''The name of the master user for the DB cluster.

        .. epigraph::

           If you specify the ``SourceDBClusterIdentifier`` , ``SnapshotIdentifier`` , or ``GlobalClusterIdentifier`` property, don't specify this property. The value is inherited from the source DB cluster, the snapshot, or the primary DB cluster for the global database cluster, respectively.

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-masterusername
        '''
        result = self._values.get("master_username")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def master_user_password(self) -> typing.Optional[builtins.str]:
        '''The master password for the DB instance.

        .. epigraph::

           If you specify the ``SourceDBClusterIdentifier`` , ``SnapshotIdentifier`` , or ``GlobalClusterIdentifier`` property, don't specify this property. The value is inherited from the source DB cluster, the snapshot, or the primary DB cluster for the global database cluster, respectively.

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-masteruserpassword
        '''
        result = self._values.get("master_user_password")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def master_user_secret(
        self,
    ) -> typing.Optional[typing.Union[CfnDBCluster.MasterUserSecretProperty, _IResolvable_a771d0ef]]:
        '''Contains the secret managed by RDS in AWS Secrets Manager for the master user password.

        For more information, see `Password management with AWS Secrets Manager <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-secrets-manager.html>`_ in the *Amazon RDS User Guide* and `Password management with AWS Secrets Manager <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/rds-secrets-manager.html>`_ in the *Amazon Aurora User Guide.*

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-masterusersecret
        '''
        result = self._values.get("master_user_secret")
        return typing.cast(typing.Optional[typing.Union[CfnDBCluster.MasterUserSecretProperty, _IResolvable_a771d0ef]], result)

    @builtins.property
    def monitoring_interval(self) -> typing.Optional[jsii.Number]:
        '''The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the DB cluster.

        To turn off collecting Enhanced Monitoring metrics, specify 0. The default is 0.

        If ``MonitoringRoleArn`` is specified, also set ``MonitoringInterval`` to a value other than 0.

        Valid Values: ``0, 1, 5, 10, 15, 30, 60``

        Valid for: Multi-AZ DB clusters only

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-monitoringinterval
        '''
        result = self._values.get("monitoring_interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def monitoring_role_arn(self) -> typing.Optional[builtins.str]:
        '''The Amazon Resource Name (ARN) for the IAM role that permits RDS to send Enhanced Monitoring metrics to Amazon CloudWatch Logs.

        An example is ``arn:aws:iam:123456789012:role/emaccess`` . For information on creating a monitoring role, see `Setting up and enabling Enhanced Monitoring <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Monitoring.OS.html#USER_Monitoring.OS.Enabling>`_ in the *Amazon RDS User Guide* .

        If ``MonitoringInterval`` is set to a value other than 0, supply a ``MonitoringRoleArn`` value.

        Valid for: Multi-AZ DB clusters only

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-monitoringrolearn
        '''
        result = self._values.get("monitoring_role_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def network_type(self) -> typing.Optional[builtins.str]:
        '''The network type of the DB cluster.

        Valid values:

        - ``IPV4``
        - ``DUAL``

        The network type is determined by the ``DBSubnetGroup`` specified for the DB cluster. A ``DBSubnetGroup`` can support only the IPv4 protocol or the IPv4 and IPv6 protocols ( ``DUAL`` ).

        For more information, see `Working with a DB instance in a VPC <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_VPC.WorkingWithRDSInstanceinaVPC.html>`_ in the *Amazon Aurora User Guide.*

        Valid for: Aurora DB clusters only

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-networktype
        '''
        result = self._values.get("network_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def performance_insights_enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''A value that indicates whether to turn on Performance Insights for the DB cluster.

        For more information, see `Using Amazon Performance Insights <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PerfInsights.html>`_ in the *Amazon RDS User Guide* .

        Valid for: Multi-AZ DB clusters only

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-performanceinsightsenabled
        '''
        result = self._values.get("performance_insights_enabled")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], result)

    @builtins.property
    def performance_insights_kms_key_id(self) -> typing.Optional[builtins.str]:
        '''The AWS KMS key identifier for encryption of Performance Insights data.

        The AWS KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key.

        If you don't specify a value for ``PerformanceInsightsKMSKeyId`` , then Amazon RDS uses your default KMS key. There is a default KMS key for your AWS account . Your AWS account has a different default KMS key for each AWS Region .

        Valid for: Multi-AZ DB clusters only

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-performanceinsightskmskeyid
        '''
        result = self._values.get("performance_insights_kms_key_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def performance_insights_retention_period(self) -> typing.Optional[jsii.Number]:
        '''The number of days to retain Performance Insights data. The default is 7 days. The following values are valid:.

        - 7
        - *month* * 31, where *month* is a number of months from 1-23
        - 731

        For example, the following values are valid:

        - 93 (3 months * 31)
        - 341 (11 months * 31)
        - 589 (19 months * 31)
        - 731

        If you specify a retention period such as 94, which isn't a valid value, RDS issues an error.

        Valid for: Multi-AZ DB clusters only

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-performanceinsightsretentionperiod
        '''
        result = self._values.get("performance_insights_retention_period")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def port(self) -> typing.Optional[jsii.Number]:
        '''The port number on which the DB instances in the DB cluster accept connections.

        Default:

        - When ``EngineMode`` is ``provisioned`` , ``3306`` (for both Aurora MySQL and Aurora PostgreSQL)
        - When ``EngineMode`` is ``serverless`` :
        - ``3306`` when ``Engine`` is ``aurora`` or ``aurora-mysql``
        - ``5432`` when ``Engine`` is ``aurora-postgresql``

        .. epigraph::

           The ``No interruption`` on update behavior only applies to DB clusters. If you are updating a DB instance, see `Port <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-database-instance.html#cfn-rds-dbinstance-port>`_ for the AWS::RDS::DBInstance resource.

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-port
        '''
        result = self._values.get("port")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def preferred_backup_window(self) -> typing.Optional[builtins.str]:
        '''The daily time range during which automated backups are created.

        For more information, see `Backup Window <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.Managing.Backups.html#Aurora.Managing.Backups.BackupWindow>`_ in the *Amazon Aurora User Guide.*

        Constraints:

        - Must be in the format ``hh24:mi-hh24:mi`` .
        - Must be in Universal Coordinated Time (UTC).
        - Must not conflict with the preferred maintenance window.
        - Must be at least 30 minutes.

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-preferredbackupwindow
        '''
        result = self._values.get("preferred_backup_window")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def preferred_maintenance_window(self) -> typing.Optional[builtins.str]:
        '''The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC).

        Format: ``ddd:hh24:mi-ddd:hh24:mi``

        The default is a 30-minute window selected at random from an 8-hour block of time for each AWS Region, occurring on a random day of the week. To see the time blocks available, see `Adjusting the Preferred DB Cluster Maintenance Window <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_UpgradeDBInstance.Maintenance.html#AdjustingTheMaintenanceWindow.Aurora>`_ in the *Amazon Aurora User Guide.*

        Valid Days: Mon, Tue, Wed, Thu, Fri, Sat, Sun.

        Constraints: Minimum 30-minute window.

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-preferredmaintenancewindow
        '''
        result = self._values.get("preferred_maintenance_window")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def publicly_accessible(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''A value that indicates whether the DB cluster is publicly accessible.

        When the DB cluster is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address from within the DB cluster's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB cluster's VPC. Access to the DB cluster is ultimately controlled by the security group it uses. That public access isn't permitted if the security group assigned to the DB cluster doesn't permit it.

        When the DB cluster isn't publicly accessible, it is an internal DB cluster with a DNS name that resolves to a private IP address.

        Default: The default behavior varies depending on whether ``DBSubnetGroupName`` is specified.

        If ``DBSubnetGroupName`` isn't specified, and ``PubliclyAccessible`` isn't specified, the following applies:

        - If the default VPC in the target Region doesnt have an internet gateway attached to it, the DB cluster is private.
        - If the default VPC in the target Region has an internet gateway attached to it, the DB cluster is public.

        If ``DBSubnetGroupName`` is specified, and ``PubliclyAccessible`` isn't specified, the following applies:

        - If the subnets are part of a VPC that doesnt have an internet gateway attached to it, the DB cluster is private.
        - If the subnets are part of a VPC that has an internet gateway attached to it, the DB cluster is public.

        Valid for: Multi-AZ DB clusters only

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-publiclyaccessible
        '''
        result = self._values.get("publicly_accessible")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], result)

    @builtins.property
    def replication_source_identifier(self) -> typing.Optional[builtins.str]:
        '''The Amazon Resource Name (ARN) of the source DB instance or DB cluster if this DB cluster is created as a read replica.

        Valid for: Aurora DB clusters only

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-replicationsourceidentifier
        '''
        result = self._values.get("replication_source_identifier")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def restore_to_time(self) -> typing.Optional[builtins.str]:
        '''The date and time to restore the DB cluster to.

        Valid Values: Value must be a time in Universal Coordinated Time (UTC) format

        Constraints:

        - Must be before the latest restorable time for the DB instance
        - Must be specified if ``UseLatestRestorableTime`` parameter isn't provided
        - Can't be specified if the ``UseLatestRestorableTime`` parameter is enabled
        - Can't be specified if the ``RestoreType`` parameter is ``copy-on-write``

        Example: ``2015-03-07T23:45:00Z``

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-restoretotime
        '''
        result = self._values.get("restore_to_time")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def restore_type(self) -> typing.Optional[builtins.str]:
        '''The type of restore to be performed. You can specify one of the following values:.

        - ``full-copy`` - The new DB cluster is restored as a full copy of the source DB cluster.
        - ``copy-on-write`` - The new DB cluster is restored as a clone of the source DB cluster.

        If you don't specify a ``RestoreType`` value, then the new DB cluster is restored as a full copy of the source DB cluster.

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-restoretype
        '''
        result = self._values.get("restore_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scaling_configuration(
        self,
    ) -> typing.Optional[typing.Union[CfnDBCluster.ScalingConfigurationProperty, _IResolvable_a771d0ef]]:
        '''The ``ScalingConfiguration`` property type specifies the scaling configuration of an Aurora Serverless DB cluster.

        This property is only supported for Aurora Serverless v1. For Aurora Serverless v2, use ``ServerlessV2ScalingConfiguration`` property.

        Valid for: Aurora DB clusters only

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-scalingconfiguration
        '''
        result = self._values.get("scaling_configuration")
        return typing.cast(typing.Optional[typing.Union[CfnDBCluster.ScalingConfigurationProperty, _IResolvable_a771d0ef]], result)

    @builtins.property
    def serverless_v2_scaling_configuration(
        self,
    ) -> typing.Optional[typing.Union[CfnDBCluster.ServerlessV2ScalingConfigurationProperty, _IResolvable_a771d0ef]]:
        '''The ``ServerlessV2ScalingConfiguration`` property type specifies the scaling configuration of an Aurora Serverless V2 DB cluster.

        This property is only supported for Aurora Serverless v2. For Aurora Serverless v1, use ``ScalingConfiguration`` property.

        Valid for: Aurora DB clusters only

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-serverlessv2scalingconfiguration
        '''
        result = self._values.get("serverless_v2_scaling_configuration")
        return typing.cast(typing.Optional[typing.Union[CfnDBCluster.ServerlessV2ScalingConfigurationProperty, _IResolvable_a771d0ef]], result)

    @builtins.property
    def snapshot_identifier(self) -> typing.Optional[builtins.str]:
        '''The identifier for the DB snapshot or DB cluster snapshot to restore from.

        You can use either the name or the Amazon Resource Name (ARN) to specify a DB cluster snapshot. However, you can use only the ARN to specify a DB snapshot.

        After you restore a DB cluster with a ``SnapshotIdentifier`` property, you must specify the same ``SnapshotIdentifier`` property for any future updates to the DB cluster. When you specify this property for an update, the DB cluster is not restored from the snapshot again, and the data in the database is not changed. However, if you don't specify the ``SnapshotIdentifier`` property, an empty DB cluster is created, and the original DB cluster is deleted. If you specify a property that is different from the previous snapshot restore property, a new DB cluster is restored from the specified ``SnapshotIdentifier`` property, and the original DB cluster is deleted.

        If you specify the ``SnapshotIdentifier`` property to restore a DB cluster (as opposed to specifying it for DB cluster updates), then don't specify the following properties:

        - ``GlobalClusterIdentifier``
        - ``MasterUsername``
        - ``MasterUserPassword``
        - ``ReplicationSourceIdentifier``
        - ``RestoreType``
        - ``SourceDBClusterIdentifier``
        - ``SourceRegion``
        - ``StorageEncrypted`` (for an encrypted snapshot)
        - ``UseLatestRestorableTime``

        Constraints:

        - Must match the identifier of an existing Snapshot.

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-snapshotidentifier
        '''
        result = self._values.get("snapshot_identifier")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def source_db_cluster_identifier(self) -> typing.Optional[builtins.str]:
        '''When restoring a DB cluster to a point in time, the identifier of the source DB cluster from which to restore.

        Constraints:

        - Must match the identifier of an existing DBCluster.

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-sourcedbclusteridentifier
        '''
        result = self._values.get("source_db_cluster_identifier")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def source_region(self) -> typing.Optional[builtins.str]:
        '''The AWS Region which contains the source DB cluster when replicating a DB cluster. For example, ``us-east-1`` .

        Valid for: Aurora DB clusters only

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-sourceregion
        '''
        result = self._values.get("source_region")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def storage_encrypted(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''Indicates whether the DB cluster is encrypted.

        If you specify the ``KmsKeyId`` property, then you must enable encryption.

        If you specify the ``SourceDBClusterIdentifier`` property, don't specify this property. The value is inherited from the source DB cluster, and if the DB cluster is encrypted, the specified ``KmsKeyId`` property is used.

        If you specify the ``SnapshotIdentifier`` and the specified snapshot is encrypted, don't specify this property. The value is inherited from the snapshot, and the specified ``KmsKeyId`` property is used.

        If you specify the ``SnapshotIdentifier`` and the specified snapshot isn't encrypted, you can use this property to specify that the restored DB cluster is encrypted. Specify the ``KmsKeyId`` property for the KMS key to use for encryption. If you don't want the restored DB cluster to be encrypted, then don't set this property or set it to ``false`` .

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-storageencrypted
        '''
        result = self._values.get("storage_encrypted")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], result)

    @builtins.property
    def storage_type(self) -> typing.Optional[builtins.str]:
        '''Specifies the storage type to be associated with the DB cluster.

        This setting is required to create a Multi-AZ DB cluster.

        When specified for a Multi-AZ DB cluster, a value for the ``Iops`` parameter is required.

        Valid values: ``aurora`` , ``aurora-iopt1`` (Aurora DB clusters); ``io1`` (Multi-AZ DB clusters)

        Default: ``aurora`` (Aurora DB clusters); ``io1`` (Multi-AZ DB clusters)

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        For more information on storage types for Aurora DB clusters, see `Storage configurations for Amazon Aurora DB clusters <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.Overview.StorageReliability.html#aurora-storage-type>`_ . For more information on storage types for Multi-AZ DB clusters, see `Settings for creating Multi-AZ DB clusters <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/create-multi-az-db-cluster.html#create-multi-az-db-cluster-settings>`_ .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-storagetype
        '''
        result = self._values.get("storage_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[_CfnTag_95fbdc29]]:
        '''An optional array of key-value pairs to apply to this DB cluster.

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[_CfnTag_95fbdc29]], result)

    @builtins.property
    def use_latest_restorable_time(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''A value that indicates whether to restore the DB cluster to the latest restorable backup time.

        By default, the DB cluster is not restored to the latest restorable backup time.

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-uselatestrestorabletime
        '''
        result = self._values.get("use_latest_restorable_time")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], result)

    @builtins.property
    def vpc_security_group_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''A list of EC2 VPC security groups to associate with this DB cluster.

        If you plan to update the resource, don't specify VPC security groups in a shared VPC.

        Valid for: Aurora DB clusters and Multi-AZ DB clusters

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html#cfn-rds-dbcluster-vpcsecuritygroupids
        '''
        result = self._values.get("vpc_security_group_ids")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnDBClusterProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_82c04a63)
class CfnDBInstance(
    _CfnResource_e0a482dc,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_rds.CfnDBInstance",
):
    '''A CloudFormation ``AWS::RDS::DBInstance``.

    The ``AWS::RDS::DBInstance`` resource creates an Amazon DB instance. The new DB instance can be an RDS DB instance, or it can be a DB instance in an Aurora DB cluster.

    For more information about creating an RDS DB instance, see `Creating an Amazon RDS DB instance <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_CreateDBInstance.html>`_ in the *Amazon RDS User Guide* .

    For more information about creating a DB instance in an Aurora DB cluster, see `Creating an Amazon Aurora DB cluster <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.CreateInstance.html>`_ in the *Amazon Aurora User Guide* .

    If you import an existing DB instance, and the template configuration doesn't match the actual configuration of the DB instance, AWS CloudFormation applies the changes in the template during the import operation.
    .. epigraph::

       If a DB instance is deleted or replaced during an update, AWS CloudFormation deletes all automated snapshots. However, it retains manual DB snapshots. During an update that requires replacement, you can apply a stack policy to prevent DB instances from being replaced. For more information, see `Prevent Updates to Stack Resources <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/protect-stack-resources.html>`_ .

    *Updating DB instances*

    When properties labeled " *Update requires:* `Replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ " are updated, AWS CloudFormation first creates a replacement DB instance, then changes references from other dependent resources to point to the replacement DB instance, and finally deletes the old DB instance.
    .. epigraph::

       We highly recommend that you take a snapshot of the database before updating the stack. If you don't, you lose the data when AWS CloudFormation replaces your DB instance. To preserve your data, perform the following procedure:

       - Deactivate any applications that are using the DB instance so that there's no activity on the DB instance.
       - Create a snapshot of the DB instance. For more information, see `Creating a DB Snapshot <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_CreateSnapshot.html>`_ .
       - If you want to restore your instance using a DB snapshot, modify the updated template with your DB instance changes and add the ``DBSnapshotIdentifier`` property with the ID of the DB snapshot that you want to use.

       After you restore a DB instance with a ``DBSnapshotIdentifier`` property, you must specify the same ``DBSnapshotIdentifier`` property for any future updates to the DB instance. When you specify this property for an update, the DB instance is not restored from the DB snapshot again, and the data in the database is not changed. However, if you don't specify the ``DBSnapshotIdentifier`` property, an empty DB instance is created, and the original DB instance is deleted. If you specify a property that is different from the previous snapshot restore property, a new DB instance is restored from the specified ``DBSnapshotIdentifier`` property, and the original DB instance is deleted.

       - Update the stack.

    For more information about updating other properties of this resource, see ``[ModifyDBInstance](https://docs.aws.amazon.com//AmazonRDS/latest/APIReference/API_ModifyDBInstance.html)`` . For more information about updating stacks, see `AWS CloudFormation Stacks Updates <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks.html>`_ .

    *Deleting DB instances*

    For DB instances that are part of an Aurora DB cluster, you can set a deletion policy for your DB instance to control how AWS CloudFormation handles the DB instance when the stack is deleted. For Amazon RDS DB instances, you can choose to *retain* the DB instance, to *delete* the DB instance, or to *create a snapshot* of the DB instance. The default AWS CloudFormation behavior depends on the ``DBClusterIdentifier`` property:

    - For ``AWS::RDS::DBInstance`` resources that don't specify the ``DBClusterIdentifier`` property, AWS CloudFormation saves a snapshot of the DB instance.
    - For ``AWS::RDS::DBInstance`` resources that do specify the ``DBClusterIdentifier`` property, AWS CloudFormation deletes the DB instance.

    For more information, see `DeletionPolicy Attribute <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html>`_ .

    :cloudformationResource: AWS::RDS::DBInstance
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from monocdk import aws_rds as rds
        
        cfn_dBInstance = rds.CfnDBInstance(self, "MyCfnDBInstance",
            allocated_storage="allocatedStorage",
            allow_major_version_upgrade=False,
            associated_roles=[rds.CfnDBInstance.DBInstanceRoleProperty(
                feature_name="featureName",
                role_arn="roleArn"
            )],
            auto_minor_version_upgrade=False,
            availability_zone="availabilityZone",
            backup_retention_period=123,
            ca_certificate_identifier="caCertificateIdentifier",
            certificate_details=rds.CfnDBInstance.CertificateDetailsProperty(
                ca_identifier="caIdentifier",
                valid_till="validTill"
            ),
            certificate_rotation_restart=False,
            character_set_name="characterSetName",
            copy_tags_to_snapshot=False,
            custom_iam_instance_profile="customIamInstanceProfile",
            db_cluster_identifier="dbClusterIdentifier",
            db_cluster_snapshot_identifier="dbClusterSnapshotIdentifier",
            db_instance_class="dbInstanceClass",
            db_instance_identifier="dbInstanceIdentifier",
            db_name="dbName",
            db_parameter_group_name="dbParameterGroupName",
            db_security_groups=["dbSecurityGroups"],
            db_snapshot_identifier="dbSnapshotIdentifier",
            db_subnet_group_name="dbSubnetGroupName",
            delete_automated_backups=False,
            deletion_protection=False,
            domain="domain",
            domain_iam_role_name="domainIamRoleName",
            enable_cloudwatch_logs_exports=["enableCloudwatchLogsExports"],
            enable_iam_database_authentication=False,
            enable_performance_insights=False,
            endpoint=rds.CfnDBInstance.EndpointProperty(
                address="address",
                hosted_zone_id="hostedZoneId",
                port="port"
            ),
            engine="engine",
            engine_version="engineVersion",
            iops=123,
            kms_key_id="kmsKeyId",
            license_model="licenseModel",
            manage_master_user_password=False,
            master_username="masterUsername",
            master_user_password="masterUserPassword",
            master_user_secret=rds.CfnDBInstance.MasterUserSecretProperty(
                kms_key_id="kmsKeyId",
                secret_arn="secretArn"
            ),
            max_allocated_storage=123,
            monitoring_interval=123,
            monitoring_role_arn="monitoringRoleArn",
            multi_az=False,
            nchar_character_set_name="ncharCharacterSetName",
            network_type="networkType",
            option_group_name="optionGroupName",
            performance_insights_kms_key_id="performanceInsightsKmsKeyId",
            performance_insights_retention_period=123,
            port="port",
            preferred_backup_window="preferredBackupWindow",
            preferred_maintenance_window="preferredMaintenanceWindow",
            processor_features=[rds.CfnDBInstance.ProcessorFeatureProperty(
                name="name",
                value="value"
            )],
            promotion_tier=123,
            publicly_accessible=False,
            replica_mode="replicaMode",
            restore_time="restoreTime",
            source_db_cluster_identifier="sourceDbClusterIdentifier",
            source_db_instance_automated_backups_arn="sourceDbInstanceAutomatedBackupsArn",
            source_db_instance_identifier="sourceDbInstanceIdentifier",
            source_dbi_resource_id="sourceDbiResourceId",
            source_region="sourceRegion",
            storage_encrypted=False,
            storage_throughput=123,
            storage_type="storageType",
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            timezone="timezone",
            use_default_processor_features=False,
            use_latest_restorable_time=False,
            vpc_security_groups=["vpcSecurityGroups"]
        )
    '''

    def __init__(
        self,
        scope: _Construct_e78e779f,
        id: builtins.str,
        *,
        allocated_storage: typing.Optional[builtins.str] = None,
        allow_major_version_upgrade: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        associated_roles: typing.Optional[typing.Union[_IResolvable_a771d0ef, typing.Sequence[typing.Union[typing.Union["CfnDBInstance.DBInstanceRoleProperty", typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]]]] = None,
        auto_minor_version_upgrade: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        availability_zone: typing.Optional[builtins.str] = None,
        backup_retention_period: typing.Optional[jsii.Number] = None,
        ca_certificate_identifier: typing.Optional[builtins.str] = None,
        certificate_details: typing.Optional[typing.Union[typing.Union["CfnDBInstance.CertificateDetailsProperty", typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]] = None,
        certificate_rotation_restart: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        character_set_name: typing.Optional[builtins.str] = None,
        copy_tags_to_snapshot: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        custom_iam_instance_profile: typing.Optional[builtins.str] = None,
        db_cluster_identifier: typing.Optional[builtins.str] = None,
        db_cluster_snapshot_identifier: typing.Optional[builtins.str] = None,
        db_instance_class: typing.Optional[builtins.str] = None,
        db_instance_identifier: typing.Optional[builtins.str] = None,
        db_name: typing.Optional[builtins.str] = None,
        db_parameter_group_name: typing.Optional[builtins.str] = None,
        db_security_groups: typing.Optional[typing.Sequence[builtins.str]] = None,
        db_snapshot_identifier: typing.Optional[builtins.str] = None,
        db_subnet_group_name: typing.Optional[builtins.str] = None,
        delete_automated_backups: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        deletion_protection: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        domain: typing.Optional[builtins.str] = None,
        domain_iam_role_name: typing.Optional[builtins.str] = None,
        enable_cloudwatch_logs_exports: typing.Optional[typing.Sequence[builtins.str]] = None,
        enable_iam_database_authentication: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        enable_performance_insights: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        endpoint: typing.Optional[typing.Union[typing.Union["CfnDBInstance.EndpointProperty", typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]] = None,
        engine: typing.Optional[builtins.str] = None,
        engine_version: typing.Optional[builtins.str] = None,
        iops: typing.Optional[jsii.Number] = None,
        kms_key_id: typing.Optional[builtins.str] = None,
        license_model: typing.Optional[builtins.str] = None,
        manage_master_user_password: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        master_username: typing.Optional[builtins.str] = None,
        master_user_password: typing.Optional[builtins.str] = None,
        master_user_secret: typing.Optional[typing.Union[typing.Union["CfnDBInstance.MasterUserSecretProperty", typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]] = None,
        max_allocated_storage: typing.Optional[jsii.Number] = None,
        monitoring_interval: typing.Optional[jsii.Number] = None,
        monitoring_role_arn: typing.Optional[builtins.str] = None,
        multi_az: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        nchar_character_set_name: typing.Optional[builtins.str] = None,
        network_type: typing.Optional[builtins.str] = None,
        option_group_name: typing.Optional[builtins.str] = None,
        performance_insights_kms_key_id: typing.Optional[builtins.str] = None,
        performance_insights_retention_period: typing.Optional[jsii.Number] = None,
        port: typing.Optional[builtins.str] = None,
        preferred_backup_window: typing.Optional[builtins.str] = None,
        preferred_maintenance_window: typing.Optional[builtins.str] = None,
        processor_features: typing.Optional[typing.Union[_IResolvable_a771d0ef, typing.Sequence[typing.Union[typing.Union["CfnDBInstance.ProcessorFeatureProperty", typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]]]] = None,
        promotion_tier: typing.Optional[jsii.Number] = None,
        publicly_accessible: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        replica_mode: typing.Optional[builtins.str] = None,
        restore_time: typing.Optional[builtins.str] = None,
        source_db_cluster_identifier: typing.Optional[builtins.str] = None,
        source_db_instance_automated_backups_arn: typing.Optional[builtins.str] = None,
        source_db_instance_identifier: typing.Optional[builtins.str] = None,
        source_dbi_resource_id: typing.Optional[builtins.str] = None,
        source_region: typing.Optional[builtins.str] = None,
        storage_encrypted: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        storage_throughput: typing.Optional[jsii.Number] = None,
        storage_type: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union[_CfnTag_95fbdc29, typing.Dict[builtins.str, typing.Any]]]] = None,
        timezone: typing.Optional[builtins.str] = None,
        use_default_processor_features: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        use_latest_restorable_time: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        vpc_security_groups: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''Create a new ``AWS::RDS::DBInstance``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param allocated_storage: The amount of storage in gibibytes (GiB) to be initially allocated for the database instance. .. epigraph:: If any value is set in the ``Iops`` parameter, ``AllocatedStorage`` must be at least 100 GiB, which corresponds to the minimum Iops value of 1,000. If you increase the ``Iops`` value (in 1,000 IOPS increments), then you must also increase the ``AllocatedStorage`` value (in 100-GiB increments). *Amazon Aurora* Not applicable. Aurora cluster volumes automatically grow as the amount of data in your database increases, though you are only charged for the space that you use in an Aurora cluster volume. *MySQL* Constraints to the amount of storage for each storage type are the following: - General Purpose (SSD) storage (gp2): Must be an integer from 20 to 65536. - Provisioned IOPS storage (io1): Must be an integer from 100 to 65536. - Magnetic storage (standard): Must be an integer from 5 to 3072. *MariaDB* Constraints to the amount of storage for each storage type are the following: - General Purpose (SSD) storage (gp2): Must be an integer from 20 to 65536. - Provisioned IOPS storage (io1): Must be an integer from 100 to 65536. - Magnetic storage (standard): Must be an integer from 5 to 3072. *PostgreSQL* Constraints to the amount of storage for each storage type are the following: - General Purpose (SSD) storage (gp2): Must be an integer from 20 to 65536. - Provisioned IOPS storage (io1): Must be an integer from 100 to 65536. - Magnetic storage (standard): Must be an integer from 5 to 3072. *Oracle* Constraints to the amount of storage for each storage type are the following: - General Purpose (SSD) storage (gp2): Must be an integer from 20 to 65536. - Provisioned IOPS storage (io1): Must be an integer from 100 to 65536. - Magnetic storage (standard): Must be an integer from 10 to 3072. *SQL Server* Constraints to the amount of storage for each storage type are the following: - General Purpose (SSD) storage (gp2): - Enterprise and Standard editions: Must be an integer from 20 to 16384. - Web and Express editions: Must be an integer from 20 to 16384. - Provisioned IOPS storage (io1): - Enterprise and Standard editions: Must be an integer from 20 to 16384. - Web and Express editions: Must be an integer from 20 to 16384. - Magnetic storage (standard): - Enterprise and Standard editions: Must be an integer from 20 to 1024. - Web and Express editions: Must be an integer from 20 to 1024.
        :param allow_major_version_upgrade: A value that indicates whether major version upgrades are allowed. Changing this parameter doesn't result in an outage and the change is asynchronously applied as soon as possible. Constraints: Major version upgrades must be allowed when specifying a value for the ``EngineVersion`` parameter that is a different major version than the DB instance's current version.
        :param associated_roles: The AWS Identity and Access Management (IAM) roles associated with the DB instance. *Amazon Aurora* Not applicable. The associated roles are managed by the DB cluster.
        :param auto_minor_version_upgrade: A value that indicates whether minor engine upgrades are applied automatically to the DB instance during the maintenance window. By default, minor engine upgrades are applied automatically.
        :param availability_zone: The Availability Zone (AZ) where the database will be created. For information on AWS Regions and Availability Zones, see `Regions and Availability Zones <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.RegionsAndAvailabilityZones.html>`_ . *Amazon Aurora* Each Aurora DB cluster hosts copies of its storage in three separate Availability Zones. Specify one of these Availability Zones. Aurora automatically chooses an appropriate Availability Zone if you don't specify one. Default: A random, system-chosen Availability Zone in the endpoint's AWS Region . Example: ``us-east-1d`` Constraint: The ``AvailabilityZone`` parameter can't be specified if the DB instance is a Multi-AZ deployment. The specified Availability Zone must be in the same AWS Region as the current endpoint.
        :param backup_retention_period: The number of days for which automated backups are retained. Setting this parameter to a positive number enables backups. Setting this parameter to 0 disables automated backups. *Amazon Aurora* Not applicable. The retention period for automated backups is managed by the DB cluster. Default: 1 Constraints: - Must be a value from 0 to 35 - Can't be set to 0 if the DB instance is a source to read replicas
        :param ca_certificate_identifier: The identifier of the CA certificate for this DB instance. .. epigraph:: Specifying or updating this property triggers a reboot. For more information about CA certificate identifiers for RDS DB engines, see `Rotating Your SSL/TLS Certificate <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.SSL-certificate-rotation.html>`_ in the *Amazon RDS User Guide* . For more information about CA certificate identifiers for Aurora DB engines, see `Rotating Your SSL/TLS Certificate <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/UsingWithRDS.SSL-certificate-rotation.html>`_ in the *Amazon Aurora User Guide* .
        :param certificate_details: The details of the DB instance's server certificate.
        :param certificate_rotation_restart: A value that indicates whether the DB instance is restarted when you rotate your SSL/TLS certificate. By default, the DB instance is restarted when you rotate your SSL/TLS certificate. The certificate is not updated until the DB instance is restarted. .. epigraph:: Set this parameter only if you are *not* using SSL/TLS to connect to the DB instance. If you are using SSL/TLS to connect to the DB instance, follow the appropriate instructions for your DB engine to rotate your SSL/TLS certificate: - For more information about rotating your SSL/TLS certificate for RDS DB engines, see `Rotating Your SSL/TLS Certificate. <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.SSL-certificate-rotation.html>`_ in the *Amazon RDS User Guide.* - For more information about rotating your SSL/TLS certificate for Aurora DB engines, see `Rotating Your SSL/TLS Certificate <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/UsingWithRDS.SSL-certificate-rotation.html>`_ in the *Amazon Aurora User Guide* . This setting doesn't apply to RDS Custom.
        :param character_set_name: For supported engines, indicates that the DB instance should be associated with the specified character set. *Amazon Aurora* Not applicable. The character set is managed by the DB cluster. For more information, see `AWS::RDS::DBCluster <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html>`_ .
        :param copy_tags_to_snapshot: A value that indicates whether to copy tags from the DB instance to snapshots of the DB instance. By default, tags are not copied. *Amazon Aurora* Not applicable. Copying tags to snapshots is managed by the DB cluster. Setting this value for an Aurora DB instance has no effect on the DB cluster setting.
        :param custom_iam_instance_profile: The instance profile associated with the underlying Amazon EC2 instance of an RDS Custom DB instance. The instance profile must meet the following requirements: - The profile must exist in your account. - The profile must have an IAM role that Amazon EC2 has permissions to assume. - The instance profile name and the associated IAM role name must start with the prefix ``AWSRDSCustom`` . For the list of permissions required for the IAM role, see `Configure IAM and your VPC <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/custom-setup-orcl.html#custom-setup-orcl.iam-vpc>`_ in the *Amazon RDS User Guide* . This setting is required for RDS Custom.
        :param db_cluster_identifier: The identifier of the DB cluster that the instance will belong to.
        :param db_cluster_snapshot_identifier: The identifier for the RDS for MySQL Multi-AZ DB cluster snapshot to restore from. For more information on Multi-AZ DB clusters, see `Multi-AZ DB cluster deployments <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/multi-az-db-clusters-concepts.html>`_ in the *Amazon RDS User Guide* . Constraints: - Must match the identifier of an existing Multi-AZ DB cluster snapshot. - Can't be specified when ``DBSnapshotIdentifier`` is specified. - Must be specified when ``DBSnapshotIdentifier`` isn't specified. - If you are restoring from a shared manual Multi-AZ DB cluster snapshot, the ``DBClusterSnapshotIdentifier`` must be the ARN of the shared snapshot. - Can't be the identifier of an Aurora DB cluster snapshot. - Can't be the identifier of an RDS for PostgreSQL Multi-AZ DB cluster snapshot.
        :param db_instance_class: The compute and memory capacity of the DB instance, for example, ``db.m4.large`` . Not all DB instance classes are available in all AWS Regions, or for all database engines. For the full list of DB instance classes, and availability for your engine, see `DB Instance Class <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html>`_ in the *Amazon RDS User Guide.* For more information about DB instance class pricing and AWS Region support for DB instance classes, see `Amazon RDS Pricing <https://docs.aws.amazon.com/rds/pricing/>`_ .
        :param db_instance_identifier: A name for the DB instance. If you specify a name, AWS CloudFormation converts it to lowercase. If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the DB instance. For more information, see `Name Type <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html>`_ . For information about constraints that apply to DB instance identifiers, see `Naming constraints in Amazon RDS <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Limits.html#RDS_Limits.Constraints>`_ in the *Amazon RDS User Guide* . .. epigraph:: If you specify a name, you can't perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name.
        :param db_name: The meaning of this parameter differs according to the database engine you use. .. epigraph:: If you specify the ``[DBSnapshotIdentifier](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-database-instance.html#cfn-rds-dbinstance-dbsnapshotidentifier)`` property, this property only applies to RDS for Oracle. *Amazon Aurora* Not applicable. The database name is managed by the DB cluster. *MySQL* The name of the database to create when the DB instance is created. If this parameter is not specified, no database is created in the DB instance. Constraints: - Must contain 1 to 64 letters or numbers. - Can't be a word reserved by the specified database engine *MariaDB* The name of the database to create when the DB instance is created. If this parameter is not specified, no database is created in the DB instance. Constraints: - Must contain 1 to 64 letters or numbers. - Can't be a word reserved by the specified database engine *PostgreSQL* The name of the database to create when the DB instance is created. If this parameter is not specified, the default ``postgres`` database is created in the DB instance. Constraints: - Must begin with a letter. Subsequent characters can be letters, underscores, or digits (0-9). - Must contain 1 to 63 characters. - Can't be a word reserved by the specified database engine *Oracle* The Oracle System ID (SID) of the created DB instance. If you specify ``null`` , the default value ``ORCL`` is used. You can't specify the string NULL, or any other reserved word, for ``DBName`` . Default: ``ORCL`` Constraints: - Can't be longer than 8 characters *SQL Server* Not applicable. Must be null.
        :param db_parameter_group_name: The name of an existing DB parameter group or a reference to an `AWS::RDS::DBParameterGroup <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbparametergroup.html>`_ resource created in the template. To list all of the available DB parameter group names, use the following command: ``aws rds describe-db-parameter-groups --query "DBParameterGroups[].DBParameterGroupName" --output text`` .. epigraph:: If any of the data members of the referenced parameter group are changed during an update, the DB instance might need to be restarted, which causes some interruption. If the parameter group contains static parameters, whether they were changed or not, an update triggers a reboot. If you don't specify a value for ``DBParameterGroupName`` property, the default DB parameter group for the specified engine and engine version is used.
        :param db_security_groups: A list of the DB security groups to assign to the DB instance. The list can include both the name of existing DB security groups or references to AWS::RDS::DBSecurityGroup resources created in the template. If you set DBSecurityGroups, you must not set VPCSecurityGroups, and vice versa. Also, note that the DBSecurityGroups property exists only for backwards compatibility with older regions and is no longer recommended for providing security information to an RDS DB instance. Instead, use VPCSecurityGroups. .. epigraph:: If you specify this property, AWS CloudFormation sends only the following properties (if specified) to Amazon RDS during create operations: - ``AllocatedStorage`` - ``AutoMinorVersionUpgrade`` - ``AvailabilityZone`` - ``BackupRetentionPeriod`` - ``CharacterSetName`` - ``DBInstanceClass`` - ``DBName`` - ``DBParameterGroupName`` - ``DBSecurityGroups`` - ``DBSubnetGroupName`` - ``Engine`` - ``EngineVersion`` - ``Iops`` - ``LicenseModel`` - ``MasterUsername`` - ``MasterUserPassword`` - ``MultiAZ`` - ``OptionGroupName`` - ``PreferredBackupWindow`` - ``PreferredMaintenanceWindow`` All other properties are ignored. Specify a virtual private cloud (VPC) security group if you want to submit other properties, such as ``StorageType`` , ``StorageEncrypted`` , or ``KmsKeyId`` . If you're already using the ``DBSecurityGroups`` property, you can't use these other properties by updating your DB instance to use a VPC security group. You must recreate the DB instance.
        :param db_snapshot_identifier: The name or Amazon Resource Name (ARN) of the DB snapshot that's used to restore the DB instance. If you're restoring from a shared manual DB snapshot, you must specify the ARN of the snapshot. By specifying this property, you can create a DB instance from the specified DB snapshot. If the ``DBSnapshotIdentifier`` property is an empty string or the ``AWS::RDS::DBInstance`` declaration has no ``DBSnapshotIdentifier`` property, AWS CloudFormation creates a new database. If the property contains a value (other than an empty string), AWS CloudFormation creates a database from the specified snapshot. If a snapshot with the specified name doesn't exist, AWS CloudFormation can't create the database and it rolls back the stack. Some DB instance properties aren't valid when you restore from a snapshot, such as the ``MasterUsername`` and ``MasterUserPassword`` properties. For information about the properties that you can specify, see the ``RestoreDBInstanceFromDBSnapshot`` action in the *Amazon RDS API Reference* . After you restore a DB instance with a ``DBSnapshotIdentifier`` property, you must specify the same ``DBSnapshotIdentifier`` property for any future updates to the DB instance. When you specify this property for an update, the DB instance is not restored from the DB snapshot again, and the data in the database is not changed. However, if you don't specify the ``DBSnapshotIdentifier`` property, an empty DB instance is created, and the original DB instance is deleted. If you specify a property that is different from the previous snapshot restore property, a new DB instance is restored from the specified ``DBSnapshotIdentifier`` property, and the original DB instance is deleted. If you specify the ``DBSnapshotIdentifier`` property to restore a DB instance (as opposed to specifying it for DB instance updates), then don't specify the following properties: - ``CharacterSetName`` - ``DBClusterIdentifier`` - ``DBName`` - ``DeleteAutomatedBackups`` - ``EnablePerformanceInsights`` - ``KmsKeyId`` - ``MasterUsername`` - ``MasterUserPassword`` - ``PerformanceInsightsKMSKeyId`` - ``PerformanceInsightsRetentionPeriod`` - ``PromotionTier`` - ``SourceDBInstanceIdentifier`` - ``SourceRegion`` - ``StorageEncrypted`` (for an encrypted snapshot) - ``Timezone`` *Amazon Aurora* Not applicable. Snapshot restore is managed by the DB cluster.
        :param db_subnet_group_name: A DB subnet group to associate with the DB instance. If you update this value, the new subnet group must be a subnet group in a new VPC. If there's no DB subnet group, then the DB instance isn't a VPC DB instance. For more information about using Amazon RDS in a VPC, see `Using Amazon RDS with Amazon Virtual Private Cloud (VPC) <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_VPC.html>`_ in the *Amazon RDS User Guide* . *Amazon Aurora* Not applicable. The DB subnet group is managed by the DB cluster. If specified, the setting must match the DB cluster setting.
        :param delete_automated_backups: A value that indicates whether to remove automated backups immediately after the DB instance is deleted. This parameter isn't case-sensitive. The default is to remove automated backups immediately after the DB instance is deleted. *Amazon Aurora* Not applicable. When you delete a DB cluster, all automated backups for that DB cluster are deleted and can't be recovered. Manual DB cluster snapshots of the DB cluster are not deleted.
        :param deletion_protection: A value that indicates whether the DB instance has deletion protection enabled. The database can't be deleted when deletion protection is enabled. By default, deletion protection is disabled. For more information, see `Deleting a DB Instance <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_DeleteInstance.html>`_ . *Amazon Aurora* Not applicable. You can enable or disable deletion protection for the DB cluster. For more information, see ``CreateDBCluster`` . DB instances in a DB cluster can be deleted even when deletion protection is enabled for the DB cluster.
        :param domain: The Active Directory directory ID to create the DB instance in. Currently, only Microsoft SQL Server, Oracle, and PostgreSQL DB instances can be created in an Active Directory Domain. For more information, see `Kerberos Authentication <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/kerberos-authentication.html>`_ in the *Amazon RDS User Guide* .
        :param domain_iam_role_name: Specify the name of the IAM role to be used when making API calls to the Directory Service. This setting doesn't apply to RDS Custom. *Amazon Aurora* Not applicable. The domain is managed by the DB cluster.
        :param enable_cloudwatch_logs_exports: The list of log types that need to be enabled for exporting to CloudWatch Logs. The values in the list depend on the DB engine being used. For more information, see `Publishing Database Logs to Amazon CloudWatch Logs <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_LogAccess.html#USER_LogAccess.Procedural.UploadtoCloudWatch>`_ in the *Amazon Relational Database Service User Guide* . *Amazon Aurora* Not applicable. CloudWatch Logs exports are managed by the DB cluster. *MariaDB* Valid values: ``audit`` , ``error`` , ``general`` , ``slowquery`` *Microsoft SQL Server* Valid values: ``agent`` , ``error`` *MySQL* Valid values: ``audit`` , ``error`` , ``general`` , ``slowquery`` *Oracle* Valid values: ``alert`` , ``audit`` , ``listener`` , ``trace`` *PostgreSQL* Valid values: ``postgresql`` , ``upgrade``
        :param enable_iam_database_authentication: A value that indicates whether to enable mapping of AWS Identity and Access Management (IAM) accounts to database accounts. By default, mapping is disabled. This property is supported for RDS for MariaDB, RDS for MySQL, and RDS for PostgreSQL. For more information, see `IAM Database Authentication for MariaDB, MySQL, and PostgreSQL <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.IAMDBAuth.html>`_ in the *Amazon RDS User Guide.* *Amazon Aurora* Not applicable. Mapping AWS IAM accounts to database accounts is managed by the DB cluster.
        :param enable_performance_insights: A value that indicates whether to enable Performance Insights for the DB instance. For more information, see `Using Amazon Performance Insights <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PerfInsights.html>`_ in the *Amazon RDS User Guide* . This setting doesn't apply to RDS Custom.
        :param endpoint: Specifies the connection endpoint. .. epigraph:: The endpoint might not be shown for instances whose status is ``creating`` .
        :param engine: The name of the database engine that you want to use for this DB instance. .. epigraph:: When you are creating a DB instance, the ``Engine`` property is required. Valid Values: - ``aurora-mysql`` (for Aurora MySQL DB instances) - ``aurora-postgresql`` (for Aurora PostgreSQL DB instances) - ``custom-oracle-ee`` (for RDS Custom for Oracle DB instances) - ``custom-oracle-ee-cdb`` (for RDS Custom for Oracle DB instances) - ``custom-sqlserver-ee`` (for RDS Custom for SQL Server DB instances) - ``custom-sqlserver-se`` (for RDS Custom for SQL Server DB instances) - ``custom-sqlserver-web`` (for RDS Custom for SQL Server DB instances) - ``mariadb`` - ``mysql`` - ``oracle-ee`` - ``oracle-ee-cdb`` - ``oracle-se2`` - ``oracle-se2-cdb`` - ``postgres`` - ``sqlserver-ee`` - ``sqlserver-se`` - ``sqlserver-ex`` - ``sqlserver-web``
        :param engine_version: The version number of the database engine to use. For a list of valid engine versions, use the ``DescribeDBEngineVersions`` action. The following are the database engines and links to information about the major and minor versions that are available with Amazon RDS. Not every database engine is available for every AWS Region. *Amazon Aurora* Not applicable. The version number of the database engine to be used by the DB instance is managed by the DB cluster. *MariaDB* See `MariaDB on Amazon RDS Versions <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_MariaDB.html#MariaDB.Concepts.VersionMgmt>`_ in the *Amazon RDS User Guide.* *Microsoft SQL Server* See `Microsoft SQL Server Versions on Amazon RDS <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_SQLServer.html#SQLServer.Concepts.General.VersionSupport>`_ in the *Amazon RDS User Guide.* *MySQL* See `MySQL on Amazon RDS Versions <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_MySQL.html#MySQL.Concepts.VersionMgmt>`_ in the *Amazon RDS User Guide.* *Oracle* See `Oracle Database Engine Release Notes <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Appendix.Oracle.PatchComposition.html>`_ in the *Amazon RDS User Guide.* *PostgreSQL* See `Supported PostgreSQL Database Versions <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_PostgreSQL.html#PostgreSQL.Concepts.General.DBVersions>`_ in the *Amazon RDS User Guide.*
        :param iops: The number of I/O operations per second (IOPS) that the database provisions. The value must be equal to or greater than 1000. If you specify this property, you must follow the range of allowed ratios of your requested IOPS rate to the amount of storage that you allocate (IOPS to allocated storage). For example, you can provision an Oracle database instance with 1000 IOPS and 200 GiB of storage (a ratio of 5:1), or specify 2000 IOPS with 200 GiB of storage (a ratio of 10:1). For more information, see `Amazon RDS Provisioned IOPS Storage to Improve Performance <https://docs.aws.amazon.com/AmazonRDS/latest/DeveloperGuide/CHAP_Storage.html#USER_PIOPS>`_ in the *Amazon RDS User Guide* . .. epigraph:: If you specify ``io1`` for the ``StorageType`` property, then you must also specify the ``Iops`` property.
        :param kms_key_id: The ARN of the AWS KMS key that's used to encrypt the DB instance, such as ``arn:aws:kms:us-east-1:012345678910:key/abcd1234-a123-456a-a12b-a123b4cd56ef`` . If you enable the StorageEncrypted property but don't specify this property, AWS CloudFormation uses the default KMS key. If you specify this property, you must set the StorageEncrypted property to true. If you specify the ``SourceDBInstanceIdentifier`` property, the value is inherited from the source DB instance if the read replica is created in the same region. If you create an encrypted read replica in a different AWS Region, then you must specify a KMS key for the destination AWS Region. KMS encryption keys are specific to the region that they're created in, and you can't use encryption keys from one region in another region. If you specify the ``SnapshotIdentifier`` property, the ``StorageEncrypted`` property value is inherited from the snapshot, and if the DB instance is encrypted, the specified ``KmsKeyId`` property is used. If you specify ``DBSecurityGroups`` , AWS CloudFormation ignores this property. To specify both a security group and this property, you must use a VPC security group. For more information about Amazon RDS and VPC, see `Using Amazon RDS with Amazon VPC <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_VPC.html>`_ in the *Amazon RDS User Guide* . *Amazon Aurora* Not applicable. The KMS key identifier is managed by the DB cluster.
        :param license_model: License model information for this DB instance. Valid values: - Aurora MySQL - ``general-public-license`` - Aurora PostgreSQL - ``postgresql-license`` - MariaDB - ``general-public-license`` - Microsoft SQL Server - ``license-included`` - MySQL - ``general-public-license`` - Oracle - ``bring-your-own-license`` or ``license-included`` - PostgreSQL - ``postgresql-license`` .. epigraph:: If you've specified ``DBSecurityGroups`` and then you update the license model, AWS CloudFormation replaces the underlying DB instance. This will incur some interruptions to database availability.
        :param manage_master_user_password: A value that indicates whether to manage the master user password with AWS Secrets Manager. For more information, see `Password management with AWS Secrets Manager <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-secrets-manager.html>`_ in the *Amazon RDS User Guide.* Constraints: - Can't manage the master user password with AWS Secrets Manager if ``MasterUserPassword`` is specified.
        :param master_username: The master user name for the DB instance. .. epigraph:: If you specify the ``SourceDBInstanceIdentifier`` or ``DBSnapshotIdentifier`` property, don't specify this property. The value is inherited from the source DB instance or snapshot. *Amazon Aurora* Not applicable. The name for the master user is managed by the DB cluster. *MariaDB* Constraints: - Required for MariaDB. - Must be 1 to 16 letters or numbers. - Can't be a reserved word for the chosen database engine. *Microsoft SQL Server* Constraints: - Required for SQL Server. - Must be 1 to 128 letters or numbers. - The first character must be a letter. - Can't be a reserved word for the chosen database engine. *MySQL* Constraints: - Required for MySQL. - Must be 1 to 16 letters or numbers. - First character must be a letter. - Can't be a reserved word for the chosen database engine. *Oracle* Constraints: - Required for Oracle. - Must be 1 to 30 letters or numbers. - First character must be a letter. - Can't be a reserved word for the chosen database engine. *PostgreSQL* Constraints: - Required for PostgreSQL. - Must be 1 to 63 letters or numbers. - First character must be a letter. - Can't be a reserved word for the chosen database engine.
        :param master_user_password: The password for the master user. The password can include any printable ASCII character except "/", """, or "@". *Amazon Aurora* Not applicable. The password for the master user is managed by the DB cluster. *MariaDB* Constraints: Must contain from 8 to 41 characters. *Microsoft SQL Server* Constraints: Must contain from 8 to 128 characters. *MySQL* Constraints: Must contain from 8 to 41 characters. *Oracle* Constraints: Must contain from 8 to 30 characters. *PostgreSQL* Constraints: Must contain from 8 to 128 characters.
        :param master_user_secret: Contains the secret managed by RDS in AWS Secrets Manager for the master user password. For more information, see `Password management with AWS Secrets Manager <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-secrets-manager.html>`_ in the *Amazon RDS User Guide.*
        :param max_allocated_storage: The upper limit in gibibytes (GiB) to which Amazon RDS can automatically scale the storage of the DB instance. For more information about this setting, including limitations that apply to it, see `Managing capacity automatically with Amazon RDS storage autoscaling <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PIOPS.StorageTypes.html#USER_PIOPS.Autoscaling>`_ in the *Amazon RDS User Guide* . This setting doesn't apply to RDS Custom. *Amazon Aurora* Not applicable. Storage is managed by the DB cluster.
        :param monitoring_interval: The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the DB instance. To disable collection of Enhanced Monitoring metrics, specify 0. The default is 0. If ``MonitoringRoleArn`` is specified, then you must set ``MonitoringInterval`` to a value other than 0. This setting doesn't apply to RDS Custom. Valid Values: ``0, 1, 5, 10, 15, 30, 60``
        :param monitoring_role_arn: The ARN for the IAM role that permits RDS to send enhanced monitoring metrics to Amazon CloudWatch Logs. For example, ``arn:aws:iam:123456789012:role/emaccess`` . For information on creating a monitoring role, see `Setting Up and Enabling Enhanced Monitoring <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Monitoring.OS.html#USER_Monitoring.OS.Enabling>`_ in the *Amazon RDS User Guide* . If ``MonitoringInterval`` is set to a value other than 0, then you must supply a ``MonitoringRoleArn`` value. This setting doesn't apply to RDS Custom.
        :param multi_az: Specifies whether the database instance is a Multi-AZ DB instance deployment. You can't set the ``AvailabilityZone`` parameter if the ``MultiAZ`` parameter is set to true. For more information, see `Multi-AZ deployments for high availability <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.MultiAZ.html>`_ in the *Amazon RDS User Guide* . *Amazon Aurora* Not applicable. Amazon Aurora storage is replicated across all of the Availability Zones and doesn't require the ``MultiAZ`` option to be set.
        :param nchar_character_set_name: The name of the NCHAR character set for the Oracle DB instance. This parameter doesn't apply to RDS Custom.
        :param network_type: The network type of the DB instance. Valid values: - ``IPV4`` - ``DUAL`` The network type is determined by the ``DBSubnetGroup`` specified for the DB instance. A ``DBSubnetGroup`` can support only the IPv4 protocol or the IPv4 and IPv6 protocols ( ``DUAL`` ). For more information, see `Working with a DB instance in a VPC <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_VPC.WorkingWithRDSInstanceinaVPC.html>`_ in the *Amazon RDS User Guide.*
        :param option_group_name: Indicates that the DB instance should be associated with the specified option group. Permanent options, such as the TDE option for Oracle Advanced Security TDE, can't be removed from an option group. Also, that option group can't be removed from a DB instance once it is associated with a DB instance.
        :param performance_insights_kms_key_id: The AWS KMS key identifier for encryption of Performance Insights data. The KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. If you do not specify a value for ``PerformanceInsightsKMSKeyId`` , then Amazon RDS uses your default KMS key. There is a default KMS key for your AWS account. Your AWS account has a different default KMS key for each AWS Region. For information about enabling Performance Insights, see `EnablePerformanceInsights <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-database-instance.html#cfn-rds-dbinstance-enableperformanceinsights>`_ .
        :param performance_insights_retention_period: The number of days to retain Performance Insights data. The default is 7 days. The following values are valid:. - 7 - *month* * 31, where *month* is a number of months from 1-23 - 731 For example, the following values are valid: - 93 (3 months * 31) - 341 (11 months * 31) - 589 (19 months * 31) - 731 If you specify a retention period such as 94, which isn't a valid value, RDS issues an error. This setting doesn't apply to RDS Custom.
        :param port: The port number on which the database accepts connections. *Amazon Aurora* Not applicable. The port number is managed by the DB cluster.
        :param preferred_backup_window: The daily time range during which automated backups are created if automated backups are enabled, using the ``BackupRetentionPeriod`` parameter. For more information, see `Backup Window <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithAutomatedBackups.html#USER_WorkingWithAutomatedBackups.BackupWindow>`_ in the *Amazon RDS User Guide.* Constraints: - Must be in the format ``hh24:mi-hh24:mi`` . - Must be in Universal Coordinated Time (UTC). - Must not conflict with the preferred maintenance window. - Must be at least 30 minutes. *Amazon Aurora* Not applicable. The daily time range for creating automated backups is managed by the DB cluster.
        :param preferred_maintenance_window: The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC). Format: ``ddd:hh24:mi-ddd:hh24:mi`` The default is a 30-minute window selected at random from an 8-hour block of time for each AWS Region, occurring on a random day of the week. To see the time blocks available, see `Adjusting the Preferred DB Instance Maintenance Window <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_UpgradeDBInstance.Maintenance.html#AdjustingTheMaintenanceWindow>`_ in the *Amazon RDS User Guide.* .. epigraph:: This property applies when AWS CloudFormation initially creates the DB instance. If you use AWS CloudFormation to update the DB instance, those updates are applied immediately. Constraints: Minimum 30-minute window.
        :param processor_features: The number of CPU cores and the number of threads per core for the DB instance class of the DB instance. This setting doesn't apply to RDS Custom. *Amazon Aurora* Not applicable.
        :param promotion_tier: A value that specifies the order in which an Aurora Replica is promoted to the primary instance after a failure of the existing primary instance. For more information, see `Fault Tolerance for an Aurora DB Cluster <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.Managing.Backups.html#Aurora.Managing.FaultTolerance>`_ in the *Amazon Aurora User Guide* . This setting doesn't apply to RDS Custom. Default: 1 Valid Values: 0 - 15
        :param publicly_accessible: Indicates whether the DB instance is an internet-facing instance. If you specify true, AWS CloudFormation creates an instance with a publicly resolvable DNS name, which resolves to a public IP address. If you specify false, AWS CloudFormation creates an internal instance with a DNS name that resolves to a private IP address. The default behavior value depends on your VPC setup and the database subnet group. For more information, see the ``PubliclyAccessible`` parameter in the `CreateDBInstance <https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_CreateDBInstance.html>`_ in the *Amazon RDS API Reference* .
        :param replica_mode: The open mode of an Oracle read replica. For more information, see `Working with Oracle Read Replicas for Amazon RDS <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/oracle-read-replicas.html>`_ in the *Amazon RDS User Guide* . This setting is only supported in RDS for Oracle. Default: ``open-read-only`` Valid Values: ``open-read-only`` or ``mounted``
        :param restore_time: The date and time to restore from. Valid Values: Value must be a time in Universal Coordinated Time (UTC) format Constraints: - Must be before the latest restorable time for the DB instance - Can't be specified if the ``UseLatestRestorableTime`` parameter is enabled Example: ``2009-09-07T23:45:00Z``
        :param source_db_cluster_identifier: The identifier of the Multi-AZ DB cluster that will act as the source for the read replica. Each DB cluster can have up to 15 read replicas. Constraints: - Must be the identifier of an existing Multi-AZ DB cluster. - Can't be specified if the ``SourceDBInstanceIdentifier`` parameter is also specified. - The specified DB cluster must have automatic backups enabled, that is, its backup retention period must be greater than 0. - The source DB cluster must be in the same AWS Region as the read replica. Cross-Region replication isn't supported.
        :param source_db_instance_automated_backups_arn: The Amazon Resource Name (ARN) of the replicated automated backups from which to restore, for example, ``arn:aws:rds:useast-1:123456789012:auto-backup:ab-L2IJCEXJP7XQ7HOJ4SIEXAMPLE`` . This setting doesn't apply to RDS Custom.
        :param source_db_instance_identifier: If you want to create a read replica DB instance, specify the ID of the source DB instance. Each DB instance can have a limited number of read replicas. For more information, see `Working with Read Replicas <https://docs.aws.amazon.com/AmazonRDS/latest/DeveloperGuide/USER_ReadRepl.html>`_ in the *Amazon RDS User Guide* . For information about constraints that apply to DB instance identifiers, see `Naming constraints in Amazon RDS <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Limits.html#RDS_Limits.Constraints>`_ in the *Amazon RDS User Guide* . The ``SourceDBInstanceIdentifier`` property determines whether a DB instance is a read replica. If you remove the ``SourceDBInstanceIdentifier`` property from your template and then update your stack, AWS CloudFormation promotes the Read Replica to a standalone DB instance. .. epigraph:: - If you specify a source DB instance that uses VPC security groups, we recommend that you specify the ``VPCSecurityGroups`` property. If you don't specify the property, the read replica inherits the value of the ``VPCSecurityGroups`` property from the source DB when you create the replica. However, if you update the stack, AWS CloudFormation reverts the replica's ``VPCSecurityGroups`` property to the default value because it's not defined in the stack's template. This change might cause unexpected issues. - Read replicas don't support deletion policies. AWS CloudFormation ignores any deletion policy that's associated with a read replica. - If you specify ``SourceDBInstanceIdentifier`` , don't specify the ``DBSnapshotIdentifier`` property. You can't create a read replica from a snapshot. - Don't set the ``BackupRetentionPeriod`` , ``DBName`` , ``MasterUsername`` , ``MasterUserPassword`` , and ``PreferredBackupWindow`` properties. The database attributes are inherited from the source DB instance, and backups are disabled for read replicas. - If the source DB instance is in a different region than the read replica, specify the source region in ``SourceRegion`` , and specify an ARN for a valid DB instance in ``SourceDBInstanceIdentifier`` . For more information, see `Constructing a Amazon RDS Amazon Resource Name (ARN) <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html#USER_Tagging.ARN>`_ in the *Amazon RDS User Guide* . - For DB instances in Amazon Aurora clusters, don't specify this property. Amazon RDS automatically assigns writer and reader DB instances.
        :param source_dbi_resource_id: The resource ID of the source DB instance from which to restore.
        :param source_region: The ID of the region that contains the source DB instance for the read replica.
        :param storage_encrypted: A value that indicates whether the DB instance is encrypted. By default, it isn't encrypted. If you specify the ``KmsKeyId`` property, then you must enable encryption. If you specify the ``SourceDBInstanceIdentifier`` property, don't specify this property. The value is inherited from the source DB instance, and if the DB instance is encrypted, the specified ``KmsKeyId`` property is used. If you specify the ``SnapshotIdentifier`` and the specified snapshot is encrypted, don't specify this property. The value is inherited from the snapshot, and the specified ``KmsKeyId`` property is used. If you specify the ``SnapshotIdentifier`` and the specified snapshot isn't encrypted, you can use this property to specify that the restored DB instance is encrypted. Specify the ``KmsKeyId`` property for the KMS key to use for encryption. If you don't want the restored DB instance to be encrypted, then don't set this property or set it to ``false`` . *Amazon Aurora* Not applicable. The encryption for DB instances is managed by the DB cluster.
        :param storage_throughput: Specifies the storage throughput value for the DB instance. This setting applies only to the ``gp3`` storage type. This setting doesn't apply to RDS Custom or Amazon Aurora.
        :param storage_type: Specifies the storage type to be associated with the DB instance. Valid values: ``gp2 | gp3 | io1 | standard`` The ``standard`` value is also known as magnetic. If you specify ``io1`` or ``gp3`` , you must also include a value for the ``Iops`` parameter. Default: ``io1`` if the ``Iops`` parameter is specified, otherwise ``gp2`` For more information, see `Amazon RDS DB Instance Storage <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Storage.html>`_ in the *Amazon RDS User Guide* . *Amazon Aurora* Not applicable. Aurora data is stored in the cluster volume, which is a single, virtual volume that uses solid state drives (SSDs).
        :param tags: An optional array of key-value pairs to apply to this DB instance.
        :param timezone: The time zone of the DB instance. The time zone parameter is currently supported only by `Microsoft SQL Server <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_SQLServer.html#SQLServer.Concepts.General.TimeZone>`_ .
        :param use_default_processor_features: A value that indicates whether the DB instance class of the DB instance uses its default processor features. This setting doesn't apply to RDS Custom.
        :param use_latest_restorable_time: A value that indicates whether the DB instance is restored from the latest backup time. By default, the DB instance isn't restored from the latest backup time. Constraints: Can't be specified if the ``RestoreTime`` parameter is provided.
        :param vpc_security_groups: A list of the VPC security group IDs to assign to the DB instance. The list can include both the physical IDs of existing VPC security groups and references to `AWS::EC2::SecurityGroup <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group.html>`_ resources created in the template. If you plan to update the resource, don't specify VPC security groups in a shared VPC. If you set ``VPCSecurityGroups`` , you must not set ```DBSecurityGroups`` <https://docs.aws.amazon.com//AWSCloudFormation/latest/UserGuide/aws-properties-rds-database-instance.html#cfn-rds-dbinstance-dbsecuritygroups>`_ , and vice versa. .. epigraph:: You can migrate a DB instance in your stack from an RDS DB security group to a VPC security group, but keep the following in mind: - You can't revert to using an RDS security group after you establish a VPC security group membership. - When you migrate your DB instance to VPC security groups, if your stack update rolls back because the DB instance update fails or because an update fails in another AWS CloudFormation resource, the rollback fails because it can't revert to an RDS security group. - To use the properties that are available when you use a VPC security group, you must recreate the DB instance. If you don't, AWS CloudFormation submits only the property values that are listed in the ```DBSecurityGroups`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-database-instance.html#cfn-rds-dbinstance-dbsecuritygroups>`_ property. To avoid this situation, migrate your DB instance to using VPC security groups only when that is the only change in your stack template. *Amazon Aurora* Not applicable. The associated list of EC2 VPC security groups is managed by the DB cluster. If specified, the setting must match the DB cluster setting.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c606bd0a8ff590d068fe4f90d7fe83c8aaa621c6ed05600706ac1e1283b1933f)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = CfnDBInstanceProps(
            allocated_storage=allocated_storage,
            allow_major_version_upgrade=allow_major_version_upgrade,
            associated_roles=associated_roles,
            auto_minor_version_upgrade=auto_minor_version_upgrade,
            availability_zone=availability_zone,
            backup_retention_period=backup_retention_period,
            ca_certificate_identifier=ca_certificate_identifier,
            certificate_details=certificate_details,
            certificate_rotation_restart=certificate_rotation_restart,
            character_set_name=character_set_name,
            copy_tags_to_snapshot=copy_tags_to_snapshot,
            custom_iam_instance_profile=custom_iam_instance_profile,
            db_cluster_identifier=db_cluster_identifier,
            db_cluster_snapshot_identifier=db_cluster_snapshot_identifier,
            db_instance_class=db_instance_class,
            db_instance_identifier=db_instance_identifier,
            db_name=db_name,
            db_parameter_group_name=db_parameter_group_name,
            db_security_groups=db_security_groups,
            db_snapshot_identifier=db_snapshot_identifier,
            db_subnet_group_name=db_subnet_group_name,
            delete_automated_backups=delete_automated_backups,
            deletion_protection=deletion_protection,
            domain=domain,
            domain_iam_role_name=domain_iam_role_name,
            enable_cloudwatch_logs_exports=enable_cloudwatch_logs_exports,
            enable_iam_database_authentication=enable_iam_database_authentication,
            enable_performance_insights=enable_performance_insights,
            endpoint=endpoint,
            engine=engine,
            engine_version=engine_version,
            iops=iops,
            kms_key_id=kms_key_id,
            license_model=license_model,
            manage_master_user_password=manage_master_user_password,
            master_username=master_username,
            master_user_password=master_user_password,
            master_user_secret=master_user_secret,
            max_allocated_storage=max_allocated_storage,
            monitoring_interval=monitoring_interval,
            monitoring_role_arn=monitoring_role_arn,
            multi_az=multi_az,
            nchar_character_set_name=nchar_character_set_name,
            network_type=network_type,
            option_group_name=option_group_name,
            performance_insights_kms_key_id=performance_insights_kms_key_id,
            performance_insights_retention_period=performance_insights_retention_period,
            port=port,
            preferred_backup_window=preferred_backup_window,
            preferred_maintenance_window=preferred_maintenance_window,
            processor_features=processor_features,
            promotion_tier=promotion_tier,
            publicly_accessible=publicly_accessible,
            replica_mode=replica_mode,
            restore_time=restore_time,
            source_db_cluster_identifier=source_db_cluster_identifier,
            source_db_instance_automated_backups_arn=source_db_instance_automated_backups_arn,
            source_db_instance_identifier=source_db_instance_identifier,
            source_dbi_resource_id=source_dbi_resource_id,
            source_region=source_region,
            storage_encrypted=storage_encrypted,
            storage_throughput=storage_throughput,
            storage_type=storage_type,
            tags=tags,
            timezone=timezone,
            use_default_processor_features=use_default_processor_features,
            use_latest_restorable_time=use_latest_restorable_time,
            vpc_security_groups=vpc_security_groups,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_1cd1894e) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__771f4d7ea048112360e7bc3038e30aba879d80e5477f41280ef9dc248f667baf)
            check_type(argname="argument inspector", value=inspector, expected_type=type_hints["inspector"])
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__234612597441a3e579324845dad3d1e6ea039ee8d98e571fd464e79cc5efdd94)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrCertificateDetailsCaIdentifier")
    def attr_certificate_details_ca_identifier(self) -> builtins.str:
        '''The CA identifier of the CA certificate used for the DB instance's server certificate.

        :cloudformationAttribute: CertificateDetails.CAIdentifier
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrCertificateDetailsCaIdentifier"))

    @builtins.property
    @jsii.member(jsii_name="attrCertificateDetailsValidTill")
    def attr_certificate_details_valid_till(self) -> builtins.str:
        '''The expiration date of the DB instances server certificate.

        :cloudformationAttribute: CertificateDetails.ValidTill
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrCertificateDetailsValidTill"))

    @builtins.property
    @jsii.member(jsii_name="attrDbInstanceArn")
    def attr_db_instance_arn(self) -> builtins.str:
        '''The Amazon Resource Name (ARN) for the DB instance.

        :cloudformationAttribute: DBInstanceArn
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrDbInstanceArn"))

    @builtins.property
    @jsii.member(jsii_name="attrDbiResourceId")
    def attr_dbi_resource_id(self) -> builtins.str:
        '''The AWS Region-unique, immutable identifier for the DB instance.

        This identifier is found in AWS CloudTrail log entries whenever the AWS KMS key for the DB instance is accessed.

        :cloudformationAttribute: DbiResourceId
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrDbiResourceId"))

    @builtins.property
    @jsii.member(jsii_name="attrDbSystemId")
    def attr_db_system_id(self) -> builtins.str:
        '''The Oracle system ID (Oracle SID) for a container database (CDB).

        The Oracle SID is also the name of the CDB.

        This setting is valid for RDS Custom only.

        :cloudformationAttribute: DBSystemId
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrDbSystemId"))

    @builtins.property
    @jsii.member(jsii_name="attrEndpointAddress")
    def attr_endpoint_address(self) -> builtins.str:
        '''The connection endpoint for the database. For example: ``mystack-mydb-1apw1j4phylrk.cg034hpkmmjt.us-east-2.rds.amazonaws.com``.

        For Aurora Serverless DB clusters, the connection endpoint only applies to the DB cluster.

        :cloudformationAttribute: Endpoint.Address
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrEndpointAddress"))

    @builtins.property
    @jsii.member(jsii_name="attrEndpointHostedZoneId")
    def attr_endpoint_hosted_zone_id(self) -> builtins.str:
        '''The ID that Amazon Route 53 assigns when you create a hosted zone.

        :cloudformationAttribute: Endpoint.HostedZoneId
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrEndpointHostedZoneId"))

    @builtins.property
    @jsii.member(jsii_name="attrEndpointPort")
    def attr_endpoint_port(self) -> builtins.str:
        '''The port number on which the database accepts connections.

        For example: ``3306``

        :cloudformationAttribute: Endpoint.Port
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrEndpointPort"))

    @builtins.property
    @jsii.member(jsii_name="attrMasterUserSecretSecretArn")
    def attr_master_user_secret_secret_arn(self) -> builtins.str:
        '''The Amazon Resource Name (ARN) of the secret.

        :cloudformationAttribute: MasterUserSecret.SecretArn
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrMasterUserSecretSecretArn"))

    @builtins.property
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property
    @jsii.member(jsii_name="tags")
    def tags(self) -> _TagManager_0b7ab120:
        '''An optional array of key-value pairs to apply to this DB instance.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-tags
        '''
        return typing.cast(_TagManager_0b7ab120, jsii.get(self, "tags"))

    @builtins.property
    @jsii.member(jsii_name="allocatedStorage")
    def allocated_storage(self) -> typing.Optional[builtins.str]:
        '''The amount of storage in gibibytes (GiB) to be initially allocated for the database instance.

        .. epigraph::

           If any value is set in the ``Iops`` parameter, ``AllocatedStorage`` must be at least 100 GiB, which corresponds to the minimum Iops value of 1,000. If you increase the ``Iops`` value (in 1,000 IOPS increments), then you must also increase the ``AllocatedStorage`` value (in 100-GiB increments).

        *Amazon Aurora*

        Not applicable. Aurora cluster volumes automatically grow as the amount of data in your database increases, though you are only charged for the space that you use in an Aurora cluster volume.

        *MySQL*

        Constraints to the amount of storage for each storage type are the following:

        - General Purpose (SSD) storage (gp2): Must be an integer from 20 to 65536.
        - Provisioned IOPS storage (io1): Must be an integer from 100 to 65536.
        - Magnetic storage (standard): Must be an integer from 5 to 3072.

        *MariaDB*

        Constraints to the amount of storage for each storage type are the following:

        - General Purpose (SSD) storage (gp2): Must be an integer from 20 to 65536.
        - Provisioned IOPS storage (io1): Must be an integer from 100 to 65536.
        - Magnetic storage (standard): Must be an integer from 5 to 3072.

        *PostgreSQL*

        Constraints to the amount of storage for each storage type are the following:

        - General Purpose (SSD) storage (gp2): Must be an integer from 20 to 65536.
        - Provisioned IOPS storage (io1): Must be an integer from 100 to 65536.
        - Magnetic storage (standard): Must be an integer from 5 to 3072.

        *Oracle*

        Constraints to the amount of storage for each storage type are the following:

        - General Purpose (SSD) storage (gp2): Must be an integer from 20 to 65536.
        - Provisioned IOPS storage (io1): Must be an integer from 100 to 65536.
        - Magnetic storage (standard): Must be an integer from 10 to 3072.

        *SQL Server*

        Constraints to the amount of storage for each storage type are the following:

        - General Purpose (SSD) storage (gp2):
        - Enterprise and Standard editions: Must be an integer from 20 to 16384.
        - Web and Express editions: Must be an integer from 20 to 16384.
        - Provisioned IOPS storage (io1):
        - Enterprise and Standard editions: Must be an integer from 20 to 16384.
        - Web and Express editions: Must be an integer from 20 to 16384.
        - Magnetic storage (standard):
        - Enterprise and Standard editions: Must be an integer from 20 to 1024.
        - Web and Express editions: Must be an integer from 20 to 1024.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-allocatedstorage
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "allocatedStorage"))

    @allocated_storage.setter
    def allocated_storage(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f30ac34c92f1ed4bbc4352ef3997cf5e224ef6d6a883e6b2c8cb9ad15ad56ed8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "allocatedStorage", value)

    @builtins.property
    @jsii.member(jsii_name="allowMajorVersionUpgrade")
    def allow_major_version_upgrade(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''A value that indicates whether major version upgrades are allowed.

        Changing this parameter doesn't result in an outage and the change is asynchronously applied as soon as possible.

        Constraints: Major version upgrades must be allowed when specifying a value for the ``EngineVersion`` parameter that is a different major version than the DB instance's current version.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-allowmajorversionupgrade
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], jsii.get(self, "allowMajorVersionUpgrade"))

    @allow_major_version_upgrade.setter
    def allow_major_version_upgrade(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__74ab94e5101e04b5fb5ff83c99c5b520eeea3baf28f6e294316d894b1a5b4ef9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "allowMajorVersionUpgrade", value)

    @builtins.property
    @jsii.member(jsii_name="associatedRoles")
    def associated_roles(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_a771d0ef, typing.List[typing.Union["CfnDBInstance.DBInstanceRoleProperty", _IResolvable_a771d0ef]]]]:
        '''The AWS Identity and Access Management (IAM) roles associated with the DB instance.

        *Amazon Aurora*

        Not applicable. The associated roles are managed by the DB cluster.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-associatedroles
        '''
        return typing.cast(typing.Optional[typing.Union[_IResolvable_a771d0ef, typing.List[typing.Union["CfnDBInstance.DBInstanceRoleProperty", _IResolvable_a771d0ef]]]], jsii.get(self, "associatedRoles"))

    @associated_roles.setter
    def associated_roles(
        self,
        value: typing.Optional[typing.Union[_IResolvable_a771d0ef, typing.List[typing.Union["CfnDBInstance.DBInstanceRoleProperty", _IResolvable_a771d0ef]]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__180aab7f21fa6a40b6e368188a38a6ab0c898e2ea4d7b5c5144e26df0e9583f6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "associatedRoles", value)

    @builtins.property
    @jsii.member(jsii_name="autoMinorVersionUpgrade")
    def auto_minor_version_upgrade(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''A value that indicates whether minor engine upgrades are applied automatically to the DB instance during the maintenance window.

        By default, minor engine upgrades are applied automatically.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-autominorversionupgrade
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], jsii.get(self, "autoMinorVersionUpgrade"))

    @auto_minor_version_upgrade.setter
    def auto_minor_version_upgrade(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f47631fdd86ba904175fdf3d413da9ee0611e6248c39cb97ffa408800ad60fca)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "autoMinorVersionUpgrade", value)

    @builtins.property
    @jsii.member(jsii_name="availabilityZone")
    def availability_zone(self) -> typing.Optional[builtins.str]:
        '''The Availability Zone (AZ) where the database will be created.

        For information on AWS Regions and Availability Zones, see `Regions and Availability Zones <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.RegionsAndAvailabilityZones.html>`_ .

        *Amazon Aurora*

        Each Aurora DB cluster hosts copies of its storage in three separate Availability Zones. Specify one of these Availability Zones. Aurora automatically chooses an appropriate Availability Zone if you don't specify one.

        Default: A random, system-chosen Availability Zone in the endpoint's AWS Region .

        Example: ``us-east-1d``

        Constraint: The ``AvailabilityZone`` parameter can't be specified if the DB instance is a Multi-AZ deployment. The specified Availability Zone must be in the same AWS Region as the current endpoint.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-availabilityzone
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "availabilityZone"))

    @availability_zone.setter
    def availability_zone(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__736bf61bbf857e3f5d156473dde3aec8157a869e9aa829031591bfee5577e7cb)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "availabilityZone", value)

    @builtins.property
    @jsii.member(jsii_name="backupRetentionPeriod")
    def backup_retention_period(self) -> typing.Optional[jsii.Number]:
        '''The number of days for which automated backups are retained.

        Setting this parameter to a positive number enables backups. Setting this parameter to 0 disables automated backups.

        *Amazon Aurora*

        Not applicable. The retention period for automated backups is managed by the DB cluster.

        Default: 1

        Constraints:

        - Must be a value from 0 to 35
        - Can't be set to 0 if the DB instance is a source to read replicas

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-backupretentionperiod
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "backupRetentionPeriod"))

    @backup_retention_period.setter
    def backup_retention_period(self, value: typing.Optional[jsii.Number]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7c7ed9000aad473bbdca38324efe5e7c8df236468d3f50d8e515323df05c88f4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "backupRetentionPeriod", value)

    @builtins.property
    @jsii.member(jsii_name="caCertificateIdentifier")
    def ca_certificate_identifier(self) -> typing.Optional[builtins.str]:
        '''The identifier of the CA certificate for this DB instance.

        .. epigraph::

           Specifying or updating this property triggers a reboot.

        For more information about CA certificate identifiers for RDS DB engines, see `Rotating Your SSL/TLS Certificate <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.SSL-certificate-rotation.html>`_ in the *Amazon RDS User Guide* .

        For more information about CA certificate identifiers for Aurora DB engines, see `Rotating Your SSL/TLS Certificate <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/UsingWithRDS.SSL-certificate-rotation.html>`_ in the *Amazon Aurora User Guide* .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-cacertificateidentifier
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "caCertificateIdentifier"))

    @ca_certificate_identifier.setter
    def ca_certificate_identifier(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fc1a30e374a43cac11871b5fbcb869f25da71d31962675a125b91d834fdba14f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "caCertificateIdentifier", value)

    @builtins.property
    @jsii.member(jsii_name="certificateDetails")
    def certificate_details(
        self,
    ) -> typing.Optional[typing.Union["CfnDBInstance.CertificateDetailsProperty", _IResolvable_a771d0ef]]:
        '''The details of the DB instance's server certificate.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-certificatedetails
        '''
        return typing.cast(typing.Optional[typing.Union["CfnDBInstance.CertificateDetailsProperty", _IResolvable_a771d0ef]], jsii.get(self, "certificateDetails"))

    @certificate_details.setter
    def certificate_details(
        self,
        value: typing.Optional[typing.Union["CfnDBInstance.CertificateDetailsProperty", _IResolvable_a771d0ef]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1c145766ddab759cfba073659140b34ff2f6d5084b49fdfcb48a6a6142cbc082)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "certificateDetails", value)

    @builtins.property
    @jsii.member(jsii_name="certificateRotationRestart")
    def certificate_rotation_restart(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''A value that indicates whether the DB instance is restarted when you rotate your SSL/TLS certificate.

        By default, the DB instance is restarted when you rotate your SSL/TLS certificate. The certificate is not updated until the DB instance is restarted.
        .. epigraph::

           Set this parameter only if you are *not* using SSL/TLS to connect to the DB instance.

        If you are using SSL/TLS to connect to the DB instance, follow the appropriate instructions for your DB engine to rotate your SSL/TLS certificate:

        - For more information about rotating your SSL/TLS certificate for RDS DB engines, see `Rotating Your SSL/TLS Certificate. <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.SSL-certificate-rotation.html>`_ in the *Amazon RDS User Guide.*
        - For more information about rotating your SSL/TLS certificate for Aurora DB engines, see `Rotating Your SSL/TLS Certificate <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/UsingWithRDS.SSL-certificate-rotation.html>`_ in the *Amazon Aurora User Guide* .

        This setting doesn't apply to RDS Custom.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-certificaterotationrestart
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], jsii.get(self, "certificateRotationRestart"))

    @certificate_rotation_restart.setter
    def certificate_rotation_restart(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cadcd0ca784fe888fce63c692136fd6694a426037faec6bc85b099d88879786a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "certificateRotationRestart", value)

    @builtins.property
    @jsii.member(jsii_name="characterSetName")
    def character_set_name(self) -> typing.Optional[builtins.str]:
        '''For supported engines, indicates that the DB instance should be associated with the specified character set.

        *Amazon Aurora*

        Not applicable. The character set is managed by the DB cluster. For more information, see `AWS::RDS::DBCluster <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html>`_ .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-charactersetname
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "characterSetName"))

    @character_set_name.setter
    def character_set_name(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5daa49efa52d13d99a332fd35c25369d10a56f59e9934e1ce2a1e7f73ff5322d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "characterSetName", value)

    @builtins.property
    @jsii.member(jsii_name="copyTagsToSnapshot")
    def copy_tags_to_snapshot(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''A value that indicates whether to copy tags from the DB instance to snapshots of the DB instance.

        By default, tags are not copied.

        *Amazon Aurora*

        Not applicable. Copying tags to snapshots is managed by the DB cluster. Setting this value for an Aurora DB instance has no effect on the DB cluster setting.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-copytagstosnapshot
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], jsii.get(self, "copyTagsToSnapshot"))

    @copy_tags_to_snapshot.setter
    def copy_tags_to_snapshot(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a565cee18d76d8438a280751a0fc381f3a970600369212a67e8bd7cdc5f62a4b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "copyTagsToSnapshot", value)

    @builtins.property
    @jsii.member(jsii_name="customIamInstanceProfile")
    def custom_iam_instance_profile(self) -> typing.Optional[builtins.str]:
        '''The instance profile associated with the underlying Amazon EC2 instance of an RDS Custom DB instance.

        The instance profile must meet the following requirements:

        - The profile must exist in your account.
        - The profile must have an IAM role that Amazon EC2 has permissions to assume.
        - The instance profile name and the associated IAM role name must start with the prefix ``AWSRDSCustom`` .

        For the list of permissions required for the IAM role, see `Configure IAM and your VPC <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/custom-setup-orcl.html#custom-setup-orcl.iam-vpc>`_ in the *Amazon RDS User Guide* .

        This setting is required for RDS Custom.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-customiaminstanceprofile
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "customIamInstanceProfile"))

    @custom_iam_instance_profile.setter
    def custom_iam_instance_profile(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3c1f4b5f46e062a262dc2ce1d7001c36206285cf797aaee1381e035e222556bd)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "customIamInstanceProfile", value)

    @builtins.property
    @jsii.member(jsii_name="dbClusterIdentifier")
    def db_cluster_identifier(self) -> typing.Optional[builtins.str]:
        '''The identifier of the DB cluster that the instance will belong to.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-dbclusteridentifier
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "dbClusterIdentifier"))

    @db_cluster_identifier.setter
    def db_cluster_identifier(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6fc3e4bb152502ba92448cf4d01648e76a6144162d08f8aedc78af23899e1bc1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dbClusterIdentifier", value)

    @builtins.property
    @jsii.member(jsii_name="dbClusterSnapshotIdentifier")
    def db_cluster_snapshot_identifier(self) -> typing.Optional[builtins.str]:
        '''The identifier for the RDS for MySQL Multi-AZ DB cluster snapshot to restore from.

        For more information on Multi-AZ DB clusters, see `Multi-AZ DB cluster deployments <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/multi-az-db-clusters-concepts.html>`_ in the *Amazon RDS User Guide* .

        Constraints:

        - Must match the identifier of an existing Multi-AZ DB cluster snapshot.
        - Can't be specified when ``DBSnapshotIdentifier`` is specified.
        - Must be specified when ``DBSnapshotIdentifier`` isn't specified.
        - If you are restoring from a shared manual Multi-AZ DB cluster snapshot, the ``DBClusterSnapshotIdentifier`` must be the ARN of the shared snapshot.
        - Can't be the identifier of an Aurora DB cluster snapshot.
        - Can't be the identifier of an RDS for PostgreSQL Multi-AZ DB cluster snapshot.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-dbclustersnapshotidentifier
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "dbClusterSnapshotIdentifier"))

    @db_cluster_snapshot_identifier.setter
    def db_cluster_snapshot_identifier(
        self,
        value: typing.Optional[builtins.str],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__550c49ea20b997cea5ed397642b8e0afbefd25a663bc63f164a94163b779994e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dbClusterSnapshotIdentifier", value)

    @builtins.property
    @jsii.member(jsii_name="dbInstanceClass")
    def db_instance_class(self) -> typing.Optional[builtins.str]:
        '''The compute and memory capacity of the DB instance, for example, ``db.m4.large`` . Not all DB instance classes are available in all AWS Regions, or for all database engines.

        For the full list of DB instance classes, and availability for your engine, see `DB Instance Class <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html>`_ in the *Amazon RDS User Guide.* For more information about DB instance class pricing and AWS Region support for DB instance classes, see `Amazon RDS Pricing <https://docs.aws.amazon.com/rds/pricing/>`_ .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-dbinstanceclass
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "dbInstanceClass"))

    @db_instance_class.setter
    def db_instance_class(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__722688888959726be9de6dd3a15e420fb27666e2703808dd9c1d35b009cb9e30)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dbInstanceClass", value)

    @builtins.property
    @jsii.member(jsii_name="dbInstanceIdentifier")
    def db_instance_identifier(self) -> typing.Optional[builtins.str]:
        '''A name for the DB instance.

        If you specify a name, AWS CloudFormation converts it to lowercase. If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the DB instance. For more information, see `Name Type <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html>`_ .

        For information about constraints that apply to DB instance identifiers, see `Naming constraints in Amazon RDS <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Limits.html#RDS_Limits.Constraints>`_ in the *Amazon RDS User Guide* .
        .. epigraph::

           If you specify a name, you can't perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-dbinstanceidentifier
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "dbInstanceIdentifier"))

    @db_instance_identifier.setter
    def db_instance_identifier(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__094c1781a68c6868527b0557da13af1e22d17de7c6434939d6642273af8dc33d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dbInstanceIdentifier", value)

    @builtins.property
    @jsii.member(jsii_name="dbName")
    def db_name(self) -> typing.Optional[builtins.str]:
        '''The meaning of this parameter differs according to the database engine you use.

        .. epigraph::

           If you specify the ``[DBSnapshotIdentifier](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-database-instance.html#cfn-rds-dbinstance-dbsnapshotidentifier)`` property, this property only applies to RDS for Oracle.

        *Amazon Aurora*

        Not applicable. The database name is managed by the DB cluster.

        *MySQL*

        The name of the database to create when the DB instance is created. If this parameter is not specified, no database is created in the DB instance.

        Constraints:

        - Must contain 1 to 64 letters or numbers.
        - Can't be a word reserved by the specified database engine

        *MariaDB*

        The name of the database to create when the DB instance is created. If this parameter is not specified, no database is created in the DB instance.

        Constraints:

        - Must contain 1 to 64 letters or numbers.
        - Can't be a word reserved by the specified database engine

        *PostgreSQL*

        The name of the database to create when the DB instance is created. If this parameter is not specified, the default ``postgres`` database is created in the DB instance.

        Constraints:

        - Must begin with a letter. Subsequent characters can be letters, underscores, or digits (0-9).
        - Must contain 1 to 63 characters.
        - Can't be a word reserved by the specified database engine

        *Oracle*

        The Oracle System ID (SID) of the created DB instance. If you specify ``null`` , the default value ``ORCL`` is used. You can't specify the string NULL, or any other reserved word, for ``DBName`` .

        Default: ``ORCL``

        Constraints:

        - Can't be longer than 8 characters

        *SQL Server*

        Not applicable. Must be null.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-dbname
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "dbName"))

    @db_name.setter
    def db_name(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2cc610d1c9b1b8860675d310165f13be25673d303ac33e6da3a467f176d4ad94)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dbName", value)

    @builtins.property
    @jsii.member(jsii_name="dbParameterGroupName")
    def db_parameter_group_name(self) -> typing.Optional[builtins.str]:
        '''The name of an existing DB parameter group or a reference to an `AWS::RDS::DBParameterGroup <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbparametergroup.html>`_ resource created in the template.

        To list all of the available DB parameter group names, use the following command:

        ``aws rds describe-db-parameter-groups --query "DBParameterGroups[].DBParameterGroupName" --output text``
        .. epigraph::

           If any of the data members of the referenced parameter group are changed during an update, the DB instance might need to be restarted, which causes some interruption. If the parameter group contains static parameters, whether they were changed or not, an update triggers a reboot.

        If you don't specify a value for ``DBParameterGroupName`` property, the default DB parameter group for the specified engine and engine version is used.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-dbparametergroupname
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "dbParameterGroupName"))

    @db_parameter_group_name.setter
    def db_parameter_group_name(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5f8edd06a989361ace23482972419a964c44920872a4177465add6d3179f00d4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dbParameterGroupName", value)

    @builtins.property
    @jsii.member(jsii_name="dbSecurityGroups")
    def db_security_groups(self) -> typing.Optional[typing.List[builtins.str]]:
        '''A list of the DB security groups to assign to the DB instance.

        The list can include both the name of existing DB security groups or references to AWS::RDS::DBSecurityGroup resources created in the template.

        If you set DBSecurityGroups, you must not set VPCSecurityGroups, and vice versa. Also, note that the DBSecurityGroups property exists only for backwards compatibility with older regions and is no longer recommended for providing security information to an RDS DB instance. Instead, use VPCSecurityGroups.
        .. epigraph::

           If you specify this property, AWS CloudFormation sends only the following properties (if specified) to Amazon RDS during create operations:

           - ``AllocatedStorage``
           - ``AutoMinorVersionUpgrade``
           - ``AvailabilityZone``
           - ``BackupRetentionPeriod``
           - ``CharacterSetName``
           - ``DBInstanceClass``
           - ``DBName``
           - ``DBParameterGroupName``
           - ``DBSecurityGroups``
           - ``DBSubnetGroupName``
           - ``Engine``
           - ``EngineVersion``
           - ``Iops``
           - ``LicenseModel``
           - ``MasterUsername``
           - ``MasterUserPassword``
           - ``MultiAZ``
           - ``OptionGroupName``
           - ``PreferredBackupWindow``
           - ``PreferredMaintenanceWindow``

           All other properties are ignored. Specify a virtual private cloud (VPC) security group if you want to submit other properties, such as ``StorageType`` , ``StorageEncrypted`` , or ``KmsKeyId`` . If you're already using the ``DBSecurityGroups`` property, you can't use these other properties by updating your DB instance to use a VPC security group. You must recreate the DB instance.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-dbsecuritygroups
        '''
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "dbSecurityGroups"))

    @db_security_groups.setter
    def db_security_groups(
        self,
        value: typing.Optional[typing.List[builtins.str]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f1bdb9f09049929a348b5e80a4618176330c0f8e854d7255c8e21d6973060d7c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dbSecurityGroups", value)

    @builtins.property
    @jsii.member(jsii_name="dbSnapshotIdentifier")
    def db_snapshot_identifier(self) -> typing.Optional[builtins.str]:
        '''The name or Amazon Resource Name (ARN) of the DB snapshot that's used to restore the DB instance.

        If you're restoring from a shared manual DB snapshot, you must specify the ARN of the snapshot.

        By specifying this property, you can create a DB instance from the specified DB snapshot. If the ``DBSnapshotIdentifier`` property is an empty string or the ``AWS::RDS::DBInstance`` declaration has no ``DBSnapshotIdentifier`` property, AWS CloudFormation creates a new database. If the property contains a value (other than an empty string), AWS CloudFormation creates a database from the specified snapshot. If a snapshot with the specified name doesn't exist, AWS CloudFormation can't create the database and it rolls back the stack.

        Some DB instance properties aren't valid when you restore from a snapshot, such as the ``MasterUsername`` and ``MasterUserPassword`` properties. For information about the properties that you can specify, see the ``RestoreDBInstanceFromDBSnapshot`` action in the *Amazon RDS API Reference* .

        After you restore a DB instance with a ``DBSnapshotIdentifier`` property, you must specify the same ``DBSnapshotIdentifier`` property for any future updates to the DB instance. When you specify this property for an update, the DB instance is not restored from the DB snapshot again, and the data in the database is not changed. However, if you don't specify the ``DBSnapshotIdentifier`` property, an empty DB instance is created, and the original DB instance is deleted. If you specify a property that is different from the previous snapshot restore property, a new DB instance is restored from the specified ``DBSnapshotIdentifier`` property, and the original DB instance is deleted.

        If you specify the ``DBSnapshotIdentifier`` property to restore a DB instance (as opposed to specifying it for DB instance updates), then don't specify the following properties:

        - ``CharacterSetName``
        - ``DBClusterIdentifier``
        - ``DBName``
        - ``DeleteAutomatedBackups``
        - ``EnablePerformanceInsights``
        - ``KmsKeyId``
        - ``MasterUsername``
        - ``MasterUserPassword``
        - ``PerformanceInsightsKMSKeyId``
        - ``PerformanceInsightsRetentionPeriod``
        - ``PromotionTier``
        - ``SourceDBInstanceIdentifier``
        - ``SourceRegion``
        - ``StorageEncrypted`` (for an encrypted snapshot)
        - ``Timezone``

        *Amazon Aurora*

        Not applicable. Snapshot restore is managed by the DB cluster.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-dbsnapshotidentifier
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "dbSnapshotIdentifier"))

    @db_snapshot_identifier.setter
    def db_snapshot_identifier(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__76bdf9d6dbcea0d2b18f3af2cb8de634ce0588f9d475733a64dcce76172e3f1d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dbSnapshotIdentifier", value)

    @builtins.property
    @jsii.member(jsii_name="dbSubnetGroupName")
    def db_subnet_group_name(self) -> typing.Optional[builtins.str]:
        '''A DB subnet group to associate with the DB instance.

        If you update this value, the new subnet group must be a subnet group in a new VPC.

        If there's no DB subnet group, then the DB instance isn't a VPC DB instance.

        For more information about using Amazon RDS in a VPC, see `Using Amazon RDS with Amazon Virtual Private Cloud (VPC) <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_VPC.html>`_ in the *Amazon RDS User Guide* .

        *Amazon Aurora*

        Not applicable. The DB subnet group is managed by the DB cluster. If specified, the setting must match the DB cluster setting.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-dbsubnetgroupname
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "dbSubnetGroupName"))

    @db_subnet_group_name.setter
    def db_subnet_group_name(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9e2d5400d4d20d125a177eacfc5a8d3cd86f0dd695453ea6e769b140bb7e1d1e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dbSubnetGroupName", value)

    @builtins.property
    @jsii.member(jsii_name="deleteAutomatedBackups")
    def delete_automated_backups(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''A value that indicates whether to remove automated backups immediately after the DB instance is deleted.

        This parameter isn't case-sensitive. The default is to remove automated backups immediately after the DB instance is deleted.

        *Amazon Aurora*

        Not applicable. When you delete a DB cluster, all automated backups for that DB cluster are deleted and can't be recovered. Manual DB cluster snapshots of the DB cluster are not deleted.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-deleteautomatedbackups
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], jsii.get(self, "deleteAutomatedBackups"))

    @delete_automated_backups.setter
    def delete_automated_backups(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b70c9262f31c23b7f158d30e6dcaadca7b4798011225eb2ce38c45dc07212cbb)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "deleteAutomatedBackups", value)

    @builtins.property
    @jsii.member(jsii_name="deletionProtection")
    def deletion_protection(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''A value that indicates whether the DB instance has deletion protection enabled.

        The database can't be deleted when deletion protection is enabled. By default, deletion protection is disabled. For more information, see `Deleting a DB Instance <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_DeleteInstance.html>`_ .

        *Amazon Aurora*

        Not applicable. You can enable or disable deletion protection for the DB cluster. For more information, see ``CreateDBCluster`` . DB instances in a DB cluster can be deleted even when deletion protection is enabled for the DB cluster.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-deletionprotection
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], jsii.get(self, "deletionProtection"))

    @deletion_protection.setter
    def deletion_protection(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1b5cc0dbf9065b76eb8f6ae42592d603d3a43171eef8d122f03bd586ecfd37bc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "deletionProtection", value)

    @builtins.property
    @jsii.member(jsii_name="domain")
    def domain(self) -> typing.Optional[builtins.str]:
        '''The Active Directory directory ID to create the DB instance in.

        Currently, only Microsoft SQL Server, Oracle, and PostgreSQL DB instances can be created in an Active Directory Domain.

        For more information, see `Kerberos Authentication <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/kerberos-authentication.html>`_ in the *Amazon RDS User Guide* .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-domain
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "domain"))

    @domain.setter
    def domain(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d564f1d05f384e48e0c8e8469eebfa538bdd306ae5f999dde42b8e2ac0d8dceb)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "domain", value)

    @builtins.property
    @jsii.member(jsii_name="domainIamRoleName")
    def domain_iam_role_name(self) -> typing.Optional[builtins.str]:
        '''Specify the name of the IAM role to be used when making API calls to the Directory Service.

        This setting doesn't apply to RDS Custom.

        *Amazon Aurora*

        Not applicable. The domain is managed by the DB cluster.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-domainiamrolename
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "domainIamRoleName"))

    @domain_iam_role_name.setter
    def domain_iam_role_name(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d1a00150fe6f5d6fa506a35d981f3d1fc4b6d879c83c7637a050123ea12ba697)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "domainIamRoleName", value)

    @builtins.property
    @jsii.member(jsii_name="enableCloudwatchLogsExports")
    def enable_cloudwatch_logs_exports(
        self,
    ) -> typing.Optional[typing.List[builtins.str]]:
        '''The list of log types that need to be enabled for exporting to CloudWatch Logs.

        The values in the list depend on the DB engine being used. For more information, see `Publishing Database Logs to Amazon CloudWatch Logs <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_LogAccess.html#USER_LogAccess.Procedural.UploadtoCloudWatch>`_ in the *Amazon Relational Database Service User Guide* .

        *Amazon Aurora*

        Not applicable. CloudWatch Logs exports are managed by the DB cluster.

        *MariaDB*

        Valid values: ``audit`` , ``error`` , ``general`` , ``slowquery``

        *Microsoft SQL Server*

        Valid values: ``agent`` , ``error``

        *MySQL*

        Valid values: ``audit`` , ``error`` , ``general`` , ``slowquery``

        *Oracle*

        Valid values: ``alert`` , ``audit`` , ``listener`` , ``trace``

        *PostgreSQL*

        Valid values: ``postgresql`` , ``upgrade``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-enablecloudwatchlogsexports
        '''
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "enableCloudwatchLogsExports"))

    @enable_cloudwatch_logs_exports.setter
    def enable_cloudwatch_logs_exports(
        self,
        value: typing.Optional[typing.List[builtins.str]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f029ffd7857beec79c7f0542ed5d44b91650b9188821223d61ae68b343a51a2e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableCloudwatchLogsExports", value)

    @builtins.property
    @jsii.member(jsii_name="enableIamDatabaseAuthentication")
    def enable_iam_database_authentication(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''A value that indicates whether to enable mapping of AWS Identity and Access Management (IAM) accounts to database accounts.

        By default, mapping is disabled.

        This property is supported for RDS for MariaDB, RDS for MySQL, and RDS for PostgreSQL. For more information, see `IAM Database Authentication for MariaDB, MySQL, and PostgreSQL <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.IAMDBAuth.html>`_ in the *Amazon RDS User Guide.*

        *Amazon Aurora*

        Not applicable. Mapping AWS IAM accounts to database accounts is managed by the DB cluster.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-enableiamdatabaseauthentication
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], jsii.get(self, "enableIamDatabaseAuthentication"))

    @enable_iam_database_authentication.setter
    def enable_iam_database_authentication(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4c57eafe16db80f59e89d945a3e79d21bc2ffa64b996867b60ca8025a55ebce5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableIamDatabaseAuthentication", value)

    @builtins.property
    @jsii.member(jsii_name="enablePerformanceInsights")
    def enable_performance_insights(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''A value that indicates whether to enable Performance Insights for the DB instance.

        For more information, see `Using Amazon Performance Insights <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PerfInsights.html>`_ in the *Amazon RDS User Guide* .

        This setting doesn't apply to RDS Custom.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-enableperformanceinsights
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], jsii.get(self, "enablePerformanceInsights"))

    @enable_performance_insights.setter
    def enable_performance_insights(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c128a767782518434c97489d60918be935d47b6c681a1a283f9f125a49963a82)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enablePerformanceInsights", value)

    @builtins.property
    @jsii.member(jsii_name="endpoint")
    def endpoint(
        self,
    ) -> typing.Optional[typing.Union["CfnDBInstance.EndpointProperty", _IResolvable_a771d0ef]]:
        '''Specifies the connection endpoint.

        .. epigraph::

           The endpoint might not be shown for instances whose status is ``creating`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-endpoint
        '''
        return typing.cast(typing.Optional[typing.Union["CfnDBInstance.EndpointProperty", _IResolvable_a771d0ef]], jsii.get(self, "endpoint"))

    @endpoint.setter
    def endpoint(
        self,
        value: typing.Optional[typing.Union["CfnDBInstance.EndpointProperty", _IResolvable_a771d0ef]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__127b913ac7a8914ce02de2f07c698abe52e0c97758eaf0b0ae1f94d6be29b70c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "endpoint", value)

    @builtins.property
    @jsii.member(jsii_name="engine")
    def engine(self) -> typing.Optional[builtins.str]:
        '''The name of the database engine that you want to use for this DB instance.

        .. epigraph::

           When you are creating a DB instance, the ``Engine`` property is required.

        Valid Values:

        - ``aurora-mysql`` (for Aurora MySQL DB instances)
        - ``aurora-postgresql`` (for Aurora PostgreSQL DB instances)
        - ``custom-oracle-ee`` (for RDS Custom for Oracle DB instances)
        - ``custom-oracle-ee-cdb`` (for RDS Custom for Oracle DB instances)
        - ``custom-sqlserver-ee`` (for RDS Custom for SQL Server DB instances)
        - ``custom-sqlserver-se`` (for RDS Custom for SQL Server DB instances)
        - ``custom-sqlserver-web`` (for RDS Custom for SQL Server DB instances)
        - ``mariadb``
        - ``mysql``
        - ``oracle-ee``
        - ``oracle-ee-cdb``
        - ``oracle-se2``
        - ``oracle-se2-cdb``
        - ``postgres``
        - ``sqlserver-ee``
        - ``sqlserver-se``
        - ``sqlserver-ex``
        - ``sqlserver-web``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-engine
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "engine"))

    @engine.setter
    def engine(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ffb9a98966d575a19a1d108bd10d9fa5cc6a5ef4450fa29e0eb131b4bb1cf229)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "engine", value)

    @builtins.property
    @jsii.member(jsii_name="engineVersion")
    def engine_version(self) -> typing.Optional[builtins.str]:
        '''The version number of the database engine to use.

        For a list of valid engine versions, use the ``DescribeDBEngineVersions`` action.

        The following are the database engines and links to information about the major and minor versions that are available with Amazon RDS. Not every database engine is available for every AWS Region.

        *Amazon Aurora*

        Not applicable. The version number of the database engine to be used by the DB instance is managed by the DB cluster.

        *MariaDB*

        See `MariaDB on Amazon RDS Versions <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_MariaDB.html#MariaDB.Concepts.VersionMgmt>`_ in the *Amazon RDS User Guide.*

        *Microsoft SQL Server*

        See `Microsoft SQL Server Versions on Amazon RDS <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_SQLServer.html#SQLServer.Concepts.General.VersionSupport>`_ in the *Amazon RDS User Guide.*

        *MySQL*

        See `MySQL on Amazon RDS Versions <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_MySQL.html#MySQL.Concepts.VersionMgmt>`_ in the *Amazon RDS User Guide.*

        *Oracle*

        See `Oracle Database Engine Release Notes <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Appendix.Oracle.PatchComposition.html>`_ in the *Amazon RDS User Guide.*

        *PostgreSQL*

        See `Supported PostgreSQL Database Versions <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_PostgreSQL.html#PostgreSQL.Concepts.General.DBVersions>`_ in the *Amazon RDS User Guide.*

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-engineversion
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "engineVersion"))

    @engine_version.setter
    def engine_version(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4504039382292325cf77ba17393c302d43b6046a50fa4a7694f1e62d10258cfb)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "engineVersion", value)

    @builtins.property
    @jsii.member(jsii_name="iops")
    def iops(self) -> typing.Optional[jsii.Number]:
        '''The number of I/O operations per second (IOPS) that the database provisions.

        The value must be equal to or greater than 1000.

        If you specify this property, you must follow the range of allowed ratios of your requested IOPS rate to the amount of storage that you allocate (IOPS to allocated storage). For example, you can provision an Oracle database instance with 1000 IOPS and 200 GiB of storage (a ratio of 5:1), or specify 2000 IOPS with 200 GiB of storage (a ratio of 10:1). For more information, see `Amazon RDS Provisioned IOPS Storage to Improve Performance <https://docs.aws.amazon.com/AmazonRDS/latest/DeveloperGuide/CHAP_Storage.html#USER_PIOPS>`_ in the *Amazon RDS User Guide* .
        .. epigraph::

           If you specify ``io1`` for the ``StorageType`` property, then you must also specify the ``Iops`` property.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-iops
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "iops"))

    @iops.setter
    def iops(self, value: typing.Optional[jsii.Number]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9805183f9f5e0103023052807798679b700260e9a732565ecad63e8f02664c6c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "iops", value)

    @builtins.property
    @jsii.member(jsii_name="kmsKeyId")
    def kms_key_id(self) -> typing.Optional[builtins.str]:
        '''The ARN of the AWS KMS key that's used to encrypt the DB instance, such as ``arn:aws:kms:us-east-1:012345678910:key/abcd1234-a123-456a-a12b-a123b4cd56ef`` .

        If you enable the StorageEncrypted property but don't specify this property, AWS CloudFormation uses the default KMS key. If you specify this property, you must set the StorageEncrypted property to true.

        If you specify the ``SourceDBInstanceIdentifier`` property, the value is inherited from the source DB instance if the read replica is created in the same region.

        If you create an encrypted read replica in a different AWS Region, then you must specify a KMS key for the destination AWS Region. KMS encryption keys are specific to the region that they're created in, and you can't use encryption keys from one region in another region.

        If you specify the ``SnapshotIdentifier`` property, the ``StorageEncrypted`` property value is inherited from the snapshot, and if the DB instance is encrypted, the specified ``KmsKeyId`` property is used.

        If you specify ``DBSecurityGroups`` , AWS CloudFormation ignores this property. To specify both a security group and this property, you must use a VPC security group. For more information about Amazon RDS and VPC, see `Using Amazon RDS with Amazon VPC <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_VPC.html>`_ in the *Amazon RDS User Guide* .

        *Amazon Aurora*

        Not applicable. The KMS key identifier is managed by the DB cluster.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-kmskeyid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "kmsKeyId"))

    @kms_key_id.setter
    def kms_key_id(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__973c7ec44f61fa9a94e7fc35582c42ef927a1545f0140e3984e5b75cd3361853)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "kmsKeyId", value)

    @builtins.property
    @jsii.member(jsii_name="licenseModel")
    def license_model(self) -> typing.Optional[builtins.str]:
        '''License model information for this DB instance.

        Valid values:

        - Aurora MySQL - ``general-public-license``
        - Aurora PostgreSQL - ``postgresql-license``
        - MariaDB - ``general-public-license``
        - Microsoft SQL Server - ``license-included``
        - MySQL - ``general-public-license``
        - Oracle - ``bring-your-own-license`` or ``license-included``
        - PostgreSQL - ``postgresql-license``

        .. epigraph::

           If you've specified ``DBSecurityGroups`` and then you update the license model, AWS CloudFormation replaces the underlying DB instance. This will incur some interruptions to database availability.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-licensemodel
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "licenseModel"))

    @license_model.setter
    def license_model(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d4d0249030623e1c88b397921a64f718d8553a827ccce8e9c8d9f2fc06a1580e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "licenseModel", value)

    @builtins.property
    @jsii.member(jsii_name="manageMasterUserPassword")
    def manage_master_user_password(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''A value that indicates whether to manage the master user password with AWS Secrets Manager.

        For more information, see `Password management with AWS Secrets Manager <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-secrets-manager.html>`_ in the *Amazon RDS User Guide.*

        Constraints:

        - Can't manage the master user password with AWS Secrets Manager if ``MasterUserPassword`` is specified.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-managemasteruserpassword
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], jsii.get(self, "manageMasterUserPassword"))

    @manage_master_user_password.setter
    def manage_master_user_password(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3e9f03df1ec94c95325085eb832747858d56510196b933a87ce8b1f89f91180f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "manageMasterUserPassword", value)

    @builtins.property
    @jsii.member(jsii_name="masterUsername")
    def master_username(self) -> typing.Optional[builtins.str]:
        '''The master user name for the DB instance.

        .. epigraph::

           If you specify the ``SourceDBInstanceIdentifier`` or ``DBSnapshotIdentifier`` property, don't specify this property. The value is inherited from the source DB instance or snapshot.

        *Amazon Aurora*

        Not applicable. The name for the master user is managed by the DB cluster.

        *MariaDB*

        Constraints:

        - Required for MariaDB.
        - Must be 1 to 16 letters or numbers.
        - Can't be a reserved word for the chosen database engine.

        *Microsoft SQL Server*

        Constraints:

        - Required for SQL Server.
        - Must be 1 to 128 letters or numbers.
        - The first character must be a letter.
        - Can't be a reserved word for the chosen database engine.

        *MySQL*

        Constraints:

        - Required for MySQL.
        - Must be 1 to 16 letters or numbers.
        - First character must be a letter.
        - Can't be a reserved word for the chosen database engine.

        *Oracle*

        Constraints:

        - Required for Oracle.
        - Must be 1 to 30 letters or numbers.
        - First character must be a letter.
        - Can't be a reserved word for the chosen database engine.

        *PostgreSQL*

        Constraints:

        - Required for PostgreSQL.
        - Must be 1 to 63 letters or numbers.
        - First character must be a letter.
        - Can't be a reserved word for the chosen database engine.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-masterusername
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "masterUsername"))

    @master_username.setter
    def master_username(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__efdaa4cc868863dc09102c7f305d360a1cdc60d8f3fb9d20306d642b298a7a32)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "masterUsername", value)

    @builtins.property
    @jsii.member(jsii_name="masterUserPassword")
    def master_user_password(self) -> typing.Optional[builtins.str]:
        '''The password for the master user. The password can include any printable ASCII character except "/", """, or "@".

        *Amazon Aurora*

        Not applicable. The password for the master user is managed by the DB cluster.

        *MariaDB*

        Constraints: Must contain from 8 to 41 characters.

        *Microsoft SQL Server*

        Constraints: Must contain from 8 to 128 characters.

        *MySQL*

        Constraints: Must contain from 8 to 41 characters.

        *Oracle*

        Constraints: Must contain from 8 to 30 characters.

        *PostgreSQL*

        Constraints: Must contain from 8 to 128 characters.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-masteruserpassword
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "masterUserPassword"))

    @master_user_password.setter
    def master_user_password(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a522181a51c056c81cabd0d3d2ac9381b98d86f249ea450522d64477f4734dd7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "masterUserPassword", value)

    @builtins.property
    @jsii.member(jsii_name="masterUserSecret")
    def master_user_secret(
        self,
    ) -> typing.Optional[typing.Union["CfnDBInstance.MasterUserSecretProperty", _IResolvable_a771d0ef]]:
        '''Contains the secret managed by RDS in AWS Secrets Manager for the master user password.

        For more information, see `Password management with AWS Secrets Manager <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-secrets-manager.html>`_ in the *Amazon RDS User Guide.*

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-masterusersecret
        '''
        return typing.cast(typing.Optional[typing.Union["CfnDBInstance.MasterUserSecretProperty", _IResolvable_a771d0ef]], jsii.get(self, "masterUserSecret"))

    @master_user_secret.setter
    def master_user_secret(
        self,
        value: typing.Optional[typing.Union["CfnDBInstance.MasterUserSecretProperty", _IResolvable_a771d0ef]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7bd70e9588050997d0ffd351fbb3398e7efc5d56ec1fd71905b44c8f8735a691)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "masterUserSecret", value)

    @builtins.property
    @jsii.member(jsii_name="maxAllocatedStorage")
    def max_allocated_storage(self) -> typing.Optional[jsii.Number]:
        '''The upper limit in gibibytes (GiB) to which Amazon RDS can automatically scale the storage of the DB instance.

        For more information about this setting, including limitations that apply to it, see `Managing capacity automatically with Amazon RDS storage autoscaling <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PIOPS.StorageTypes.html#USER_PIOPS.Autoscaling>`_ in the *Amazon RDS User Guide* .

        This setting doesn't apply to RDS Custom.

        *Amazon Aurora*

        Not applicable. Storage is managed by the DB cluster.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-maxallocatedstorage
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "maxAllocatedStorage"))

    @max_allocated_storage.setter
    def max_allocated_storage(self, value: typing.Optional[jsii.Number]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b872061b1a35df5b0679f2dbc888d81ffe4cfff5aef35794f41757fd67213594)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "maxAllocatedStorage", value)

    @builtins.property
    @jsii.member(jsii_name="monitoringInterval")
    def monitoring_interval(self) -> typing.Optional[jsii.Number]:
        '''The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the DB instance.

        To disable collection of Enhanced Monitoring metrics, specify 0. The default is 0.

        If ``MonitoringRoleArn`` is specified, then you must set ``MonitoringInterval`` to a value other than 0.

        This setting doesn't apply to RDS Custom.

        Valid Values: ``0, 1, 5, 10, 15, 30, 60``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-monitoringinterval
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "monitoringInterval"))

    @monitoring_interval.setter
    def monitoring_interval(self, value: typing.Optional[jsii.Number]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__717ffb8ddd0de94d486eb5379bfead182533ff3e0bae50393797df5312bd278f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "monitoringInterval", value)

    @builtins.property
    @jsii.member(jsii_name="monitoringRoleArn")
    def monitoring_role_arn(self) -> typing.Optional[builtins.str]:
        '''The ARN for the IAM role that permits RDS to send enhanced monitoring metrics to Amazon CloudWatch Logs.

        For example, ``arn:aws:iam:123456789012:role/emaccess`` . For information on creating a monitoring role, see `Setting Up and Enabling Enhanced Monitoring <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Monitoring.OS.html#USER_Monitoring.OS.Enabling>`_ in the *Amazon RDS User Guide* .

        If ``MonitoringInterval`` is set to a value other than 0, then you must supply a ``MonitoringRoleArn`` value.

        This setting doesn't apply to RDS Custom.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-monitoringrolearn
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "monitoringRoleArn"))

    @monitoring_role_arn.setter
    def monitoring_role_arn(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__455aabd381bdbd84d6d43a77f45827e7be21b04f982f4916a727ddc16fecd025)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "monitoringRoleArn", value)

    @builtins.property
    @jsii.member(jsii_name="multiAz")
    def multi_az(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''Specifies whether the database instance is a Multi-AZ DB instance deployment.

        You can't set the ``AvailabilityZone`` parameter if the ``MultiAZ`` parameter is set to true.

        For more information, see `Multi-AZ deployments for high availability <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.MultiAZ.html>`_ in the *Amazon RDS User Guide* .

        *Amazon Aurora*

        Not applicable. Amazon Aurora storage is replicated across all of the Availability Zones and doesn't require the ``MultiAZ`` option to be set.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-multiaz
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], jsii.get(self, "multiAz"))

    @multi_az.setter
    def multi_az(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9b94d073818f9a2d23622b52e8632f6d4ae4ac0564a728fc40b93f8cbcb304f4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "multiAz", value)

    @builtins.property
    @jsii.member(jsii_name="ncharCharacterSetName")
    def nchar_character_set_name(self) -> typing.Optional[builtins.str]:
        '''The name of the NCHAR character set for the Oracle DB instance.

        This parameter doesn't apply to RDS Custom.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-ncharcharactersetname
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "ncharCharacterSetName"))

    @nchar_character_set_name.setter
    def nchar_character_set_name(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f9448042bf220c6e34749c5c09b98e2e6ed3c46d45952bdf795c42da9fa284fe)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "ncharCharacterSetName", value)

    @builtins.property
    @jsii.member(jsii_name="networkType")
    def network_type(self) -> typing.Optional[builtins.str]:
        '''The network type of the DB instance.

        Valid values:

        - ``IPV4``
        - ``DUAL``

        The network type is determined by the ``DBSubnetGroup`` specified for the DB instance. A ``DBSubnetGroup`` can support only the IPv4 protocol or the IPv4 and IPv6 protocols ( ``DUAL`` ).

        For more information, see `Working with a DB instance in a VPC <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_VPC.WorkingWithRDSInstanceinaVPC.html>`_ in the *Amazon RDS User Guide.*

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-networktype
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "networkType"))

    @network_type.setter
    def network_type(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ecc914b64ca8cfeacffc7b2276a9dcdc64e82a7a71bfce2e60c4712725e4e314)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "networkType", value)

    @builtins.property
    @jsii.member(jsii_name="optionGroupName")
    def option_group_name(self) -> typing.Optional[builtins.str]:
        '''Indicates that the DB instance should be associated with the specified option group.

        Permanent options, such as the TDE option for Oracle Advanced Security TDE, can't be removed from an option group. Also, that option group can't be removed from a DB instance once it is associated with a DB instance.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-optiongroupname
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "optionGroupName"))

    @option_group_name.setter
    def option_group_name(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__20d46636651d55f1dd3c1dbb72495f4d7ac078063a57cce60320ab8eaeda5af8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "optionGroupName", value)

    @builtins.property
    @jsii.member(jsii_name="performanceInsightsKmsKeyId")
    def performance_insights_kms_key_id(self) -> typing.Optional[builtins.str]:
        '''The AWS KMS key identifier for encryption of Performance Insights data.

        The KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key.

        If you do not specify a value for ``PerformanceInsightsKMSKeyId`` , then Amazon RDS uses your default KMS key. There is a default KMS key for your AWS account. Your AWS account has a different default KMS key for each AWS Region.

        For information about enabling Performance Insights, see `EnablePerformanceInsights <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-database-instance.html#cfn-rds-dbinstance-enableperformanceinsights>`_ .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-performanceinsightskmskeyid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "performanceInsightsKmsKeyId"))

    @performance_insights_kms_key_id.setter
    def performance_insights_kms_key_id(
        self,
        value: typing.Optional[builtins.str],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b4b1df9e801f40ad82c9538f0c471dbf5a1a8797368f4abdba3e1ee2d9936478)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "performanceInsightsKmsKeyId", value)

    @builtins.property
    @jsii.member(jsii_name="performanceInsightsRetentionPeriod")
    def performance_insights_retention_period(self) -> typing.Optional[jsii.Number]:
        '''The number of days to retain Performance Insights data. The default is 7 days. The following values are valid:.

        - 7
        - *month* * 31, where *month* is a number of months from 1-23
        - 731

        For example, the following values are valid:

        - 93 (3 months * 31)
        - 341 (11 months * 31)
        - 589 (19 months * 31)
        - 731

        If you specify a retention period such as 94, which isn't a valid value, RDS issues an error.

        This setting doesn't apply to RDS Custom.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-performanceinsightsretentionperiod
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "performanceInsightsRetentionPeriod"))

    @performance_insights_retention_period.setter
    def performance_insights_retention_period(
        self,
        value: typing.Optional[jsii.Number],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5ff7ad8621f6d2153a2d623f24fb253a38d009a37ab769ee7976ad81649e78b8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "performanceInsightsRetentionPeriod", value)

    @builtins.property
    @jsii.member(jsii_name="port")
    def port(self) -> typing.Optional[builtins.str]:
        '''The port number on which the database accepts connections.

        *Amazon Aurora*

        Not applicable. The port number is managed by the DB cluster.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-port
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "port"))

    @port.setter
    def port(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6e77911c19a49a842c5cbc5fa2a4157e5fe35666027020bad6b5a3a5511f508a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "port", value)

    @builtins.property
    @jsii.member(jsii_name="preferredBackupWindow")
    def preferred_backup_window(self) -> typing.Optional[builtins.str]:
        '''The daily time range during which automated backups are created if automated backups are enabled, using the ``BackupRetentionPeriod`` parameter.

        For more information, see `Backup Window <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithAutomatedBackups.html#USER_WorkingWithAutomatedBackups.BackupWindow>`_ in the *Amazon RDS User Guide.*

        Constraints:

        - Must be in the format ``hh24:mi-hh24:mi`` .
        - Must be in Universal Coordinated Time (UTC).
        - Must not conflict with the preferred maintenance window.
        - Must be at least 30 minutes.

        *Amazon Aurora*

        Not applicable. The daily time range for creating automated backups is managed by the DB cluster.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-preferredbackupwindow
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "preferredBackupWindow"))

    @preferred_backup_window.setter
    def preferred_backup_window(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__56ee09102bda13e49fec046d7f1924118906c8467a1840e41d7791f68cb4f6fb)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "preferredBackupWindow", value)

    @builtins.property
    @jsii.member(jsii_name="preferredMaintenanceWindow")
    def preferred_maintenance_window(self) -> typing.Optional[builtins.str]:
        '''The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC).

        Format: ``ddd:hh24:mi-ddd:hh24:mi``

        The default is a 30-minute window selected at random from an 8-hour block of time for each AWS Region, occurring on a random day of the week. To see the time blocks available, see `Adjusting the Preferred DB Instance Maintenance Window <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_UpgradeDBInstance.Maintenance.html#AdjustingTheMaintenanceWindow>`_ in the *Amazon RDS User Guide.*
        .. epigraph::

           This property applies when AWS CloudFormation initially creates the DB instance. If you use AWS CloudFormation to update the DB instance, those updates are applied immediately.

        Constraints: Minimum 30-minute window.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-preferredmaintenancewindow
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "preferredMaintenanceWindow"))

    @preferred_maintenance_window.setter
    def preferred_maintenance_window(
        self,
        value: typing.Optional[builtins.str],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1be30c0799236518ef5c6d039de824301aa753c338908bca66ca580a175a2eab)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "preferredMaintenanceWindow", value)

    @builtins.property
    @jsii.member(jsii_name="processorFeatures")
    def processor_features(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_a771d0ef, typing.List[typing.Union["CfnDBInstance.ProcessorFeatureProperty", _IResolvable_a771d0ef]]]]:
        '''The number of CPU cores and the number of threads per core for the DB instance class of the DB instance.

        This setting doesn't apply to RDS Custom.

        *Amazon Aurora*

        Not applicable.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-processorfeatures
        '''
        return typing.cast(typing.Optional[typing.Union[_IResolvable_a771d0ef, typing.List[typing.Union["CfnDBInstance.ProcessorFeatureProperty", _IResolvable_a771d0ef]]]], jsii.get(self, "processorFeatures"))

    @processor_features.setter
    def processor_features(
        self,
        value: typing.Optional[typing.Union[_IResolvable_a771d0ef, typing.List[typing.Union["CfnDBInstance.ProcessorFeatureProperty", _IResolvable_a771d0ef]]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__be2f039f6710ee121d3788f9c0d1db2ebbb91965b55f689e9e1138652f8d788d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "processorFeatures", value)

    @builtins.property
    @jsii.member(jsii_name="promotionTier")
    def promotion_tier(self) -> typing.Optional[jsii.Number]:
        '''A value that specifies the order in which an Aurora Replica is promoted to the primary instance after a failure of the existing primary instance.

        For more information, see `Fault Tolerance for an Aurora DB Cluster <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.Managing.Backups.html#Aurora.Managing.FaultTolerance>`_ in the *Amazon Aurora User Guide* .

        This setting doesn't apply to RDS Custom.

        Default: 1

        Valid Values: 0 - 15

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-promotiontier
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "promotionTier"))

    @promotion_tier.setter
    def promotion_tier(self, value: typing.Optional[jsii.Number]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ca47f2c7da4fb549a2af33e46ec25896736e9e4232b0ce5f946845d12f02e5db)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "promotionTier", value)

    @builtins.property
    @jsii.member(jsii_name="publiclyAccessible")
    def publicly_accessible(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''Indicates whether the DB instance is an internet-facing instance.

        If you specify true, AWS CloudFormation creates an instance with a publicly resolvable DNS name, which resolves to a public IP address. If you specify false, AWS CloudFormation creates an internal instance with a DNS name that resolves to a private IP address.

        The default behavior value depends on your VPC setup and the database subnet group. For more information, see the ``PubliclyAccessible`` parameter in the `CreateDBInstance <https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_CreateDBInstance.html>`_ in the *Amazon RDS API Reference* .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-publiclyaccessible
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], jsii.get(self, "publiclyAccessible"))

    @publicly_accessible.setter
    def publicly_accessible(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fffe54595977e414c09c13ae24c623caf2c4b8bed64b304ebcdb3eca7a4b78e4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "publiclyAccessible", value)

    @builtins.property
    @jsii.member(jsii_name="replicaMode")
    def replica_mode(self) -> typing.Optional[builtins.str]:
        '''The open mode of an Oracle read replica.

        For more information, see `Working with Oracle Read Replicas for Amazon RDS <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/oracle-read-replicas.html>`_ in the *Amazon RDS User Guide* .

        This setting is only supported in RDS for Oracle.

        Default: ``open-read-only``

        Valid Values: ``open-read-only`` or ``mounted``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-replicamode
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "replicaMode"))

    @replica_mode.setter
    def replica_mode(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__414e8fd38a6a70e2a47d5bb53520eef7288fd3a2d7ec1e08aaf4a68843b5b42a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "replicaMode", value)

    @builtins.property
    @jsii.member(jsii_name="restoreTime")
    def restore_time(self) -> typing.Optional[builtins.str]:
        '''The date and time to restore from.

        Valid Values: Value must be a time in Universal Coordinated Time (UTC) format

        Constraints:

        - Must be before the latest restorable time for the DB instance
        - Can't be specified if the ``UseLatestRestorableTime`` parameter is enabled

        Example: ``2009-09-07T23:45:00Z``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-restoretime
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "restoreTime"))

    @restore_time.setter
    def restore_time(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dcf1570561d817933fd802ffd98134ad609b566e0001158f385eb4188de74ad8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "restoreTime", value)

    @builtins.property
    @jsii.member(jsii_name="sourceDbClusterIdentifier")
    def source_db_cluster_identifier(self) -> typing.Optional[builtins.str]:
        '''The identifier of the Multi-AZ DB cluster that will act as the source for the read replica.

        Each DB cluster can have up to 15 read replicas.

        Constraints:

        - Must be the identifier of an existing Multi-AZ DB cluster.
        - Can't be specified if the ``SourceDBInstanceIdentifier`` parameter is also specified.
        - The specified DB cluster must have automatic backups enabled, that is, its backup retention period must be greater than 0.
        - The source DB cluster must be in the same AWS Region as the read replica. Cross-Region replication isn't supported.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-sourcedbclusteridentifier
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "sourceDbClusterIdentifier"))

    @source_db_cluster_identifier.setter
    def source_db_cluster_identifier(
        self,
        value: typing.Optional[builtins.str],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__146050eb5a20219727266ce1e0d8de2035ea0a7179138ee0a56903052736e225)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "sourceDbClusterIdentifier", value)

    @builtins.property
    @jsii.member(jsii_name="sourceDbInstanceAutomatedBackupsArn")
    def source_db_instance_automated_backups_arn(self) -> typing.Optional[builtins.str]:
        '''The Amazon Resource Name (ARN) of the replicated automated backups from which to restore, for example, ``arn:aws:rds:useast-1:123456789012:auto-backup:ab-L2IJCEXJP7XQ7HOJ4SIEXAMPLE`` .

        This setting doesn't apply to RDS Custom.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-sourcedbinstanceautomatedbackupsarn
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "sourceDbInstanceAutomatedBackupsArn"))

    @source_db_instance_automated_backups_arn.setter
    def source_db_instance_automated_backups_arn(
        self,
        value: typing.Optional[builtins.str],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3ba4c3ea04b55ba955fbea1252346bbe1eadb7aa3560d4791dbfcad7c1a43118)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "sourceDbInstanceAutomatedBackupsArn", value)

    @builtins.property
    @jsii.member(jsii_name="sourceDbInstanceIdentifier")
    def source_db_instance_identifier(self) -> typing.Optional[builtins.str]:
        '''If you want to create a read replica DB instance, specify the ID of the source DB instance.

        Each DB instance can have a limited number of read replicas. For more information, see `Working with Read Replicas <https://docs.aws.amazon.com/AmazonRDS/latest/DeveloperGuide/USER_ReadRepl.html>`_ in the *Amazon RDS User Guide* .

        For information about constraints that apply to DB instance identifiers, see `Naming constraints in Amazon RDS <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Limits.html#RDS_Limits.Constraints>`_ in the *Amazon RDS User Guide* .

        The ``SourceDBInstanceIdentifier`` property determines whether a DB instance is a read replica. If you remove the ``SourceDBInstanceIdentifier`` property from your template and then update your stack, AWS CloudFormation promotes the Read Replica to a standalone DB instance.
        .. epigraph::

           - If you specify a source DB instance that uses VPC security groups, we recommend that you specify the ``VPCSecurityGroups`` property. If you don't specify the property, the read replica inherits the value of the ``VPCSecurityGroups`` property from the source DB when you create the replica. However, if you update the stack, AWS CloudFormation reverts the replica's ``VPCSecurityGroups`` property to the default value because it's not defined in the stack's template. This change might cause unexpected issues.
           - Read replicas don't support deletion policies. AWS CloudFormation ignores any deletion policy that's associated with a read replica.
           - If you specify ``SourceDBInstanceIdentifier`` , don't specify the ``DBSnapshotIdentifier`` property. You can't create a read replica from a snapshot.
           - Don't set the ``BackupRetentionPeriod`` , ``DBName`` , ``MasterUsername`` , ``MasterUserPassword`` , and ``PreferredBackupWindow`` properties. The database attributes are inherited from the source DB instance, and backups are disabled for read replicas.
           - If the source DB instance is in a different region than the read replica, specify the source region in ``SourceRegion`` , and specify an ARN for a valid DB instance in ``SourceDBInstanceIdentifier`` . For more information, see `Constructing a Amazon RDS Amazon Resource Name (ARN) <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html#USER_Tagging.ARN>`_ in the *Amazon RDS User Guide* .
           - For DB instances in Amazon Aurora clusters, don't specify this property. Amazon RDS automatically assigns writer and reader DB instances.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-sourcedbinstanceidentifier
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "sourceDbInstanceIdentifier"))

    @source_db_instance_identifier.setter
    def source_db_instance_identifier(
        self,
        value: typing.Optional[builtins.str],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7ee8dbbf7bf17ec5768d5f178c2cbbd5b01dd00a956d4ef34fd5380ea204fb28)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "sourceDbInstanceIdentifier", value)

    @builtins.property
    @jsii.member(jsii_name="sourceDbiResourceId")
    def source_dbi_resource_id(self) -> typing.Optional[builtins.str]:
        '''The resource ID of the source DB instance from which to restore.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-sourcedbiresourceid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "sourceDbiResourceId"))

    @source_dbi_resource_id.setter
    def source_dbi_resource_id(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ae6b0b64230466c68662663146964977b55e0736a8468aa1af070f966eae6af3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "sourceDbiResourceId", value)

    @builtins.property
    @jsii.member(jsii_name="sourceRegion")
    def source_region(self) -> typing.Optional[builtins.str]:
        '''The ID of the region that contains the source DB instance for the read replica.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-sourceregion
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "sourceRegion"))

    @source_region.setter
    def source_region(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e5dc487b92e71ad98a01c35fb315e0612b5e20ebf104ea8decdeadd5b4c6d13f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "sourceRegion", value)

    @builtins.property
    @jsii.member(jsii_name="storageEncrypted")
    def storage_encrypted(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''A value that indicates whether the DB instance is encrypted. By default, it isn't encrypted.

        If you specify the ``KmsKeyId`` property, then you must enable encryption.

        If you specify the ``SourceDBInstanceIdentifier`` property, don't specify this property. The value is inherited from the source DB instance, and if the DB instance is encrypted, the specified ``KmsKeyId`` property is used.

        If you specify the ``SnapshotIdentifier`` and the specified snapshot is encrypted, don't specify this property. The value is inherited from the snapshot, and the specified ``KmsKeyId`` property is used.

        If you specify the ``SnapshotIdentifier`` and the specified snapshot isn't encrypted, you can use this property to specify that the restored DB instance is encrypted. Specify the ``KmsKeyId`` property for the KMS key to use for encryption. If you don't want the restored DB instance to be encrypted, then don't set this property or set it to ``false`` .

        *Amazon Aurora*

        Not applicable. The encryption for DB instances is managed by the DB cluster.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-storageencrypted
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], jsii.get(self, "storageEncrypted"))

    @storage_encrypted.setter
    def storage_encrypted(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__002a3e5ce8b8f5cd07b2c4ff71b882c2f7438c00d511e6b88f5735acc18ff367)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "storageEncrypted", value)

    @builtins.property
    @jsii.member(jsii_name="storageThroughput")
    def storage_throughput(self) -> typing.Optional[jsii.Number]:
        '''Specifies the storage throughput value for the DB instance. This setting applies only to the ``gp3`` storage type.

        This setting doesn't apply to RDS Custom or Amazon Aurora.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-storagethroughput
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "storageThroughput"))

    @storage_throughput.setter
    def storage_throughput(self, value: typing.Optional[jsii.Number]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b59c7ed22fae8e242d3c3c1c52f17eb7d5100eba9664aad31abea30a157a4ff8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "storageThroughput", value)

    @builtins.property
    @jsii.member(jsii_name="storageType")
    def storage_type(self) -> typing.Optional[builtins.str]:
        '''Specifies the storage type to be associated with the DB instance.

        Valid values: ``gp2 | gp3 | io1 | standard``

        The ``standard`` value is also known as magnetic.

        If you specify ``io1`` or ``gp3`` , you must also include a value for the ``Iops`` parameter.

        Default: ``io1`` if the ``Iops`` parameter is specified, otherwise ``gp2``

        For more information, see `Amazon RDS DB Instance Storage <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Storage.html>`_ in the *Amazon RDS User Guide* .

        *Amazon Aurora*

        Not applicable. Aurora data is stored in the cluster volume, which is a single, virtual volume that uses solid state drives (SSDs).

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-storagetype
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "storageType"))

    @storage_type.setter
    def storage_type(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7349846e2c1121d7f11b6d513f8041fb18d4ae3baca10cd96f2ac2e4ccce9c37)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "storageType", value)

    @builtins.property
    @jsii.member(jsii_name="timezone")
    def timezone(self) -> typing.Optional[builtins.str]:
        '''The time zone of the DB instance.

        The time zone parameter is currently supported only by `Microsoft SQL Server <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_SQLServer.html#SQLServer.Concepts.General.TimeZone>`_ .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-timezone
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "timezone"))

    @timezone.setter
    def timezone(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4331fdf05ef3e743bcd2975717144e4dd2fd426f0e88e4f63118d5106191f2c7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "timezone", value)

    @builtins.property
    @jsii.member(jsii_name="useDefaultProcessorFeatures")
    def use_default_processor_features(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''A value that indicates whether the DB instance class of the DB instance uses its default processor features.

        This setting doesn't apply to RDS Custom.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-usedefaultprocessorfeatures
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], jsii.get(self, "useDefaultProcessorFeatures"))

    @use_default_processor_features.setter
    def use_default_processor_features(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4affe4310a88cb92253e261bd1cc76d7835a67968198a9dfd02011bfca0068c4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "useDefaultProcessorFeatures", value)

    @builtins.property
    @jsii.member(jsii_name="useLatestRestorableTime")
    def use_latest_restorable_time(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''A value that indicates whether the DB instance is restored from the latest backup time.

        By default, the DB instance isn't restored from the latest backup time.

        Constraints: Can't be specified if the ``RestoreTime`` parameter is provided.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-uselatestrestorabletime
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], jsii.get(self, "useLatestRestorableTime"))

    @use_latest_restorable_time.setter
    def use_latest_restorable_time(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__faa00e8e0239c97f283b46e94dc1a0fff45b34d48afab929f6276e6f006e3dff)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "useLatestRestorableTime", value)

    @builtins.property
    @jsii.member(jsii_name="vpcSecurityGroups")
    def vpc_security_groups(self) -> typing.Optional[typing.List[builtins.str]]:
        '''A list of the VPC security group IDs to assign to the DB instance.

        The list can include both the physical IDs of existing VPC security groups and references to `AWS::EC2::SecurityGroup <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group.html>`_ resources created in the template.

        If you plan to update the resource, don't specify VPC security groups in a shared VPC.

        If you set ``VPCSecurityGroups`` , you must not set ```DBSecurityGroups`` <https://docs.aws.amazon.com//AWSCloudFormation/latest/UserGuide/aws-properties-rds-database-instance.html#cfn-rds-dbinstance-dbsecuritygroups>`_ , and vice versa.
        .. epigraph::

           You can migrate a DB instance in your stack from an RDS DB security group to a VPC security group, but keep the following in mind:

           - You can't revert to using an RDS security group after you establish a VPC security group membership.
           - When you migrate your DB instance to VPC security groups, if your stack update rolls back because the DB instance update fails or because an update fails in another AWS CloudFormation resource, the rollback fails because it can't revert to an RDS security group.
           - To use the properties that are available when you use a VPC security group, you must recreate the DB instance. If you don't, AWS CloudFormation submits only the property values that are listed in the ```DBSecurityGroups`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-database-instance.html#cfn-rds-dbinstance-dbsecuritygroups>`_ property.

        To avoid this situation, migrate your DB instance to using VPC security groups only when that is the only change in your stack template.

        *Amazon Aurora*

        Not applicable. The associated list of EC2 VPC security groups is managed by the DB cluster. If specified, the setting must match the DB cluster setting.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-vpcsecuritygroups
        '''
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "vpcSecurityGroups"))

    @vpc_security_groups.setter
    def vpc_security_groups(
        self,
        value: typing.Optional[typing.List[builtins.str]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__232e6bb7671760c1e77aed5f275375029efdde6e133f00e5ab39ab6e0f86debf)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "vpcSecurityGroups", value)

    @jsii.data_type(
        jsii_type="monocdk.aws_rds.CfnDBInstance.CertificateDetailsProperty",
        jsii_struct_bases=[],
        name_mapping={"ca_identifier": "caIdentifier", "valid_till": "validTill"},
    )
    class CertificateDetailsProperty:
        def __init__(
            self,
            *,
            ca_identifier: typing.Optional[builtins.str] = None,
            valid_till: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Returns the details of the DB instances server certificate.

            For more information, see `Using SSL/TLS to encrypt a connection to a DB instance <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.SSL.html>`_ in the *Amazon RDS User Guide* and `Using SSL/TLS to encrypt a connection to a DB cluster <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/UsingWithRDS.SSL.html>`_ in the *Amazon Aurora User Guide* .

            :param ca_identifier: The CA identifier of the CA certificate used for the DB instance's server certificate.
            :param valid_till: The expiration date of the DB instances server certificate.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbinstance-certificatedetails.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from monocdk import aws_rds as rds
                
                certificate_details_property = rds.CfnDBInstance.CertificateDetailsProperty(
                    ca_identifier="caIdentifier",
                    valid_till="validTill"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__bead06731748842ac4fca1ed916eb6f10016926222b8e26fa14ba6a32da86775)
                check_type(argname="argument ca_identifier", value=ca_identifier, expected_type=type_hints["ca_identifier"])
                check_type(argname="argument valid_till", value=valid_till, expected_type=type_hints["valid_till"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if ca_identifier is not None:
                self._values["ca_identifier"] = ca_identifier
            if valid_till is not None:
                self._values["valid_till"] = valid_till

        @builtins.property
        def ca_identifier(self) -> typing.Optional[builtins.str]:
            '''The CA identifier of the CA certificate used for the DB instance's server certificate.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbinstance-certificatedetails.html#cfn-rds-dbinstance-certificatedetails-caidentifier
            '''
            result = self._values.get("ca_identifier")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def valid_till(self) -> typing.Optional[builtins.str]:
            '''The expiration date of the DB instances server certificate.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbinstance-certificatedetails.html#cfn-rds-dbinstance-certificatedetails-validtill
            '''
            result = self._values.get("valid_till")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "CertificateDetailsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="monocdk.aws_rds.CfnDBInstance.DBInstanceRoleProperty",
        jsii_struct_bases=[],
        name_mapping={"feature_name": "featureName", "role_arn": "roleArn"},
    )
    class DBInstanceRoleProperty:
        def __init__(
            self,
            *,
            feature_name: builtins.str,
            role_arn: builtins.str,
        ) -> None:
            '''Describes an AWS Identity and Access Management (IAM) role that is associated with a DB instance.

            :param feature_name: The name of the feature associated with the AWS Identity and Access Management (IAM) role. IAM roles that are associated with a DB instance grant permission for the DB instance to access other AWS services on your behalf. For the list of supported feature names, see the ``SupportedFeatureNames`` description in `DBEngineVersion <https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_DBEngineVersion.html>`_ in the *Amazon RDS API Reference* .
            :param role_arn: The Amazon Resource Name (ARN) of the IAM role that is associated with the DB instance.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbinstance-dbinstancerole.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from monocdk import aws_rds as rds
                
                d_bInstance_role_property = rds.CfnDBInstance.DBInstanceRoleProperty(
                    feature_name="featureName",
                    role_arn="roleArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__1c7f2a8f46a824e6360eedb79a668893026d65dbd8bf3df7319cc1460320ac08)
                check_type(argname="argument feature_name", value=feature_name, expected_type=type_hints["feature_name"])
                check_type(argname="argument role_arn", value=role_arn, expected_type=type_hints["role_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "feature_name": feature_name,
                "role_arn": role_arn,
            }

        @builtins.property
        def feature_name(self) -> builtins.str:
            '''The name of the feature associated with the AWS Identity and Access Management (IAM) role.

            IAM roles that are associated with a DB instance grant permission for the DB instance to access other AWS services on your behalf. For the list of supported feature names, see the ``SupportedFeatureNames`` description in `DBEngineVersion <https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_DBEngineVersion.html>`_ in the *Amazon RDS API Reference* .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbinstance-dbinstancerole.html#cfn-rds-dbinstance-dbinstancerole-featurename
            '''
            result = self._values.get("feature_name")
            assert result is not None, "Required property 'feature_name' is missing"
            return typing.cast(builtins.str, result)

        @builtins.property
        def role_arn(self) -> builtins.str:
            '''The Amazon Resource Name (ARN) of the IAM role that is associated with the DB instance.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbinstance-dbinstancerole.html#cfn-rds-dbinstance-dbinstancerole-rolearn
            '''
            result = self._values.get("role_arn")
            assert result is not None, "Required property 'role_arn' is missing"
            return typing.cast(builtins.str, result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "DBInstanceRoleProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="monocdk.aws_rds.CfnDBInstance.EndpointProperty",
        jsii_struct_bases=[],
        name_mapping={
            "address": "address",
            "hosted_zone_id": "hostedZoneId",
            "port": "port",
        },
    )
    class EndpointProperty:
        def __init__(
            self,
            *,
            address: typing.Optional[builtins.str] = None,
            hosted_zone_id: typing.Optional[builtins.str] = None,
            port: typing.Optional[builtins.str] = None,
        ) -> None:
            '''This data type represents the information you need to connect to an Amazon RDS DB instance.

            This data type is used as a response element in the following actions:

            - ``CreateDBInstance``
            - ``DescribeDBInstances``
            - ``DeleteDBInstance``

            For the data structure that represents Amazon Aurora DB cluster endpoints, see ``DBClusterEndpoint`` .

            :param address: Specifies the DNS address of the DB instance.
            :param hosted_zone_id: Specifies the ID that Amazon Route 53 assigns when you create a hosted zone.
            :param port: Specifies the port that the database engine is listening on.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbinstance-endpoint.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from monocdk import aws_rds as rds
                
                endpoint_property = rds.CfnDBInstance.EndpointProperty(
                    address="address",
                    hosted_zone_id="hostedZoneId",
                    port="port"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__f194a7b42653c68c1ce135d700efbb0703b58da0eae55325c5fe286dc8e8668b)
                check_type(argname="argument address", value=address, expected_type=type_hints["address"])
                check_type(argname="argument hosted_zone_id", value=hosted_zone_id, expected_type=type_hints["hosted_zone_id"])
                check_type(argname="argument port", value=port, expected_type=type_hints["port"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if address is not None:
                self._values["address"] = address
            if hosted_zone_id is not None:
                self._values["hosted_zone_id"] = hosted_zone_id
            if port is not None:
                self._values["port"] = port

        @builtins.property
        def address(self) -> typing.Optional[builtins.str]:
            '''Specifies the DNS address of the DB instance.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbinstance-endpoint.html#cfn-rds-dbinstance-endpoint-address
            '''
            result = self._values.get("address")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def hosted_zone_id(self) -> typing.Optional[builtins.str]:
            '''Specifies the ID that Amazon Route 53 assigns when you create a hosted zone.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbinstance-endpoint.html#cfn-rds-dbinstance-endpoint-hostedzoneid
            '''
            result = self._values.get("hosted_zone_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def port(self) -> typing.Optional[builtins.str]:
            '''Specifies the port that the database engine is listening on.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbinstance-endpoint.html#cfn-rds-dbinstance-endpoint-port
            '''
            result = self._values.get("port")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "EndpointProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="monocdk.aws_rds.CfnDBInstance.MasterUserSecretProperty",
        jsii_struct_bases=[],
        name_mapping={"kms_key_id": "kmsKeyId", "secret_arn": "secretArn"},
    )
    class MasterUserSecretProperty:
        def __init__(
            self,
            *,
            kms_key_id: typing.Optional[builtins.str] = None,
            secret_arn: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The ``MasterUserSecret`` return value specifies the secret managed by RDS in AWS Secrets Manager for the master user password.

            For more information, see `Password management with AWS Secrets Manager <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-secrets-manager.html>`_ in the *Amazon RDS User Guide* and `Password management with AWS Secrets Manager <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/rds-secrets-manager.html>`_ in the *Amazon Aurora User Guide.*

            :param kms_key_id: The AWS KMS key identifier that is used to encrypt the secret.
            :param secret_arn: The Amazon Resource Name (ARN) of the secret.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbinstance-masterusersecret.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from monocdk import aws_rds as rds
                
                master_user_secret_property = rds.CfnDBInstance.MasterUserSecretProperty(
                    kms_key_id="kmsKeyId",
                    secret_arn="secretArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__bb851cdf1d49b20e936f0b6c311bb23e7ceb584d928276da89ea9d94203ce69b)
                check_type(argname="argument kms_key_id", value=kms_key_id, expected_type=type_hints["kms_key_id"])
                check_type(argname="argument secret_arn", value=secret_arn, expected_type=type_hints["secret_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if kms_key_id is not None:
                self._values["kms_key_id"] = kms_key_id
            if secret_arn is not None:
                self._values["secret_arn"] = secret_arn

        @builtins.property
        def kms_key_id(self) -> typing.Optional[builtins.str]:
            '''The AWS KMS key identifier that is used to encrypt the secret.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbinstance-masterusersecret.html#cfn-rds-dbinstance-masterusersecret-kmskeyid
            '''
            result = self._values.get("kms_key_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def secret_arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the secret.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbinstance-masterusersecret.html#cfn-rds-dbinstance-masterusersecret-secretarn
            '''
            result = self._values.get("secret_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "MasterUserSecretProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="monocdk.aws_rds.CfnDBInstance.ProcessorFeatureProperty",
        jsii_struct_bases=[],
        name_mapping={"name": "name", "value": "value"},
    )
    class ProcessorFeatureProperty:
        def __init__(
            self,
            *,
            name: typing.Optional[builtins.str] = None,
            value: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The ``ProcessorFeature`` property type specifies the processor features of a DB instance class status.

            :param name: The name of the processor feature. Valid names are ``coreCount`` and ``threadsPerCore`` .
            :param value: The value of a processor feature name.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbinstance-processorfeature.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from monocdk import aws_rds as rds
                
                processor_feature_property = rds.CfnDBInstance.ProcessorFeatureProperty(
                    name="name",
                    value="value"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__d3e5fa5a0cac4ac24f527c5fceb1e70de8aabfa0ab1b67d11510cbea792a63de)
                check_type(argname="argument name", value=name, expected_type=type_hints["name"])
                check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if name is not None:
                self._values["name"] = name
            if value is not None:
                self._values["value"] = value

        @builtins.property
        def name(self) -> typing.Optional[builtins.str]:
            '''The name of the processor feature.

            Valid names are ``coreCount`` and ``threadsPerCore`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbinstance-processorfeature.html#cfn-rds-dbinstance-processorfeature-name
            '''
            result = self._values.get("name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def value(self) -> typing.Optional[builtins.str]:
            '''The value of a processor feature name.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbinstance-processorfeature.html#cfn-rds-dbinstance-processorfeature-value
            '''
            result = self._values.get("value")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ProcessorFeatureProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="monocdk.aws_rds.CfnDBInstanceProps",
    jsii_struct_bases=[],
    name_mapping={
        "allocated_storage": "allocatedStorage",
        "allow_major_version_upgrade": "allowMajorVersionUpgrade",
        "associated_roles": "associatedRoles",
        "auto_minor_version_upgrade": "autoMinorVersionUpgrade",
        "availability_zone": "availabilityZone",
        "backup_retention_period": "backupRetentionPeriod",
        "ca_certificate_identifier": "caCertificateIdentifier",
        "certificate_details": "certificateDetails",
        "certificate_rotation_restart": "certificateRotationRestart",
        "character_set_name": "characterSetName",
        "copy_tags_to_snapshot": "copyTagsToSnapshot",
        "custom_iam_instance_profile": "customIamInstanceProfile",
        "db_cluster_identifier": "dbClusterIdentifier",
        "db_cluster_snapshot_identifier": "dbClusterSnapshotIdentifier",
        "db_instance_class": "dbInstanceClass",
        "db_instance_identifier": "dbInstanceIdentifier",
        "db_name": "dbName",
        "db_parameter_group_name": "dbParameterGroupName",
        "db_security_groups": "dbSecurityGroups",
        "db_snapshot_identifier": "dbSnapshotIdentifier",
        "db_subnet_group_name": "dbSubnetGroupName",
        "delete_automated_backups": "deleteAutomatedBackups",
        "deletion_protection": "deletionProtection",
        "domain": "domain",
        "domain_iam_role_name": "domainIamRoleName",
        "enable_cloudwatch_logs_exports": "enableCloudwatchLogsExports",
        "enable_iam_database_authentication": "enableIamDatabaseAuthentication",
        "enable_performance_insights": "enablePerformanceInsights",
        "endpoint": "endpoint",
        "engine": "engine",
        "engine_version": "engineVersion",
        "iops": "iops",
        "kms_key_id": "kmsKeyId",
        "license_model": "licenseModel",
        "manage_master_user_password": "manageMasterUserPassword",
        "master_username": "masterUsername",
        "master_user_password": "masterUserPassword",
        "master_user_secret": "masterUserSecret",
        "max_allocated_storage": "maxAllocatedStorage",
        "monitoring_interval": "monitoringInterval",
        "monitoring_role_arn": "monitoringRoleArn",
        "multi_az": "multiAz",
        "nchar_character_set_name": "ncharCharacterSetName",
        "network_type": "networkType",
        "option_group_name": "optionGroupName",
        "performance_insights_kms_key_id": "performanceInsightsKmsKeyId",
        "performance_insights_retention_period": "performanceInsightsRetentionPeriod",
        "port": "port",
        "preferred_backup_window": "preferredBackupWindow",
        "preferred_maintenance_window": "preferredMaintenanceWindow",
        "processor_features": "processorFeatures",
        "promotion_tier": "promotionTier",
        "publicly_accessible": "publiclyAccessible",
        "replica_mode": "replicaMode",
        "restore_time": "restoreTime",
        "source_db_cluster_identifier": "sourceDbClusterIdentifier",
        "source_db_instance_automated_backups_arn": "sourceDbInstanceAutomatedBackupsArn",
        "source_db_instance_identifier": "sourceDbInstanceIdentifier",
        "source_dbi_resource_id": "sourceDbiResourceId",
        "source_region": "sourceRegion",
        "storage_encrypted": "storageEncrypted",
        "storage_throughput": "storageThroughput",
        "storage_type": "storageType",
        "tags": "tags",
        "timezone": "timezone",
        "use_default_processor_features": "useDefaultProcessorFeatures",
        "use_latest_restorable_time": "useLatestRestorableTime",
        "vpc_security_groups": "vpcSecurityGroups",
    },
)
class CfnDBInstanceProps:
    def __init__(
        self,
        *,
        allocated_storage: typing.Optional[builtins.str] = None,
        allow_major_version_upgrade: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        associated_roles: typing.Optional[typing.Union[_IResolvable_a771d0ef, typing.Sequence[typing.Union[typing.Union[CfnDBInstance.DBInstanceRoleProperty, typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]]]] = None,
        auto_minor_version_upgrade: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        availability_zone: typing.Optional[builtins.str] = None,
        backup_retention_period: typing.Optional[jsii.Number] = None,
        ca_certificate_identifier: typing.Optional[builtins.str] = None,
        certificate_details: typing.Optional[typing.Union[typing.Union[CfnDBInstance.CertificateDetailsProperty, typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]] = None,
        certificate_rotation_restart: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        character_set_name: typing.Optional[builtins.str] = None,
        copy_tags_to_snapshot: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        custom_iam_instance_profile: typing.Optional[builtins.str] = None,
        db_cluster_identifier: typing.Optional[builtins.str] = None,
        db_cluster_snapshot_identifier: typing.Optional[builtins.str] = None,
        db_instance_class: typing.Optional[builtins.str] = None,
        db_instance_identifier: typing.Optional[builtins.str] = None,
        db_name: typing.Optional[builtins.str] = None,
        db_parameter_group_name: typing.Optional[builtins.str] = None,
        db_security_groups: typing.Optional[typing.Sequence[builtins.str]] = None,
        db_snapshot_identifier: typing.Optional[builtins.str] = None,
        db_subnet_group_name: typing.Optional[builtins.str] = None,
        delete_automated_backups: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        deletion_protection: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        domain: typing.Optional[builtins.str] = None,
        domain_iam_role_name: typing.Optional[builtins.str] = None,
        enable_cloudwatch_logs_exports: typing.Optional[typing.Sequence[builtins.str]] = None,
        enable_iam_database_authentication: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        enable_performance_insights: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        endpoint: typing.Optional[typing.Union[typing.Union[CfnDBInstance.EndpointProperty, typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]] = None,
        engine: typing.Optional[builtins.str] = None,
        engine_version: typing.Optional[builtins.str] = None,
        iops: typing.Optional[jsii.Number] = None,
        kms_key_id: typing.Optional[builtins.str] = None,
        license_model: typing.Optional[builtins.str] = None,
        manage_master_user_password: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        master_username: typing.Optional[builtins.str] = None,
        master_user_password: typing.Optional[builtins.str] = None,
        master_user_secret: typing.Optional[typing.Union[typing.Union[CfnDBInstance.MasterUserSecretProperty, typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]] = None,
        max_allocated_storage: typing.Optional[jsii.Number] = None,
        monitoring_interval: typing.Optional[jsii.Number] = None,
        monitoring_role_arn: typing.Optional[builtins.str] = None,
        multi_az: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        nchar_character_set_name: typing.Optional[builtins.str] = None,
        network_type: typing.Optional[builtins.str] = None,
        option_group_name: typing.Optional[builtins.str] = None,
        performance_insights_kms_key_id: typing.Optional[builtins.str] = None,
        performance_insights_retention_period: typing.Optional[jsii.Number] = None,
        port: typing.Optional[builtins.str] = None,
        preferred_backup_window: typing.Optional[builtins.str] = None,
        preferred_maintenance_window: typing.Optional[builtins.str] = None,
        processor_features: typing.Optional[typing.Union[_IResolvable_a771d0ef, typing.Sequence[typing.Union[typing.Union[CfnDBInstance.ProcessorFeatureProperty, typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]]]] = None,
        promotion_tier: typing.Optional[jsii.Number] = None,
        publicly_accessible: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        replica_mode: typing.Optional[builtins.str] = None,
        restore_time: typing.Optional[builtins.str] = None,
        source_db_cluster_identifier: typing.Optional[builtins.str] = None,
        source_db_instance_automated_backups_arn: typing.Optional[builtins.str] = None,
        source_db_instance_identifier: typing.Optional[builtins.str] = None,
        source_dbi_resource_id: typing.Optional[builtins.str] = None,
        source_region: typing.Optional[builtins.str] = None,
        storage_encrypted: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        storage_throughput: typing.Optional[jsii.Number] = None,
        storage_type: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union[_CfnTag_95fbdc29, typing.Dict[builtins.str, typing.Any]]]] = None,
        timezone: typing.Optional[builtins.str] = None,
        use_default_processor_features: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        use_latest_restorable_time: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        vpc_security_groups: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''Properties for defining a ``CfnDBInstance``.

        :param allocated_storage: The amount of storage in gibibytes (GiB) to be initially allocated for the database instance. .. epigraph:: If any value is set in the ``Iops`` parameter, ``AllocatedStorage`` must be at least 100 GiB, which corresponds to the minimum Iops value of 1,000. If you increase the ``Iops`` value (in 1,000 IOPS increments), then you must also increase the ``AllocatedStorage`` value (in 100-GiB increments). *Amazon Aurora* Not applicable. Aurora cluster volumes automatically grow as the amount of data in your database increases, though you are only charged for the space that you use in an Aurora cluster volume. *MySQL* Constraints to the amount of storage for each storage type are the following: - General Purpose (SSD) storage (gp2): Must be an integer from 20 to 65536. - Provisioned IOPS storage (io1): Must be an integer from 100 to 65536. - Magnetic storage (standard): Must be an integer from 5 to 3072. *MariaDB* Constraints to the amount of storage for each storage type are the following: - General Purpose (SSD) storage (gp2): Must be an integer from 20 to 65536. - Provisioned IOPS storage (io1): Must be an integer from 100 to 65536. - Magnetic storage (standard): Must be an integer from 5 to 3072. *PostgreSQL* Constraints to the amount of storage for each storage type are the following: - General Purpose (SSD) storage (gp2): Must be an integer from 20 to 65536. - Provisioned IOPS storage (io1): Must be an integer from 100 to 65536. - Magnetic storage (standard): Must be an integer from 5 to 3072. *Oracle* Constraints to the amount of storage for each storage type are the following: - General Purpose (SSD) storage (gp2): Must be an integer from 20 to 65536. - Provisioned IOPS storage (io1): Must be an integer from 100 to 65536. - Magnetic storage (standard): Must be an integer from 10 to 3072. *SQL Server* Constraints to the amount of storage for each storage type are the following: - General Purpose (SSD) storage (gp2): - Enterprise and Standard editions: Must be an integer from 20 to 16384. - Web and Express editions: Must be an integer from 20 to 16384. - Provisioned IOPS storage (io1): - Enterprise and Standard editions: Must be an integer from 20 to 16384. - Web and Express editions: Must be an integer from 20 to 16384. - Magnetic storage (standard): - Enterprise and Standard editions: Must be an integer from 20 to 1024. - Web and Express editions: Must be an integer from 20 to 1024.
        :param allow_major_version_upgrade: A value that indicates whether major version upgrades are allowed. Changing this parameter doesn't result in an outage and the change is asynchronously applied as soon as possible. Constraints: Major version upgrades must be allowed when specifying a value for the ``EngineVersion`` parameter that is a different major version than the DB instance's current version.
        :param associated_roles: The AWS Identity and Access Management (IAM) roles associated with the DB instance. *Amazon Aurora* Not applicable. The associated roles are managed by the DB cluster.
        :param auto_minor_version_upgrade: A value that indicates whether minor engine upgrades are applied automatically to the DB instance during the maintenance window. By default, minor engine upgrades are applied automatically.
        :param availability_zone: The Availability Zone (AZ) where the database will be created. For information on AWS Regions and Availability Zones, see `Regions and Availability Zones <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.RegionsAndAvailabilityZones.html>`_ . *Amazon Aurora* Each Aurora DB cluster hosts copies of its storage in three separate Availability Zones. Specify one of these Availability Zones. Aurora automatically chooses an appropriate Availability Zone if you don't specify one. Default: A random, system-chosen Availability Zone in the endpoint's AWS Region . Example: ``us-east-1d`` Constraint: The ``AvailabilityZone`` parameter can't be specified if the DB instance is a Multi-AZ deployment. The specified Availability Zone must be in the same AWS Region as the current endpoint.
        :param backup_retention_period: The number of days for which automated backups are retained. Setting this parameter to a positive number enables backups. Setting this parameter to 0 disables automated backups. *Amazon Aurora* Not applicable. The retention period for automated backups is managed by the DB cluster. Default: 1 Constraints: - Must be a value from 0 to 35 - Can't be set to 0 if the DB instance is a source to read replicas
        :param ca_certificate_identifier: The identifier of the CA certificate for this DB instance. .. epigraph:: Specifying or updating this property triggers a reboot. For more information about CA certificate identifiers for RDS DB engines, see `Rotating Your SSL/TLS Certificate <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.SSL-certificate-rotation.html>`_ in the *Amazon RDS User Guide* . For more information about CA certificate identifiers for Aurora DB engines, see `Rotating Your SSL/TLS Certificate <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/UsingWithRDS.SSL-certificate-rotation.html>`_ in the *Amazon Aurora User Guide* .
        :param certificate_details: The details of the DB instance's server certificate.
        :param certificate_rotation_restart: A value that indicates whether the DB instance is restarted when you rotate your SSL/TLS certificate. By default, the DB instance is restarted when you rotate your SSL/TLS certificate. The certificate is not updated until the DB instance is restarted. .. epigraph:: Set this parameter only if you are *not* using SSL/TLS to connect to the DB instance. If you are using SSL/TLS to connect to the DB instance, follow the appropriate instructions for your DB engine to rotate your SSL/TLS certificate: - For more information about rotating your SSL/TLS certificate for RDS DB engines, see `Rotating Your SSL/TLS Certificate. <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.SSL-certificate-rotation.html>`_ in the *Amazon RDS User Guide.* - For more information about rotating your SSL/TLS certificate for Aurora DB engines, see `Rotating Your SSL/TLS Certificate <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/UsingWithRDS.SSL-certificate-rotation.html>`_ in the *Amazon Aurora User Guide* . This setting doesn't apply to RDS Custom.
        :param character_set_name: For supported engines, indicates that the DB instance should be associated with the specified character set. *Amazon Aurora* Not applicable. The character set is managed by the DB cluster. For more information, see `AWS::RDS::DBCluster <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html>`_ .
        :param copy_tags_to_snapshot: A value that indicates whether to copy tags from the DB instance to snapshots of the DB instance. By default, tags are not copied. *Amazon Aurora* Not applicable. Copying tags to snapshots is managed by the DB cluster. Setting this value for an Aurora DB instance has no effect on the DB cluster setting.
        :param custom_iam_instance_profile: The instance profile associated with the underlying Amazon EC2 instance of an RDS Custom DB instance. The instance profile must meet the following requirements: - The profile must exist in your account. - The profile must have an IAM role that Amazon EC2 has permissions to assume. - The instance profile name and the associated IAM role name must start with the prefix ``AWSRDSCustom`` . For the list of permissions required for the IAM role, see `Configure IAM and your VPC <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/custom-setup-orcl.html#custom-setup-orcl.iam-vpc>`_ in the *Amazon RDS User Guide* . This setting is required for RDS Custom.
        :param db_cluster_identifier: The identifier of the DB cluster that the instance will belong to.
        :param db_cluster_snapshot_identifier: The identifier for the RDS for MySQL Multi-AZ DB cluster snapshot to restore from. For more information on Multi-AZ DB clusters, see `Multi-AZ DB cluster deployments <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/multi-az-db-clusters-concepts.html>`_ in the *Amazon RDS User Guide* . Constraints: - Must match the identifier of an existing Multi-AZ DB cluster snapshot. - Can't be specified when ``DBSnapshotIdentifier`` is specified. - Must be specified when ``DBSnapshotIdentifier`` isn't specified. - If you are restoring from a shared manual Multi-AZ DB cluster snapshot, the ``DBClusterSnapshotIdentifier`` must be the ARN of the shared snapshot. - Can't be the identifier of an Aurora DB cluster snapshot. - Can't be the identifier of an RDS for PostgreSQL Multi-AZ DB cluster snapshot.
        :param db_instance_class: The compute and memory capacity of the DB instance, for example, ``db.m4.large`` . Not all DB instance classes are available in all AWS Regions, or for all database engines. For the full list of DB instance classes, and availability for your engine, see `DB Instance Class <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html>`_ in the *Amazon RDS User Guide.* For more information about DB instance class pricing and AWS Region support for DB instance classes, see `Amazon RDS Pricing <https://docs.aws.amazon.com/rds/pricing/>`_ .
        :param db_instance_identifier: A name for the DB instance. If you specify a name, AWS CloudFormation converts it to lowercase. If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the DB instance. For more information, see `Name Type <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html>`_ . For information about constraints that apply to DB instance identifiers, see `Naming constraints in Amazon RDS <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Limits.html#RDS_Limits.Constraints>`_ in the *Amazon RDS User Guide* . .. epigraph:: If you specify a name, you can't perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name.
        :param db_name: The meaning of this parameter differs according to the database engine you use. .. epigraph:: If you specify the ``[DBSnapshotIdentifier](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-database-instance.html#cfn-rds-dbinstance-dbsnapshotidentifier)`` property, this property only applies to RDS for Oracle. *Amazon Aurora* Not applicable. The database name is managed by the DB cluster. *MySQL* The name of the database to create when the DB instance is created. If this parameter is not specified, no database is created in the DB instance. Constraints: - Must contain 1 to 64 letters or numbers. - Can't be a word reserved by the specified database engine *MariaDB* The name of the database to create when the DB instance is created. If this parameter is not specified, no database is created in the DB instance. Constraints: - Must contain 1 to 64 letters or numbers. - Can't be a word reserved by the specified database engine *PostgreSQL* The name of the database to create when the DB instance is created. If this parameter is not specified, the default ``postgres`` database is created in the DB instance. Constraints: - Must begin with a letter. Subsequent characters can be letters, underscores, or digits (0-9). - Must contain 1 to 63 characters. - Can't be a word reserved by the specified database engine *Oracle* The Oracle System ID (SID) of the created DB instance. If you specify ``null`` , the default value ``ORCL`` is used. You can't specify the string NULL, or any other reserved word, for ``DBName`` . Default: ``ORCL`` Constraints: - Can't be longer than 8 characters *SQL Server* Not applicable. Must be null.
        :param db_parameter_group_name: The name of an existing DB parameter group or a reference to an `AWS::RDS::DBParameterGroup <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbparametergroup.html>`_ resource created in the template. To list all of the available DB parameter group names, use the following command: ``aws rds describe-db-parameter-groups --query "DBParameterGroups[].DBParameterGroupName" --output text`` .. epigraph:: If any of the data members of the referenced parameter group are changed during an update, the DB instance might need to be restarted, which causes some interruption. If the parameter group contains static parameters, whether they were changed or not, an update triggers a reboot. If you don't specify a value for ``DBParameterGroupName`` property, the default DB parameter group for the specified engine and engine version is used.
        :param db_security_groups: A list of the DB security groups to assign to the DB instance. The list can include both the name of existing DB security groups or references to AWS::RDS::DBSecurityGroup resources created in the template. If you set DBSecurityGroups, you must not set VPCSecurityGroups, and vice versa. Also, note that the DBSecurityGroups property exists only for backwards compatibility with older regions and is no longer recommended for providing security information to an RDS DB instance. Instead, use VPCSecurityGroups. .. epigraph:: If you specify this property, AWS CloudFormation sends only the following properties (if specified) to Amazon RDS during create operations: - ``AllocatedStorage`` - ``AutoMinorVersionUpgrade`` - ``AvailabilityZone`` - ``BackupRetentionPeriod`` - ``CharacterSetName`` - ``DBInstanceClass`` - ``DBName`` - ``DBParameterGroupName`` - ``DBSecurityGroups`` - ``DBSubnetGroupName`` - ``Engine`` - ``EngineVersion`` - ``Iops`` - ``LicenseModel`` - ``MasterUsername`` - ``MasterUserPassword`` - ``MultiAZ`` - ``OptionGroupName`` - ``PreferredBackupWindow`` - ``PreferredMaintenanceWindow`` All other properties are ignored. Specify a virtual private cloud (VPC) security group if you want to submit other properties, such as ``StorageType`` , ``StorageEncrypted`` , or ``KmsKeyId`` . If you're already using the ``DBSecurityGroups`` property, you can't use these other properties by updating your DB instance to use a VPC security group. You must recreate the DB instance.
        :param db_snapshot_identifier: The name or Amazon Resource Name (ARN) of the DB snapshot that's used to restore the DB instance. If you're restoring from a shared manual DB snapshot, you must specify the ARN of the snapshot. By specifying this property, you can create a DB instance from the specified DB snapshot. If the ``DBSnapshotIdentifier`` property is an empty string or the ``AWS::RDS::DBInstance`` declaration has no ``DBSnapshotIdentifier`` property, AWS CloudFormation creates a new database. If the property contains a value (other than an empty string), AWS CloudFormation creates a database from the specified snapshot. If a snapshot with the specified name doesn't exist, AWS CloudFormation can't create the database and it rolls back the stack. Some DB instance properties aren't valid when you restore from a snapshot, such as the ``MasterUsername`` and ``MasterUserPassword`` properties. For information about the properties that you can specify, see the ``RestoreDBInstanceFromDBSnapshot`` action in the *Amazon RDS API Reference* . After you restore a DB instance with a ``DBSnapshotIdentifier`` property, you must specify the same ``DBSnapshotIdentifier`` property for any future updates to the DB instance. When you specify this property for an update, the DB instance is not restored from the DB snapshot again, and the data in the database is not changed. However, if you don't specify the ``DBSnapshotIdentifier`` property, an empty DB instance is created, and the original DB instance is deleted. If you specify a property that is different from the previous snapshot restore property, a new DB instance is restored from the specified ``DBSnapshotIdentifier`` property, and the original DB instance is deleted. If you specify the ``DBSnapshotIdentifier`` property to restore a DB instance (as opposed to specifying it for DB instance updates), then don't specify the following properties: - ``CharacterSetName`` - ``DBClusterIdentifier`` - ``DBName`` - ``DeleteAutomatedBackups`` - ``EnablePerformanceInsights`` - ``KmsKeyId`` - ``MasterUsername`` - ``MasterUserPassword`` - ``PerformanceInsightsKMSKeyId`` - ``PerformanceInsightsRetentionPeriod`` - ``PromotionTier`` - ``SourceDBInstanceIdentifier`` - ``SourceRegion`` - ``StorageEncrypted`` (for an encrypted snapshot) - ``Timezone`` *Amazon Aurora* Not applicable. Snapshot restore is managed by the DB cluster.
        :param db_subnet_group_name: A DB subnet group to associate with the DB instance. If you update this value, the new subnet group must be a subnet group in a new VPC. If there's no DB subnet group, then the DB instance isn't a VPC DB instance. For more information about using Amazon RDS in a VPC, see `Using Amazon RDS with Amazon Virtual Private Cloud (VPC) <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_VPC.html>`_ in the *Amazon RDS User Guide* . *Amazon Aurora* Not applicable. The DB subnet group is managed by the DB cluster. If specified, the setting must match the DB cluster setting.
        :param delete_automated_backups: A value that indicates whether to remove automated backups immediately after the DB instance is deleted. This parameter isn't case-sensitive. The default is to remove automated backups immediately after the DB instance is deleted. *Amazon Aurora* Not applicable. When you delete a DB cluster, all automated backups for that DB cluster are deleted and can't be recovered. Manual DB cluster snapshots of the DB cluster are not deleted.
        :param deletion_protection: A value that indicates whether the DB instance has deletion protection enabled. The database can't be deleted when deletion protection is enabled. By default, deletion protection is disabled. For more information, see `Deleting a DB Instance <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_DeleteInstance.html>`_ . *Amazon Aurora* Not applicable. You can enable or disable deletion protection for the DB cluster. For more information, see ``CreateDBCluster`` . DB instances in a DB cluster can be deleted even when deletion protection is enabled for the DB cluster.
        :param domain: The Active Directory directory ID to create the DB instance in. Currently, only Microsoft SQL Server, Oracle, and PostgreSQL DB instances can be created in an Active Directory Domain. For more information, see `Kerberos Authentication <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/kerberos-authentication.html>`_ in the *Amazon RDS User Guide* .
        :param domain_iam_role_name: Specify the name of the IAM role to be used when making API calls to the Directory Service. This setting doesn't apply to RDS Custom. *Amazon Aurora* Not applicable. The domain is managed by the DB cluster.
        :param enable_cloudwatch_logs_exports: The list of log types that need to be enabled for exporting to CloudWatch Logs. The values in the list depend on the DB engine being used. For more information, see `Publishing Database Logs to Amazon CloudWatch Logs <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_LogAccess.html#USER_LogAccess.Procedural.UploadtoCloudWatch>`_ in the *Amazon Relational Database Service User Guide* . *Amazon Aurora* Not applicable. CloudWatch Logs exports are managed by the DB cluster. *MariaDB* Valid values: ``audit`` , ``error`` , ``general`` , ``slowquery`` *Microsoft SQL Server* Valid values: ``agent`` , ``error`` *MySQL* Valid values: ``audit`` , ``error`` , ``general`` , ``slowquery`` *Oracle* Valid values: ``alert`` , ``audit`` , ``listener`` , ``trace`` *PostgreSQL* Valid values: ``postgresql`` , ``upgrade``
        :param enable_iam_database_authentication: A value that indicates whether to enable mapping of AWS Identity and Access Management (IAM) accounts to database accounts. By default, mapping is disabled. This property is supported for RDS for MariaDB, RDS for MySQL, and RDS for PostgreSQL. For more information, see `IAM Database Authentication for MariaDB, MySQL, and PostgreSQL <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.IAMDBAuth.html>`_ in the *Amazon RDS User Guide.* *Amazon Aurora* Not applicable. Mapping AWS IAM accounts to database accounts is managed by the DB cluster.
        :param enable_performance_insights: A value that indicates whether to enable Performance Insights for the DB instance. For more information, see `Using Amazon Performance Insights <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PerfInsights.html>`_ in the *Amazon RDS User Guide* . This setting doesn't apply to RDS Custom.
        :param endpoint: Specifies the connection endpoint. .. epigraph:: The endpoint might not be shown for instances whose status is ``creating`` .
        :param engine: The name of the database engine that you want to use for this DB instance. .. epigraph:: When you are creating a DB instance, the ``Engine`` property is required. Valid Values: - ``aurora-mysql`` (for Aurora MySQL DB instances) - ``aurora-postgresql`` (for Aurora PostgreSQL DB instances) - ``custom-oracle-ee`` (for RDS Custom for Oracle DB instances) - ``custom-oracle-ee-cdb`` (for RDS Custom for Oracle DB instances) - ``custom-sqlserver-ee`` (for RDS Custom for SQL Server DB instances) - ``custom-sqlserver-se`` (for RDS Custom for SQL Server DB instances) - ``custom-sqlserver-web`` (for RDS Custom for SQL Server DB instances) - ``mariadb`` - ``mysql`` - ``oracle-ee`` - ``oracle-ee-cdb`` - ``oracle-se2`` - ``oracle-se2-cdb`` - ``postgres`` - ``sqlserver-ee`` - ``sqlserver-se`` - ``sqlserver-ex`` - ``sqlserver-web``
        :param engine_version: The version number of the database engine to use. For a list of valid engine versions, use the ``DescribeDBEngineVersions`` action. The following are the database engines and links to information about the major and minor versions that are available with Amazon RDS. Not every database engine is available for every AWS Region. *Amazon Aurora* Not applicable. The version number of the database engine to be used by the DB instance is managed by the DB cluster. *MariaDB* See `MariaDB on Amazon RDS Versions <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_MariaDB.html#MariaDB.Concepts.VersionMgmt>`_ in the *Amazon RDS User Guide.* *Microsoft SQL Server* See `Microsoft SQL Server Versions on Amazon RDS <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_SQLServer.html#SQLServer.Concepts.General.VersionSupport>`_ in the *Amazon RDS User Guide.* *MySQL* See `MySQL on Amazon RDS Versions <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_MySQL.html#MySQL.Concepts.VersionMgmt>`_ in the *Amazon RDS User Guide.* *Oracle* See `Oracle Database Engine Release Notes <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Appendix.Oracle.PatchComposition.html>`_ in the *Amazon RDS User Guide.* *PostgreSQL* See `Supported PostgreSQL Database Versions <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_PostgreSQL.html#PostgreSQL.Concepts.General.DBVersions>`_ in the *Amazon RDS User Guide.*
        :param iops: The number of I/O operations per second (IOPS) that the database provisions. The value must be equal to or greater than 1000. If you specify this property, you must follow the range of allowed ratios of your requested IOPS rate to the amount of storage that you allocate (IOPS to allocated storage). For example, you can provision an Oracle database instance with 1000 IOPS and 200 GiB of storage (a ratio of 5:1), or specify 2000 IOPS with 200 GiB of storage (a ratio of 10:1). For more information, see `Amazon RDS Provisioned IOPS Storage to Improve Performance <https://docs.aws.amazon.com/AmazonRDS/latest/DeveloperGuide/CHAP_Storage.html#USER_PIOPS>`_ in the *Amazon RDS User Guide* . .. epigraph:: If you specify ``io1`` for the ``StorageType`` property, then you must also specify the ``Iops`` property.
        :param kms_key_id: The ARN of the AWS KMS key that's used to encrypt the DB instance, such as ``arn:aws:kms:us-east-1:012345678910:key/abcd1234-a123-456a-a12b-a123b4cd56ef`` . If you enable the StorageEncrypted property but don't specify this property, AWS CloudFormation uses the default KMS key. If you specify this property, you must set the StorageEncrypted property to true. If you specify the ``SourceDBInstanceIdentifier`` property, the value is inherited from the source DB instance if the read replica is created in the same region. If you create an encrypted read replica in a different AWS Region, then you must specify a KMS key for the destination AWS Region. KMS encryption keys are specific to the region that they're created in, and you can't use encryption keys from one region in another region. If you specify the ``SnapshotIdentifier`` property, the ``StorageEncrypted`` property value is inherited from the snapshot, and if the DB instance is encrypted, the specified ``KmsKeyId`` property is used. If you specify ``DBSecurityGroups`` , AWS CloudFormation ignores this property. To specify both a security group and this property, you must use a VPC security group. For more information about Amazon RDS and VPC, see `Using Amazon RDS with Amazon VPC <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_VPC.html>`_ in the *Amazon RDS User Guide* . *Amazon Aurora* Not applicable. The KMS key identifier is managed by the DB cluster.
        :param license_model: License model information for this DB instance. Valid values: - Aurora MySQL - ``general-public-license`` - Aurora PostgreSQL - ``postgresql-license`` - MariaDB - ``general-public-license`` - Microsoft SQL Server - ``license-included`` - MySQL - ``general-public-license`` - Oracle - ``bring-your-own-license`` or ``license-included`` - PostgreSQL - ``postgresql-license`` .. epigraph:: If you've specified ``DBSecurityGroups`` and then you update the license model, AWS CloudFormation replaces the underlying DB instance. This will incur some interruptions to database availability.
        :param manage_master_user_password: A value that indicates whether to manage the master user password with AWS Secrets Manager. For more information, see `Password management with AWS Secrets Manager <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-secrets-manager.html>`_ in the *Amazon RDS User Guide.* Constraints: - Can't manage the master user password with AWS Secrets Manager if ``MasterUserPassword`` is specified.
        :param master_username: The master user name for the DB instance. .. epigraph:: If you specify the ``SourceDBInstanceIdentifier`` or ``DBSnapshotIdentifier`` property, don't specify this property. The value is inherited from the source DB instance or snapshot. *Amazon Aurora* Not applicable. The name for the master user is managed by the DB cluster. *MariaDB* Constraints: - Required for MariaDB. - Must be 1 to 16 letters or numbers. - Can't be a reserved word for the chosen database engine. *Microsoft SQL Server* Constraints: - Required for SQL Server. - Must be 1 to 128 letters or numbers. - The first character must be a letter. - Can't be a reserved word for the chosen database engine. *MySQL* Constraints: - Required for MySQL. - Must be 1 to 16 letters or numbers. - First character must be a letter. - Can't be a reserved word for the chosen database engine. *Oracle* Constraints: - Required for Oracle. - Must be 1 to 30 letters or numbers. - First character must be a letter. - Can't be a reserved word for the chosen database engine. *PostgreSQL* Constraints: - Required for PostgreSQL. - Must be 1 to 63 letters or numbers. - First character must be a letter. - Can't be a reserved word for the chosen database engine.
        :param master_user_password: The password for the master user. The password can include any printable ASCII character except "/", """, or "@". *Amazon Aurora* Not applicable. The password for the master user is managed by the DB cluster. *MariaDB* Constraints: Must contain from 8 to 41 characters. *Microsoft SQL Server* Constraints: Must contain from 8 to 128 characters. *MySQL* Constraints: Must contain from 8 to 41 characters. *Oracle* Constraints: Must contain from 8 to 30 characters. *PostgreSQL* Constraints: Must contain from 8 to 128 characters.
        :param master_user_secret: Contains the secret managed by RDS in AWS Secrets Manager for the master user password. For more information, see `Password management with AWS Secrets Manager <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-secrets-manager.html>`_ in the *Amazon RDS User Guide.*
        :param max_allocated_storage: The upper limit in gibibytes (GiB) to which Amazon RDS can automatically scale the storage of the DB instance. For more information about this setting, including limitations that apply to it, see `Managing capacity automatically with Amazon RDS storage autoscaling <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PIOPS.StorageTypes.html#USER_PIOPS.Autoscaling>`_ in the *Amazon RDS User Guide* . This setting doesn't apply to RDS Custom. *Amazon Aurora* Not applicable. Storage is managed by the DB cluster.
        :param monitoring_interval: The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the DB instance. To disable collection of Enhanced Monitoring metrics, specify 0. The default is 0. If ``MonitoringRoleArn`` is specified, then you must set ``MonitoringInterval`` to a value other than 0. This setting doesn't apply to RDS Custom. Valid Values: ``0, 1, 5, 10, 15, 30, 60``
        :param monitoring_role_arn: The ARN for the IAM role that permits RDS to send enhanced monitoring metrics to Amazon CloudWatch Logs. For example, ``arn:aws:iam:123456789012:role/emaccess`` . For information on creating a monitoring role, see `Setting Up and Enabling Enhanced Monitoring <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Monitoring.OS.html#USER_Monitoring.OS.Enabling>`_ in the *Amazon RDS User Guide* . If ``MonitoringInterval`` is set to a value other than 0, then you must supply a ``MonitoringRoleArn`` value. This setting doesn't apply to RDS Custom.
        :param multi_az: Specifies whether the database instance is a Multi-AZ DB instance deployment. You can't set the ``AvailabilityZone`` parameter if the ``MultiAZ`` parameter is set to true. For more information, see `Multi-AZ deployments for high availability <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.MultiAZ.html>`_ in the *Amazon RDS User Guide* . *Amazon Aurora* Not applicable. Amazon Aurora storage is replicated across all of the Availability Zones and doesn't require the ``MultiAZ`` option to be set.
        :param nchar_character_set_name: The name of the NCHAR character set for the Oracle DB instance. This parameter doesn't apply to RDS Custom.
        :param network_type: The network type of the DB instance. Valid values: - ``IPV4`` - ``DUAL`` The network type is determined by the ``DBSubnetGroup`` specified for the DB instance. A ``DBSubnetGroup`` can support only the IPv4 protocol or the IPv4 and IPv6 protocols ( ``DUAL`` ). For more information, see `Working with a DB instance in a VPC <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_VPC.WorkingWithRDSInstanceinaVPC.html>`_ in the *Amazon RDS User Guide.*
        :param option_group_name: Indicates that the DB instance should be associated with the specified option group. Permanent options, such as the TDE option for Oracle Advanced Security TDE, can't be removed from an option group. Also, that option group can't be removed from a DB instance once it is associated with a DB instance.
        :param performance_insights_kms_key_id: The AWS KMS key identifier for encryption of Performance Insights data. The KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. If you do not specify a value for ``PerformanceInsightsKMSKeyId`` , then Amazon RDS uses your default KMS key. There is a default KMS key for your AWS account. Your AWS account has a different default KMS key for each AWS Region. For information about enabling Performance Insights, see `EnablePerformanceInsights <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-database-instance.html#cfn-rds-dbinstance-enableperformanceinsights>`_ .
        :param performance_insights_retention_period: The number of days to retain Performance Insights data. The default is 7 days. The following values are valid:. - 7 - *month* * 31, where *month* is a number of months from 1-23 - 731 For example, the following values are valid: - 93 (3 months * 31) - 341 (11 months * 31) - 589 (19 months * 31) - 731 If you specify a retention period such as 94, which isn't a valid value, RDS issues an error. This setting doesn't apply to RDS Custom.
        :param port: The port number on which the database accepts connections. *Amazon Aurora* Not applicable. The port number is managed by the DB cluster.
        :param preferred_backup_window: The daily time range during which automated backups are created if automated backups are enabled, using the ``BackupRetentionPeriod`` parameter. For more information, see `Backup Window <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithAutomatedBackups.html#USER_WorkingWithAutomatedBackups.BackupWindow>`_ in the *Amazon RDS User Guide.* Constraints: - Must be in the format ``hh24:mi-hh24:mi`` . - Must be in Universal Coordinated Time (UTC). - Must not conflict with the preferred maintenance window. - Must be at least 30 minutes. *Amazon Aurora* Not applicable. The daily time range for creating automated backups is managed by the DB cluster.
        :param preferred_maintenance_window: The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC). Format: ``ddd:hh24:mi-ddd:hh24:mi`` The default is a 30-minute window selected at random from an 8-hour block of time for each AWS Region, occurring on a random day of the week. To see the time blocks available, see `Adjusting the Preferred DB Instance Maintenance Window <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_UpgradeDBInstance.Maintenance.html#AdjustingTheMaintenanceWindow>`_ in the *Amazon RDS User Guide.* .. epigraph:: This property applies when AWS CloudFormation initially creates the DB instance. If you use AWS CloudFormation to update the DB instance, those updates are applied immediately. Constraints: Minimum 30-minute window.
        :param processor_features: The number of CPU cores and the number of threads per core for the DB instance class of the DB instance. This setting doesn't apply to RDS Custom. *Amazon Aurora* Not applicable.
        :param promotion_tier: A value that specifies the order in which an Aurora Replica is promoted to the primary instance after a failure of the existing primary instance. For more information, see `Fault Tolerance for an Aurora DB Cluster <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.Managing.Backups.html#Aurora.Managing.FaultTolerance>`_ in the *Amazon Aurora User Guide* . This setting doesn't apply to RDS Custom. Default: 1 Valid Values: 0 - 15
        :param publicly_accessible: Indicates whether the DB instance is an internet-facing instance. If you specify true, AWS CloudFormation creates an instance with a publicly resolvable DNS name, which resolves to a public IP address. If you specify false, AWS CloudFormation creates an internal instance with a DNS name that resolves to a private IP address. The default behavior value depends on your VPC setup and the database subnet group. For more information, see the ``PubliclyAccessible`` parameter in the `CreateDBInstance <https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_CreateDBInstance.html>`_ in the *Amazon RDS API Reference* .
        :param replica_mode: The open mode of an Oracle read replica. For more information, see `Working with Oracle Read Replicas for Amazon RDS <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/oracle-read-replicas.html>`_ in the *Amazon RDS User Guide* . This setting is only supported in RDS for Oracle. Default: ``open-read-only`` Valid Values: ``open-read-only`` or ``mounted``
        :param restore_time: The date and time to restore from. Valid Values: Value must be a time in Universal Coordinated Time (UTC) format Constraints: - Must be before the latest restorable time for the DB instance - Can't be specified if the ``UseLatestRestorableTime`` parameter is enabled Example: ``2009-09-07T23:45:00Z``
        :param source_db_cluster_identifier: The identifier of the Multi-AZ DB cluster that will act as the source for the read replica. Each DB cluster can have up to 15 read replicas. Constraints: - Must be the identifier of an existing Multi-AZ DB cluster. - Can't be specified if the ``SourceDBInstanceIdentifier`` parameter is also specified. - The specified DB cluster must have automatic backups enabled, that is, its backup retention period must be greater than 0. - The source DB cluster must be in the same AWS Region as the read replica. Cross-Region replication isn't supported.
        :param source_db_instance_automated_backups_arn: The Amazon Resource Name (ARN) of the replicated automated backups from which to restore, for example, ``arn:aws:rds:useast-1:123456789012:auto-backup:ab-L2IJCEXJP7XQ7HOJ4SIEXAMPLE`` . This setting doesn't apply to RDS Custom.
        :param source_db_instance_identifier: If you want to create a read replica DB instance, specify the ID of the source DB instance. Each DB instance can have a limited number of read replicas. For more information, see `Working with Read Replicas <https://docs.aws.amazon.com/AmazonRDS/latest/DeveloperGuide/USER_ReadRepl.html>`_ in the *Amazon RDS User Guide* . For information about constraints that apply to DB instance identifiers, see `Naming constraints in Amazon RDS <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Limits.html#RDS_Limits.Constraints>`_ in the *Amazon RDS User Guide* . The ``SourceDBInstanceIdentifier`` property determines whether a DB instance is a read replica. If you remove the ``SourceDBInstanceIdentifier`` property from your template and then update your stack, AWS CloudFormation promotes the Read Replica to a standalone DB instance. .. epigraph:: - If you specify a source DB instance that uses VPC security groups, we recommend that you specify the ``VPCSecurityGroups`` property. If you don't specify the property, the read replica inherits the value of the ``VPCSecurityGroups`` property from the source DB when you create the replica. However, if you update the stack, AWS CloudFormation reverts the replica's ``VPCSecurityGroups`` property to the default value because it's not defined in the stack's template. This change might cause unexpected issues. - Read replicas don't support deletion policies. AWS CloudFormation ignores any deletion policy that's associated with a read replica. - If you specify ``SourceDBInstanceIdentifier`` , don't specify the ``DBSnapshotIdentifier`` property. You can't create a read replica from a snapshot. - Don't set the ``BackupRetentionPeriod`` , ``DBName`` , ``MasterUsername`` , ``MasterUserPassword`` , and ``PreferredBackupWindow`` properties. The database attributes are inherited from the source DB instance, and backups are disabled for read replicas. - If the source DB instance is in a different region than the read replica, specify the source region in ``SourceRegion`` , and specify an ARN for a valid DB instance in ``SourceDBInstanceIdentifier`` . For more information, see `Constructing a Amazon RDS Amazon Resource Name (ARN) <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html#USER_Tagging.ARN>`_ in the *Amazon RDS User Guide* . - For DB instances in Amazon Aurora clusters, don't specify this property. Amazon RDS automatically assigns writer and reader DB instances.
        :param source_dbi_resource_id: The resource ID of the source DB instance from which to restore.
        :param source_region: The ID of the region that contains the source DB instance for the read replica.
        :param storage_encrypted: A value that indicates whether the DB instance is encrypted. By default, it isn't encrypted. If you specify the ``KmsKeyId`` property, then you must enable encryption. If you specify the ``SourceDBInstanceIdentifier`` property, don't specify this property. The value is inherited from the source DB instance, and if the DB instance is encrypted, the specified ``KmsKeyId`` property is used. If you specify the ``SnapshotIdentifier`` and the specified snapshot is encrypted, don't specify this property. The value is inherited from the snapshot, and the specified ``KmsKeyId`` property is used. If you specify the ``SnapshotIdentifier`` and the specified snapshot isn't encrypted, you can use this property to specify that the restored DB instance is encrypted. Specify the ``KmsKeyId`` property for the KMS key to use for encryption. If you don't want the restored DB instance to be encrypted, then don't set this property or set it to ``false`` . *Amazon Aurora* Not applicable. The encryption for DB instances is managed by the DB cluster.
        :param storage_throughput: Specifies the storage throughput value for the DB instance. This setting applies only to the ``gp3`` storage type. This setting doesn't apply to RDS Custom or Amazon Aurora.
        :param storage_type: Specifies the storage type to be associated with the DB instance. Valid values: ``gp2 | gp3 | io1 | standard`` The ``standard`` value is also known as magnetic. If you specify ``io1`` or ``gp3`` , you must also include a value for the ``Iops`` parameter. Default: ``io1`` if the ``Iops`` parameter is specified, otherwise ``gp2`` For more information, see `Amazon RDS DB Instance Storage <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Storage.html>`_ in the *Amazon RDS User Guide* . *Amazon Aurora* Not applicable. Aurora data is stored in the cluster volume, which is a single, virtual volume that uses solid state drives (SSDs).
        :param tags: An optional array of key-value pairs to apply to this DB instance.
        :param timezone: The time zone of the DB instance. The time zone parameter is currently supported only by `Microsoft SQL Server <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_SQLServer.html#SQLServer.Concepts.General.TimeZone>`_ .
        :param use_default_processor_features: A value that indicates whether the DB instance class of the DB instance uses its default processor features. This setting doesn't apply to RDS Custom.
        :param use_latest_restorable_time: A value that indicates whether the DB instance is restored from the latest backup time. By default, the DB instance isn't restored from the latest backup time. Constraints: Can't be specified if the ``RestoreTime`` parameter is provided.
        :param vpc_security_groups: A list of the VPC security group IDs to assign to the DB instance. The list can include both the physical IDs of existing VPC security groups and references to `AWS::EC2::SecurityGroup <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group.html>`_ resources created in the template. If you plan to update the resource, don't specify VPC security groups in a shared VPC. If you set ``VPCSecurityGroups`` , you must not set ```DBSecurityGroups`` <https://docs.aws.amazon.com//AWSCloudFormation/latest/UserGuide/aws-properties-rds-database-instance.html#cfn-rds-dbinstance-dbsecuritygroups>`_ , and vice versa. .. epigraph:: You can migrate a DB instance in your stack from an RDS DB security group to a VPC security group, but keep the following in mind: - You can't revert to using an RDS security group after you establish a VPC security group membership. - When you migrate your DB instance to VPC security groups, if your stack update rolls back because the DB instance update fails or because an update fails in another AWS CloudFormation resource, the rollback fails because it can't revert to an RDS security group. - To use the properties that are available when you use a VPC security group, you must recreate the DB instance. If you don't, AWS CloudFormation submits only the property values that are listed in the ```DBSecurityGroups`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-database-instance.html#cfn-rds-dbinstance-dbsecuritygroups>`_ property. To avoid this situation, migrate your DB instance to using VPC security groups only when that is the only change in your stack template. *Amazon Aurora* Not applicable. The associated list of EC2 VPC security groups is managed by the DB cluster. If specified, the setting must match the DB cluster setting.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_rds as rds
            
            cfn_dBInstance_props = rds.CfnDBInstanceProps(
                allocated_storage="allocatedStorage",
                allow_major_version_upgrade=False,
                associated_roles=[rds.CfnDBInstance.DBInstanceRoleProperty(
                    feature_name="featureName",
                    role_arn="roleArn"
                )],
                auto_minor_version_upgrade=False,
                availability_zone="availabilityZone",
                backup_retention_period=123,
                ca_certificate_identifier="caCertificateIdentifier",
                certificate_details=rds.CfnDBInstance.CertificateDetailsProperty(
                    ca_identifier="caIdentifier",
                    valid_till="validTill"
                ),
                certificate_rotation_restart=False,
                character_set_name="characterSetName",
                copy_tags_to_snapshot=False,
                custom_iam_instance_profile="customIamInstanceProfile",
                db_cluster_identifier="dbClusterIdentifier",
                db_cluster_snapshot_identifier="dbClusterSnapshotIdentifier",
                db_instance_class="dbInstanceClass",
                db_instance_identifier="dbInstanceIdentifier",
                db_name="dbName",
                db_parameter_group_name="dbParameterGroupName",
                db_security_groups=["dbSecurityGroups"],
                db_snapshot_identifier="dbSnapshotIdentifier",
                db_subnet_group_name="dbSubnetGroupName",
                delete_automated_backups=False,
                deletion_protection=False,
                domain="domain",
                domain_iam_role_name="domainIamRoleName",
                enable_cloudwatch_logs_exports=["enableCloudwatchLogsExports"],
                enable_iam_database_authentication=False,
                enable_performance_insights=False,
                endpoint=rds.CfnDBInstance.EndpointProperty(
                    address="address",
                    hosted_zone_id="hostedZoneId",
                    port="port"
                ),
                engine="engine",
                engine_version="engineVersion",
                iops=123,
                kms_key_id="kmsKeyId",
                license_model="licenseModel",
                manage_master_user_password=False,
                master_username="masterUsername",
                master_user_password="masterUserPassword",
                master_user_secret=rds.CfnDBInstance.MasterUserSecretProperty(
                    kms_key_id="kmsKeyId",
                    secret_arn="secretArn"
                ),
                max_allocated_storage=123,
                monitoring_interval=123,
                monitoring_role_arn="monitoringRoleArn",
                multi_az=False,
                nchar_character_set_name="ncharCharacterSetName",
                network_type="networkType",
                option_group_name="optionGroupName",
                performance_insights_kms_key_id="performanceInsightsKmsKeyId",
                performance_insights_retention_period=123,
                port="port",
                preferred_backup_window="preferredBackupWindow",
                preferred_maintenance_window="preferredMaintenanceWindow",
                processor_features=[rds.CfnDBInstance.ProcessorFeatureProperty(
                    name="name",
                    value="value"
                )],
                promotion_tier=123,
                publicly_accessible=False,
                replica_mode="replicaMode",
                restore_time="restoreTime",
                source_db_cluster_identifier="sourceDbClusterIdentifier",
                source_db_instance_automated_backups_arn="sourceDbInstanceAutomatedBackupsArn",
                source_db_instance_identifier="sourceDbInstanceIdentifier",
                source_dbi_resource_id="sourceDbiResourceId",
                source_region="sourceRegion",
                storage_encrypted=False,
                storage_throughput=123,
                storage_type="storageType",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                timezone="timezone",
                use_default_processor_features=False,
                use_latest_restorable_time=False,
                vpc_security_groups=["vpcSecurityGroups"]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cbec2b622ae3e8c6fd02ef8a6a19a85d6618c55f9591759ffcab13f8f280fd92)
            check_type(argname="argument allocated_storage", value=allocated_storage, expected_type=type_hints["allocated_storage"])
            check_type(argname="argument allow_major_version_upgrade", value=allow_major_version_upgrade, expected_type=type_hints["allow_major_version_upgrade"])
            check_type(argname="argument associated_roles", value=associated_roles, expected_type=type_hints["associated_roles"])
            check_type(argname="argument auto_minor_version_upgrade", value=auto_minor_version_upgrade, expected_type=type_hints["auto_minor_version_upgrade"])
            check_type(argname="argument availability_zone", value=availability_zone, expected_type=type_hints["availability_zone"])
            check_type(argname="argument backup_retention_period", value=backup_retention_period, expected_type=type_hints["backup_retention_period"])
            check_type(argname="argument ca_certificate_identifier", value=ca_certificate_identifier, expected_type=type_hints["ca_certificate_identifier"])
            check_type(argname="argument certificate_details", value=certificate_details, expected_type=type_hints["certificate_details"])
            check_type(argname="argument certificate_rotation_restart", value=certificate_rotation_restart, expected_type=type_hints["certificate_rotation_restart"])
            check_type(argname="argument character_set_name", value=character_set_name, expected_type=type_hints["character_set_name"])
            check_type(argname="argument copy_tags_to_snapshot", value=copy_tags_to_snapshot, expected_type=type_hints["copy_tags_to_snapshot"])
            check_type(argname="argument custom_iam_instance_profile", value=custom_iam_instance_profile, expected_type=type_hints["custom_iam_instance_profile"])
            check_type(argname="argument db_cluster_identifier", value=db_cluster_identifier, expected_type=type_hints["db_cluster_identifier"])
            check_type(argname="argument db_cluster_snapshot_identifier", value=db_cluster_snapshot_identifier, expected_type=type_hints["db_cluster_snapshot_identifier"])
            check_type(argname="argument db_instance_class", value=db_instance_class, expected_type=type_hints["db_instance_class"])
            check_type(argname="argument db_instance_identifier", value=db_instance_identifier, expected_type=type_hints["db_instance_identifier"])
            check_type(argname="argument db_name", value=db_name, expected_type=type_hints["db_name"])
            check_type(argname="argument db_parameter_group_name", value=db_parameter_group_name, expected_type=type_hints["db_parameter_group_name"])
            check_type(argname="argument db_security_groups", value=db_security_groups, expected_type=type_hints["db_security_groups"])
            check_type(argname="argument db_snapshot_identifier", value=db_snapshot_identifier, expected_type=type_hints["db_snapshot_identifier"])
            check_type(argname="argument db_subnet_group_name", value=db_subnet_group_name, expected_type=type_hints["db_subnet_group_name"])
            check_type(argname="argument delete_automated_backups", value=delete_automated_backups, expected_type=type_hints["delete_automated_backups"])
            check_type(argname="argument deletion_protection", value=deletion_protection, expected_type=type_hints["deletion_protection"])
            check_type(argname="argument domain", value=domain, expected_type=type_hints["domain"])
            check_type(argname="argument domain_iam_role_name", value=domain_iam_role_name, expected_type=type_hints["domain_iam_role_name"])
            check_type(argname="argument enable_cloudwatch_logs_exports", value=enable_cloudwatch_logs_exports, expected_type=type_hints["enable_cloudwatch_logs_exports"])
            check_type(argname="argument enable_iam_database_authentication", value=enable_iam_database_authentication, expected_type=type_hints["enable_iam_database_authentication"])
            check_type(argname="argument enable_performance_insights", value=enable_performance_insights, expected_type=type_hints["enable_performance_insights"])
            check_type(argname="argument endpoint", value=endpoint, expected_type=type_hints["endpoint"])
            check_type(argname="argument engine", value=engine, expected_type=type_hints["engine"])
            check_type(argname="argument engine_version", value=engine_version, expected_type=type_hints["engine_version"])
            check_type(argname="argument iops", value=iops, expected_type=type_hints["iops"])
            check_type(argname="argument kms_key_id", value=kms_key_id, expected_type=type_hints["kms_key_id"])
            check_type(argname="argument license_model", value=license_model, expected_type=type_hints["license_model"])
            check_type(argname="argument manage_master_user_password", value=manage_master_user_password, expected_type=type_hints["manage_master_user_password"])
            check_type(argname="argument master_username", value=master_username, expected_type=type_hints["master_username"])
            check_type(argname="argument master_user_password", value=master_user_password, expected_type=type_hints["master_user_password"])
            check_type(argname="argument master_user_secret", value=master_user_secret, expected_type=type_hints["master_user_secret"])
            check_type(argname="argument max_allocated_storage", value=max_allocated_storage, expected_type=type_hints["max_allocated_storage"])
            check_type(argname="argument monitoring_interval", value=monitoring_interval, expected_type=type_hints["monitoring_interval"])
            check_type(argname="argument monitoring_role_arn", value=monitoring_role_arn, expected_type=type_hints["monitoring_role_arn"])
            check_type(argname="argument multi_az", value=multi_az, expected_type=type_hints["multi_az"])
            check_type(argname="argument nchar_character_set_name", value=nchar_character_set_name, expected_type=type_hints["nchar_character_set_name"])
            check_type(argname="argument network_type", value=network_type, expected_type=type_hints["network_type"])
            check_type(argname="argument option_group_name", value=option_group_name, expected_type=type_hints["option_group_name"])
            check_type(argname="argument performance_insights_kms_key_id", value=performance_insights_kms_key_id, expected_type=type_hints["performance_insights_kms_key_id"])
            check_type(argname="argument performance_insights_retention_period", value=performance_insights_retention_period, expected_type=type_hints["performance_insights_retention_period"])
            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
            check_type(argname="argument preferred_backup_window", value=preferred_backup_window, expected_type=type_hints["preferred_backup_window"])
            check_type(argname="argument preferred_maintenance_window", value=preferred_maintenance_window, expected_type=type_hints["preferred_maintenance_window"])
            check_type(argname="argument processor_features", value=processor_features, expected_type=type_hints["processor_features"])
            check_type(argname="argument promotion_tier", value=promotion_tier, expected_type=type_hints["promotion_tier"])
            check_type(argname="argument publicly_accessible", value=publicly_accessible, expected_type=type_hints["publicly_accessible"])
            check_type(argname="argument replica_mode", value=replica_mode, expected_type=type_hints["replica_mode"])
            check_type(argname="argument restore_time", value=restore_time, expected_type=type_hints["restore_time"])
            check_type(argname="argument source_db_cluster_identifier", value=source_db_cluster_identifier, expected_type=type_hints["source_db_cluster_identifier"])
            check_type(argname="argument source_db_instance_automated_backups_arn", value=source_db_instance_automated_backups_arn, expected_type=type_hints["source_db_instance_automated_backups_arn"])
            check_type(argname="argument source_db_instance_identifier", value=source_db_instance_identifier, expected_type=type_hints["source_db_instance_identifier"])
            check_type(argname="argument source_dbi_resource_id", value=source_dbi_resource_id, expected_type=type_hints["source_dbi_resource_id"])
            check_type(argname="argument source_region", value=source_region, expected_type=type_hints["source_region"])
            check_type(argname="argument storage_encrypted", value=storage_encrypted, expected_type=type_hints["storage_encrypted"])
            check_type(argname="argument storage_throughput", value=storage_throughput, expected_type=type_hints["storage_throughput"])
            check_type(argname="argument storage_type", value=storage_type, expected_type=type_hints["storage_type"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument timezone", value=timezone, expected_type=type_hints["timezone"])
            check_type(argname="argument use_default_processor_features", value=use_default_processor_features, expected_type=type_hints["use_default_processor_features"])
            check_type(argname="argument use_latest_restorable_time", value=use_latest_restorable_time, expected_type=type_hints["use_latest_restorable_time"])
            check_type(argname="argument vpc_security_groups", value=vpc_security_groups, expected_type=type_hints["vpc_security_groups"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if allocated_storage is not None:
            self._values["allocated_storage"] = allocated_storage
        if allow_major_version_upgrade is not None:
            self._values["allow_major_version_upgrade"] = allow_major_version_upgrade
        if associated_roles is not None:
            self._values["associated_roles"] = associated_roles
        if auto_minor_version_upgrade is not None:
            self._values["auto_minor_version_upgrade"] = auto_minor_version_upgrade
        if availability_zone is not None:
            self._values["availability_zone"] = availability_zone
        if backup_retention_period is not None:
            self._values["backup_retention_period"] = backup_retention_period
        if ca_certificate_identifier is not None:
            self._values["ca_certificate_identifier"] = ca_certificate_identifier
        if certificate_details is not None:
            self._values["certificate_details"] = certificate_details
        if certificate_rotation_restart is not None:
            self._values["certificate_rotation_restart"] = certificate_rotation_restart
        if character_set_name is not None:
            self._values["character_set_name"] = character_set_name
        if copy_tags_to_snapshot is not None:
            self._values["copy_tags_to_snapshot"] = copy_tags_to_snapshot
        if custom_iam_instance_profile is not None:
            self._values["custom_iam_instance_profile"] = custom_iam_instance_profile
        if db_cluster_identifier is not None:
            self._values["db_cluster_identifier"] = db_cluster_identifier
        if db_cluster_snapshot_identifier is not None:
            self._values["db_cluster_snapshot_identifier"] = db_cluster_snapshot_identifier
        if db_instance_class is not None:
            self._values["db_instance_class"] = db_instance_class
        if db_instance_identifier is not None:
            self._values["db_instance_identifier"] = db_instance_identifier
        if db_name is not None:
            self._values["db_name"] = db_name
        if db_parameter_group_name is not None:
            self._values["db_parameter_group_name"] = db_parameter_group_name
        if db_security_groups is not None:
            self._values["db_security_groups"] = db_security_groups
        if db_snapshot_identifier is not None:
            self._values["db_snapshot_identifier"] = db_snapshot_identifier
        if db_subnet_group_name is not None:
            self._values["db_subnet_group_name"] = db_subnet_group_name
        if delete_automated_backups is not None:
            self._values["delete_automated_backups"] = delete_automated_backups
        if deletion_protection is not None:
            self._values["deletion_protection"] = deletion_protection
        if domain is not None:
            self._values["domain"] = domain
        if domain_iam_role_name is not None:
            self._values["domain_iam_role_name"] = domain_iam_role_name
        if enable_cloudwatch_logs_exports is not None:
            self._values["enable_cloudwatch_logs_exports"] = enable_cloudwatch_logs_exports
        if enable_iam_database_authentication is not None:
            self._values["enable_iam_database_authentication"] = enable_iam_database_authentication
        if enable_performance_insights is not None:
            self._values["enable_performance_insights"] = enable_performance_insights
        if endpoint is not None:
            self._values["endpoint"] = endpoint
        if engine is not None:
            self._values["engine"] = engine
        if engine_version is not None:
            self._values["engine_version"] = engine_version
        if iops is not None:
            self._values["iops"] = iops
        if kms_key_id is not None:
            self._values["kms_key_id"] = kms_key_id
        if license_model is not None:
            self._values["license_model"] = license_model
        if manage_master_user_password is not None:
            self._values["manage_master_user_password"] = manage_master_user_password
        if master_username is not None:
            self._values["master_username"] = master_username
        if master_user_password is not None:
            self._values["master_user_password"] = master_user_password
        if master_user_secret is not None:
            self._values["master_user_secret"] = master_user_secret
        if max_allocated_storage is not None:
            self._values["max_allocated_storage"] = max_allocated_storage
        if monitoring_interval is not None:
            self._values["monitoring_interval"] = monitoring_interval
        if monitoring_role_arn is not None:
            self._values["monitoring_role_arn"] = monitoring_role_arn
        if multi_az is not None:
            self._values["multi_az"] = multi_az
        if nchar_character_set_name is not None:
            self._values["nchar_character_set_name"] = nchar_character_set_name
        if network_type is not None:
            self._values["network_type"] = network_type
        if option_group_name is not None:
            self._values["option_group_name"] = option_group_name
        if performance_insights_kms_key_id is not None:
            self._values["performance_insights_kms_key_id"] = performance_insights_kms_key_id
        if performance_insights_retention_period is not None:
            self._values["performance_insights_retention_period"] = performance_insights_retention_period
        if port is not None:
            self._values["port"] = port
        if preferred_backup_window is not None:
            self._values["preferred_backup_window"] = preferred_backup_window
        if preferred_maintenance_window is not None:
            self._values["preferred_maintenance_window"] = preferred_maintenance_window
        if processor_features is not None:
            self._values["processor_features"] = processor_features
        if promotion_tier is not None:
            self._values["promotion_tier"] = promotion_tier
        if publicly_accessible is not None:
            self._values["publicly_accessible"] = publicly_accessible
        if replica_mode is not None:
            self._values["replica_mode"] = replica_mode
        if restore_time is not None:
            self._values["restore_time"] = restore_time
        if source_db_cluster_identifier is not None:
            self._values["source_db_cluster_identifier"] = source_db_cluster_identifier
        if source_db_instance_automated_backups_arn is not None:
            self._values["source_db_instance_automated_backups_arn"] = source_db_instance_automated_backups_arn
        if source_db_instance_identifier is not None:
            self._values["source_db_instance_identifier"] = source_db_instance_identifier
        if source_dbi_resource_id is not None:
            self._values["source_dbi_resource_id"] = source_dbi_resource_id
        if source_region is not None:
            self._values["source_region"] = source_region
        if storage_encrypted is not None:
            self._values["storage_encrypted"] = storage_encrypted
        if storage_throughput is not None:
            self._values["storage_throughput"] = storage_throughput
        if storage_type is not None:
            self._values["storage_type"] = storage_type
        if tags is not None:
            self._values["tags"] = tags
        if timezone is not None:
            self._values["timezone"] = timezone
        if use_default_processor_features is not None:
            self._values["use_default_processor_features"] = use_default_processor_features
        if use_latest_restorable_time is not None:
            self._values["use_latest_restorable_time"] = use_latest_restorable_time
        if vpc_security_groups is not None:
            self._values["vpc_security_groups"] = vpc_security_groups

    @builtins.property
    def allocated_storage(self) -> typing.Optional[builtins.str]:
        '''The amount of storage in gibibytes (GiB) to be initially allocated for the database instance.

        .. epigraph::

           If any value is set in the ``Iops`` parameter, ``AllocatedStorage`` must be at least 100 GiB, which corresponds to the minimum Iops value of 1,000. If you increase the ``Iops`` value (in 1,000 IOPS increments), then you must also increase the ``AllocatedStorage`` value (in 100-GiB increments).

        *Amazon Aurora*

        Not applicable. Aurora cluster volumes automatically grow as the amount of data in your database increases, though you are only charged for the space that you use in an Aurora cluster volume.

        *MySQL*

        Constraints to the amount of storage for each storage type are the following:

        - General Purpose (SSD) storage (gp2): Must be an integer from 20 to 65536.
        - Provisioned IOPS storage (io1): Must be an integer from 100 to 65536.
        - Magnetic storage (standard): Must be an integer from 5 to 3072.

        *MariaDB*

        Constraints to the amount of storage for each storage type are the following:

        - General Purpose (SSD) storage (gp2): Must be an integer from 20 to 65536.
        - Provisioned IOPS storage (io1): Must be an integer from 100 to 65536.
        - Magnetic storage (standard): Must be an integer from 5 to 3072.

        *PostgreSQL*

        Constraints to the amount of storage for each storage type are the following:

        - General Purpose (SSD) storage (gp2): Must be an integer from 20 to 65536.
        - Provisioned IOPS storage (io1): Must be an integer from 100 to 65536.
        - Magnetic storage (standard): Must be an integer from 5 to 3072.

        *Oracle*

        Constraints to the amount of storage for each storage type are the following:

        - General Purpose (SSD) storage (gp2): Must be an integer from 20 to 65536.
        - Provisioned IOPS storage (io1): Must be an integer from 100 to 65536.
        - Magnetic storage (standard): Must be an integer from 10 to 3072.

        *SQL Server*

        Constraints to the amount of storage for each storage type are the following:

        - General Purpose (SSD) storage (gp2):
        - Enterprise and Standard editions: Must be an integer from 20 to 16384.
        - Web and Express editions: Must be an integer from 20 to 16384.
        - Provisioned IOPS storage (io1):
        - Enterprise and Standard editions: Must be an integer from 20 to 16384.
        - Web and Express editions: Must be an integer from 20 to 16384.
        - Magnetic storage (standard):
        - Enterprise and Standard editions: Must be an integer from 20 to 1024.
        - Web and Express editions: Must be an integer from 20 to 1024.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-allocatedstorage
        '''
        result = self._values.get("allocated_storage")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def allow_major_version_upgrade(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''A value that indicates whether major version upgrades are allowed.

        Changing this parameter doesn't result in an outage and the change is asynchronously applied as soon as possible.

        Constraints: Major version upgrades must be allowed when specifying a value for the ``EngineVersion`` parameter that is a different major version than the DB instance's current version.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-allowmajorversionupgrade
        '''
        result = self._values.get("allow_major_version_upgrade")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], result)

    @builtins.property
    def associated_roles(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_a771d0ef, typing.List[typing.Union[CfnDBInstance.DBInstanceRoleProperty, _IResolvable_a771d0ef]]]]:
        '''The AWS Identity and Access Management (IAM) roles associated with the DB instance.

        *Amazon Aurora*

        Not applicable. The associated roles are managed by the DB cluster.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-associatedroles
        '''
        result = self._values.get("associated_roles")
        return typing.cast(typing.Optional[typing.Union[_IResolvable_a771d0ef, typing.List[typing.Union[CfnDBInstance.DBInstanceRoleProperty, _IResolvable_a771d0ef]]]], result)

    @builtins.property
    def auto_minor_version_upgrade(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''A value that indicates whether minor engine upgrades are applied automatically to the DB instance during the maintenance window.

        By default, minor engine upgrades are applied automatically.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-autominorversionupgrade
        '''
        result = self._values.get("auto_minor_version_upgrade")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], result)

    @builtins.property
    def availability_zone(self) -> typing.Optional[builtins.str]:
        '''The Availability Zone (AZ) where the database will be created.

        For information on AWS Regions and Availability Zones, see `Regions and Availability Zones <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.RegionsAndAvailabilityZones.html>`_ .

        *Amazon Aurora*

        Each Aurora DB cluster hosts copies of its storage in three separate Availability Zones. Specify one of these Availability Zones. Aurora automatically chooses an appropriate Availability Zone if you don't specify one.

        Default: A random, system-chosen Availability Zone in the endpoint's AWS Region .

        Example: ``us-east-1d``

        Constraint: The ``AvailabilityZone`` parameter can't be specified if the DB instance is a Multi-AZ deployment. The specified Availability Zone must be in the same AWS Region as the current endpoint.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-availabilityzone
        '''
        result = self._values.get("availability_zone")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def backup_retention_period(self) -> typing.Optional[jsii.Number]:
        '''The number of days for which automated backups are retained.

        Setting this parameter to a positive number enables backups. Setting this parameter to 0 disables automated backups.

        *Amazon Aurora*

        Not applicable. The retention period for automated backups is managed by the DB cluster.

        Default: 1

        Constraints:

        - Must be a value from 0 to 35
        - Can't be set to 0 if the DB instance is a source to read replicas

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-backupretentionperiod
        '''
        result = self._values.get("backup_retention_period")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def ca_certificate_identifier(self) -> typing.Optional[builtins.str]:
        '''The identifier of the CA certificate for this DB instance.

        .. epigraph::

           Specifying or updating this property triggers a reboot.

        For more information about CA certificate identifiers for RDS DB engines, see `Rotating Your SSL/TLS Certificate <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.SSL-certificate-rotation.html>`_ in the *Amazon RDS User Guide* .

        For more information about CA certificate identifiers for Aurora DB engines, see `Rotating Your SSL/TLS Certificate <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/UsingWithRDS.SSL-certificate-rotation.html>`_ in the *Amazon Aurora User Guide* .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-cacertificateidentifier
        '''
        result = self._values.get("ca_certificate_identifier")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def certificate_details(
        self,
    ) -> typing.Optional[typing.Union[CfnDBInstance.CertificateDetailsProperty, _IResolvable_a771d0ef]]:
        '''The details of the DB instance's server certificate.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-certificatedetails
        '''
        result = self._values.get("certificate_details")
        return typing.cast(typing.Optional[typing.Union[CfnDBInstance.CertificateDetailsProperty, _IResolvable_a771d0ef]], result)

    @builtins.property
    def certificate_rotation_restart(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''A value that indicates whether the DB instance is restarted when you rotate your SSL/TLS certificate.

        By default, the DB instance is restarted when you rotate your SSL/TLS certificate. The certificate is not updated until the DB instance is restarted.
        .. epigraph::

           Set this parameter only if you are *not* using SSL/TLS to connect to the DB instance.

        If you are using SSL/TLS to connect to the DB instance, follow the appropriate instructions for your DB engine to rotate your SSL/TLS certificate:

        - For more information about rotating your SSL/TLS certificate for RDS DB engines, see `Rotating Your SSL/TLS Certificate. <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.SSL-certificate-rotation.html>`_ in the *Amazon RDS User Guide.*
        - For more information about rotating your SSL/TLS certificate for Aurora DB engines, see `Rotating Your SSL/TLS Certificate <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/UsingWithRDS.SSL-certificate-rotation.html>`_ in the *Amazon Aurora User Guide* .

        This setting doesn't apply to RDS Custom.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-certificaterotationrestart
        '''
        result = self._values.get("certificate_rotation_restart")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], result)

    @builtins.property
    def character_set_name(self) -> typing.Optional[builtins.str]:
        '''For supported engines, indicates that the DB instance should be associated with the specified character set.

        *Amazon Aurora*

        Not applicable. The character set is managed by the DB cluster. For more information, see `AWS::RDS::DBCluster <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html>`_ .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-charactersetname
        '''
        result = self._values.get("character_set_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def copy_tags_to_snapshot(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''A value that indicates whether to copy tags from the DB instance to snapshots of the DB instance.

        By default, tags are not copied.

        *Amazon Aurora*

        Not applicable. Copying tags to snapshots is managed by the DB cluster. Setting this value for an Aurora DB instance has no effect on the DB cluster setting.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-copytagstosnapshot
        '''
        result = self._values.get("copy_tags_to_snapshot")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], result)

    @builtins.property
    def custom_iam_instance_profile(self) -> typing.Optional[builtins.str]:
        '''The instance profile associated with the underlying Amazon EC2 instance of an RDS Custom DB instance.

        The instance profile must meet the following requirements:

        - The profile must exist in your account.
        - The profile must have an IAM role that Amazon EC2 has permissions to assume.
        - The instance profile name and the associated IAM role name must start with the prefix ``AWSRDSCustom`` .

        For the list of permissions required for the IAM role, see `Configure IAM and your VPC <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/custom-setup-orcl.html#custom-setup-orcl.iam-vpc>`_ in the *Amazon RDS User Guide* .

        This setting is required for RDS Custom.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-customiaminstanceprofile
        '''
        result = self._values.get("custom_iam_instance_profile")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def db_cluster_identifier(self) -> typing.Optional[builtins.str]:
        '''The identifier of the DB cluster that the instance will belong to.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-dbclusteridentifier
        '''
        result = self._values.get("db_cluster_identifier")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def db_cluster_snapshot_identifier(self) -> typing.Optional[builtins.str]:
        '''The identifier for the RDS for MySQL Multi-AZ DB cluster snapshot to restore from.

        For more information on Multi-AZ DB clusters, see `Multi-AZ DB cluster deployments <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/multi-az-db-clusters-concepts.html>`_ in the *Amazon RDS User Guide* .

        Constraints:

        - Must match the identifier of an existing Multi-AZ DB cluster snapshot.
        - Can't be specified when ``DBSnapshotIdentifier`` is specified.
        - Must be specified when ``DBSnapshotIdentifier`` isn't specified.
        - If you are restoring from a shared manual Multi-AZ DB cluster snapshot, the ``DBClusterSnapshotIdentifier`` must be the ARN of the shared snapshot.
        - Can't be the identifier of an Aurora DB cluster snapshot.
        - Can't be the identifier of an RDS for PostgreSQL Multi-AZ DB cluster snapshot.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-dbclustersnapshotidentifier
        '''
        result = self._values.get("db_cluster_snapshot_identifier")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def db_instance_class(self) -> typing.Optional[builtins.str]:
        '''The compute and memory capacity of the DB instance, for example, ``db.m4.large`` . Not all DB instance classes are available in all AWS Regions, or for all database engines.

        For the full list of DB instance classes, and availability for your engine, see `DB Instance Class <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html>`_ in the *Amazon RDS User Guide.* For more information about DB instance class pricing and AWS Region support for DB instance classes, see `Amazon RDS Pricing <https://docs.aws.amazon.com/rds/pricing/>`_ .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-dbinstanceclass
        '''
        result = self._values.get("db_instance_class")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def db_instance_identifier(self) -> typing.Optional[builtins.str]:
        '''A name for the DB instance.

        If you specify a name, AWS CloudFormation converts it to lowercase. If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the DB instance. For more information, see `Name Type <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html>`_ .

        For information about constraints that apply to DB instance identifiers, see `Naming constraints in Amazon RDS <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Limits.html#RDS_Limits.Constraints>`_ in the *Amazon RDS User Guide* .
        .. epigraph::

           If you specify a name, you can't perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-dbinstanceidentifier
        '''
        result = self._values.get("db_instance_identifier")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def db_name(self) -> typing.Optional[builtins.str]:
        '''The meaning of this parameter differs according to the database engine you use.

        .. epigraph::

           If you specify the ``[DBSnapshotIdentifier](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-database-instance.html#cfn-rds-dbinstance-dbsnapshotidentifier)`` property, this property only applies to RDS for Oracle.

        *Amazon Aurora*

        Not applicable. The database name is managed by the DB cluster.

        *MySQL*

        The name of the database to create when the DB instance is created. If this parameter is not specified, no database is created in the DB instance.

        Constraints:

        - Must contain 1 to 64 letters or numbers.
        - Can't be a word reserved by the specified database engine

        *MariaDB*

        The name of the database to create when the DB instance is created. If this parameter is not specified, no database is created in the DB instance.

        Constraints:

        - Must contain 1 to 64 letters or numbers.
        - Can't be a word reserved by the specified database engine

        *PostgreSQL*

        The name of the database to create when the DB instance is created. If this parameter is not specified, the default ``postgres`` database is created in the DB instance.

        Constraints:

        - Must begin with a letter. Subsequent characters can be letters, underscores, or digits (0-9).
        - Must contain 1 to 63 characters.
        - Can't be a word reserved by the specified database engine

        *Oracle*

        The Oracle System ID (SID) of the created DB instance. If you specify ``null`` , the default value ``ORCL`` is used. You can't specify the string NULL, or any other reserved word, for ``DBName`` .

        Default: ``ORCL``

        Constraints:

        - Can't be longer than 8 characters

        *SQL Server*

        Not applicable. Must be null.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-dbname
        '''
        result = self._values.get("db_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def db_parameter_group_name(self) -> typing.Optional[builtins.str]:
        '''The name of an existing DB parameter group or a reference to an `AWS::RDS::DBParameterGroup <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbparametergroup.html>`_ resource created in the template.

        To list all of the available DB parameter group names, use the following command:

        ``aws rds describe-db-parameter-groups --query "DBParameterGroups[].DBParameterGroupName" --output text``
        .. epigraph::

           If any of the data members of the referenced parameter group are changed during an update, the DB instance might need to be restarted, which causes some interruption. If the parameter group contains static parameters, whether they were changed or not, an update triggers a reboot.

        If you don't specify a value for ``DBParameterGroupName`` property, the default DB parameter group for the specified engine and engine version is used.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-dbparametergroupname
        '''
        result = self._values.get("db_parameter_group_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def db_security_groups(self) -> typing.Optional[typing.List[builtins.str]]:
        '''A list of the DB security groups to assign to the DB instance.

        The list can include both the name of existing DB security groups or references to AWS::RDS::DBSecurityGroup resources created in the template.

        If you set DBSecurityGroups, you must not set VPCSecurityGroups, and vice versa. Also, note that the DBSecurityGroups property exists only for backwards compatibility with older regions and is no longer recommended for providing security information to an RDS DB instance. Instead, use VPCSecurityGroups.
        .. epigraph::

           If you specify this property, AWS CloudFormation sends only the following properties (if specified) to Amazon RDS during create operations:

           - ``AllocatedStorage``
           - ``AutoMinorVersionUpgrade``
           - ``AvailabilityZone``
           - ``BackupRetentionPeriod``
           - ``CharacterSetName``
           - ``DBInstanceClass``
           - ``DBName``
           - ``DBParameterGroupName``
           - ``DBSecurityGroups``
           - ``DBSubnetGroupName``
           - ``Engine``
           - ``EngineVersion``
           - ``Iops``
           - ``LicenseModel``
           - ``MasterUsername``
           - ``MasterUserPassword``
           - ``MultiAZ``
           - ``OptionGroupName``
           - ``PreferredBackupWindow``
           - ``PreferredMaintenanceWindow``

           All other properties are ignored. Specify a virtual private cloud (VPC) security group if you want to submit other properties, such as ``StorageType`` , ``StorageEncrypted`` , or ``KmsKeyId`` . If you're already using the ``DBSecurityGroups`` property, you can't use these other properties by updating your DB instance to use a VPC security group. You must recreate the DB instance.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-dbsecuritygroups
        '''
        result = self._values.get("db_security_groups")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def db_snapshot_identifier(self) -> typing.Optional[builtins.str]:
        '''The name or Amazon Resource Name (ARN) of the DB snapshot that's used to restore the DB instance.

        If you're restoring from a shared manual DB snapshot, you must specify the ARN of the snapshot.

        By specifying this property, you can create a DB instance from the specified DB snapshot. If the ``DBSnapshotIdentifier`` property is an empty string or the ``AWS::RDS::DBInstance`` declaration has no ``DBSnapshotIdentifier`` property, AWS CloudFormation creates a new database. If the property contains a value (other than an empty string), AWS CloudFormation creates a database from the specified snapshot. If a snapshot with the specified name doesn't exist, AWS CloudFormation can't create the database and it rolls back the stack.

        Some DB instance properties aren't valid when you restore from a snapshot, such as the ``MasterUsername`` and ``MasterUserPassword`` properties. For information about the properties that you can specify, see the ``RestoreDBInstanceFromDBSnapshot`` action in the *Amazon RDS API Reference* .

        After you restore a DB instance with a ``DBSnapshotIdentifier`` property, you must specify the same ``DBSnapshotIdentifier`` property for any future updates to the DB instance. When you specify this property for an update, the DB instance is not restored from the DB snapshot again, and the data in the database is not changed. However, if you don't specify the ``DBSnapshotIdentifier`` property, an empty DB instance is created, and the original DB instance is deleted. If you specify a property that is different from the previous snapshot restore property, a new DB instance is restored from the specified ``DBSnapshotIdentifier`` property, and the original DB instance is deleted.

        If you specify the ``DBSnapshotIdentifier`` property to restore a DB instance (as opposed to specifying it for DB instance updates), then don't specify the following properties:

        - ``CharacterSetName``
        - ``DBClusterIdentifier``
        - ``DBName``
        - ``DeleteAutomatedBackups``
        - ``EnablePerformanceInsights``
        - ``KmsKeyId``
        - ``MasterUsername``
        - ``MasterUserPassword``
        - ``PerformanceInsightsKMSKeyId``
        - ``PerformanceInsightsRetentionPeriod``
        - ``PromotionTier``
        - ``SourceDBInstanceIdentifier``
        - ``SourceRegion``
        - ``StorageEncrypted`` (for an encrypted snapshot)
        - ``Timezone``

        *Amazon Aurora*

        Not applicable. Snapshot restore is managed by the DB cluster.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-dbsnapshotidentifier
        '''
        result = self._values.get("db_snapshot_identifier")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def db_subnet_group_name(self) -> typing.Optional[builtins.str]:
        '''A DB subnet group to associate with the DB instance.

        If you update this value, the new subnet group must be a subnet group in a new VPC.

        If there's no DB subnet group, then the DB instance isn't a VPC DB instance.

        For more information about using Amazon RDS in a VPC, see `Using Amazon RDS with Amazon Virtual Private Cloud (VPC) <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_VPC.html>`_ in the *Amazon RDS User Guide* .

        *Amazon Aurora*

        Not applicable. The DB subnet group is managed by the DB cluster. If specified, the setting must match the DB cluster setting.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-dbsubnetgroupname
        '''
        result = self._values.get("db_subnet_group_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def delete_automated_backups(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''A value that indicates whether to remove automated backups immediately after the DB instance is deleted.

        This parameter isn't case-sensitive. The default is to remove automated backups immediately after the DB instance is deleted.

        *Amazon Aurora*

        Not applicable. When you delete a DB cluster, all automated backups for that DB cluster are deleted and can't be recovered. Manual DB cluster snapshots of the DB cluster are not deleted.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-deleteautomatedbackups
        '''
        result = self._values.get("delete_automated_backups")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], result)

    @builtins.property
    def deletion_protection(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''A value that indicates whether the DB instance has deletion protection enabled.

        The database can't be deleted when deletion protection is enabled. By default, deletion protection is disabled. For more information, see `Deleting a DB Instance <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_DeleteInstance.html>`_ .

        *Amazon Aurora*

        Not applicable. You can enable or disable deletion protection for the DB cluster. For more information, see ``CreateDBCluster`` . DB instances in a DB cluster can be deleted even when deletion protection is enabled for the DB cluster.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-deletionprotection
        '''
        result = self._values.get("deletion_protection")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], result)

    @builtins.property
    def domain(self) -> typing.Optional[builtins.str]:
        '''The Active Directory directory ID to create the DB instance in.

        Currently, only Microsoft SQL Server, Oracle, and PostgreSQL DB instances can be created in an Active Directory Domain.

        For more information, see `Kerberos Authentication <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/kerberos-authentication.html>`_ in the *Amazon RDS User Guide* .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-domain
        '''
        result = self._values.get("domain")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def domain_iam_role_name(self) -> typing.Optional[builtins.str]:
        '''Specify the name of the IAM role to be used when making API calls to the Directory Service.

        This setting doesn't apply to RDS Custom.

        *Amazon Aurora*

        Not applicable. The domain is managed by the DB cluster.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-domainiamrolename
        '''
        result = self._values.get("domain_iam_role_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_cloudwatch_logs_exports(
        self,
    ) -> typing.Optional[typing.List[builtins.str]]:
        '''The list of log types that need to be enabled for exporting to CloudWatch Logs.

        The values in the list depend on the DB engine being used. For more information, see `Publishing Database Logs to Amazon CloudWatch Logs <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_LogAccess.html#USER_LogAccess.Procedural.UploadtoCloudWatch>`_ in the *Amazon Relational Database Service User Guide* .

        *Amazon Aurora*

        Not applicable. CloudWatch Logs exports are managed by the DB cluster.

        *MariaDB*

        Valid values: ``audit`` , ``error`` , ``general`` , ``slowquery``

        *Microsoft SQL Server*

        Valid values: ``agent`` , ``error``

        *MySQL*

        Valid values: ``audit`` , ``error`` , ``general`` , ``slowquery``

        *Oracle*

        Valid values: ``alert`` , ``audit`` , ``listener`` , ``trace``

        *PostgreSQL*

        Valid values: ``postgresql`` , ``upgrade``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-enablecloudwatchlogsexports
        '''
        result = self._values.get("enable_cloudwatch_logs_exports")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def enable_iam_database_authentication(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''A value that indicates whether to enable mapping of AWS Identity and Access Management (IAM) accounts to database accounts.

        By default, mapping is disabled.

        This property is supported for RDS for MariaDB, RDS for MySQL, and RDS for PostgreSQL. For more information, see `IAM Database Authentication for MariaDB, MySQL, and PostgreSQL <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.IAMDBAuth.html>`_ in the *Amazon RDS User Guide.*

        *Amazon Aurora*

        Not applicable. Mapping AWS IAM accounts to database accounts is managed by the DB cluster.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-enableiamdatabaseauthentication
        '''
        result = self._values.get("enable_iam_database_authentication")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], result)

    @builtins.property
    def enable_performance_insights(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''A value that indicates whether to enable Performance Insights for the DB instance.

        For more information, see `Using Amazon Performance Insights <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PerfInsights.html>`_ in the *Amazon RDS User Guide* .

        This setting doesn't apply to RDS Custom.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-enableperformanceinsights
        '''
        result = self._values.get("enable_performance_insights")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], result)

    @builtins.property
    def endpoint(
        self,
    ) -> typing.Optional[typing.Union[CfnDBInstance.EndpointProperty, _IResolvable_a771d0ef]]:
        '''Specifies the connection endpoint.

        .. epigraph::

           The endpoint might not be shown for instances whose status is ``creating`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-endpoint
        '''
        result = self._values.get("endpoint")
        return typing.cast(typing.Optional[typing.Union[CfnDBInstance.EndpointProperty, _IResolvable_a771d0ef]], result)

    @builtins.property
    def engine(self) -> typing.Optional[builtins.str]:
        '''The name of the database engine that you want to use for this DB instance.

        .. epigraph::

           When you are creating a DB instance, the ``Engine`` property is required.

        Valid Values:

        - ``aurora-mysql`` (for Aurora MySQL DB instances)
        - ``aurora-postgresql`` (for Aurora PostgreSQL DB instances)
        - ``custom-oracle-ee`` (for RDS Custom for Oracle DB instances)
        - ``custom-oracle-ee-cdb`` (for RDS Custom for Oracle DB instances)
        - ``custom-sqlserver-ee`` (for RDS Custom for SQL Server DB instances)
        - ``custom-sqlserver-se`` (for RDS Custom for SQL Server DB instances)
        - ``custom-sqlserver-web`` (for RDS Custom for SQL Server DB instances)
        - ``mariadb``
        - ``mysql``
        - ``oracle-ee``
        - ``oracle-ee-cdb``
        - ``oracle-se2``
        - ``oracle-se2-cdb``
        - ``postgres``
        - ``sqlserver-ee``
        - ``sqlserver-se``
        - ``sqlserver-ex``
        - ``sqlserver-web``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-engine
        '''
        result = self._values.get("engine")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def engine_version(self) -> typing.Optional[builtins.str]:
        '''The version number of the database engine to use.

        For a list of valid engine versions, use the ``DescribeDBEngineVersions`` action.

        The following are the database engines and links to information about the major and minor versions that are available with Amazon RDS. Not every database engine is available for every AWS Region.

        *Amazon Aurora*

        Not applicable. The version number of the database engine to be used by the DB instance is managed by the DB cluster.

        *MariaDB*

        See `MariaDB on Amazon RDS Versions <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_MariaDB.html#MariaDB.Concepts.VersionMgmt>`_ in the *Amazon RDS User Guide.*

        *Microsoft SQL Server*

        See `Microsoft SQL Server Versions on Amazon RDS <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_SQLServer.html#SQLServer.Concepts.General.VersionSupport>`_ in the *Amazon RDS User Guide.*

        *MySQL*

        See `MySQL on Amazon RDS Versions <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_MySQL.html#MySQL.Concepts.VersionMgmt>`_ in the *Amazon RDS User Guide.*

        *Oracle*

        See `Oracle Database Engine Release Notes <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Appendix.Oracle.PatchComposition.html>`_ in the *Amazon RDS User Guide.*

        *PostgreSQL*

        See `Supported PostgreSQL Database Versions <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_PostgreSQL.html#PostgreSQL.Concepts.General.DBVersions>`_ in the *Amazon RDS User Guide.*

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-engineversion
        '''
        result = self._values.get("engine_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def iops(self) -> typing.Optional[jsii.Number]:
        '''The number of I/O operations per second (IOPS) that the database provisions.

        The value must be equal to or greater than 1000.

        If you specify this property, you must follow the range of allowed ratios of your requested IOPS rate to the amount of storage that you allocate (IOPS to allocated storage). For example, you can provision an Oracle database instance with 1000 IOPS and 200 GiB of storage (a ratio of 5:1), or specify 2000 IOPS with 200 GiB of storage (a ratio of 10:1). For more information, see `Amazon RDS Provisioned IOPS Storage to Improve Performance <https://docs.aws.amazon.com/AmazonRDS/latest/DeveloperGuide/CHAP_Storage.html#USER_PIOPS>`_ in the *Amazon RDS User Guide* .
        .. epigraph::

           If you specify ``io1`` for the ``StorageType`` property, then you must also specify the ``Iops`` property.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-iops
        '''
        result = self._values.get("iops")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def kms_key_id(self) -> typing.Optional[builtins.str]:
        '''The ARN of the AWS KMS key that's used to encrypt the DB instance, such as ``arn:aws:kms:us-east-1:012345678910:key/abcd1234-a123-456a-a12b-a123b4cd56ef`` .

        If you enable the StorageEncrypted property but don't specify this property, AWS CloudFormation uses the default KMS key. If you specify this property, you must set the StorageEncrypted property to true.

        If you specify the ``SourceDBInstanceIdentifier`` property, the value is inherited from the source DB instance if the read replica is created in the same region.

        If you create an encrypted read replica in a different AWS Region, then you must specify a KMS key for the destination AWS Region. KMS encryption keys are specific to the region that they're created in, and you can't use encryption keys from one region in another region.

        If you specify the ``SnapshotIdentifier`` property, the ``StorageEncrypted`` property value is inherited from the snapshot, and if the DB instance is encrypted, the specified ``KmsKeyId`` property is used.

        If you specify ``DBSecurityGroups`` , AWS CloudFormation ignores this property. To specify both a security group and this property, you must use a VPC security group. For more information about Amazon RDS and VPC, see `Using Amazon RDS with Amazon VPC <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_VPC.html>`_ in the *Amazon RDS User Guide* .

        *Amazon Aurora*

        Not applicable. The KMS key identifier is managed by the DB cluster.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-kmskeyid
        '''
        result = self._values.get("kms_key_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def license_model(self) -> typing.Optional[builtins.str]:
        '''License model information for this DB instance.

        Valid values:

        - Aurora MySQL - ``general-public-license``
        - Aurora PostgreSQL - ``postgresql-license``
        - MariaDB - ``general-public-license``
        - Microsoft SQL Server - ``license-included``
        - MySQL - ``general-public-license``
        - Oracle - ``bring-your-own-license`` or ``license-included``
        - PostgreSQL - ``postgresql-license``

        .. epigraph::

           If you've specified ``DBSecurityGroups`` and then you update the license model, AWS CloudFormation replaces the underlying DB instance. This will incur some interruptions to database availability.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-licensemodel
        '''
        result = self._values.get("license_model")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def manage_master_user_password(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''A value that indicates whether to manage the master user password with AWS Secrets Manager.

        For more information, see `Password management with AWS Secrets Manager <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-secrets-manager.html>`_ in the *Amazon RDS User Guide.*

        Constraints:

        - Can't manage the master user password with AWS Secrets Manager if ``MasterUserPassword`` is specified.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-managemasteruserpassword
        '''
        result = self._values.get("manage_master_user_password")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], result)

    @builtins.property
    def master_username(self) -> typing.Optional[builtins.str]:
        '''The master user name for the DB instance.

        .. epigraph::

           If you specify the ``SourceDBInstanceIdentifier`` or ``DBSnapshotIdentifier`` property, don't specify this property. The value is inherited from the source DB instance or snapshot.

        *Amazon Aurora*

        Not applicable. The name for the master user is managed by the DB cluster.

        *MariaDB*

        Constraints:

        - Required for MariaDB.
        - Must be 1 to 16 letters or numbers.
        - Can't be a reserved word for the chosen database engine.

        *Microsoft SQL Server*

        Constraints:

        - Required for SQL Server.
        - Must be 1 to 128 letters or numbers.
        - The first character must be a letter.
        - Can't be a reserved word for the chosen database engine.

        *MySQL*

        Constraints:

        - Required for MySQL.
        - Must be 1 to 16 letters or numbers.
        - First character must be a letter.
        - Can't be a reserved word for the chosen database engine.

        *Oracle*

        Constraints:

        - Required for Oracle.
        - Must be 1 to 30 letters or numbers.
        - First character must be a letter.
        - Can't be a reserved word for the chosen database engine.

        *PostgreSQL*

        Constraints:

        - Required for PostgreSQL.
        - Must be 1 to 63 letters or numbers.
        - First character must be a letter.
        - Can't be a reserved word for the chosen database engine.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-masterusername
        '''
        result = self._values.get("master_username")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def master_user_password(self) -> typing.Optional[builtins.str]:
        '''The password for the master user. The password can include any printable ASCII character except "/", """, or "@".

        *Amazon Aurora*

        Not applicable. The password for the master user is managed by the DB cluster.

        *MariaDB*

        Constraints: Must contain from 8 to 41 characters.

        *Microsoft SQL Server*

        Constraints: Must contain from 8 to 128 characters.

        *MySQL*

        Constraints: Must contain from 8 to 41 characters.

        *Oracle*

        Constraints: Must contain from 8 to 30 characters.

        *PostgreSQL*

        Constraints: Must contain from 8 to 128 characters.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-masteruserpassword
        '''
        result = self._values.get("master_user_password")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def master_user_secret(
        self,
    ) -> typing.Optional[typing.Union[CfnDBInstance.MasterUserSecretProperty, _IResolvable_a771d0ef]]:
        '''Contains the secret managed by RDS in AWS Secrets Manager for the master user password.

        For more information, see `Password management with AWS Secrets Manager <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-secrets-manager.html>`_ in the *Amazon RDS User Guide.*

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-masterusersecret
        '''
        result = self._values.get("master_user_secret")
        return typing.cast(typing.Optional[typing.Union[CfnDBInstance.MasterUserSecretProperty, _IResolvable_a771d0ef]], result)

    @builtins.property
    def max_allocated_storage(self) -> typing.Optional[jsii.Number]:
        '''The upper limit in gibibytes (GiB) to which Amazon RDS can automatically scale the storage of the DB instance.

        For more information about this setting, including limitations that apply to it, see `Managing capacity automatically with Amazon RDS storage autoscaling <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PIOPS.StorageTypes.html#USER_PIOPS.Autoscaling>`_ in the *Amazon RDS User Guide* .

        This setting doesn't apply to RDS Custom.

        *Amazon Aurora*

        Not applicable. Storage is managed by the DB cluster.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-maxallocatedstorage
        '''
        result = self._values.get("max_allocated_storage")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def monitoring_interval(self) -> typing.Optional[jsii.Number]:
        '''The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the DB instance.

        To disable collection of Enhanced Monitoring metrics, specify 0. The default is 0.

        If ``MonitoringRoleArn`` is specified, then you must set ``MonitoringInterval`` to a value other than 0.

        This setting doesn't apply to RDS Custom.

        Valid Values: ``0, 1, 5, 10, 15, 30, 60``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-monitoringinterval
        '''
        result = self._values.get("monitoring_interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def monitoring_role_arn(self) -> typing.Optional[builtins.str]:
        '''The ARN for the IAM role that permits RDS to send enhanced monitoring metrics to Amazon CloudWatch Logs.

        For example, ``arn:aws:iam:123456789012:role/emaccess`` . For information on creating a monitoring role, see `Setting Up and Enabling Enhanced Monitoring <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Monitoring.OS.html#USER_Monitoring.OS.Enabling>`_ in the *Amazon RDS User Guide* .

        If ``MonitoringInterval`` is set to a value other than 0, then you must supply a ``MonitoringRoleArn`` value.

        This setting doesn't apply to RDS Custom.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-monitoringrolearn
        '''
        result = self._values.get("monitoring_role_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def multi_az(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''Specifies whether the database instance is a Multi-AZ DB instance deployment.

        You can't set the ``AvailabilityZone`` parameter if the ``MultiAZ`` parameter is set to true.

        For more information, see `Multi-AZ deployments for high availability <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.MultiAZ.html>`_ in the *Amazon RDS User Guide* .

        *Amazon Aurora*

        Not applicable. Amazon Aurora storage is replicated across all of the Availability Zones and doesn't require the ``MultiAZ`` option to be set.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-multiaz
        '''
        result = self._values.get("multi_az")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], result)

    @builtins.property
    def nchar_character_set_name(self) -> typing.Optional[builtins.str]:
        '''The name of the NCHAR character set for the Oracle DB instance.

        This parameter doesn't apply to RDS Custom.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-ncharcharactersetname
        '''
        result = self._values.get("nchar_character_set_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def network_type(self) -> typing.Optional[builtins.str]:
        '''The network type of the DB instance.

        Valid values:

        - ``IPV4``
        - ``DUAL``

        The network type is determined by the ``DBSubnetGroup`` specified for the DB instance. A ``DBSubnetGroup`` can support only the IPv4 protocol or the IPv4 and IPv6 protocols ( ``DUAL`` ).

        For more information, see `Working with a DB instance in a VPC <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_VPC.WorkingWithRDSInstanceinaVPC.html>`_ in the *Amazon RDS User Guide.*

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-networktype
        '''
        result = self._values.get("network_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def option_group_name(self) -> typing.Optional[builtins.str]:
        '''Indicates that the DB instance should be associated with the specified option group.

        Permanent options, such as the TDE option for Oracle Advanced Security TDE, can't be removed from an option group. Also, that option group can't be removed from a DB instance once it is associated with a DB instance.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-optiongroupname
        '''
        result = self._values.get("option_group_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def performance_insights_kms_key_id(self) -> typing.Optional[builtins.str]:
        '''The AWS KMS key identifier for encryption of Performance Insights data.

        The KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key.

        If you do not specify a value for ``PerformanceInsightsKMSKeyId`` , then Amazon RDS uses your default KMS key. There is a default KMS key for your AWS account. Your AWS account has a different default KMS key for each AWS Region.

        For information about enabling Performance Insights, see `EnablePerformanceInsights <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-database-instance.html#cfn-rds-dbinstance-enableperformanceinsights>`_ .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-performanceinsightskmskeyid
        '''
        result = self._values.get("performance_insights_kms_key_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def performance_insights_retention_period(self) -> typing.Optional[jsii.Number]:
        '''The number of days to retain Performance Insights data. The default is 7 days. The following values are valid:.

        - 7
        - *month* * 31, where *month* is a number of months from 1-23
        - 731

        For example, the following values are valid:

        - 93 (3 months * 31)
        - 341 (11 months * 31)
        - 589 (19 months * 31)
        - 731

        If you specify a retention period such as 94, which isn't a valid value, RDS issues an error.

        This setting doesn't apply to RDS Custom.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-performanceinsightsretentionperiod
        '''
        result = self._values.get("performance_insights_retention_period")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def port(self) -> typing.Optional[builtins.str]:
        '''The port number on which the database accepts connections.

        *Amazon Aurora*

        Not applicable. The port number is managed by the DB cluster.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-port
        '''
        result = self._values.get("port")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def preferred_backup_window(self) -> typing.Optional[builtins.str]:
        '''The daily time range during which automated backups are created if automated backups are enabled, using the ``BackupRetentionPeriod`` parameter.

        For more information, see `Backup Window <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithAutomatedBackups.html#USER_WorkingWithAutomatedBackups.BackupWindow>`_ in the *Amazon RDS User Guide.*

        Constraints:

        - Must be in the format ``hh24:mi-hh24:mi`` .
        - Must be in Universal Coordinated Time (UTC).
        - Must not conflict with the preferred maintenance window.
        - Must be at least 30 minutes.

        *Amazon Aurora*

        Not applicable. The daily time range for creating automated backups is managed by the DB cluster.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-preferredbackupwindow
        '''
        result = self._values.get("preferred_backup_window")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def preferred_maintenance_window(self) -> typing.Optional[builtins.str]:
        '''The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC).

        Format: ``ddd:hh24:mi-ddd:hh24:mi``

        The default is a 30-minute window selected at random from an 8-hour block of time for each AWS Region, occurring on a random day of the week. To see the time blocks available, see `Adjusting the Preferred DB Instance Maintenance Window <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_UpgradeDBInstance.Maintenance.html#AdjustingTheMaintenanceWindow>`_ in the *Amazon RDS User Guide.*
        .. epigraph::

           This property applies when AWS CloudFormation initially creates the DB instance. If you use AWS CloudFormation to update the DB instance, those updates are applied immediately.

        Constraints: Minimum 30-minute window.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-preferredmaintenancewindow
        '''
        result = self._values.get("preferred_maintenance_window")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def processor_features(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_a771d0ef, typing.List[typing.Union[CfnDBInstance.ProcessorFeatureProperty, _IResolvable_a771d0ef]]]]:
        '''The number of CPU cores and the number of threads per core for the DB instance class of the DB instance.

        This setting doesn't apply to RDS Custom.

        *Amazon Aurora*

        Not applicable.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-processorfeatures
        '''
        result = self._values.get("processor_features")
        return typing.cast(typing.Optional[typing.Union[_IResolvable_a771d0ef, typing.List[typing.Union[CfnDBInstance.ProcessorFeatureProperty, _IResolvable_a771d0ef]]]], result)

    @builtins.property
    def promotion_tier(self) -> typing.Optional[jsii.Number]:
        '''A value that specifies the order in which an Aurora Replica is promoted to the primary instance after a failure of the existing primary instance.

        For more information, see `Fault Tolerance for an Aurora DB Cluster <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.Managing.Backups.html#Aurora.Managing.FaultTolerance>`_ in the *Amazon Aurora User Guide* .

        This setting doesn't apply to RDS Custom.

        Default: 1

        Valid Values: 0 - 15

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-promotiontier
        '''
        result = self._values.get("promotion_tier")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def publicly_accessible(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''Indicates whether the DB instance is an internet-facing instance.

        If you specify true, AWS CloudFormation creates an instance with a publicly resolvable DNS name, which resolves to a public IP address. If you specify false, AWS CloudFormation creates an internal instance with a DNS name that resolves to a private IP address.

        The default behavior value depends on your VPC setup and the database subnet group. For more information, see the ``PubliclyAccessible`` parameter in the `CreateDBInstance <https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_CreateDBInstance.html>`_ in the *Amazon RDS API Reference* .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-publiclyaccessible
        '''
        result = self._values.get("publicly_accessible")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], result)

    @builtins.property
    def replica_mode(self) -> typing.Optional[builtins.str]:
        '''The open mode of an Oracle read replica.

        For more information, see `Working with Oracle Read Replicas for Amazon RDS <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/oracle-read-replicas.html>`_ in the *Amazon RDS User Guide* .

        This setting is only supported in RDS for Oracle.

        Default: ``open-read-only``

        Valid Values: ``open-read-only`` or ``mounted``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-replicamode
        '''
        result = self._values.get("replica_mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def restore_time(self) -> typing.Optional[builtins.str]:
        '''The date and time to restore from.

        Valid Values: Value must be a time in Universal Coordinated Time (UTC) format

        Constraints:

        - Must be before the latest restorable time for the DB instance
        - Can't be specified if the ``UseLatestRestorableTime`` parameter is enabled

        Example: ``2009-09-07T23:45:00Z``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-restoretime
        '''
        result = self._values.get("restore_time")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def source_db_cluster_identifier(self) -> typing.Optional[builtins.str]:
        '''The identifier of the Multi-AZ DB cluster that will act as the source for the read replica.

        Each DB cluster can have up to 15 read replicas.

        Constraints:

        - Must be the identifier of an existing Multi-AZ DB cluster.
        - Can't be specified if the ``SourceDBInstanceIdentifier`` parameter is also specified.
        - The specified DB cluster must have automatic backups enabled, that is, its backup retention period must be greater than 0.
        - The source DB cluster must be in the same AWS Region as the read replica. Cross-Region replication isn't supported.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-sourcedbclusteridentifier
        '''
        result = self._values.get("source_db_cluster_identifier")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def source_db_instance_automated_backups_arn(self) -> typing.Optional[builtins.str]:
        '''The Amazon Resource Name (ARN) of the replicated automated backups from which to restore, for example, ``arn:aws:rds:useast-1:123456789012:auto-backup:ab-L2IJCEXJP7XQ7HOJ4SIEXAMPLE`` .

        This setting doesn't apply to RDS Custom.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-sourcedbinstanceautomatedbackupsarn
        '''
        result = self._values.get("source_db_instance_automated_backups_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def source_db_instance_identifier(self) -> typing.Optional[builtins.str]:
        '''If you want to create a read replica DB instance, specify the ID of the source DB instance.

        Each DB instance can have a limited number of read replicas. For more information, see `Working with Read Replicas <https://docs.aws.amazon.com/AmazonRDS/latest/DeveloperGuide/USER_ReadRepl.html>`_ in the *Amazon RDS User Guide* .

        For information about constraints that apply to DB instance identifiers, see `Naming constraints in Amazon RDS <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Limits.html#RDS_Limits.Constraints>`_ in the *Amazon RDS User Guide* .

        The ``SourceDBInstanceIdentifier`` property determines whether a DB instance is a read replica. If you remove the ``SourceDBInstanceIdentifier`` property from your template and then update your stack, AWS CloudFormation promotes the Read Replica to a standalone DB instance.
        .. epigraph::

           - If you specify a source DB instance that uses VPC security groups, we recommend that you specify the ``VPCSecurityGroups`` property. If you don't specify the property, the read replica inherits the value of the ``VPCSecurityGroups`` property from the source DB when you create the replica. However, if you update the stack, AWS CloudFormation reverts the replica's ``VPCSecurityGroups`` property to the default value because it's not defined in the stack's template. This change might cause unexpected issues.
           - Read replicas don't support deletion policies. AWS CloudFormation ignores any deletion policy that's associated with a read replica.
           - If you specify ``SourceDBInstanceIdentifier`` , don't specify the ``DBSnapshotIdentifier`` property. You can't create a read replica from a snapshot.
           - Don't set the ``BackupRetentionPeriod`` , ``DBName`` , ``MasterUsername`` , ``MasterUserPassword`` , and ``PreferredBackupWindow`` properties. The database attributes are inherited from the source DB instance, and backups are disabled for read replicas.
           - If the source DB instance is in a different region than the read replica, specify the source region in ``SourceRegion`` , and specify an ARN for a valid DB instance in ``SourceDBInstanceIdentifier`` . For more information, see `Constructing a Amazon RDS Amazon Resource Name (ARN) <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html#USER_Tagging.ARN>`_ in the *Amazon RDS User Guide* .
           - For DB instances in Amazon Aurora clusters, don't specify this property. Amazon RDS automatically assigns writer and reader DB instances.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-sourcedbinstanceidentifier
        '''
        result = self._values.get("source_db_instance_identifier")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def source_dbi_resource_id(self) -> typing.Optional[builtins.str]:
        '''The resource ID of the source DB instance from which to restore.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-sourcedbiresourceid
        '''
        result = self._values.get("source_dbi_resource_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def source_region(self) -> typing.Optional[builtins.str]:
        '''The ID of the region that contains the source DB instance for the read replica.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-sourceregion
        '''
        result = self._values.get("source_region")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def storage_encrypted(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''A value that indicates whether the DB instance is encrypted. By default, it isn't encrypted.

        If you specify the ``KmsKeyId`` property, then you must enable encryption.

        If you specify the ``SourceDBInstanceIdentifier`` property, don't specify this property. The value is inherited from the source DB instance, and if the DB instance is encrypted, the specified ``KmsKeyId`` property is used.

        If you specify the ``SnapshotIdentifier`` and the specified snapshot is encrypted, don't specify this property. The value is inherited from the snapshot, and the specified ``KmsKeyId`` property is used.

        If you specify the ``SnapshotIdentifier`` and the specified snapshot isn't encrypted, you can use this property to specify that the restored DB instance is encrypted. Specify the ``KmsKeyId`` property for the KMS key to use for encryption. If you don't want the restored DB instance to be encrypted, then don't set this property or set it to ``false`` .

        *Amazon Aurora*

        Not applicable. The encryption for DB instances is managed by the DB cluster.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-storageencrypted
        '''
        result = self._values.get("storage_encrypted")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], result)

    @builtins.property
    def storage_throughput(self) -> typing.Optional[jsii.Number]:
        '''Specifies the storage throughput value for the DB instance. This setting applies only to the ``gp3`` storage type.

        This setting doesn't apply to RDS Custom or Amazon Aurora.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-storagethroughput
        '''
        result = self._values.get("storage_throughput")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def storage_type(self) -> typing.Optional[builtins.str]:
        '''Specifies the storage type to be associated with the DB instance.

        Valid values: ``gp2 | gp3 | io1 | standard``

        The ``standard`` value is also known as magnetic.

        If you specify ``io1`` or ``gp3`` , you must also include a value for the ``Iops`` parameter.

        Default: ``io1`` if the ``Iops`` parameter is specified, otherwise ``gp2``

        For more information, see `Amazon RDS DB Instance Storage <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Storage.html>`_ in the *Amazon RDS User Guide* .

        *Amazon Aurora*

        Not applicable. Aurora data is stored in the cluster volume, which is a single, virtual volume that uses solid state drives (SSDs).

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-storagetype
        '''
        result = self._values.get("storage_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[_CfnTag_95fbdc29]]:
        '''An optional array of key-value pairs to apply to this DB instance.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[_CfnTag_95fbdc29]], result)

    @builtins.property
    def timezone(self) -> typing.Optional[builtins.str]:
        '''The time zone of the DB instance.

        The time zone parameter is currently supported only by `Microsoft SQL Server <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_SQLServer.html#SQLServer.Concepts.General.TimeZone>`_ .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-timezone
        '''
        result = self._values.get("timezone")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def use_default_processor_features(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''A value that indicates whether the DB instance class of the DB instance uses its default processor features.

        This setting doesn't apply to RDS Custom.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-usedefaultprocessorfeatures
        '''
        result = self._values.get("use_default_processor_features")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], result)

    @builtins.property
    def use_latest_restorable_time(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''A value that indicates whether the DB instance is restored from the latest backup time.

        By default, the DB instance isn't restored from the latest backup time.

        Constraints: Can't be specified if the ``RestoreTime`` parameter is provided.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-uselatestrestorabletime
        '''
        result = self._values.get("use_latest_restorable_time")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], result)

    @builtins.property
    def vpc_security_groups(self) -> typing.Optional[typing.List[builtins.str]]:
        '''A list of the VPC security group IDs to assign to the DB instance.

        The list can include both the physical IDs of existing VPC security groups and references to `AWS::EC2::SecurityGroup <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group.html>`_ resources created in the template.

        If you plan to update the resource, don't specify VPC security groups in a shared VPC.

        If you set ``VPCSecurityGroups`` , you must not set ```DBSecurityGroups`` <https://docs.aws.amazon.com//AWSCloudFormation/latest/UserGuide/aws-properties-rds-database-instance.html#cfn-rds-dbinstance-dbsecuritygroups>`_ , and vice versa.
        .. epigraph::

           You can migrate a DB instance in your stack from an RDS DB security group to a VPC security group, but keep the following in mind:

           - You can't revert to using an RDS security group after you establish a VPC security group membership.
           - When you migrate your DB instance to VPC security groups, if your stack update rolls back because the DB instance update fails or because an update fails in another AWS CloudFormation resource, the rollback fails because it can't revert to an RDS security group.
           - To use the properties that are available when you use a VPC security group, you must recreate the DB instance. If you don't, AWS CloudFormation submits only the property values that are listed in the ```DBSecurityGroups`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-database-instance.html#cfn-rds-dbinstance-dbsecuritygroups>`_ property.

        To avoid this situation, migrate your DB instance to using VPC security groups only when that is the only change in your stack template.

        *Amazon Aurora*

        Not applicable. The associated list of EC2 VPC security groups is managed by the DB cluster. If specified, the setting must match the DB cluster setting.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbinstance.html#cfn-rds-dbinstance-vpcsecuritygroups
        '''
        result = self._values.get("vpc_security_groups")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnDBInstanceProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_82c04a63)
class CfnDBParameterGroup(
    _CfnResource_e0a482dc,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_rds.CfnDBParameterGroup",
):
    '''A CloudFormation ``AWS::RDS::DBParameterGroup``.

    The ``AWS::RDS::DBParameterGroup`` resource creates a custom parameter group for an RDS database family.

    This type can be declared in a template and referenced in the ``DBParameterGroupName`` property of an ``[AWS::RDS::DBInstance](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-database-instance.html)`` resource.

    For information about configuring parameters for Amazon RDS DB instances, see `Working with parameter groups <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithParamGroups.html>`_ in the *Amazon RDS User Guide* .

    For information about configuring parameters for Amazon Aurora DB instances, see `Working with parameter groups <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_WorkingWithParamGroups.html>`_ in the *Amazon Aurora User Guide* .
    .. epigraph::

       Applying a parameter group to a DB instance may require the DB instance to reboot, resulting in a database outage for the duration of the reboot.

    :cloudformationResource: AWS::RDS::DBParameterGroup
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbparametergroup.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from monocdk import aws_rds as rds
        
        # parameters: Any
        
        cfn_dBParameter_group = rds.CfnDBParameterGroup(self, "MyCfnDBParameterGroup",
            description="description",
            family="family",
        
            # the properties below are optional
            db_parameter_group_name="dbParameterGroupName",
            parameters=parameters,
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        )
    '''

    def __init__(
        self,
        scope: _Construct_e78e779f,
        id: builtins.str,
        *,
        description: builtins.str,
        family: builtins.str,
        db_parameter_group_name: typing.Optional[builtins.str] = None,
        parameters: typing.Any = None,
        tags: typing.Optional[typing.Sequence[typing.Union[_CfnTag_95fbdc29, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Create a new ``AWS::RDS::DBParameterGroup``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param description: Provides the customer-specified description for this DB parameter group.
        :param family: The DB parameter group family name. A DB parameter group can be associated with one and only one DB parameter group family, and can be applied only to a DB instance running a DB engine and engine version compatible with that DB parameter group family. .. epigraph:: The DB parameter group family can't be changed when updating a DB parameter group. To list all of the available parameter group families, use the following command: ``aws rds describe-db-engine-versions --query "DBEngineVersions[].DBParameterGroupFamily"`` The output contains duplicates. For more information, see ``[CreateDBParameterGroup](https://docs.aws.amazon.com//AmazonRDS/latest/APIReference/API_CreateDBParameterGroup.html)`` .
        :param db_parameter_group_name: The name of the DB parameter group. Constraints: - Must be 1 to 255 letters, numbers, or hyphens. - First character must be a letter - Can't end with a hyphen or contain two consecutive hyphens If you don't specify a value for ``DBParameterGroupName`` property, a name is automatically created for the DB parameter group. .. epigraph:: This value is stored as a lowercase string.
        :param parameters: An array of parameter names and values for the parameter update. At least one parameter name and value must be supplied. Subsequent arguments are optional. For more information about DB parameters and DB parameter groups for Amazon RDS DB engines, see `Working with DB Parameter Groups <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithParamGroups.html>`_ in the *Amazon RDS User Guide* . For more information about DB cluster and DB instance parameters and parameter groups for Amazon Aurora DB engines, see `Working with DB Parameter Groups and DB Cluster Parameter Groups <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_WorkingWithParamGroups.html>`_ in the *Amazon Aurora User Guide* . .. epigraph:: AWS CloudFormation doesn't support specifying an apply method for each individual parameter. The default apply method for each parameter is used.
        :param tags: An optional array of key-value pairs to apply to this DB parameter group. .. epigraph:: Currently, this is the only property that supports drift detection.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8b469a4fced86a01176742c0ee985cbcbb1582925d034ed2afed4457177f67db)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = CfnDBParameterGroupProps(
            description=description,
            family=family,
            db_parameter_group_name=db_parameter_group_name,
            parameters=parameters,
            tags=tags,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_1cd1894e) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b317a67ac4dbc9ca4935a00e06892a4eb0c225b58a90b718de21bf63d31fded4)
            check_type(argname="argument inspector", value=inspector, expected_type=type_hints["inspector"])
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__91a684c87b67b3089e356900289eb5a270617740cc312f960bf0eac1ec10cb13)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrDbParameterGroupName")
    def attr_db_parameter_group_name(self) -> builtins.str:
        '''The name of the DB parameter group.

        :cloudformationAttribute: DBParameterGroupName
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrDbParameterGroupName"))

    @builtins.property
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property
    @jsii.member(jsii_name="tags")
    def tags(self) -> _TagManager_0b7ab120:
        '''An optional array of key-value pairs to apply to this DB parameter group.

        .. epigraph::

           Currently, this is the only property that supports drift detection.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbparametergroup.html#cfn-rds-dbparametergroup-tags
        '''
        return typing.cast(_TagManager_0b7ab120, jsii.get(self, "tags"))

    @builtins.property
    @jsii.member(jsii_name="description")
    def description(self) -> builtins.str:
        '''Provides the customer-specified description for this DB parameter group.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbparametergroup.html#cfn-rds-dbparametergroup-description
        '''
        return typing.cast(builtins.str, jsii.get(self, "description"))

    @description.setter
    def description(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bd3cc3a4b820772179c6a31d9eac61a408e487dc67852aff69b0a6daf1a04495)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "description", value)

    @builtins.property
    @jsii.member(jsii_name="family")
    def family(self) -> builtins.str:
        '''The DB parameter group family name.

        A DB parameter group can be associated with one and only one DB parameter group family, and can be applied only to a DB instance running a DB engine and engine version compatible with that DB parameter group family.
        .. epigraph::

           The DB parameter group family can't be changed when updating a DB parameter group.

        To list all of the available parameter group families, use the following command:

        ``aws rds describe-db-engine-versions --query "DBEngineVersions[].DBParameterGroupFamily"``

        The output contains duplicates.

        For more information, see ``[CreateDBParameterGroup](https://docs.aws.amazon.com//AmazonRDS/latest/APIReference/API_CreateDBParameterGroup.html)`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbparametergroup.html#cfn-rds-dbparametergroup-family
        '''
        return typing.cast(builtins.str, jsii.get(self, "family"))

    @family.setter
    def family(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8d85936df088d2f09b5b96bfaa878fc17c5da03e17a3ac82b26f2ce03ec1be54)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "family", value)

    @builtins.property
    @jsii.member(jsii_name="parameters")
    def parameters(self) -> typing.Any:
        '''An array of parameter names and values for the parameter update.

        At least one parameter name and value must be supplied. Subsequent arguments are optional.

        For more information about DB parameters and DB parameter groups for Amazon RDS DB engines, see `Working with DB Parameter Groups <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithParamGroups.html>`_ in the *Amazon RDS User Guide* .

        For more information about DB cluster and DB instance parameters and parameter groups for Amazon Aurora DB engines, see `Working with DB Parameter Groups and DB Cluster Parameter Groups <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_WorkingWithParamGroups.html>`_ in the *Amazon Aurora User Guide* .
        .. epigraph::

           AWS CloudFormation doesn't support specifying an apply method for each individual parameter. The default apply method for each parameter is used.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbparametergroup.html#cfn-rds-dbparametergroup-parameters
        '''
        return typing.cast(typing.Any, jsii.get(self, "parameters"))

    @parameters.setter
    def parameters(self, value: typing.Any) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__99cacfa2cfbf028ef62e95634fb7dd8333b35d027219c829f4f7c48f3c218330)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "parameters", value)

    @builtins.property
    @jsii.member(jsii_name="dbParameterGroupName")
    def db_parameter_group_name(self) -> typing.Optional[builtins.str]:
        '''The name of the DB parameter group.

        Constraints:

        - Must be 1 to 255 letters, numbers, or hyphens.
        - First character must be a letter
        - Can't end with a hyphen or contain two consecutive hyphens

        If you don't specify a value for ``DBParameterGroupName`` property, a name is automatically created for the DB parameter group.
        .. epigraph::

           This value is stored as a lowercase string.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbparametergroup.html#cfn-rds-dbparametergroup-dbparametergroupname
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "dbParameterGroupName"))

    @db_parameter_group_name.setter
    def db_parameter_group_name(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c636c2d6ae6863e86614a7268efcd49cd185eaad4bc367e00c9d97daa5f38e5b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dbParameterGroupName", value)


@jsii.data_type(
    jsii_type="monocdk.aws_rds.CfnDBParameterGroupProps",
    jsii_struct_bases=[],
    name_mapping={
        "description": "description",
        "family": "family",
        "db_parameter_group_name": "dbParameterGroupName",
        "parameters": "parameters",
        "tags": "tags",
    },
)
class CfnDBParameterGroupProps:
    def __init__(
        self,
        *,
        description: builtins.str,
        family: builtins.str,
        db_parameter_group_name: typing.Optional[builtins.str] = None,
        parameters: typing.Any = None,
        tags: typing.Optional[typing.Sequence[typing.Union[_CfnTag_95fbdc29, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for defining a ``CfnDBParameterGroup``.

        :param description: Provides the customer-specified description for this DB parameter group.
        :param family: The DB parameter group family name. A DB parameter group can be associated with one and only one DB parameter group family, and can be applied only to a DB instance running a DB engine and engine version compatible with that DB parameter group family. .. epigraph:: The DB parameter group family can't be changed when updating a DB parameter group. To list all of the available parameter group families, use the following command: ``aws rds describe-db-engine-versions --query "DBEngineVersions[].DBParameterGroupFamily"`` The output contains duplicates. For more information, see ``[CreateDBParameterGroup](https://docs.aws.amazon.com//AmazonRDS/latest/APIReference/API_CreateDBParameterGroup.html)`` .
        :param db_parameter_group_name: The name of the DB parameter group. Constraints: - Must be 1 to 255 letters, numbers, or hyphens. - First character must be a letter - Can't end with a hyphen or contain two consecutive hyphens If you don't specify a value for ``DBParameterGroupName`` property, a name is automatically created for the DB parameter group. .. epigraph:: This value is stored as a lowercase string.
        :param parameters: An array of parameter names and values for the parameter update. At least one parameter name and value must be supplied. Subsequent arguments are optional. For more information about DB parameters and DB parameter groups for Amazon RDS DB engines, see `Working with DB Parameter Groups <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithParamGroups.html>`_ in the *Amazon RDS User Guide* . For more information about DB cluster and DB instance parameters and parameter groups for Amazon Aurora DB engines, see `Working with DB Parameter Groups and DB Cluster Parameter Groups <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_WorkingWithParamGroups.html>`_ in the *Amazon Aurora User Guide* . .. epigraph:: AWS CloudFormation doesn't support specifying an apply method for each individual parameter. The default apply method for each parameter is used.
        :param tags: An optional array of key-value pairs to apply to this DB parameter group. .. epigraph:: Currently, this is the only property that supports drift detection.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbparametergroup.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_rds as rds
            
            # parameters: Any
            
            cfn_dBParameter_group_props = rds.CfnDBParameterGroupProps(
                description="description",
                family="family",
            
                # the properties below are optional
                db_parameter_group_name="dbParameterGroupName",
                parameters=parameters,
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9ca53911a1d6df64c2da5051a78db0f32f6b90e8f17ff9a39ba8d770b4454dc9)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument family", value=family, expected_type=type_hints["family"])
            check_type(argname="argument db_parameter_group_name", value=db_parameter_group_name, expected_type=type_hints["db_parameter_group_name"])
            check_type(argname="argument parameters", value=parameters, expected_type=type_hints["parameters"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "description": description,
            "family": family,
        }
        if db_parameter_group_name is not None:
            self._values["db_parameter_group_name"] = db_parameter_group_name
        if parameters is not None:
            self._values["parameters"] = parameters
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def description(self) -> builtins.str:
        '''Provides the customer-specified description for this DB parameter group.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbparametergroup.html#cfn-rds-dbparametergroup-description
        '''
        result = self._values.get("description")
        assert result is not None, "Required property 'description' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def family(self) -> builtins.str:
        '''The DB parameter group family name.

        A DB parameter group can be associated with one and only one DB parameter group family, and can be applied only to a DB instance running a DB engine and engine version compatible with that DB parameter group family.
        .. epigraph::

           The DB parameter group family can't be changed when updating a DB parameter group.

        To list all of the available parameter group families, use the following command:

        ``aws rds describe-db-engine-versions --query "DBEngineVersions[].DBParameterGroupFamily"``

        The output contains duplicates.

        For more information, see ``[CreateDBParameterGroup](https://docs.aws.amazon.com//AmazonRDS/latest/APIReference/API_CreateDBParameterGroup.html)`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbparametergroup.html#cfn-rds-dbparametergroup-family
        '''
        result = self._values.get("family")
        assert result is not None, "Required property 'family' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def db_parameter_group_name(self) -> typing.Optional[builtins.str]:
        '''The name of the DB parameter group.

        Constraints:

        - Must be 1 to 255 letters, numbers, or hyphens.
        - First character must be a letter
        - Can't end with a hyphen or contain two consecutive hyphens

        If you don't specify a value for ``DBParameterGroupName`` property, a name is automatically created for the DB parameter group.
        .. epigraph::

           This value is stored as a lowercase string.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbparametergroup.html#cfn-rds-dbparametergroup-dbparametergroupname
        '''
        result = self._values.get("db_parameter_group_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def parameters(self) -> typing.Any:
        '''An array of parameter names and values for the parameter update.

        At least one parameter name and value must be supplied. Subsequent arguments are optional.

        For more information about DB parameters and DB parameter groups for Amazon RDS DB engines, see `Working with DB Parameter Groups <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithParamGroups.html>`_ in the *Amazon RDS User Guide* .

        For more information about DB cluster and DB instance parameters and parameter groups for Amazon Aurora DB engines, see `Working with DB Parameter Groups and DB Cluster Parameter Groups <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_WorkingWithParamGroups.html>`_ in the *Amazon Aurora User Guide* .
        .. epigraph::

           AWS CloudFormation doesn't support specifying an apply method for each individual parameter. The default apply method for each parameter is used.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbparametergroup.html#cfn-rds-dbparametergroup-parameters
        '''
        result = self._values.get("parameters")
        return typing.cast(typing.Any, result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[_CfnTag_95fbdc29]]:
        '''An optional array of key-value pairs to apply to this DB parameter group.

        .. epigraph::

           Currently, this is the only property that supports drift detection.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbparametergroup.html#cfn-rds-dbparametergroup-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[_CfnTag_95fbdc29]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnDBParameterGroupProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_82c04a63)
class CfnDBProxy(
    _CfnResource_e0a482dc,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_rds.CfnDBProxy",
):
    '''A CloudFormation ``AWS::RDS::DBProxy``.

    The ``AWS::RDS::DBProxy`` resource creates or updates a DB proxy.

    For information about RDS Proxy for Amazon RDS, see `Managing Connections with Amazon RDS Proxy <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-proxy.html>`_ in the *Amazon RDS User Guide* .

    For information about RDS Proxy for Amazon Aurora, see `Managing Connections with Amazon RDS Proxy <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/rds-proxy.html>`_ in the *Amazon Aurora User Guide* .
    .. epigraph::

       Limitations apply to RDS Proxy, including DB engine version limitations and AWS Region limitations.

       For information about limitations that apply to RDS Proxy for Amazon RDS, see `Limitations for RDS Proxy <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-proxy.html#rds-proxy.limitations>`_ in the *Amazon RDS User Guide* .

       For information about that apply to RDS Proxy for Amazon Aurora, see `Limitations for RDS Proxy <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/rds-proxy.html#rds-proxy.limitations>`_ in the *Amazon Aurora User Guide* .

    :cloudformationResource: AWS::RDS::DBProxy
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbproxy.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from monocdk import aws_rds as rds
        
        cfn_dBProxy = rds.CfnDBProxy(self, "MyCfnDBProxy",
            auth=[rds.CfnDBProxy.AuthFormatProperty(
                auth_scheme="authScheme",
                client_password_auth_type="clientPasswordAuthType",
                description="description",
                iam_auth="iamAuth",
                secret_arn="secretArn"
            )],
            db_proxy_name="dbProxyName",
            engine_family="engineFamily",
            role_arn="roleArn",
            vpc_subnet_ids=["vpcSubnetIds"],
        
            # the properties below are optional
            debug_logging=False,
            idle_client_timeout=123,
            require_tls=False,
            tags=[rds.CfnDBProxy.TagFormatProperty(
                key="key",
                value="value"
            )],
            vpc_security_group_ids=["vpcSecurityGroupIds"]
        )
    '''

    def __init__(
        self,
        scope: _Construct_e78e779f,
        id: builtins.str,
        *,
        auth: typing.Union[_IResolvable_a771d0ef, typing.Sequence[typing.Union[typing.Union["CfnDBProxy.AuthFormatProperty", typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]]],
        db_proxy_name: builtins.str,
        engine_family: builtins.str,
        role_arn: builtins.str,
        vpc_subnet_ids: typing.Sequence[builtins.str],
        debug_logging: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        idle_client_timeout: typing.Optional[jsii.Number] = None,
        require_tls: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union["CfnDBProxy.TagFormatProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        vpc_security_group_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''Create a new ``AWS::RDS::DBProxy``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param auth: The authorization mechanism that the proxy uses.
        :param db_proxy_name: The identifier for the proxy. This name must be unique for all proxies owned by your AWS account in the specified AWS Region . An identifier must begin with a letter and must contain only ASCII letters, digits, and hyphens; it can't end with a hyphen or contain two consecutive hyphens.
        :param engine_family: The kinds of databases that the proxy can connect to. This value determines which database network protocol the proxy recognizes when it interprets network traffic to and from the database. For Aurora MySQL, RDS for MariaDB, and RDS for MySQL databases, specify ``MYSQL`` . For Aurora PostgreSQL and RDS for PostgreSQL databases, specify ``POSTGRESQL`` . For RDS for Microsoft SQL Server, specify ``SQLSERVER`` . *Valid values* : ``MYSQL`` | ``POSTGRESQL`` | ``SQLSERVER``
        :param role_arn: The Amazon Resource Name (ARN) of the IAM role that the proxy uses to access secrets in AWS Secrets Manager.
        :param vpc_subnet_ids: One or more VPC subnet IDs to associate with the new proxy.
        :param debug_logging: Whether the proxy includes detailed information about SQL statements in its logs. This information helps you to debug issues involving SQL behavior or the performance and scalability of the proxy connections. The debug information includes the text of SQL statements that you submit through the proxy. Thus, only enable this setting when needed for debugging, and only when you have security measures in place to safeguard any sensitive information that appears in the logs.
        :param idle_client_timeout: The number of seconds that a connection to the proxy can be inactive before the proxy disconnects it. You can set this value higher or lower than the connection timeout limit for the associated database.
        :param require_tls: A Boolean parameter that specifies whether Transport Layer Security (TLS) encryption is required for connections to the proxy. By enabling this setting, you can enforce encrypted TLS connections to the proxy.
        :param tags: An optional set of key-value pairs to associate arbitrary data of your choosing with the proxy.
        :param vpc_security_group_ids: One or more VPC security group IDs to associate with the new proxy. If you plan to update the resource, don't specify VPC security groups in a shared VPC.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9495d46744894209d6d1bb1607877196f80d42b1af7795e4c767f04f92fd3cc5)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = CfnDBProxyProps(
            auth=auth,
            db_proxy_name=db_proxy_name,
            engine_family=engine_family,
            role_arn=role_arn,
            vpc_subnet_ids=vpc_subnet_ids,
            debug_logging=debug_logging,
            idle_client_timeout=idle_client_timeout,
            require_tls=require_tls,
            tags=tags,
            vpc_security_group_ids=vpc_security_group_ids,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_1cd1894e) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a985556d7913082516936b96e8abb30b51ddd104d14c399c8e1d3e9c3a4af725)
            check_type(argname="argument inspector", value=inspector, expected_type=type_hints["inspector"])
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__765e68e014ec6b81c3d8e54abe5a5863c2a8482561e86fdc0d9ee8256840c5eb)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrDbProxyArn")
    def attr_db_proxy_arn(self) -> builtins.str:
        '''The Amazon Resource Name (ARN) representing the target group.

        :cloudformationAttribute: DBProxyArn
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrDbProxyArn"))

    @builtins.property
    @jsii.member(jsii_name="attrEndpoint")
    def attr_endpoint(self) -> builtins.str:
        '''The writer endpoint for the RDS DB instance or Aurora DB cluster.

        :cloudformationAttribute: Endpoint
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrEndpoint"))

    @builtins.property
    @jsii.member(jsii_name="attrVpcId")
    def attr_vpc_id(self) -> builtins.str:
        '''The VPC ID to associate with the DB proxy.

        :cloudformationAttribute: VpcId
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrVpcId"))

    @builtins.property
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property
    @jsii.member(jsii_name="auth")
    def auth(
        self,
    ) -> typing.Union[_IResolvable_a771d0ef, typing.List[typing.Union["CfnDBProxy.AuthFormatProperty", _IResolvable_a771d0ef]]]:
        '''The authorization mechanism that the proxy uses.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbproxy.html#cfn-rds-dbproxy-auth
        '''
        return typing.cast(typing.Union[_IResolvable_a771d0ef, typing.List[typing.Union["CfnDBProxy.AuthFormatProperty", _IResolvable_a771d0ef]]], jsii.get(self, "auth"))

    @auth.setter
    def auth(
        self,
        value: typing.Union[_IResolvable_a771d0ef, typing.List[typing.Union["CfnDBProxy.AuthFormatProperty", _IResolvable_a771d0ef]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f40c459770ce92eee6b1dc409038c3b5d157134ee410908805700e68af2124f7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "auth", value)

    @builtins.property
    @jsii.member(jsii_name="dbProxyName")
    def db_proxy_name(self) -> builtins.str:
        '''The identifier for the proxy.

        This name must be unique for all proxies owned by your AWS account in the specified AWS Region . An identifier must begin with a letter and must contain only ASCII letters, digits, and hyphens; it can't end with a hyphen or contain two consecutive hyphens.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbproxy.html#cfn-rds-dbproxy-dbproxyname
        '''
        return typing.cast(builtins.str, jsii.get(self, "dbProxyName"))

    @db_proxy_name.setter
    def db_proxy_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__676e1fa17feca75773d712c06df72f8614ac73ed63c00dbc42db7893ce13ac5e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dbProxyName", value)

    @builtins.property
    @jsii.member(jsii_name="engineFamily")
    def engine_family(self) -> builtins.str:
        '''The kinds of databases that the proxy can connect to.

        This value determines which database network protocol the proxy recognizes when it interprets network traffic to and from the database. For Aurora MySQL, RDS for MariaDB, and RDS for MySQL databases, specify ``MYSQL`` . For Aurora PostgreSQL and RDS for PostgreSQL databases, specify ``POSTGRESQL`` . For RDS for Microsoft SQL Server, specify ``SQLSERVER`` .

        *Valid values* : ``MYSQL`` | ``POSTGRESQL`` | ``SQLSERVER``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbproxy.html#cfn-rds-dbproxy-enginefamily
        '''
        return typing.cast(builtins.str, jsii.get(self, "engineFamily"))

    @engine_family.setter
    def engine_family(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__47dfe074e5846f7906bfb38fbfe996a0fbec41821479293928dd017876495618)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "engineFamily", value)

    @builtins.property
    @jsii.member(jsii_name="roleArn")
    def role_arn(self) -> builtins.str:
        '''The Amazon Resource Name (ARN) of the IAM role that the proxy uses to access secrets in AWS Secrets Manager.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbproxy.html#cfn-rds-dbproxy-rolearn
        '''
        return typing.cast(builtins.str, jsii.get(self, "roleArn"))

    @role_arn.setter
    def role_arn(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__848e9f1e0f23c37b98f20d5d80f1eea43daa039ea7181e3b4a3dd3f647ef3b72)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "roleArn", value)

    @builtins.property
    @jsii.member(jsii_name="vpcSubnetIds")
    def vpc_subnet_ids(self) -> typing.List[builtins.str]:
        '''One or more VPC subnet IDs to associate with the new proxy.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbproxy.html#cfn-rds-dbproxy-vpcsubnetids
        '''
        return typing.cast(typing.List[builtins.str], jsii.get(self, "vpcSubnetIds"))

    @vpc_subnet_ids.setter
    def vpc_subnet_ids(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ab780893e01b331588409afd139045d55a03980dfabe5c2b05a4f2a8f0abfd4a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "vpcSubnetIds", value)

    @builtins.property
    @jsii.member(jsii_name="debugLogging")
    def debug_logging(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''Whether the proxy includes detailed information about SQL statements in its logs.

        This information helps you to debug issues involving SQL behavior or the performance and scalability of the proxy connections. The debug information includes the text of SQL statements that you submit through the proxy. Thus, only enable this setting when needed for debugging, and only when you have security measures in place to safeguard any sensitive information that appears in the logs.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbproxy.html#cfn-rds-dbproxy-debuglogging
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], jsii.get(self, "debugLogging"))

    @debug_logging.setter
    def debug_logging(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9d96e7f6a1cbbc6984a5acc918cff293a01c7cbed0cd5a89b9aa07be0f2b0962)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "debugLogging", value)

    @builtins.property
    @jsii.member(jsii_name="idleClientTimeout")
    def idle_client_timeout(self) -> typing.Optional[jsii.Number]:
        '''The number of seconds that a connection to the proxy can be inactive before the proxy disconnects it.

        You can set this value higher or lower than the connection timeout limit for the associated database.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbproxy.html#cfn-rds-dbproxy-idleclienttimeout
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "idleClientTimeout"))

    @idle_client_timeout.setter
    def idle_client_timeout(self, value: typing.Optional[jsii.Number]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8af1a584de482ef2668d41b4f637f93cf5d2af96c752959cf44c17d919ec4ad9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "idleClientTimeout", value)

    @builtins.property
    @jsii.member(jsii_name="requireTls")
    def require_tls(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''A Boolean parameter that specifies whether Transport Layer Security (TLS) encryption is required for connections to the proxy.

        By enabling this setting, you can enforce encrypted TLS connections to the proxy.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbproxy.html#cfn-rds-dbproxy-requiretls
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], jsii.get(self, "requireTls"))

    @require_tls.setter
    def require_tls(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c7e9d2ebf26653242af38a796368be442b0a3cbf868c542f5db7a56e0c845cf9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "requireTls", value)

    @builtins.property
    @jsii.member(jsii_name="tags")
    def tags(self) -> typing.Optional[typing.List["CfnDBProxy.TagFormatProperty"]]:
        '''An optional set of key-value pairs to associate arbitrary data of your choosing with the proxy.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbproxy.html#cfn-rds-dbproxy-tags
        '''
        return typing.cast(typing.Optional[typing.List["CfnDBProxy.TagFormatProperty"]], jsii.get(self, "tags"))

    @tags.setter
    def tags(
        self,
        value: typing.Optional[typing.List["CfnDBProxy.TagFormatProperty"]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7e45986aaafc274aeb72227fdbb0afb0e1fba0bcc169dd0fc8e6c85bef254456)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "tags", value)

    @builtins.property
    @jsii.member(jsii_name="vpcSecurityGroupIds")
    def vpc_security_group_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''One or more VPC security group IDs to associate with the new proxy.

        If you plan to update the resource, don't specify VPC security groups in a shared VPC.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbproxy.html#cfn-rds-dbproxy-vpcsecuritygroupids
        '''
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "vpcSecurityGroupIds"))

    @vpc_security_group_ids.setter
    def vpc_security_group_ids(
        self,
        value: typing.Optional[typing.List[builtins.str]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a07064958b6c136ee003d1f13739e2b6a94197d1dc450b1206bb3c090e727d17)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "vpcSecurityGroupIds", value)

    @jsii.data_type(
        jsii_type="monocdk.aws_rds.CfnDBProxy.AuthFormatProperty",
        jsii_struct_bases=[],
        name_mapping={
            "auth_scheme": "authScheme",
            "client_password_auth_type": "clientPasswordAuthType",
            "description": "description",
            "iam_auth": "iamAuth",
            "secret_arn": "secretArn",
        },
    )
    class AuthFormatProperty:
        def __init__(
            self,
            *,
            auth_scheme: typing.Optional[builtins.str] = None,
            client_password_auth_type: typing.Optional[builtins.str] = None,
            description: typing.Optional[builtins.str] = None,
            iam_auth: typing.Optional[builtins.str] = None,
            secret_arn: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies the details of authentication used by a proxy to log in as a specific database user.

            :param auth_scheme: The type of authentication that the proxy uses for connections from the proxy to the underlying database. Valid Values: ``SECRETS``
            :param client_password_auth_type: Specifies the details of authentication used by a proxy to log in as a specific database user.
            :param description: A user-specified description about the authentication used by a proxy to log in as a specific database user.
            :param iam_auth: Whether to require or disallow AWS Identity and Access Management (IAM) authentication for connections to the proxy. The ``ENABLED`` value is valid only for proxies with RDS for Microsoft SQL Server. Valid Values: ``ENABLED | DISABLED | REQUIRED``
            :param secret_arn: The Amazon Resource Name (ARN) representing the secret that the proxy uses to authenticate to the RDS DB instance or Aurora DB cluster. These secrets are stored within Amazon Secrets Manager.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbproxy-authformat.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from monocdk import aws_rds as rds
                
                auth_format_property = rds.CfnDBProxy.AuthFormatProperty(
                    auth_scheme="authScheme",
                    client_password_auth_type="clientPasswordAuthType",
                    description="description",
                    iam_auth="iamAuth",
                    secret_arn="secretArn"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__d1e33b6e31c351c09614c1bcf23cffe6553682bd162b94bb936b16cdd8ae6fc7)
                check_type(argname="argument auth_scheme", value=auth_scheme, expected_type=type_hints["auth_scheme"])
                check_type(argname="argument client_password_auth_type", value=client_password_auth_type, expected_type=type_hints["client_password_auth_type"])
                check_type(argname="argument description", value=description, expected_type=type_hints["description"])
                check_type(argname="argument iam_auth", value=iam_auth, expected_type=type_hints["iam_auth"])
                check_type(argname="argument secret_arn", value=secret_arn, expected_type=type_hints["secret_arn"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if auth_scheme is not None:
                self._values["auth_scheme"] = auth_scheme
            if client_password_auth_type is not None:
                self._values["client_password_auth_type"] = client_password_auth_type
            if description is not None:
                self._values["description"] = description
            if iam_auth is not None:
                self._values["iam_auth"] = iam_auth
            if secret_arn is not None:
                self._values["secret_arn"] = secret_arn

        @builtins.property
        def auth_scheme(self) -> typing.Optional[builtins.str]:
            '''The type of authentication that the proxy uses for connections from the proxy to the underlying database.

            Valid Values: ``SECRETS``

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbproxy-authformat.html#cfn-rds-dbproxy-authformat-authscheme
            '''
            result = self._values.get("auth_scheme")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def client_password_auth_type(self) -> typing.Optional[builtins.str]:
            '''Specifies the details of authentication used by a proxy to log in as a specific database user.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbproxy-authformat.html#cfn-rds-dbproxy-authformat-clientpasswordauthtype
            '''
            result = self._values.get("client_password_auth_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def description(self) -> typing.Optional[builtins.str]:
            '''A user-specified description about the authentication used by a proxy to log in as a specific database user.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbproxy-authformat.html#cfn-rds-dbproxy-authformat-description
            '''
            result = self._values.get("description")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def iam_auth(self) -> typing.Optional[builtins.str]:
            '''Whether to require or disallow AWS Identity and Access Management (IAM) authentication for connections to the proxy.

            The ``ENABLED`` value is valid only for proxies with RDS for Microsoft SQL Server.

            Valid Values: ``ENABLED | DISABLED | REQUIRED``

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbproxy-authformat.html#cfn-rds-dbproxy-authformat-iamauth
            '''
            result = self._values.get("iam_auth")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def secret_arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) representing the secret that the proxy uses to authenticate to the RDS DB instance or Aurora DB cluster.

            These secrets are stored within Amazon Secrets Manager.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbproxy-authformat.html#cfn-rds-dbproxy-authformat-secretarn
            '''
            result = self._values.get("secret_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AuthFormatProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="monocdk.aws_rds.CfnDBProxy.TagFormatProperty",
        jsii_struct_bases=[],
        name_mapping={"key": "key", "value": "value"},
    )
    class TagFormatProperty:
        def __init__(
            self,
            *,
            key: typing.Optional[builtins.str] = None,
            value: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Metadata assigned to a DB proxy consisting of a key-value pair.

            :param key: A key is the required name of the tag. The string value can be 1-128 Unicode characters in length and can't be prefixed with ``aws:`` . The string can contain only the set of Unicode letters, digits, white-space, '*', '.', '/', '=', '+', '-' (Java regex: "^([\\p{L}\\p{Z}\\p{N}*.:/=+\\-]*)$").
            :param value: A value is the optional value of the tag. The string value can be 1-256 Unicode characters in length and can't be prefixed with ``aws:`` . The string can contain only the set of Unicode letters, digits, white-space, '*', '.', '/', '=', '+', '-' (Java regex: "^([\\p{L}\\p{Z}\\p{N}*.:/=+\\-]*)$").

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbproxy-tagformat.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from monocdk import aws_rds as rds
                
                tag_format_property = rds.CfnDBProxy.TagFormatProperty(
                    key="key",
                    value="value"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__999594722dc31082e96928af4fd13ea02b9ebbb85848c27f75622b9f7d2f7b42)
                check_type(argname="argument key", value=key, expected_type=type_hints["key"])
                check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if key is not None:
                self._values["key"] = key
            if value is not None:
                self._values["value"] = value

        @builtins.property
        def key(self) -> typing.Optional[builtins.str]:
            '''A key is the required name of the tag.

            The string value can be 1-128 Unicode characters in length and can't be prefixed with ``aws:`` . The string can contain only the set of Unicode letters, digits, white-space, '*', '.', '/', '=', '+', '-' (Java regex: "^([\\p{L}\\p{Z}\\p{N}*.:/=+-]*)$").

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbproxy-tagformat.html#cfn-rds-dbproxy-tagformat-key
            '''
            result = self._values.get("key")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def value(self) -> typing.Optional[builtins.str]:
            '''A value is the optional value of the tag.

            The string value can be 1-256 Unicode characters in length and can't be prefixed with ``aws:`` . The string can contain only the set of Unicode letters, digits, white-space, '*', '.', '/', '=', '+', '-' (Java regex: "^([\\p{L}\\p{Z}\\p{N}*.:/=+-]*)$").

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbproxy-tagformat.html#cfn-rds-dbproxy-tagformat-value
            '''
            result = self._values.get("value")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TagFormatProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.implements(_IInspectable_82c04a63)
class CfnDBProxyEndpoint(
    _CfnResource_e0a482dc,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_rds.CfnDBProxyEndpoint",
):
    '''A CloudFormation ``AWS::RDS::DBProxyEndpoint``.

    The ``AWS::RDS::DBProxyEndpoint`` resource creates or updates a DB proxy endpoint. You can use custom proxy endpoints to access a proxy through a different VPC than the proxy's default VPC.

    For more information about RDS Proxy, see `AWS::RDS::DBProxy <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbproxy.html>`_ .

    :cloudformationResource: AWS::RDS::DBProxyEndpoint
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbproxyendpoint.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from monocdk import aws_rds as rds
        
        cfn_dBProxy_endpoint = rds.CfnDBProxyEndpoint(self, "MyCfnDBProxyEndpoint",
            db_proxy_endpoint_name="dbProxyEndpointName",
            db_proxy_name="dbProxyName",
            vpc_subnet_ids=["vpcSubnetIds"],
        
            # the properties below are optional
            tags=[rds.CfnDBProxyEndpoint.TagFormatProperty(
                key="key",
                value="value"
            )],
            target_role="targetRole",
            vpc_security_group_ids=["vpcSecurityGroupIds"]
        )
    '''

    def __init__(
        self,
        scope: _Construct_e78e779f,
        id: builtins.str,
        *,
        db_proxy_endpoint_name: builtins.str,
        db_proxy_name: builtins.str,
        vpc_subnet_ids: typing.Sequence[builtins.str],
        tags: typing.Optional[typing.Sequence[typing.Union["CfnDBProxyEndpoint.TagFormatProperty", typing.Dict[builtins.str, typing.Any]]]] = None,
        target_role: typing.Optional[builtins.str] = None,
        vpc_security_group_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''Create a new ``AWS::RDS::DBProxyEndpoint``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param db_proxy_endpoint_name: The name of the DB proxy endpoint to create.
        :param db_proxy_name: The name of the DB proxy associated with the DB proxy endpoint that you create.
        :param vpc_subnet_ids: The VPC subnet IDs for the DB proxy endpoint that you create. You can specify a different set of subnet IDs than for the original DB proxy.
        :param tags: An optional set of key-value pairs to associate arbitrary data of your choosing with the proxy.
        :param target_role: A value that indicates whether the DB proxy endpoint can be used for read/write or read-only operations. Valid Values: ``READ_WRITE | READ_ONLY``
        :param vpc_security_group_ids: The VPC security group IDs for the DB proxy endpoint that you create. You can specify a different set of security group IDs than for the original DB proxy. The default is the default security group for the VPC.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f845097f272b79b09b6480cc1d5ae32acc251207614ea5136f774e999f3ef4b1)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = CfnDBProxyEndpointProps(
            db_proxy_endpoint_name=db_proxy_endpoint_name,
            db_proxy_name=db_proxy_name,
            vpc_subnet_ids=vpc_subnet_ids,
            tags=tags,
            target_role=target_role,
            vpc_security_group_ids=vpc_security_group_ids,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_1cd1894e) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f88b4078e7a8ed76379a1132cd4ed75f5299e67380b820ab11e76f4089052785)
            check_type(argname="argument inspector", value=inspector, expected_type=type_hints["inspector"])
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__787c6b122dbdfd7b6a81da3d03af99b355477e2280083056ab30a50741b72bf0)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrDbProxyEndpointArn")
    def attr_db_proxy_endpoint_arn(self) -> builtins.str:
        '''The Amazon Resource Name (ARN) representing the DB proxy endpoint.

        :cloudformationAttribute: DBProxyEndpointArn
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrDbProxyEndpointArn"))

    @builtins.property
    @jsii.member(jsii_name="attrEndpoint")
    def attr_endpoint(self) -> builtins.str:
        '''The custom endpoint for the RDS DB instance or Aurora DB cluster.

        :cloudformationAttribute: Endpoint
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrEndpoint"))

    @builtins.property
    @jsii.member(jsii_name="attrIsDefault")
    def attr_is_default(self) -> _IResolvable_a771d0ef:
        '''A value that indicates whether this endpoint is the default endpoint for the associated DB proxy.

        Default DB proxy endpoints always have read/write capability. Other endpoints that you associate with the DB proxy can be either read/write or read-only.

        :cloudformationAttribute: IsDefault
        '''
        return typing.cast(_IResolvable_a771d0ef, jsii.get(self, "attrIsDefault"))

    @builtins.property
    @jsii.member(jsii_name="attrVpcId")
    def attr_vpc_id(self) -> builtins.str:
        '''The VPC ID of the DB proxy endpoint.

        :cloudformationAttribute: VpcId
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrVpcId"))

    @builtins.property
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property
    @jsii.member(jsii_name="dbProxyEndpointName")
    def db_proxy_endpoint_name(self) -> builtins.str:
        '''The name of the DB proxy endpoint to create.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbproxyendpoint.html#cfn-rds-dbproxyendpoint-dbproxyendpointname
        '''
        return typing.cast(builtins.str, jsii.get(self, "dbProxyEndpointName"))

    @db_proxy_endpoint_name.setter
    def db_proxy_endpoint_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f8b1a2a046a60aac05f23773eed1fb5802dc62120741d3e1fabd1d26e83a1bab)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dbProxyEndpointName", value)

    @builtins.property
    @jsii.member(jsii_name="dbProxyName")
    def db_proxy_name(self) -> builtins.str:
        '''The name of the DB proxy associated with the DB proxy endpoint that you create.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbproxyendpoint.html#cfn-rds-dbproxyendpoint-dbproxyname
        '''
        return typing.cast(builtins.str, jsii.get(self, "dbProxyName"))

    @db_proxy_name.setter
    def db_proxy_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b8a1764132ee4f6151443f30fae73ee56659f0a433c6d22ac55834849b6e254f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dbProxyName", value)

    @builtins.property
    @jsii.member(jsii_name="vpcSubnetIds")
    def vpc_subnet_ids(self) -> typing.List[builtins.str]:
        '''The VPC subnet IDs for the DB proxy endpoint that you create.

        You can specify a different set of subnet IDs than for the original DB proxy.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbproxyendpoint.html#cfn-rds-dbproxyendpoint-vpcsubnetids
        '''
        return typing.cast(typing.List[builtins.str], jsii.get(self, "vpcSubnetIds"))

    @vpc_subnet_ids.setter
    def vpc_subnet_ids(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ee573296b273bb1ee5cb4e504adcacc50e982b3ec13d787f8dbd90fa92844263)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "vpcSubnetIds", value)

    @builtins.property
    @jsii.member(jsii_name="tags")
    def tags(
        self,
    ) -> typing.Optional[typing.List["CfnDBProxyEndpoint.TagFormatProperty"]]:
        '''An optional set of key-value pairs to associate arbitrary data of your choosing with the proxy.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbproxyendpoint.html#cfn-rds-dbproxyendpoint-tags
        '''
        return typing.cast(typing.Optional[typing.List["CfnDBProxyEndpoint.TagFormatProperty"]], jsii.get(self, "tags"))

    @tags.setter
    def tags(
        self,
        value: typing.Optional[typing.List["CfnDBProxyEndpoint.TagFormatProperty"]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__953fee923a0a9d5f8d27fee1530996c0a37743137e8564209e5538dbafc87e61)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "tags", value)

    @builtins.property
    @jsii.member(jsii_name="targetRole")
    def target_role(self) -> typing.Optional[builtins.str]:
        '''A value that indicates whether the DB proxy endpoint can be used for read/write or read-only operations.

        Valid Values: ``READ_WRITE | READ_ONLY``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbproxyendpoint.html#cfn-rds-dbproxyendpoint-targetrole
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "targetRole"))

    @target_role.setter
    def target_role(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ec8a1f5e210da14c13686d2d53996e9470c69baa0d83c7d177ea2c0ebc60c942)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "targetRole", value)

    @builtins.property
    @jsii.member(jsii_name="vpcSecurityGroupIds")
    def vpc_security_group_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The VPC security group IDs for the DB proxy endpoint that you create.

        You can specify a different set of security group IDs than for the original DB proxy. The default is the default security group for the VPC.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbproxyendpoint.html#cfn-rds-dbproxyendpoint-vpcsecuritygroupids
        '''
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "vpcSecurityGroupIds"))

    @vpc_security_group_ids.setter
    def vpc_security_group_ids(
        self,
        value: typing.Optional[typing.List[builtins.str]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__be0cf55b254b04a10c9624ceedefd73fc88271bf6d0e4a36f0e2144f93f9684f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "vpcSecurityGroupIds", value)

    @jsii.data_type(
        jsii_type="monocdk.aws_rds.CfnDBProxyEndpoint.TagFormatProperty",
        jsii_struct_bases=[],
        name_mapping={"key": "key", "value": "value"},
    )
    class TagFormatProperty:
        def __init__(
            self,
            *,
            key: typing.Optional[builtins.str] = None,
            value: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Metadata assigned to a DB proxy endpoint consisting of a key-value pair.

            :param key: A value is the optional value of the tag. The string value can be 1-256 Unicode characters in length and can't be prefixed with ``aws:`` . The string can contain only the set of Unicode letters, digits, white-space, '*', '.', '/', '=', '+', '-' (Java regex: "^([\\p{L}\\p{Z}\\p{N}*.:/=+\\-]*)$").
            :param value: Metadata assigned to a DB instance consisting of a key-value pair.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbproxyendpoint-tagformat.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from monocdk import aws_rds as rds
                
                tag_format_property = rds.CfnDBProxyEndpoint.TagFormatProperty(
                    key="key",
                    value="value"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__c46737ff6c34d6ebc46e7a005cf44a6796a0b667020fc11b49abcb5deacf6b1d)
                check_type(argname="argument key", value=key, expected_type=type_hints["key"])
                check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if key is not None:
                self._values["key"] = key
            if value is not None:
                self._values["value"] = value

        @builtins.property
        def key(self) -> typing.Optional[builtins.str]:
            '''A value is the optional value of the tag.

            The string value can be 1-256 Unicode characters in length and can't be prefixed with ``aws:`` . The string can contain only the set of Unicode letters, digits, white-space, '*', '.', '/', '=', '+', '-' (Java regex: "^([\\p{L}\\p{Z}\\p{N}*.:/=+-]*)$").

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbproxyendpoint-tagformat.html#cfn-rds-dbproxyendpoint-tagformat-key
            '''
            result = self._values.get("key")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def value(self) -> typing.Optional[builtins.str]:
            '''Metadata assigned to a DB instance consisting of a key-value pair.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbproxyendpoint-tagformat.html#cfn-rds-dbproxyendpoint-tagformat-value
            '''
            result = self._values.get("value")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TagFormatProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="monocdk.aws_rds.CfnDBProxyEndpointProps",
    jsii_struct_bases=[],
    name_mapping={
        "db_proxy_endpoint_name": "dbProxyEndpointName",
        "db_proxy_name": "dbProxyName",
        "vpc_subnet_ids": "vpcSubnetIds",
        "tags": "tags",
        "target_role": "targetRole",
        "vpc_security_group_ids": "vpcSecurityGroupIds",
    },
)
class CfnDBProxyEndpointProps:
    def __init__(
        self,
        *,
        db_proxy_endpoint_name: builtins.str,
        db_proxy_name: builtins.str,
        vpc_subnet_ids: typing.Sequence[builtins.str],
        tags: typing.Optional[typing.Sequence[typing.Union[CfnDBProxyEndpoint.TagFormatProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
        target_role: typing.Optional[builtins.str] = None,
        vpc_security_group_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''Properties for defining a ``CfnDBProxyEndpoint``.

        :param db_proxy_endpoint_name: The name of the DB proxy endpoint to create.
        :param db_proxy_name: The name of the DB proxy associated with the DB proxy endpoint that you create.
        :param vpc_subnet_ids: The VPC subnet IDs for the DB proxy endpoint that you create. You can specify a different set of subnet IDs than for the original DB proxy.
        :param tags: An optional set of key-value pairs to associate arbitrary data of your choosing with the proxy.
        :param target_role: A value that indicates whether the DB proxy endpoint can be used for read/write or read-only operations. Valid Values: ``READ_WRITE | READ_ONLY``
        :param vpc_security_group_ids: The VPC security group IDs for the DB proxy endpoint that you create. You can specify a different set of security group IDs than for the original DB proxy. The default is the default security group for the VPC.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbproxyendpoint.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_rds as rds
            
            cfn_dBProxy_endpoint_props = rds.CfnDBProxyEndpointProps(
                db_proxy_endpoint_name="dbProxyEndpointName",
                db_proxy_name="dbProxyName",
                vpc_subnet_ids=["vpcSubnetIds"],
            
                # the properties below are optional
                tags=[rds.CfnDBProxyEndpoint.TagFormatProperty(
                    key="key",
                    value="value"
                )],
                target_role="targetRole",
                vpc_security_group_ids=["vpcSecurityGroupIds"]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f24126d4f5bb320638d718f8cdca2be62c34147c1f8746a1877238ac25102dfc)
            check_type(argname="argument db_proxy_endpoint_name", value=db_proxy_endpoint_name, expected_type=type_hints["db_proxy_endpoint_name"])
            check_type(argname="argument db_proxy_name", value=db_proxy_name, expected_type=type_hints["db_proxy_name"])
            check_type(argname="argument vpc_subnet_ids", value=vpc_subnet_ids, expected_type=type_hints["vpc_subnet_ids"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument target_role", value=target_role, expected_type=type_hints["target_role"])
            check_type(argname="argument vpc_security_group_ids", value=vpc_security_group_ids, expected_type=type_hints["vpc_security_group_ids"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "db_proxy_endpoint_name": db_proxy_endpoint_name,
            "db_proxy_name": db_proxy_name,
            "vpc_subnet_ids": vpc_subnet_ids,
        }
        if tags is not None:
            self._values["tags"] = tags
        if target_role is not None:
            self._values["target_role"] = target_role
        if vpc_security_group_ids is not None:
            self._values["vpc_security_group_ids"] = vpc_security_group_ids

    @builtins.property
    def db_proxy_endpoint_name(self) -> builtins.str:
        '''The name of the DB proxy endpoint to create.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbproxyendpoint.html#cfn-rds-dbproxyendpoint-dbproxyendpointname
        '''
        result = self._values.get("db_proxy_endpoint_name")
        assert result is not None, "Required property 'db_proxy_endpoint_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def db_proxy_name(self) -> builtins.str:
        '''The name of the DB proxy associated with the DB proxy endpoint that you create.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbproxyendpoint.html#cfn-rds-dbproxyendpoint-dbproxyname
        '''
        result = self._values.get("db_proxy_name")
        assert result is not None, "Required property 'db_proxy_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def vpc_subnet_ids(self) -> typing.List[builtins.str]:
        '''The VPC subnet IDs for the DB proxy endpoint that you create.

        You can specify a different set of subnet IDs than for the original DB proxy.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbproxyendpoint.html#cfn-rds-dbproxyendpoint-vpcsubnetids
        '''
        result = self._values.get("vpc_subnet_ids")
        assert result is not None, "Required property 'vpc_subnet_ids' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def tags(
        self,
    ) -> typing.Optional[typing.List[CfnDBProxyEndpoint.TagFormatProperty]]:
        '''An optional set of key-value pairs to associate arbitrary data of your choosing with the proxy.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbproxyendpoint.html#cfn-rds-dbproxyendpoint-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[CfnDBProxyEndpoint.TagFormatProperty]], result)

    @builtins.property
    def target_role(self) -> typing.Optional[builtins.str]:
        '''A value that indicates whether the DB proxy endpoint can be used for read/write or read-only operations.

        Valid Values: ``READ_WRITE | READ_ONLY``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbproxyendpoint.html#cfn-rds-dbproxyendpoint-targetrole
        '''
        result = self._values.get("target_role")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vpc_security_group_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The VPC security group IDs for the DB proxy endpoint that you create.

        You can specify a different set of security group IDs than for the original DB proxy. The default is the default security group for the VPC.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbproxyendpoint.html#cfn-rds-dbproxyendpoint-vpcsecuritygroupids
        '''
        result = self._values.get("vpc_security_group_ids")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnDBProxyEndpointProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_rds.CfnDBProxyProps",
    jsii_struct_bases=[],
    name_mapping={
        "auth": "auth",
        "db_proxy_name": "dbProxyName",
        "engine_family": "engineFamily",
        "role_arn": "roleArn",
        "vpc_subnet_ids": "vpcSubnetIds",
        "debug_logging": "debugLogging",
        "idle_client_timeout": "idleClientTimeout",
        "require_tls": "requireTls",
        "tags": "tags",
        "vpc_security_group_ids": "vpcSecurityGroupIds",
    },
)
class CfnDBProxyProps:
    def __init__(
        self,
        *,
        auth: typing.Union[_IResolvable_a771d0ef, typing.Sequence[typing.Union[typing.Union[CfnDBProxy.AuthFormatProperty, typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]]],
        db_proxy_name: builtins.str,
        engine_family: builtins.str,
        role_arn: builtins.str,
        vpc_subnet_ids: typing.Sequence[builtins.str],
        debug_logging: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        idle_client_timeout: typing.Optional[jsii.Number] = None,
        require_tls: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union[CfnDBProxy.TagFormatProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
        vpc_security_group_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''Properties for defining a ``CfnDBProxy``.

        :param auth: The authorization mechanism that the proxy uses.
        :param db_proxy_name: The identifier for the proxy. This name must be unique for all proxies owned by your AWS account in the specified AWS Region . An identifier must begin with a letter and must contain only ASCII letters, digits, and hyphens; it can't end with a hyphen or contain two consecutive hyphens.
        :param engine_family: The kinds of databases that the proxy can connect to. This value determines which database network protocol the proxy recognizes when it interprets network traffic to and from the database. For Aurora MySQL, RDS for MariaDB, and RDS for MySQL databases, specify ``MYSQL`` . For Aurora PostgreSQL and RDS for PostgreSQL databases, specify ``POSTGRESQL`` . For RDS for Microsoft SQL Server, specify ``SQLSERVER`` . *Valid values* : ``MYSQL`` | ``POSTGRESQL`` | ``SQLSERVER``
        :param role_arn: The Amazon Resource Name (ARN) of the IAM role that the proxy uses to access secrets in AWS Secrets Manager.
        :param vpc_subnet_ids: One or more VPC subnet IDs to associate with the new proxy.
        :param debug_logging: Whether the proxy includes detailed information about SQL statements in its logs. This information helps you to debug issues involving SQL behavior or the performance and scalability of the proxy connections. The debug information includes the text of SQL statements that you submit through the proxy. Thus, only enable this setting when needed for debugging, and only when you have security measures in place to safeguard any sensitive information that appears in the logs.
        :param idle_client_timeout: The number of seconds that a connection to the proxy can be inactive before the proxy disconnects it. You can set this value higher or lower than the connection timeout limit for the associated database.
        :param require_tls: A Boolean parameter that specifies whether Transport Layer Security (TLS) encryption is required for connections to the proxy. By enabling this setting, you can enforce encrypted TLS connections to the proxy.
        :param tags: An optional set of key-value pairs to associate arbitrary data of your choosing with the proxy.
        :param vpc_security_group_ids: One or more VPC security group IDs to associate with the new proxy. If you plan to update the resource, don't specify VPC security groups in a shared VPC.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbproxy.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_rds as rds
            
            cfn_dBProxy_props = rds.CfnDBProxyProps(
                auth=[rds.CfnDBProxy.AuthFormatProperty(
                    auth_scheme="authScheme",
                    client_password_auth_type="clientPasswordAuthType",
                    description="description",
                    iam_auth="iamAuth",
                    secret_arn="secretArn"
                )],
                db_proxy_name="dbProxyName",
                engine_family="engineFamily",
                role_arn="roleArn",
                vpc_subnet_ids=["vpcSubnetIds"],
            
                # the properties below are optional
                debug_logging=False,
                idle_client_timeout=123,
                require_tls=False,
                tags=[rds.CfnDBProxy.TagFormatProperty(
                    key="key",
                    value="value"
                )],
                vpc_security_group_ids=["vpcSecurityGroupIds"]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__54a9709bd2bf8d0f24e5e08e65a124bd095a66c41c82613fab69cb8a98c4d1db)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument db_proxy_name", value=db_proxy_name, expected_type=type_hints["db_proxy_name"])
            check_type(argname="argument engine_family", value=engine_family, expected_type=type_hints["engine_family"])
            check_type(argname="argument role_arn", value=role_arn, expected_type=type_hints["role_arn"])
            check_type(argname="argument vpc_subnet_ids", value=vpc_subnet_ids, expected_type=type_hints["vpc_subnet_ids"])
            check_type(argname="argument debug_logging", value=debug_logging, expected_type=type_hints["debug_logging"])
            check_type(argname="argument idle_client_timeout", value=idle_client_timeout, expected_type=type_hints["idle_client_timeout"])
            check_type(argname="argument require_tls", value=require_tls, expected_type=type_hints["require_tls"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument vpc_security_group_ids", value=vpc_security_group_ids, expected_type=type_hints["vpc_security_group_ids"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
            "db_proxy_name": db_proxy_name,
            "engine_family": engine_family,
            "role_arn": role_arn,
            "vpc_subnet_ids": vpc_subnet_ids,
        }
        if debug_logging is not None:
            self._values["debug_logging"] = debug_logging
        if idle_client_timeout is not None:
            self._values["idle_client_timeout"] = idle_client_timeout
        if require_tls is not None:
            self._values["require_tls"] = require_tls
        if tags is not None:
            self._values["tags"] = tags
        if vpc_security_group_ids is not None:
            self._values["vpc_security_group_ids"] = vpc_security_group_ids

    @builtins.property
    def auth(
        self,
    ) -> typing.Union[_IResolvable_a771d0ef, typing.List[typing.Union[CfnDBProxy.AuthFormatProperty, _IResolvable_a771d0ef]]]:
        '''The authorization mechanism that the proxy uses.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbproxy.html#cfn-rds-dbproxy-auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast(typing.Union[_IResolvable_a771d0ef, typing.List[typing.Union[CfnDBProxy.AuthFormatProperty, _IResolvable_a771d0ef]]], result)

    @builtins.property
    def db_proxy_name(self) -> builtins.str:
        '''The identifier for the proxy.

        This name must be unique for all proxies owned by your AWS account in the specified AWS Region . An identifier must begin with a letter and must contain only ASCII letters, digits, and hyphens; it can't end with a hyphen or contain two consecutive hyphens.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbproxy.html#cfn-rds-dbproxy-dbproxyname
        '''
        result = self._values.get("db_proxy_name")
        assert result is not None, "Required property 'db_proxy_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def engine_family(self) -> builtins.str:
        '''The kinds of databases that the proxy can connect to.

        This value determines which database network protocol the proxy recognizes when it interprets network traffic to and from the database. For Aurora MySQL, RDS for MariaDB, and RDS for MySQL databases, specify ``MYSQL`` . For Aurora PostgreSQL and RDS for PostgreSQL databases, specify ``POSTGRESQL`` . For RDS for Microsoft SQL Server, specify ``SQLSERVER`` .

        *Valid values* : ``MYSQL`` | ``POSTGRESQL`` | ``SQLSERVER``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbproxy.html#cfn-rds-dbproxy-enginefamily
        '''
        result = self._values.get("engine_family")
        assert result is not None, "Required property 'engine_family' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def role_arn(self) -> builtins.str:
        '''The Amazon Resource Name (ARN) of the IAM role that the proxy uses to access secrets in AWS Secrets Manager.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbproxy.html#cfn-rds-dbproxy-rolearn
        '''
        result = self._values.get("role_arn")
        assert result is not None, "Required property 'role_arn' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def vpc_subnet_ids(self) -> typing.List[builtins.str]:
        '''One or more VPC subnet IDs to associate with the new proxy.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbproxy.html#cfn-rds-dbproxy-vpcsubnetids
        '''
        result = self._values.get("vpc_subnet_ids")
        assert result is not None, "Required property 'vpc_subnet_ids' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def debug_logging(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''Whether the proxy includes detailed information about SQL statements in its logs.

        This information helps you to debug issues involving SQL behavior or the performance and scalability of the proxy connections. The debug information includes the text of SQL statements that you submit through the proxy. Thus, only enable this setting when needed for debugging, and only when you have security measures in place to safeguard any sensitive information that appears in the logs.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbproxy.html#cfn-rds-dbproxy-debuglogging
        '''
        result = self._values.get("debug_logging")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], result)

    @builtins.property
    def idle_client_timeout(self) -> typing.Optional[jsii.Number]:
        '''The number of seconds that a connection to the proxy can be inactive before the proxy disconnects it.

        You can set this value higher or lower than the connection timeout limit for the associated database.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbproxy.html#cfn-rds-dbproxy-idleclienttimeout
        '''
        result = self._values.get("idle_client_timeout")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def require_tls(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''A Boolean parameter that specifies whether Transport Layer Security (TLS) encryption is required for connections to the proxy.

        By enabling this setting, you can enforce encrypted TLS connections to the proxy.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbproxy.html#cfn-rds-dbproxy-requiretls
        '''
        result = self._values.get("require_tls")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[CfnDBProxy.TagFormatProperty]]:
        '''An optional set of key-value pairs to associate arbitrary data of your choosing with the proxy.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbproxy.html#cfn-rds-dbproxy-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[CfnDBProxy.TagFormatProperty]], result)

    @builtins.property
    def vpc_security_group_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''One or more VPC security group IDs to associate with the new proxy.

        If you plan to update the resource, don't specify VPC security groups in a shared VPC.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbproxy.html#cfn-rds-dbproxy-vpcsecuritygroupids
        '''
        result = self._values.get("vpc_security_group_ids")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnDBProxyProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_82c04a63)
class CfnDBProxyTargetGroup(
    _CfnResource_e0a482dc,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_rds.CfnDBProxyTargetGroup",
):
    '''A CloudFormation ``AWS::RDS::DBProxyTargetGroup``.

    The ``AWS::RDS::DBProxyTargetGroup`` resource represents a set of RDS DB instances, Aurora DB clusters, or both that a proxy can connect to. Currently, each target group is associated with exactly one RDS DB instance or Aurora DB cluster.

    This data type is used as a response element in the ``DescribeDBProxyTargetGroups`` action.

    For information about RDS Proxy for Amazon RDS, see `Managing Connections with Amazon RDS Proxy <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-proxy.html>`_ in the *Amazon RDS User Guide* .

    For information about RDS Proxy for Amazon Aurora, see `Managing Connections with Amazon RDS Proxy <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/rds-proxy.html>`_ in the *Amazon Aurora User Guide* .

    For a sample template that creates a DB proxy and registers a DB instance, see `Examples <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbproxy.html#aws-resource-rds-dbproxy--examples>`_ in AWS::RDS::DBProxy.
    .. epigraph::

       Limitations apply to RDS Proxy, including DB engine version limitations and AWS Region limitations.

       For information about limitations that apply to RDS Proxy for Amazon RDS, see `Limitations for RDS Proxy <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-proxy.html#rds-proxy.limitations>`_ in the *Amazon RDS User Guide* .

       For information about that apply to RDS Proxy for Amazon Aurora, see `Limitations for RDS Proxy <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/rds-proxy.html#rds-proxy.limitations>`_ in the *Amazon Aurora User Guide* .

    :cloudformationResource: AWS::RDS::DBProxyTargetGroup
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbproxytargetgroup.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from monocdk import aws_rds as rds
        
        cfn_dBProxy_target_group = rds.CfnDBProxyTargetGroup(self, "MyCfnDBProxyTargetGroup",
            db_proxy_name="dbProxyName",
            target_group_name="targetGroupName",
        
            # the properties below are optional
            connection_pool_configuration_info=rds.CfnDBProxyTargetGroup.ConnectionPoolConfigurationInfoFormatProperty(
                connection_borrow_timeout=123,
                init_query="initQuery",
                max_connections_percent=123,
                max_idle_connections_percent=123,
                session_pinning_filters=["sessionPinningFilters"]
            ),
            db_cluster_identifiers=["dbClusterIdentifiers"],
            db_instance_identifiers=["dbInstanceIdentifiers"]
        )
    '''

    def __init__(
        self,
        scope: _Construct_e78e779f,
        id: builtins.str,
        *,
        db_proxy_name: builtins.str,
        target_group_name: builtins.str,
        connection_pool_configuration_info: typing.Optional[typing.Union[typing.Union["CfnDBProxyTargetGroup.ConnectionPoolConfigurationInfoFormatProperty", typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]] = None,
        db_cluster_identifiers: typing.Optional[typing.Sequence[builtins.str]] = None,
        db_instance_identifiers: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''Create a new ``AWS::RDS::DBProxyTargetGroup``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param db_proxy_name: The identifier of the ``DBProxy`` that is associated with the ``DBProxyTargetGroup`` .
        :param target_group_name: The identifier for the target group. .. epigraph:: Currently, this property must be set to ``default`` .
        :param connection_pool_configuration_info: Settings that control the size and behavior of the connection pool associated with a ``DBProxyTargetGroup`` .
        :param db_cluster_identifiers: One or more DB cluster identifiers.
        :param db_instance_identifiers: One or more DB instance identifiers.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5389a35838dfc16fdb58bdea4137236c7895494e1a70f820e1116a45625d6ee0)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = CfnDBProxyTargetGroupProps(
            db_proxy_name=db_proxy_name,
            target_group_name=target_group_name,
            connection_pool_configuration_info=connection_pool_configuration_info,
            db_cluster_identifiers=db_cluster_identifiers,
            db_instance_identifiers=db_instance_identifiers,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_1cd1894e) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__43fbd7a5904716388dd71238ea25bcb868772e37f6fa4a4fb90a873a5dea705b)
            check_type(argname="argument inspector", value=inspector, expected_type=type_hints["inspector"])
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__167f158cc042a5f06a0eeb1868661fcab0dec0592294488cd05d2b86df32c1b1)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="attrTargetGroupArn")
    def attr_target_group_arn(self) -> builtins.str:
        '''The Amazon Resource Name (ARN) representing the target group.

        :cloudformationAttribute: TargetGroupArn
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrTargetGroupArn"))

    @builtins.property
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property
    @jsii.member(jsii_name="dbProxyName")
    def db_proxy_name(self) -> builtins.str:
        '''The identifier of the ``DBProxy`` that is associated with the ``DBProxyTargetGroup`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbproxytargetgroup.html#cfn-rds-dbproxytargetgroup-dbproxyname
        '''
        return typing.cast(builtins.str, jsii.get(self, "dbProxyName"))

    @db_proxy_name.setter
    def db_proxy_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__877d4ced2689548f5ab4a6849d34deaa1e4cacd0055cc4344f6f10a58c88964c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dbProxyName", value)

    @builtins.property
    @jsii.member(jsii_name="targetGroupName")
    def target_group_name(self) -> builtins.str:
        '''The identifier for the target group.

        .. epigraph::

           Currently, this property must be set to ``default`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbproxytargetgroup.html#cfn-rds-dbproxytargetgroup-targetgroupname
        '''
        return typing.cast(builtins.str, jsii.get(self, "targetGroupName"))

    @target_group_name.setter
    def target_group_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__552b2c23354860d8c4b7f36d402424bb22c7da9eee4dbea3813a53ce5d7abec6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "targetGroupName", value)

    @builtins.property
    @jsii.member(jsii_name="connectionPoolConfigurationInfo")
    def connection_pool_configuration_info(
        self,
    ) -> typing.Optional[typing.Union["CfnDBProxyTargetGroup.ConnectionPoolConfigurationInfoFormatProperty", _IResolvable_a771d0ef]]:
        '''Settings that control the size and behavior of the connection pool associated with a ``DBProxyTargetGroup`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbproxytargetgroup.html#cfn-rds-dbproxytargetgroup-connectionpoolconfigurationinfo
        '''
        return typing.cast(typing.Optional[typing.Union["CfnDBProxyTargetGroup.ConnectionPoolConfigurationInfoFormatProperty", _IResolvable_a771d0ef]], jsii.get(self, "connectionPoolConfigurationInfo"))

    @connection_pool_configuration_info.setter
    def connection_pool_configuration_info(
        self,
        value: typing.Optional[typing.Union["CfnDBProxyTargetGroup.ConnectionPoolConfigurationInfoFormatProperty", _IResolvable_a771d0ef]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__773ed9e61b188469d54c6dc756b3ada1c3521614924f0b5b30fc2bd5c7e71fc3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "connectionPoolConfigurationInfo", value)

    @builtins.property
    @jsii.member(jsii_name="dbClusterIdentifiers")
    def db_cluster_identifiers(self) -> typing.Optional[typing.List[builtins.str]]:
        '''One or more DB cluster identifiers.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbproxytargetgroup.html#cfn-rds-dbproxytargetgroup-dbclusteridentifiers
        '''
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "dbClusterIdentifiers"))

    @db_cluster_identifiers.setter
    def db_cluster_identifiers(
        self,
        value: typing.Optional[typing.List[builtins.str]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c919873c840e765ffa9b462429e223326001d0ab433c5e3b521b2d00cc2ff48d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dbClusterIdentifiers", value)

    @builtins.property
    @jsii.member(jsii_name="dbInstanceIdentifiers")
    def db_instance_identifiers(self) -> typing.Optional[typing.List[builtins.str]]:
        '''One or more DB instance identifiers.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbproxytargetgroup.html#cfn-rds-dbproxytargetgroup-dbinstanceidentifiers
        '''
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "dbInstanceIdentifiers"))

    @db_instance_identifiers.setter
    def db_instance_identifiers(
        self,
        value: typing.Optional[typing.List[builtins.str]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__26f31893b792f5568c677878d5ab2ae53b8ba629d0fed89dde24bb97d22eb0d9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dbInstanceIdentifiers", value)

    @jsii.data_type(
        jsii_type="monocdk.aws_rds.CfnDBProxyTargetGroup.ConnectionPoolConfigurationInfoFormatProperty",
        jsii_struct_bases=[],
        name_mapping={
            "connection_borrow_timeout": "connectionBorrowTimeout",
            "init_query": "initQuery",
            "max_connections_percent": "maxConnectionsPercent",
            "max_idle_connections_percent": "maxIdleConnectionsPercent",
            "session_pinning_filters": "sessionPinningFilters",
        },
    )
    class ConnectionPoolConfigurationInfoFormatProperty:
        def __init__(
            self,
            *,
            connection_borrow_timeout: typing.Optional[jsii.Number] = None,
            init_query: typing.Optional[builtins.str] = None,
            max_connections_percent: typing.Optional[jsii.Number] = None,
            max_idle_connections_percent: typing.Optional[jsii.Number] = None,
            session_pinning_filters: typing.Optional[typing.Sequence[builtins.str]] = None,
        ) -> None:
            '''Specifies the settings that control the size and behavior of the connection pool associated with a ``DBProxyTargetGroup`` .

            :param connection_borrow_timeout: The number of seconds for a proxy to wait for a connection to become available in the connection pool. Only applies when the proxy has opened its maximum number of connections and all connections are busy with client sessions. Default: 120 Constraints: between 1 and 3600, or 0 representing unlimited
            :param init_query: One or more SQL statements for the proxy to run when opening each new database connection. Typically used with ``SET`` statements to make sure that each connection has identical settings such as time zone and character set. For multiple statements, use semicolons as the separator. You can also include multiple variables in a single ``SET`` statement, such as ``SET x=1, y=2`` . Default: no initialization query
            :param max_connections_percent: The maximum size of the connection pool for each target in a target group. The value is expressed as a percentage of the ``max_connections`` setting for the RDS DB instance or Aurora DB cluster used by the target group. If you specify ``MaxIdleConnectionsPercent`` , then you must also include a value for this parameter. Default: 10 for RDS for Microsoft SQL Server, and 100 for all other engines Constraints: Must be between 1 and 100.
            :param max_idle_connections_percent: Controls how actively the proxy closes idle database connections in the connection pool. The value is expressed as a percentage of the ``max_connections`` setting for the RDS DB instance or Aurora DB cluster used by the target group. With a high value, the proxy leaves a high percentage of idle database connections open. A low value causes the proxy to close more idle connections and return them to the database. If you specify this parameter, then you must also include a value for ``MaxConnectionsPercent`` . Default: The default value is half of the value of ``MaxConnectionsPercent`` . For example, if ``MaxConnectionsPercent`` is 80, then the default value of ``MaxIdleConnectionsPercent`` is 40. If the value of ``MaxConnectionsPercent`` isn't specified, then for SQL Server, ``MaxIdleConnectionsPercent`` is 5, and for all other engines, the default is 50. Constraints: Must be between 0 and the value of ``MaxConnectionsPercent`` .
            :param session_pinning_filters: Each item in the list represents a class of SQL operations that normally cause all later statements in a session using a proxy to be pinned to the same underlying database connection. Including an item in the list exempts that class of SQL operations from the pinning behavior. Default: no session pinning filters

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbproxytargetgroup-connectionpoolconfigurationinfoformat.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from monocdk import aws_rds as rds
                
                connection_pool_configuration_info_format_property = rds.CfnDBProxyTargetGroup.ConnectionPoolConfigurationInfoFormatProperty(
                    connection_borrow_timeout=123,
                    init_query="initQuery",
                    max_connections_percent=123,
                    max_idle_connections_percent=123,
                    session_pinning_filters=["sessionPinningFilters"]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__9a22ef16c4137223a647eac410a7ca303889b997941e0fea5de937f9ffb4ebf6)
                check_type(argname="argument connection_borrow_timeout", value=connection_borrow_timeout, expected_type=type_hints["connection_borrow_timeout"])
                check_type(argname="argument init_query", value=init_query, expected_type=type_hints["init_query"])
                check_type(argname="argument max_connections_percent", value=max_connections_percent, expected_type=type_hints["max_connections_percent"])
                check_type(argname="argument max_idle_connections_percent", value=max_idle_connections_percent, expected_type=type_hints["max_idle_connections_percent"])
                check_type(argname="argument session_pinning_filters", value=session_pinning_filters, expected_type=type_hints["session_pinning_filters"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if connection_borrow_timeout is not None:
                self._values["connection_borrow_timeout"] = connection_borrow_timeout
            if init_query is not None:
                self._values["init_query"] = init_query
            if max_connections_percent is not None:
                self._values["max_connections_percent"] = max_connections_percent
            if max_idle_connections_percent is not None:
                self._values["max_idle_connections_percent"] = max_idle_connections_percent
            if session_pinning_filters is not None:
                self._values["session_pinning_filters"] = session_pinning_filters

        @builtins.property
        def connection_borrow_timeout(self) -> typing.Optional[jsii.Number]:
            '''The number of seconds for a proxy to wait for a connection to become available in the connection pool.

            Only applies when the proxy has opened its maximum number of connections and all connections are busy with client sessions.

            Default: 120

            Constraints: between 1 and 3600, or 0 representing unlimited

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbproxytargetgroup-connectionpoolconfigurationinfoformat.html#cfn-rds-dbproxytargetgroup-connectionpoolconfigurationinfoformat-connectionborrowtimeout
            '''
            result = self._values.get("connection_borrow_timeout")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def init_query(self) -> typing.Optional[builtins.str]:
            '''One or more SQL statements for the proxy to run when opening each new database connection.

            Typically used with ``SET`` statements to make sure that each connection has identical settings such as time zone and character set. For multiple statements, use semicolons as the separator. You can also include multiple variables in a single ``SET`` statement, such as ``SET x=1, y=2`` .

            Default: no initialization query

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbproxytargetgroup-connectionpoolconfigurationinfoformat.html#cfn-rds-dbproxytargetgroup-connectionpoolconfigurationinfoformat-initquery
            '''
            result = self._values.get("init_query")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def max_connections_percent(self) -> typing.Optional[jsii.Number]:
            '''The maximum size of the connection pool for each target in a target group.

            The value is expressed as a percentage of the ``max_connections`` setting for the RDS DB instance or Aurora DB cluster used by the target group.

            If you specify ``MaxIdleConnectionsPercent`` , then you must also include a value for this parameter.

            Default: 10 for RDS for Microsoft SQL Server, and 100 for all other engines

            Constraints: Must be between 1 and 100.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbproxytargetgroup-connectionpoolconfigurationinfoformat.html#cfn-rds-dbproxytargetgroup-connectionpoolconfigurationinfoformat-maxconnectionspercent
            '''
            result = self._values.get("max_connections_percent")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def max_idle_connections_percent(self) -> typing.Optional[jsii.Number]:
            '''Controls how actively the proxy closes idle database connections in the connection pool.

            The value is expressed as a percentage of the ``max_connections`` setting for the RDS DB instance or Aurora DB cluster used by the target group. With a high value, the proxy leaves a high percentage of idle database connections open. A low value causes the proxy to close more idle connections and return them to the database.

            If you specify this parameter, then you must also include a value for ``MaxConnectionsPercent`` .

            Default: The default value is half of the value of ``MaxConnectionsPercent`` . For example, if ``MaxConnectionsPercent`` is 80, then the default value of ``MaxIdleConnectionsPercent`` is 40. If the value of ``MaxConnectionsPercent`` isn't specified, then for SQL Server, ``MaxIdleConnectionsPercent`` is 5, and for all other engines, the default is 50.

            Constraints: Must be between 0 and the value of ``MaxConnectionsPercent`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbproxytargetgroup-connectionpoolconfigurationinfoformat.html#cfn-rds-dbproxytargetgroup-connectionpoolconfigurationinfoformat-maxidleconnectionspercent
            '''
            result = self._values.get("max_idle_connections_percent")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def session_pinning_filters(self) -> typing.Optional[typing.List[builtins.str]]:
            '''Each item in the list represents a class of SQL operations that normally cause all later statements in a session using a proxy to be pinned to the same underlying database connection.

            Including an item in the list exempts that class of SQL operations from the pinning behavior.

            Default: no session pinning filters

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbproxytargetgroup-connectionpoolconfigurationinfoformat.html#cfn-rds-dbproxytargetgroup-connectionpoolconfigurationinfoformat-sessionpinningfilters
            '''
            result = self._values.get("session_pinning_filters")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ConnectionPoolConfigurationInfoFormatProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="monocdk.aws_rds.CfnDBProxyTargetGroupProps",
    jsii_struct_bases=[],
    name_mapping={
        "db_proxy_name": "dbProxyName",
        "target_group_name": "targetGroupName",
        "connection_pool_configuration_info": "connectionPoolConfigurationInfo",
        "db_cluster_identifiers": "dbClusterIdentifiers",
        "db_instance_identifiers": "dbInstanceIdentifiers",
    },
)
class CfnDBProxyTargetGroupProps:
    def __init__(
        self,
        *,
        db_proxy_name: builtins.str,
        target_group_name: builtins.str,
        connection_pool_configuration_info: typing.Optional[typing.Union[typing.Union[CfnDBProxyTargetGroup.ConnectionPoolConfigurationInfoFormatProperty, typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]] = None,
        db_cluster_identifiers: typing.Optional[typing.Sequence[builtins.str]] = None,
        db_instance_identifiers: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''Properties for defining a ``CfnDBProxyTargetGroup``.

        :param db_proxy_name: The identifier of the ``DBProxy`` that is associated with the ``DBProxyTargetGroup`` .
        :param target_group_name: The identifier for the target group. .. epigraph:: Currently, this property must be set to ``default`` .
        :param connection_pool_configuration_info: Settings that control the size and behavior of the connection pool associated with a ``DBProxyTargetGroup`` .
        :param db_cluster_identifiers: One or more DB cluster identifiers.
        :param db_instance_identifiers: One or more DB instance identifiers.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbproxytargetgroup.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_rds as rds
            
            cfn_dBProxy_target_group_props = rds.CfnDBProxyTargetGroupProps(
                db_proxy_name="dbProxyName",
                target_group_name="targetGroupName",
            
                # the properties below are optional
                connection_pool_configuration_info=rds.CfnDBProxyTargetGroup.ConnectionPoolConfigurationInfoFormatProperty(
                    connection_borrow_timeout=123,
                    init_query="initQuery",
                    max_connections_percent=123,
                    max_idle_connections_percent=123,
                    session_pinning_filters=["sessionPinningFilters"]
                ),
                db_cluster_identifiers=["dbClusterIdentifiers"],
                db_instance_identifiers=["dbInstanceIdentifiers"]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__862d297175897be0b7f2017e74da436cdb0b52dacec41540c367a730a7540990)
            check_type(argname="argument db_proxy_name", value=db_proxy_name, expected_type=type_hints["db_proxy_name"])
            check_type(argname="argument target_group_name", value=target_group_name, expected_type=type_hints["target_group_name"])
            check_type(argname="argument connection_pool_configuration_info", value=connection_pool_configuration_info, expected_type=type_hints["connection_pool_configuration_info"])
            check_type(argname="argument db_cluster_identifiers", value=db_cluster_identifiers, expected_type=type_hints["db_cluster_identifiers"])
            check_type(argname="argument db_instance_identifiers", value=db_instance_identifiers, expected_type=type_hints["db_instance_identifiers"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "db_proxy_name": db_proxy_name,
            "target_group_name": target_group_name,
        }
        if connection_pool_configuration_info is not None:
            self._values["connection_pool_configuration_info"] = connection_pool_configuration_info
        if db_cluster_identifiers is not None:
            self._values["db_cluster_identifiers"] = db_cluster_identifiers
        if db_instance_identifiers is not None:
            self._values["db_instance_identifiers"] = db_instance_identifiers

    @builtins.property
    def db_proxy_name(self) -> builtins.str:
        '''The identifier of the ``DBProxy`` that is associated with the ``DBProxyTargetGroup`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbproxytargetgroup.html#cfn-rds-dbproxytargetgroup-dbproxyname
        '''
        result = self._values.get("db_proxy_name")
        assert result is not None, "Required property 'db_proxy_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def target_group_name(self) -> builtins.str:
        '''The identifier for the target group.

        .. epigraph::

           Currently, this property must be set to ``default`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbproxytargetgroup.html#cfn-rds-dbproxytargetgroup-targetgroupname
        '''
        result = self._values.get("target_group_name")
        assert result is not None, "Required property 'target_group_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def connection_pool_configuration_info(
        self,
    ) -> typing.Optional[typing.Union[CfnDBProxyTargetGroup.ConnectionPoolConfigurationInfoFormatProperty, _IResolvable_a771d0ef]]:
        '''Settings that control the size and behavior of the connection pool associated with a ``DBProxyTargetGroup`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbproxytargetgroup.html#cfn-rds-dbproxytargetgroup-connectionpoolconfigurationinfo
        '''
        result = self._values.get("connection_pool_configuration_info")
        return typing.cast(typing.Optional[typing.Union[CfnDBProxyTargetGroup.ConnectionPoolConfigurationInfoFormatProperty, _IResolvable_a771d0ef]], result)

    @builtins.property
    def db_cluster_identifiers(self) -> typing.Optional[typing.List[builtins.str]]:
        '''One or more DB cluster identifiers.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbproxytargetgroup.html#cfn-rds-dbproxytargetgroup-dbclusteridentifiers
        '''
        result = self._values.get("db_cluster_identifiers")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def db_instance_identifiers(self) -> typing.Optional[typing.List[builtins.str]]:
        '''One or more DB instance identifiers.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbproxytargetgroup.html#cfn-rds-dbproxytargetgroup-dbinstanceidentifiers
        '''
        result = self._values.get("db_instance_identifiers")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnDBProxyTargetGroupProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_82c04a63)
class CfnDBSecurityGroup(
    _CfnResource_e0a482dc,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_rds.CfnDBSecurityGroup",
):
    '''A CloudFormation ``AWS::RDS::DBSecurityGroup``.

    The ``AWS::RDS::DBSecurityGroup`` resource creates or updates an Amazon RDS DB security group.
    .. epigraph::

       EC2-Classic was retired on August 15, 2022. If you haven't migrated from EC2-Classic to a VPC, we recommend that you migrate as soon as possible. For more information, see `Migrate from EC2-Classic to a VPC <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/vpc-migrate.html>`_ in the *Amazon EC2 User Guide* , the blog `EC2-Classic Networking is Retiring  Heres How to Prepare <https://docs.aws.amazon.com/aws/ec2-classic-is-retiring-heres-how-to-prepare/>`_ , and `Moving a DB instance not in a VPC into a VPC <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_VPC.Non-VPC2VPC.html>`_ in the *Amazon RDS User Guide* .

    :cloudformationResource: AWS::RDS::DBSecurityGroup
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-security-group.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from monocdk import aws_rds as rds
        
        cfn_dBSecurity_group = rds.CfnDBSecurityGroup(self, "MyCfnDBSecurityGroup",
            db_security_group_ingress=[rds.CfnDBSecurityGroup.IngressProperty(
                cidrip="cidrip",
                ec2_security_group_id="ec2SecurityGroupId",
                ec2_security_group_name="ec2SecurityGroupName",
                ec2_security_group_owner_id="ec2SecurityGroupOwnerId"
            )],
            group_description="groupDescription",
        
            # the properties below are optional
            ec2_vpc_id="ec2VpcId",
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        )
    '''

    def __init__(
        self,
        scope: _Construct_e78e779f,
        id: builtins.str,
        *,
        db_security_group_ingress: typing.Union[_IResolvable_a771d0ef, typing.Sequence[typing.Union[typing.Union["CfnDBSecurityGroup.IngressProperty", typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]]],
        group_description: builtins.str,
        ec2_vpc_id: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union[_CfnTag_95fbdc29, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Create a new ``AWS::RDS::DBSecurityGroup``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param db_security_group_ingress: Ingress rules to be applied to the DB security group.
        :param group_description: Provides the description of the DB security group.
        :param ec2_vpc_id: The identifier of an Amazon VPC. This property indicates the VPC that this DB security group belongs to. .. epigraph:: The ``EC2VpcId`` property is for backward compatibility with older regions, and is no longer recommended for providing security information to an RDS DB instance.
        :param tags: An optional array of key-value pairs to apply to this DB security group.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9e9a67164f5812d523f1dcae62c6ec8f192d198b0c3e6e4fe1312a11b51a2388)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = CfnDBSecurityGroupProps(
            db_security_group_ingress=db_security_group_ingress,
            group_description=group_description,
            ec2_vpc_id=ec2_vpc_id,
            tags=tags,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_1cd1894e) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__671c6ad00aacd5577dfd9e623bd2e443bc7e8b81f59a59212a062586c9ceb89b)
            check_type(argname="argument inspector", value=inspector, expected_type=type_hints["inspector"])
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__78e0a25ccd5c108b35cefdec08c9e5d110d2597ac3db670e19ebf8d97524a440)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property
    @jsii.member(jsii_name="tags")
    def tags(self) -> _TagManager_0b7ab120:
        '''An optional array of key-value pairs to apply to this DB security group.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-security-group.html#cfn-rds-dbsecuritygroup-tags
        '''
        return typing.cast(_TagManager_0b7ab120, jsii.get(self, "tags"))

    @builtins.property
    @jsii.member(jsii_name="dbSecurityGroupIngress")
    def db_security_group_ingress(
        self,
    ) -> typing.Union[_IResolvable_a771d0ef, typing.List[typing.Union["CfnDBSecurityGroup.IngressProperty", _IResolvable_a771d0ef]]]:
        '''Ingress rules to be applied to the DB security group.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-security-group.html#cfn-rds-dbsecuritygroup-dbsecuritygroupingress
        '''
        return typing.cast(typing.Union[_IResolvable_a771d0ef, typing.List[typing.Union["CfnDBSecurityGroup.IngressProperty", _IResolvable_a771d0ef]]], jsii.get(self, "dbSecurityGroupIngress"))

    @db_security_group_ingress.setter
    def db_security_group_ingress(
        self,
        value: typing.Union[_IResolvable_a771d0ef, typing.List[typing.Union["CfnDBSecurityGroup.IngressProperty", _IResolvable_a771d0ef]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e3880dd72b4ab8729e8cc8c8aa16db47651002db898e5a28bcc55bfe90085a5e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dbSecurityGroupIngress", value)

    @builtins.property
    @jsii.member(jsii_name="groupDescription")
    def group_description(self) -> builtins.str:
        '''Provides the description of the DB security group.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-security-group.html#cfn-rds-dbsecuritygroup-groupdescription
        '''
        return typing.cast(builtins.str, jsii.get(self, "groupDescription"))

    @group_description.setter
    def group_description(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2d54183b3757ae5a64dedebb677eec7291e81e826915f70217a012042c884661)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "groupDescription", value)

    @builtins.property
    @jsii.member(jsii_name="ec2VpcId")
    def ec2_vpc_id(self) -> typing.Optional[builtins.str]:
        '''The identifier of an Amazon VPC. This property indicates the VPC that this DB security group belongs to.

        .. epigraph::

           The ``EC2VpcId`` property is for backward compatibility with older regions, and is no longer recommended for providing security information to an RDS DB instance.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-security-group.html#cfn-rds-dbsecuritygroup-ec2vpcid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "ec2VpcId"))

    @ec2_vpc_id.setter
    def ec2_vpc_id(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f1a41dada834ebee6a6b2d6e1420693278bd8d9889f8b5502f6cc1381535d125)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "ec2VpcId", value)

    @jsii.data_type(
        jsii_type="monocdk.aws_rds.CfnDBSecurityGroup.IngressProperty",
        jsii_struct_bases=[],
        name_mapping={
            "cidrip": "cidrip",
            "ec2_security_group_id": "ec2SecurityGroupId",
            "ec2_security_group_name": "ec2SecurityGroupName",
            "ec2_security_group_owner_id": "ec2SecurityGroupOwnerId",
        },
    )
    class IngressProperty:
        def __init__(
            self,
            *,
            cidrip: typing.Optional[builtins.str] = None,
            ec2_security_group_id: typing.Optional[builtins.str] = None,
            ec2_security_group_name: typing.Optional[builtins.str] = None,
            ec2_security_group_owner_id: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The ``Ingress`` property type specifies an individual ingress rule within an ``AWS::RDS::DBSecurityGroup`` resource.

            .. epigraph::

               EC2-Classic was retired on August 15, 2022. If you haven't migrated from EC2-Classic to a VPC, we recommend that you migrate as soon as possible. For more information, see `Migrate from EC2-Classic to a VPC <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/vpc-migrate.html>`_ in the *Amazon EC2 User Guide* , the blog `EC2-Classic Networking is Retiring  Heres How to Prepare <https://docs.aws.amazon.com/aws/ec2-classic-is-retiring-heres-how-to-prepare/>`_ , and `Moving a DB instance not in a VPC into a VPC <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_VPC.Non-VPC2VPC.html>`_ in the *Amazon RDS User Guide* .

            :param cidrip: The IP range to authorize.
            :param ec2_security_group_id: Id of the EC2 security group to authorize. For VPC DB security groups, ``EC2SecurityGroupId`` must be provided. Otherwise, ``EC2SecurityGroupOwnerId`` and either ``EC2SecurityGroupName`` or ``EC2SecurityGroupId`` must be provided.
            :param ec2_security_group_name: Name of the EC2 security group to authorize. For VPC DB security groups, ``EC2SecurityGroupId`` must be provided. Otherwise, ``EC2SecurityGroupOwnerId`` and either ``EC2SecurityGroupName`` or ``EC2SecurityGroupId`` must be provided.
            :param ec2_security_group_owner_id: AWS account number of the owner of the EC2 security group specified in the ``EC2SecurityGroupName`` parameter. The AWS access key ID isn't an acceptable value. For VPC DB security groups, ``EC2SecurityGroupId`` must be provided. Otherwise, ``EC2SecurityGroupOwnerId`` and either ``EC2SecurityGroupName`` or ``EC2SecurityGroupId`` must be provided.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-security-group-rule.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from monocdk import aws_rds as rds
                
                ingress_property = rds.CfnDBSecurityGroup.IngressProperty(
                    cidrip="cidrip",
                    ec2_security_group_id="ec2SecurityGroupId",
                    ec2_security_group_name="ec2SecurityGroupName",
                    ec2_security_group_owner_id="ec2SecurityGroupOwnerId"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__137df241ef4b31c18276d70992aa110de2ade5bfda6b9255651aa7762a822d0e)
                check_type(argname="argument cidrip", value=cidrip, expected_type=type_hints["cidrip"])
                check_type(argname="argument ec2_security_group_id", value=ec2_security_group_id, expected_type=type_hints["ec2_security_group_id"])
                check_type(argname="argument ec2_security_group_name", value=ec2_security_group_name, expected_type=type_hints["ec2_security_group_name"])
                check_type(argname="argument ec2_security_group_owner_id", value=ec2_security_group_owner_id, expected_type=type_hints["ec2_security_group_owner_id"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if cidrip is not None:
                self._values["cidrip"] = cidrip
            if ec2_security_group_id is not None:
                self._values["ec2_security_group_id"] = ec2_security_group_id
            if ec2_security_group_name is not None:
                self._values["ec2_security_group_name"] = ec2_security_group_name
            if ec2_security_group_owner_id is not None:
                self._values["ec2_security_group_owner_id"] = ec2_security_group_owner_id

        @builtins.property
        def cidrip(self) -> typing.Optional[builtins.str]:
            '''The IP range to authorize.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-security-group-rule.html#cfn-rds-securitygroup-cidrip
            '''
            result = self._values.get("cidrip")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def ec2_security_group_id(self) -> typing.Optional[builtins.str]:
            '''Id of the EC2 security group to authorize.

            For VPC DB security groups, ``EC2SecurityGroupId`` must be provided. Otherwise, ``EC2SecurityGroupOwnerId`` and either ``EC2SecurityGroupName`` or ``EC2SecurityGroupId`` must be provided.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-security-group-rule.html#cfn-rds-securitygroup-ec2securitygroupid
            '''
            result = self._values.get("ec2_security_group_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def ec2_security_group_name(self) -> typing.Optional[builtins.str]:
            '''Name of the EC2 security group to authorize.

            For VPC DB security groups, ``EC2SecurityGroupId`` must be provided. Otherwise, ``EC2SecurityGroupOwnerId`` and either ``EC2SecurityGroupName`` or ``EC2SecurityGroupId`` must be provided.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-security-group-rule.html#cfn-rds-securitygroup-ec2securitygroupname
            '''
            result = self._values.get("ec2_security_group_name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def ec2_security_group_owner_id(self) -> typing.Optional[builtins.str]:
            '''AWS account number of the owner of the EC2 security group specified in the ``EC2SecurityGroupName`` parameter.

            The AWS access key ID isn't an acceptable value. For VPC DB security groups, ``EC2SecurityGroupId`` must be provided. Otherwise, ``EC2SecurityGroupOwnerId`` and either ``EC2SecurityGroupName`` or ``EC2SecurityGroupId`` must be provided.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-security-group-rule.html#cfn-rds-securitygroup-ec2securitygroupownerid
            '''
            result = self._values.get("ec2_security_group_owner_id")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "IngressProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.implements(_IInspectable_82c04a63)
class CfnDBSecurityGroupIngress(
    _CfnResource_e0a482dc,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_rds.CfnDBSecurityGroupIngress",
):
    '''A CloudFormation ``AWS::RDS::DBSecurityGroupIngress``.

    The ``AWS::RDS::DBSecurityGroupIngress`` resource enables ingress to a DB security group using one of two forms of authorization. First, you can add EC2 or VPC security groups to the DB security group if the application using the database is running on EC2 or VPC instances. Second, IP ranges are available if the application accessing your database is running on the Internet.

    This type supports updates. For more information about updating stacks, see `AWS CloudFormation Stacks Updates <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks.html>`_ .

    For details about the settings for DB security group ingress, see `AuthorizeDBSecurityGroupIngress <https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_AuthorizeDBSecurityGroupIngress.html>`_ .
    .. epigraph::

       EC2-Classic was retired on August 15, 2022. If you haven't migrated from EC2-Classic to a VPC, we recommend that you migrate as soon as possible. For more information, see `Migrate from EC2-Classic to a VPC <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/vpc-migrate.html>`_ in the *Amazon EC2 User Guide* , the blog `EC2-Classic Networking is Retiring  Heres How to Prepare <https://docs.aws.amazon.com/aws/ec2-classic-is-retiring-heres-how-to-prepare/>`_ , and `Moving a DB instance not in a VPC into a VPC <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_VPC.Non-VPC2VPC.html>`_ in the *Amazon RDS User Guide* .

    :cloudformationResource: AWS::RDS::DBSecurityGroupIngress
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-security-group-ingress.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from monocdk import aws_rds as rds
        
        cfn_dBSecurity_group_ingress = rds.CfnDBSecurityGroupIngress(self, "MyCfnDBSecurityGroupIngress",
            db_security_group_name="dbSecurityGroupName",
        
            # the properties below are optional
            cidrip="cidrip",
            ec2_security_group_id="ec2SecurityGroupId",
            ec2_security_group_name="ec2SecurityGroupName",
            ec2_security_group_owner_id="ec2SecurityGroupOwnerId"
        )
    '''

    def __init__(
        self,
        scope: _Construct_e78e779f,
        id: builtins.str,
        *,
        db_security_group_name: builtins.str,
        cidrip: typing.Optional[builtins.str] = None,
        ec2_security_group_id: typing.Optional[builtins.str] = None,
        ec2_security_group_name: typing.Optional[builtins.str] = None,
        ec2_security_group_owner_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Create a new ``AWS::RDS::DBSecurityGroupIngress``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param db_security_group_name: The name of the DB security group to add authorization to.
        :param cidrip: The IP range to authorize.
        :param ec2_security_group_id: Id of the EC2 security group to authorize. For VPC DB security groups, ``EC2SecurityGroupId`` must be provided. Otherwise, ``EC2SecurityGroupOwnerId`` and either ``EC2SecurityGroupName`` or ``EC2SecurityGroupId`` must be provided.
        :param ec2_security_group_name: Name of the EC2 security group to authorize. For VPC DB security groups, ``EC2SecurityGroupId`` must be provided. Otherwise, ``EC2SecurityGroupOwnerId`` and either ``EC2SecurityGroupName`` or ``EC2SecurityGroupId`` must be provided.
        :param ec2_security_group_owner_id: AWS account number of the owner of the EC2 security group specified in the ``EC2SecurityGroupName`` parameter. The AWS access key ID isn't an acceptable value. For VPC DB security groups, ``EC2SecurityGroupId`` must be provided. Otherwise, ``EC2SecurityGroupOwnerId`` and either ``EC2SecurityGroupName`` or ``EC2SecurityGroupId`` must be provided.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fb87d9a69e7afe3e87948653ff0d476b92f5d6d8d7aff75b33d649963d14412b)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = CfnDBSecurityGroupIngressProps(
            db_security_group_name=db_security_group_name,
            cidrip=cidrip,
            ec2_security_group_id=ec2_security_group_id,
            ec2_security_group_name=ec2_security_group_name,
            ec2_security_group_owner_id=ec2_security_group_owner_id,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_1cd1894e) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__705f98c3c6bbfabdc5934f47d60941d41161999c4344ab85e2f5a9f58ce79d41)
            check_type(argname="argument inspector", value=inspector, expected_type=type_hints["inspector"])
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3fcb02382126a5d26ef0268f18bd7af1afff7ffaeaa8293021e02f1dee8c9ada)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property
    @jsii.member(jsii_name="dbSecurityGroupName")
    def db_security_group_name(self) -> builtins.str:
        '''The name of the DB security group to add authorization to.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-security-group-ingress.html#cfn-rds-securitygroup-ingress-dbsecuritygroupname
        '''
        return typing.cast(builtins.str, jsii.get(self, "dbSecurityGroupName"))

    @db_security_group_name.setter
    def db_security_group_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__31ef9a90a6b037a9b3ef7edcda8bc35875e3eca585363c80039cca97ad85aa9e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dbSecurityGroupName", value)

    @builtins.property
    @jsii.member(jsii_name="cidrip")
    def cidrip(self) -> typing.Optional[builtins.str]:
        '''The IP range to authorize.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-security-group-ingress.html#cfn-rds-securitygroup-ingress-cidrip
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "cidrip"))

    @cidrip.setter
    def cidrip(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__57bf6fc4ea2c1d01896ec23f0f1b4789c04257507e1fc107396c130614db9802)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "cidrip", value)

    @builtins.property
    @jsii.member(jsii_name="ec2SecurityGroupId")
    def ec2_security_group_id(self) -> typing.Optional[builtins.str]:
        '''Id of the EC2 security group to authorize.

        For VPC DB security groups, ``EC2SecurityGroupId`` must be provided. Otherwise, ``EC2SecurityGroupOwnerId`` and either ``EC2SecurityGroupName`` or ``EC2SecurityGroupId`` must be provided.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-security-group-ingress.html#cfn-rds-securitygroup-ingress-ec2securitygroupid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "ec2SecurityGroupId"))

    @ec2_security_group_id.setter
    def ec2_security_group_id(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__69486b021b641a738e72bcdb9027317af68570f2d5673a80b64240c1c32d4678)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "ec2SecurityGroupId", value)

    @builtins.property
    @jsii.member(jsii_name="ec2SecurityGroupName")
    def ec2_security_group_name(self) -> typing.Optional[builtins.str]:
        '''Name of the EC2 security group to authorize.

        For VPC DB security groups, ``EC2SecurityGroupId`` must be provided. Otherwise, ``EC2SecurityGroupOwnerId`` and either ``EC2SecurityGroupName`` or ``EC2SecurityGroupId`` must be provided.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-security-group-ingress.html#cfn-rds-securitygroup-ingress-ec2securitygroupname
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "ec2SecurityGroupName"))

    @ec2_security_group_name.setter
    def ec2_security_group_name(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3197b6af99c934a1323934a7644b111809a6b8426b5333f2dadca1714771e9af)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "ec2SecurityGroupName", value)

    @builtins.property
    @jsii.member(jsii_name="ec2SecurityGroupOwnerId")
    def ec2_security_group_owner_id(self) -> typing.Optional[builtins.str]:
        '''AWS account number of the owner of the EC2 security group specified in the ``EC2SecurityGroupName`` parameter.

        The AWS access key ID isn't an acceptable value. For VPC DB security groups, ``EC2SecurityGroupId`` must be provided. Otherwise, ``EC2SecurityGroupOwnerId`` and either ``EC2SecurityGroupName`` or ``EC2SecurityGroupId`` must be provided.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-security-group-ingress.html#cfn-rds-securitygroup-ingress-ec2securitygroupownerid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "ec2SecurityGroupOwnerId"))

    @ec2_security_group_owner_id.setter
    def ec2_security_group_owner_id(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__71a9a3d77c97e5b3e30de5c25aa5ddb2dab2afd73f720a324d7f61b03611b552)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "ec2SecurityGroupOwnerId", value)


@jsii.data_type(
    jsii_type="monocdk.aws_rds.CfnDBSecurityGroupIngressProps",
    jsii_struct_bases=[],
    name_mapping={
        "db_security_group_name": "dbSecurityGroupName",
        "cidrip": "cidrip",
        "ec2_security_group_id": "ec2SecurityGroupId",
        "ec2_security_group_name": "ec2SecurityGroupName",
        "ec2_security_group_owner_id": "ec2SecurityGroupOwnerId",
    },
)
class CfnDBSecurityGroupIngressProps:
    def __init__(
        self,
        *,
        db_security_group_name: builtins.str,
        cidrip: typing.Optional[builtins.str] = None,
        ec2_security_group_id: typing.Optional[builtins.str] = None,
        ec2_security_group_name: typing.Optional[builtins.str] = None,
        ec2_security_group_owner_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for defining a ``CfnDBSecurityGroupIngress``.

        :param db_security_group_name: The name of the DB security group to add authorization to.
        :param cidrip: The IP range to authorize.
        :param ec2_security_group_id: Id of the EC2 security group to authorize. For VPC DB security groups, ``EC2SecurityGroupId`` must be provided. Otherwise, ``EC2SecurityGroupOwnerId`` and either ``EC2SecurityGroupName`` or ``EC2SecurityGroupId`` must be provided.
        :param ec2_security_group_name: Name of the EC2 security group to authorize. For VPC DB security groups, ``EC2SecurityGroupId`` must be provided. Otherwise, ``EC2SecurityGroupOwnerId`` and either ``EC2SecurityGroupName`` or ``EC2SecurityGroupId`` must be provided.
        :param ec2_security_group_owner_id: AWS account number of the owner of the EC2 security group specified in the ``EC2SecurityGroupName`` parameter. The AWS access key ID isn't an acceptable value. For VPC DB security groups, ``EC2SecurityGroupId`` must be provided. Otherwise, ``EC2SecurityGroupOwnerId`` and either ``EC2SecurityGroupName`` or ``EC2SecurityGroupId`` must be provided.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-security-group-ingress.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_rds as rds
            
            cfn_dBSecurity_group_ingress_props = rds.CfnDBSecurityGroupIngressProps(
                db_security_group_name="dbSecurityGroupName",
            
                # the properties below are optional
                cidrip="cidrip",
                ec2_security_group_id="ec2SecurityGroupId",
                ec2_security_group_name="ec2SecurityGroupName",
                ec2_security_group_owner_id="ec2SecurityGroupOwnerId"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__273208fbcdd321b4ade3e99ff35cf4b3ed26cc3b236b446c64002183b79967f4)
            check_type(argname="argument db_security_group_name", value=db_security_group_name, expected_type=type_hints["db_security_group_name"])
            check_type(argname="argument cidrip", value=cidrip, expected_type=type_hints["cidrip"])
            check_type(argname="argument ec2_security_group_id", value=ec2_security_group_id, expected_type=type_hints["ec2_security_group_id"])
            check_type(argname="argument ec2_security_group_name", value=ec2_security_group_name, expected_type=type_hints["ec2_security_group_name"])
            check_type(argname="argument ec2_security_group_owner_id", value=ec2_security_group_owner_id, expected_type=type_hints["ec2_security_group_owner_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "db_security_group_name": db_security_group_name,
        }
        if cidrip is not None:
            self._values["cidrip"] = cidrip
        if ec2_security_group_id is not None:
            self._values["ec2_security_group_id"] = ec2_security_group_id
        if ec2_security_group_name is not None:
            self._values["ec2_security_group_name"] = ec2_security_group_name
        if ec2_security_group_owner_id is not None:
            self._values["ec2_security_group_owner_id"] = ec2_security_group_owner_id

    @builtins.property
    def db_security_group_name(self) -> builtins.str:
        '''The name of the DB security group to add authorization to.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-security-group-ingress.html#cfn-rds-securitygroup-ingress-dbsecuritygroupname
        '''
        result = self._values.get("db_security_group_name")
        assert result is not None, "Required property 'db_security_group_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def cidrip(self) -> typing.Optional[builtins.str]:
        '''The IP range to authorize.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-security-group-ingress.html#cfn-rds-securitygroup-ingress-cidrip
        '''
        result = self._values.get("cidrip")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ec2_security_group_id(self) -> typing.Optional[builtins.str]:
        '''Id of the EC2 security group to authorize.

        For VPC DB security groups, ``EC2SecurityGroupId`` must be provided. Otherwise, ``EC2SecurityGroupOwnerId`` and either ``EC2SecurityGroupName`` or ``EC2SecurityGroupId`` must be provided.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-security-group-ingress.html#cfn-rds-securitygroup-ingress-ec2securitygroupid
        '''
        result = self._values.get("ec2_security_group_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ec2_security_group_name(self) -> typing.Optional[builtins.str]:
        '''Name of the EC2 security group to authorize.

        For VPC DB security groups, ``EC2SecurityGroupId`` must be provided. Otherwise, ``EC2SecurityGroupOwnerId`` and either ``EC2SecurityGroupName`` or ``EC2SecurityGroupId`` must be provided.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-security-group-ingress.html#cfn-rds-securitygroup-ingress-ec2securitygroupname
        '''
        result = self._values.get("ec2_security_group_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ec2_security_group_owner_id(self) -> typing.Optional[builtins.str]:
        '''AWS account number of the owner of the EC2 security group specified in the ``EC2SecurityGroupName`` parameter.

        The AWS access key ID isn't an acceptable value. For VPC DB security groups, ``EC2SecurityGroupId`` must be provided. Otherwise, ``EC2SecurityGroupOwnerId`` and either ``EC2SecurityGroupName`` or ``EC2SecurityGroupId`` must be provided.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-security-group-ingress.html#cfn-rds-securitygroup-ingress-ec2securitygroupownerid
        '''
        result = self._values.get("ec2_security_group_owner_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnDBSecurityGroupIngressProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_rds.CfnDBSecurityGroupProps",
    jsii_struct_bases=[],
    name_mapping={
        "db_security_group_ingress": "dbSecurityGroupIngress",
        "group_description": "groupDescription",
        "ec2_vpc_id": "ec2VpcId",
        "tags": "tags",
    },
)
class CfnDBSecurityGroupProps:
    def __init__(
        self,
        *,
        db_security_group_ingress: typing.Union[_IResolvable_a771d0ef, typing.Sequence[typing.Union[typing.Union[CfnDBSecurityGroup.IngressProperty, typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]]],
        group_description: builtins.str,
        ec2_vpc_id: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union[_CfnTag_95fbdc29, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for defining a ``CfnDBSecurityGroup``.

        :param db_security_group_ingress: Ingress rules to be applied to the DB security group.
        :param group_description: Provides the description of the DB security group.
        :param ec2_vpc_id: The identifier of an Amazon VPC. This property indicates the VPC that this DB security group belongs to. .. epigraph:: The ``EC2VpcId`` property is for backward compatibility with older regions, and is no longer recommended for providing security information to an RDS DB instance.
        :param tags: An optional array of key-value pairs to apply to this DB security group.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-security-group.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_rds as rds
            
            cfn_dBSecurity_group_props = rds.CfnDBSecurityGroupProps(
                db_security_group_ingress=[rds.CfnDBSecurityGroup.IngressProperty(
                    cidrip="cidrip",
                    ec2_security_group_id="ec2SecurityGroupId",
                    ec2_security_group_name="ec2SecurityGroupName",
                    ec2_security_group_owner_id="ec2SecurityGroupOwnerId"
                )],
                group_description="groupDescription",
            
                # the properties below are optional
                ec2_vpc_id="ec2VpcId",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5d7b45d4c51ec74fea2243ff00660127097652f30b72d7ca6eda0d3f7f22dcc1)
            check_type(argname="argument db_security_group_ingress", value=db_security_group_ingress, expected_type=type_hints["db_security_group_ingress"])
            check_type(argname="argument group_description", value=group_description, expected_type=type_hints["group_description"])
            check_type(argname="argument ec2_vpc_id", value=ec2_vpc_id, expected_type=type_hints["ec2_vpc_id"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "db_security_group_ingress": db_security_group_ingress,
            "group_description": group_description,
        }
        if ec2_vpc_id is not None:
            self._values["ec2_vpc_id"] = ec2_vpc_id
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def db_security_group_ingress(
        self,
    ) -> typing.Union[_IResolvable_a771d0ef, typing.List[typing.Union[CfnDBSecurityGroup.IngressProperty, _IResolvable_a771d0ef]]]:
        '''Ingress rules to be applied to the DB security group.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-security-group.html#cfn-rds-dbsecuritygroup-dbsecuritygroupingress
        '''
        result = self._values.get("db_security_group_ingress")
        assert result is not None, "Required property 'db_security_group_ingress' is missing"
        return typing.cast(typing.Union[_IResolvable_a771d0ef, typing.List[typing.Union[CfnDBSecurityGroup.IngressProperty, _IResolvable_a771d0ef]]], result)

    @builtins.property
    def group_description(self) -> builtins.str:
        '''Provides the description of the DB security group.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-security-group.html#cfn-rds-dbsecuritygroup-groupdescription
        '''
        result = self._values.get("group_description")
        assert result is not None, "Required property 'group_description' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def ec2_vpc_id(self) -> typing.Optional[builtins.str]:
        '''The identifier of an Amazon VPC. This property indicates the VPC that this DB security group belongs to.

        .. epigraph::

           The ``EC2VpcId`` property is for backward compatibility with older regions, and is no longer recommended for providing security information to an RDS DB instance.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-security-group.html#cfn-rds-dbsecuritygroup-ec2vpcid
        '''
        result = self._values.get("ec2_vpc_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[_CfnTag_95fbdc29]]:
        '''An optional array of key-value pairs to apply to this DB security group.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-security-group.html#cfn-rds-dbsecuritygroup-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[_CfnTag_95fbdc29]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnDBSecurityGroupProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_82c04a63)
class CfnDBSubnetGroup(
    _CfnResource_e0a482dc,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_rds.CfnDBSubnetGroup",
):
    '''A CloudFormation ``AWS::RDS::DBSubnetGroup``.

    The ``AWS::RDS::DBSubnetGroup`` resource creates a database subnet group. Subnet groups must contain at least two subnets in two different Availability Zones in the same region.

    For more information, see `Working with DB subnet groups <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_VPC.WorkingWithRDSInstanceinaVPC.html#USER_VPC.Subnets>`_ in the *Amazon RDS User Guide* .

    :cloudformationResource: AWS::RDS::DBSubnetGroup
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbsubnetgroup.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from monocdk import aws_rds as rds
        
        cfn_dBSubnet_group = rds.CfnDBSubnetGroup(self, "MyCfnDBSubnetGroup",
            db_subnet_group_description="dbSubnetGroupDescription",
            subnet_ids=["subnetIds"],
        
            # the properties below are optional
            db_subnet_group_name="dbSubnetGroupName",
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        )
    '''

    def __init__(
        self,
        scope: _Construct_e78e779f,
        id: builtins.str,
        *,
        db_subnet_group_description: builtins.str,
        subnet_ids: typing.Sequence[builtins.str],
        db_subnet_group_name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union[_CfnTag_95fbdc29, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Create a new ``AWS::RDS::DBSubnetGroup``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param db_subnet_group_description: The description for the DB subnet group.
        :param subnet_ids: The EC2 Subnet IDs for the DB subnet group.
        :param db_subnet_group_name: The name for the DB subnet group. This value is stored as a lowercase string. Constraints: Must contain no more than 255 lowercase alphanumeric characters or hyphens. Must not be "Default". Example: ``mysubnetgroup``
        :param tags: An optional array of key-value pairs to apply to this DB subnet group.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6573958d88eab2f16ea908fc2c74b206ba1369e60a7f9a93b9c124dfa4235256)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = CfnDBSubnetGroupProps(
            db_subnet_group_description=db_subnet_group_description,
            subnet_ids=subnet_ids,
            db_subnet_group_name=db_subnet_group_name,
            tags=tags,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_1cd1894e) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0808eb1182fcf16b6e539f620f3bdec11ff5eb90a7e957481cf4520e6cc4ec4c)
            check_type(argname="argument inspector", value=inspector, expected_type=type_hints["inspector"])
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__56d456d0c3c25a9608af0fea2d0bf5991ce40d60b6ad73b799ec6341732b4e50)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property
    @jsii.member(jsii_name="tags")
    def tags(self) -> _TagManager_0b7ab120:
        '''An optional array of key-value pairs to apply to this DB subnet group.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbsubnetgroup.html#cfn-rds-dbsubnetgroup-tags
        '''
        return typing.cast(_TagManager_0b7ab120, jsii.get(self, "tags"))

    @builtins.property
    @jsii.member(jsii_name="dbSubnetGroupDescription")
    def db_subnet_group_description(self) -> builtins.str:
        '''The description for the DB subnet group.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbsubnetgroup.html#cfn-rds-dbsubnetgroup-dbsubnetgroupdescription
        '''
        return typing.cast(builtins.str, jsii.get(self, "dbSubnetGroupDescription"))

    @db_subnet_group_description.setter
    def db_subnet_group_description(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f7ef88a58ea350c3fb70e400583c3a3266478218eb46d5a3cafb29d0acf80d4a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dbSubnetGroupDescription", value)

    @builtins.property
    @jsii.member(jsii_name="subnetIds")
    def subnet_ids(self) -> typing.List[builtins.str]:
        '''The EC2 Subnet IDs for the DB subnet group.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbsubnetgroup.html#cfn-rds-dbsubnetgroup-subnetids
        '''
        return typing.cast(typing.List[builtins.str], jsii.get(self, "subnetIds"))

    @subnet_ids.setter
    def subnet_ids(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__db56c52ae801ce32e18b11f84caf6ae9cb060430880793d138b7a3ba4659fca3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "subnetIds", value)

    @builtins.property
    @jsii.member(jsii_name="dbSubnetGroupName")
    def db_subnet_group_name(self) -> typing.Optional[builtins.str]:
        '''The name for the DB subnet group. This value is stored as a lowercase string.

        Constraints: Must contain no more than 255 lowercase alphanumeric characters or hyphens. Must not be "Default".

        Example: ``mysubnetgroup``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbsubnetgroup.html#cfn-rds-dbsubnetgroup-dbsubnetgroupname
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "dbSubnetGroupName"))

    @db_subnet_group_name.setter
    def db_subnet_group_name(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8248b5b586733055c35d92ec8c3509293a818b15e176c41ce96ece35f8366936)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "dbSubnetGroupName", value)


@jsii.data_type(
    jsii_type="monocdk.aws_rds.CfnDBSubnetGroupProps",
    jsii_struct_bases=[],
    name_mapping={
        "db_subnet_group_description": "dbSubnetGroupDescription",
        "subnet_ids": "subnetIds",
        "db_subnet_group_name": "dbSubnetGroupName",
        "tags": "tags",
    },
)
class CfnDBSubnetGroupProps:
    def __init__(
        self,
        *,
        db_subnet_group_description: builtins.str,
        subnet_ids: typing.Sequence[builtins.str],
        db_subnet_group_name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union[_CfnTag_95fbdc29, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for defining a ``CfnDBSubnetGroup``.

        :param db_subnet_group_description: The description for the DB subnet group.
        :param subnet_ids: The EC2 Subnet IDs for the DB subnet group.
        :param db_subnet_group_name: The name for the DB subnet group. This value is stored as a lowercase string. Constraints: Must contain no more than 255 lowercase alphanumeric characters or hyphens. Must not be "Default". Example: ``mysubnetgroup``
        :param tags: An optional array of key-value pairs to apply to this DB subnet group.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbsubnetgroup.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_rds as rds
            
            cfn_dBSubnet_group_props = rds.CfnDBSubnetGroupProps(
                db_subnet_group_description="dbSubnetGroupDescription",
                subnet_ids=["subnetIds"],
            
                # the properties below are optional
                db_subnet_group_name="dbSubnetGroupName",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7644001f6b7f78cefdc8efc2853d2ecd628ebd4928df6b1a1c009f5e549dc7a3)
            check_type(argname="argument db_subnet_group_description", value=db_subnet_group_description, expected_type=type_hints["db_subnet_group_description"])
            check_type(argname="argument subnet_ids", value=subnet_ids, expected_type=type_hints["subnet_ids"])
            check_type(argname="argument db_subnet_group_name", value=db_subnet_group_name, expected_type=type_hints["db_subnet_group_name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "db_subnet_group_description": db_subnet_group_description,
            "subnet_ids": subnet_ids,
        }
        if db_subnet_group_name is not None:
            self._values["db_subnet_group_name"] = db_subnet_group_name
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def db_subnet_group_description(self) -> builtins.str:
        '''The description for the DB subnet group.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbsubnetgroup.html#cfn-rds-dbsubnetgroup-dbsubnetgroupdescription
        '''
        result = self._values.get("db_subnet_group_description")
        assert result is not None, "Required property 'db_subnet_group_description' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def subnet_ids(self) -> typing.List[builtins.str]:
        '''The EC2 Subnet IDs for the DB subnet group.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbsubnetgroup.html#cfn-rds-dbsubnetgroup-subnetids
        '''
        result = self._values.get("subnet_ids")
        assert result is not None, "Required property 'subnet_ids' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def db_subnet_group_name(self) -> typing.Optional[builtins.str]:
        '''The name for the DB subnet group. This value is stored as a lowercase string.

        Constraints: Must contain no more than 255 lowercase alphanumeric characters or hyphens. Must not be "Default".

        Example: ``mysubnetgroup``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbsubnetgroup.html#cfn-rds-dbsubnetgroup-dbsubnetgroupname
        '''
        result = self._values.get("db_subnet_group_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[_CfnTag_95fbdc29]]:
        '''An optional array of key-value pairs to apply to this DB subnet group.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbsubnetgroup.html#cfn-rds-dbsubnetgroup-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[_CfnTag_95fbdc29]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnDBSubnetGroupProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_82c04a63)
class CfnEventSubscription(
    _CfnResource_e0a482dc,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_rds.CfnEventSubscription",
):
    '''A CloudFormation ``AWS::RDS::EventSubscription``.

    The ``AWS::RDS::EventSubscription`` resource allows you to receive notifications for Amazon Relational Database Service events through the Amazon Simple Notification Service (Amazon SNS). For more information, see `Using Amazon RDS Event Notification <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Events.html>`_ in the *Amazon RDS User Guide* .

    :cloudformationResource: AWS::RDS::EventSubscription
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-eventsubscription.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from monocdk import aws_rds as rds
        
        cfn_event_subscription = rds.CfnEventSubscription(self, "MyCfnEventSubscription",
            sns_topic_arn="snsTopicArn",
        
            # the properties below are optional
            enabled=False,
            event_categories=["eventCategories"],
            source_ids=["sourceIds"],
            source_type="sourceType",
            subscription_name="subscriptionName",
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        )
    '''

    def __init__(
        self,
        scope: _Construct_e78e779f,
        id: builtins.str,
        *,
        sns_topic_arn: builtins.str,
        enabled: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        event_categories: typing.Optional[typing.Sequence[builtins.str]] = None,
        source_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        source_type: typing.Optional[builtins.str] = None,
        subscription_name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union[_CfnTag_95fbdc29, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Create a new ``AWS::RDS::EventSubscription``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param sns_topic_arn: The Amazon Resource Name (ARN) of the SNS topic created for event notification. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
        :param enabled: A value that indicates whether to activate the subscription. If the event notification subscription isn't activated, the subscription is created but not active.
        :param event_categories: A list of event categories for a particular source type ( ``SourceType`` ) that you want to subscribe to. You can see a list of the categories for a given source type in the "Amazon RDS event categories and event messages" section of the `*Amazon RDS User Guide* <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Events.Messages.html>`_ or the `*Amazon Aurora User Guide* <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_Events.Messages.html>`_ . You can also see this list by using the ``DescribeEventCategories`` operation.
        :param source_ids: The list of identifiers of the event sources for which events are returned. If not specified, then all sources are included in the response. An identifier must begin with a letter and must contain only ASCII letters, digits, and hyphens. It can't end with a hyphen or contain two consecutive hyphens. Constraints: - If a ``SourceIds`` value is supplied, ``SourceType`` must also be provided. - If the source type is a DB instance, a ``DBInstanceIdentifier`` value must be supplied. - If the source type is a DB cluster, a ``DBClusterIdentifier`` value must be supplied. - If the source type is a DB parameter group, a ``DBParameterGroupName`` value must be supplied. - If the source type is a DB security group, a ``DBSecurityGroupName`` value must be supplied. - If the source type is a DB snapshot, a ``DBSnapshotIdentifier`` value must be supplied. - If the source type is a DB cluster snapshot, a ``DBClusterSnapshotIdentifier`` value must be supplied.
        :param source_type: The type of source that is generating the events. For example, if you want to be notified of events generated by a DB instance, set this parameter to ``db-instance`` . If this value isn't specified, all events are returned. Valid values: ``db-instance`` | ``db-cluster`` | ``db-parameter-group`` | ``db-security-group`` | ``db-snapshot`` | ``db-cluster-snapshot``
        :param subscription_name: The name of the subscription. Constraints: The name must be less than 255 characters.
        :param tags: An optional array of key-value pairs to apply to this subscription.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__05c1386dcccd1c8f957e6442f6e78c0dcfe68c0f8dcedb9891a83018a3716333)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = CfnEventSubscriptionProps(
            sns_topic_arn=sns_topic_arn,
            enabled=enabled,
            event_categories=event_categories,
            source_ids=source_ids,
            source_type=source_type,
            subscription_name=subscription_name,
            tags=tags,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_1cd1894e) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6dbc1390a6c639e6172f4d39693640a90b786051bd0b092b82f3ea6ecc55bfc2)
            check_type(argname="argument inspector", value=inspector, expected_type=type_hints["inspector"])
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ac6208cd8c1220259b16def735c61ace211ca9731da26168ec32fcb881d5d825)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property
    @jsii.member(jsii_name="tags")
    def tags(self) -> _TagManager_0b7ab120:
        '''An optional array of key-value pairs to apply to this subscription.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-eventsubscription.html#cfn-rds-eventsubscription-tags
        '''
        return typing.cast(_TagManager_0b7ab120, jsii.get(self, "tags"))

    @builtins.property
    @jsii.member(jsii_name="snsTopicArn")
    def sns_topic_arn(self) -> builtins.str:
        '''The Amazon Resource Name (ARN) of the SNS topic created for event notification.

        The ARN is created by Amazon SNS when you create a topic and subscribe to it.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-eventsubscription.html#cfn-rds-eventsubscription-snstopicarn
        '''
        return typing.cast(builtins.str, jsii.get(self, "snsTopicArn"))

    @sns_topic_arn.setter
    def sns_topic_arn(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__034413275be1f06406cf06f0bbfa2779248f32838b961d58fa965b29605d9033)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "snsTopicArn", value)

    @builtins.property
    @jsii.member(jsii_name="enabled")
    def enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''A value that indicates whether to activate the subscription.

        If the event notification subscription isn't activated, the subscription is created but not active.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-eventsubscription.html#cfn-rds-eventsubscription-enabled
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], jsii.get(self, "enabled"))

    @enabled.setter
    def enabled(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__84290090507d33096b13a93a814e6196b10b99175e14d11be7a4b2c0be886db4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enabled", value)

    @builtins.property
    @jsii.member(jsii_name="eventCategories")
    def event_categories(self) -> typing.Optional[typing.List[builtins.str]]:
        '''A list of event categories for a particular source type ( ``SourceType`` ) that you want to subscribe to.

        You can see a list of the categories for a given source type in the "Amazon RDS event categories and event messages" section of the `*Amazon RDS User Guide* <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Events.Messages.html>`_ or the `*Amazon Aurora User Guide* <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_Events.Messages.html>`_ . You can also see this list by using the ``DescribeEventCategories`` operation.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-eventsubscription.html#cfn-rds-eventsubscription-eventcategories
        '''
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "eventCategories"))

    @event_categories.setter
    def event_categories(
        self,
        value: typing.Optional[typing.List[builtins.str]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fc02b265e42e49275e457fd0d07a66f37efc6ae0a6f52ca461f04ffdad1a4879)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "eventCategories", value)

    @builtins.property
    @jsii.member(jsii_name="sourceIds")
    def source_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The list of identifiers of the event sources for which events are returned.

        If not specified, then all sources are included in the response. An identifier must begin with a letter and must contain only ASCII letters, digits, and hyphens. It can't end with a hyphen or contain two consecutive hyphens.

        Constraints:

        - If a ``SourceIds`` value is supplied, ``SourceType`` must also be provided.
        - If the source type is a DB instance, a ``DBInstanceIdentifier`` value must be supplied.
        - If the source type is a DB cluster, a ``DBClusterIdentifier`` value must be supplied.
        - If the source type is a DB parameter group, a ``DBParameterGroupName`` value must be supplied.
        - If the source type is a DB security group, a ``DBSecurityGroupName`` value must be supplied.
        - If the source type is a DB snapshot, a ``DBSnapshotIdentifier`` value must be supplied.
        - If the source type is a DB cluster snapshot, a ``DBClusterSnapshotIdentifier`` value must be supplied.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-eventsubscription.html#cfn-rds-eventsubscription-sourceids
        '''
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "sourceIds"))

    @source_ids.setter
    def source_ids(self, value: typing.Optional[typing.List[builtins.str]]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c3235bb3e6314e79396695d782195f4a06545bc45ea96b8ecee380c28b8564ab)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "sourceIds", value)

    @builtins.property
    @jsii.member(jsii_name="sourceType")
    def source_type(self) -> typing.Optional[builtins.str]:
        '''The type of source that is generating the events.

        For example, if you want to be notified of events generated by a DB instance, set this parameter to ``db-instance`` . If this value isn't specified, all events are returned.

        Valid values: ``db-instance`` | ``db-cluster`` | ``db-parameter-group`` | ``db-security-group`` | ``db-snapshot`` | ``db-cluster-snapshot``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-eventsubscription.html#cfn-rds-eventsubscription-sourcetype
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "sourceType"))

    @source_type.setter
    def source_type(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d2875d0ab28c6da2e841060f3bfc8c54b71f3862039fc38043842dceea61daaa)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "sourceType", value)

    @builtins.property
    @jsii.member(jsii_name="subscriptionName")
    def subscription_name(self) -> typing.Optional[builtins.str]:
        '''The name of the subscription.

        Constraints: The name must be less than 255 characters.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-eventsubscription.html#cfn-rds-eventsubscription-subscriptionname
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "subscriptionName"))

    @subscription_name.setter
    def subscription_name(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3ae06bb01fa02e0c23aff0e77bd8b833540dee86f3e1bd1803dbc18a7bcd054c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "subscriptionName", value)


@jsii.data_type(
    jsii_type="monocdk.aws_rds.CfnEventSubscriptionProps",
    jsii_struct_bases=[],
    name_mapping={
        "sns_topic_arn": "snsTopicArn",
        "enabled": "enabled",
        "event_categories": "eventCategories",
        "source_ids": "sourceIds",
        "source_type": "sourceType",
        "subscription_name": "subscriptionName",
        "tags": "tags",
    },
)
class CfnEventSubscriptionProps:
    def __init__(
        self,
        *,
        sns_topic_arn: builtins.str,
        enabled: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        event_categories: typing.Optional[typing.Sequence[builtins.str]] = None,
        source_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        source_type: typing.Optional[builtins.str] = None,
        subscription_name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union[_CfnTag_95fbdc29, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for defining a ``CfnEventSubscription``.

        :param sns_topic_arn: The Amazon Resource Name (ARN) of the SNS topic created for event notification. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
        :param enabled: A value that indicates whether to activate the subscription. If the event notification subscription isn't activated, the subscription is created but not active.
        :param event_categories: A list of event categories for a particular source type ( ``SourceType`` ) that you want to subscribe to. You can see a list of the categories for a given source type in the "Amazon RDS event categories and event messages" section of the `*Amazon RDS User Guide* <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Events.Messages.html>`_ or the `*Amazon Aurora User Guide* <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_Events.Messages.html>`_ . You can also see this list by using the ``DescribeEventCategories`` operation.
        :param source_ids: The list of identifiers of the event sources for which events are returned. If not specified, then all sources are included in the response. An identifier must begin with a letter and must contain only ASCII letters, digits, and hyphens. It can't end with a hyphen or contain two consecutive hyphens. Constraints: - If a ``SourceIds`` value is supplied, ``SourceType`` must also be provided. - If the source type is a DB instance, a ``DBInstanceIdentifier`` value must be supplied. - If the source type is a DB cluster, a ``DBClusterIdentifier`` value must be supplied. - If the source type is a DB parameter group, a ``DBParameterGroupName`` value must be supplied. - If the source type is a DB security group, a ``DBSecurityGroupName`` value must be supplied. - If the source type is a DB snapshot, a ``DBSnapshotIdentifier`` value must be supplied. - If the source type is a DB cluster snapshot, a ``DBClusterSnapshotIdentifier`` value must be supplied.
        :param source_type: The type of source that is generating the events. For example, if you want to be notified of events generated by a DB instance, set this parameter to ``db-instance`` . If this value isn't specified, all events are returned. Valid values: ``db-instance`` | ``db-cluster`` | ``db-parameter-group`` | ``db-security-group`` | ``db-snapshot`` | ``db-cluster-snapshot``
        :param subscription_name: The name of the subscription. Constraints: The name must be less than 255 characters.
        :param tags: An optional array of key-value pairs to apply to this subscription.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-eventsubscription.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_rds as rds
            
            cfn_event_subscription_props = rds.CfnEventSubscriptionProps(
                sns_topic_arn="snsTopicArn",
            
                # the properties below are optional
                enabled=False,
                event_categories=["eventCategories"],
                source_ids=["sourceIds"],
                source_type="sourceType",
                subscription_name="subscriptionName",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f37e4c28c509a8e4631e90f64afd534626bb520a342e9576709507765c73d640)
            check_type(argname="argument sns_topic_arn", value=sns_topic_arn, expected_type=type_hints["sns_topic_arn"])
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            check_type(argname="argument event_categories", value=event_categories, expected_type=type_hints["event_categories"])
            check_type(argname="argument source_ids", value=source_ids, expected_type=type_hints["source_ids"])
            check_type(argname="argument source_type", value=source_type, expected_type=type_hints["source_type"])
            check_type(argname="argument subscription_name", value=subscription_name, expected_type=type_hints["subscription_name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "sns_topic_arn": sns_topic_arn,
        }
        if enabled is not None:
            self._values["enabled"] = enabled
        if event_categories is not None:
            self._values["event_categories"] = event_categories
        if source_ids is not None:
            self._values["source_ids"] = source_ids
        if source_type is not None:
            self._values["source_type"] = source_type
        if subscription_name is not None:
            self._values["subscription_name"] = subscription_name
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def sns_topic_arn(self) -> builtins.str:
        '''The Amazon Resource Name (ARN) of the SNS topic created for event notification.

        The ARN is created by Amazon SNS when you create a topic and subscribe to it.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-eventsubscription.html#cfn-rds-eventsubscription-snstopicarn
        '''
        result = self._values.get("sns_topic_arn")
        assert result is not None, "Required property 'sns_topic_arn' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''A value that indicates whether to activate the subscription.

        If the event notification subscription isn't activated, the subscription is created but not active.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-eventsubscription.html#cfn-rds-eventsubscription-enabled
        '''
        result = self._values.get("enabled")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], result)

    @builtins.property
    def event_categories(self) -> typing.Optional[typing.List[builtins.str]]:
        '''A list of event categories for a particular source type ( ``SourceType`` ) that you want to subscribe to.

        You can see a list of the categories for a given source type in the "Amazon RDS event categories and event messages" section of the `*Amazon RDS User Guide* <https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Events.Messages.html>`_ or the `*Amazon Aurora User Guide* <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_Events.Messages.html>`_ . You can also see this list by using the ``DescribeEventCategories`` operation.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-eventsubscription.html#cfn-rds-eventsubscription-eventcategories
        '''
        result = self._values.get("event_categories")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def source_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The list of identifiers of the event sources for which events are returned.

        If not specified, then all sources are included in the response. An identifier must begin with a letter and must contain only ASCII letters, digits, and hyphens. It can't end with a hyphen or contain two consecutive hyphens.

        Constraints:

        - If a ``SourceIds`` value is supplied, ``SourceType`` must also be provided.
        - If the source type is a DB instance, a ``DBInstanceIdentifier`` value must be supplied.
        - If the source type is a DB cluster, a ``DBClusterIdentifier`` value must be supplied.
        - If the source type is a DB parameter group, a ``DBParameterGroupName`` value must be supplied.
        - If the source type is a DB security group, a ``DBSecurityGroupName`` value must be supplied.
        - If the source type is a DB snapshot, a ``DBSnapshotIdentifier`` value must be supplied.
        - If the source type is a DB cluster snapshot, a ``DBClusterSnapshotIdentifier`` value must be supplied.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-eventsubscription.html#cfn-rds-eventsubscription-sourceids
        '''
        result = self._values.get("source_ids")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def source_type(self) -> typing.Optional[builtins.str]:
        '''The type of source that is generating the events.

        For example, if you want to be notified of events generated by a DB instance, set this parameter to ``db-instance`` . If this value isn't specified, all events are returned.

        Valid values: ``db-instance`` | ``db-cluster`` | ``db-parameter-group`` | ``db-security-group`` | ``db-snapshot`` | ``db-cluster-snapshot``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-eventsubscription.html#cfn-rds-eventsubscription-sourcetype
        '''
        result = self._values.get("source_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def subscription_name(self) -> typing.Optional[builtins.str]:
        '''The name of the subscription.

        Constraints: The name must be less than 255 characters.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-eventsubscription.html#cfn-rds-eventsubscription-subscriptionname
        '''
        result = self._values.get("subscription_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[_CfnTag_95fbdc29]]:
        '''An optional array of key-value pairs to apply to this subscription.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-eventsubscription.html#cfn-rds-eventsubscription-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[_CfnTag_95fbdc29]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnEventSubscriptionProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_82c04a63)
class CfnGlobalCluster(
    _CfnResource_e0a482dc,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_rds.CfnGlobalCluster",
):
    '''A CloudFormation ``AWS::RDS::GlobalCluster``.

    The ``AWS::RDS::GlobalCluster`` resource creates or updates an Amazon Aurora global database spread across multiple AWS Regions.

    The global database contains a single primary cluster with read-write capability, and a read-only secondary cluster that receives data from the primary cluster through high-speed replication performed by the Aurora storage subsystem.

    You can create a global database that is initially empty, and then add a primary cluster and a secondary cluster to it.

    For information about Aurora global databases, see `Working with Amazon Aurora Global Databases <https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-global-database.html>`_ in the *Amazon Aurora User Guide* .

    :cloudformationResource: AWS::RDS::GlobalCluster
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-globalcluster.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from monocdk import aws_rds as rds
        
        cfn_global_cluster = rds.CfnGlobalCluster(self, "MyCfnGlobalCluster",
            deletion_protection=False,
            engine="engine",
            engine_version="engineVersion",
            global_cluster_identifier="globalClusterIdentifier",
            source_db_cluster_identifier="sourceDbClusterIdentifier",
            storage_encrypted=False
        )
    '''

    def __init__(
        self,
        scope: _Construct_e78e779f,
        id: builtins.str,
        *,
        deletion_protection: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        engine: typing.Optional[builtins.str] = None,
        engine_version: typing.Optional[builtins.str] = None,
        global_cluster_identifier: typing.Optional[builtins.str] = None,
        source_db_cluster_identifier: typing.Optional[builtins.str] = None,
        storage_encrypted: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    ) -> None:
        '''Create a new ``AWS::RDS::GlobalCluster``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param deletion_protection: The deletion protection setting for the new global database. The global database can't be deleted when deletion protection is enabled.
        :param engine: The name of the database engine to be used for this DB cluster. If this property isn't specified, the database engine is derived from the source DB cluster specified by the ``SourceDBClusterIdentifier`` property. .. epigraph:: If the ``SourceDBClusterIdentifier`` property isn't specified, this property is required. If the ``SourceDBClusterIdentifier`` property is specified, make sure this property isn't specified.
        :param engine_version: The engine version of the Aurora global database.
        :param global_cluster_identifier: The cluster identifier of the global database cluster.
        :param source_db_cluster_identifier: The DB cluster identifier or Amazon Resource Name (ARN) to use as the primary cluster of the global database. .. epigraph:: If the ``Engine`` property isn't specified, this property is required. If the ``Engine`` property is specified, make sure this property isn't specified.
        :param storage_encrypted: The storage encryption setting for the global database cluster.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c46b83d41de2b16f0407b8e464dc0825b61c8a9f79f8f3849f1fe22db18e41bd)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = CfnGlobalClusterProps(
            deletion_protection=deletion_protection,
            engine=engine,
            engine_version=engine_version,
            global_cluster_identifier=global_cluster_identifier,
            source_db_cluster_identifier=source_db_cluster_identifier,
            storage_encrypted=storage_encrypted,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_1cd1894e) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__265b469ce5feb12bbf47b9074883b3387ac7e3a88ab8c5024c67a836983216a5)
            check_type(argname="argument inspector", value=inspector, expected_type=type_hints["inspector"])
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ec5f859984ee61b6a5932a3f95b5f7ace16f3ff07dc18f6b83891a1986bb810c)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property
    @jsii.member(jsii_name="deletionProtection")
    def deletion_protection(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''The deletion protection setting for the new global database.

        The global database can't be deleted when deletion protection is enabled.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-globalcluster.html#cfn-rds-globalcluster-deletionprotection
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], jsii.get(self, "deletionProtection"))

    @deletion_protection.setter
    def deletion_protection(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a73d57c3fba958a51190258f379dff439c9e8a10fee9e293b407d5903829b580)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "deletionProtection", value)

    @builtins.property
    @jsii.member(jsii_name="engine")
    def engine(self) -> typing.Optional[builtins.str]:
        '''The name of the database engine to be used for this DB cluster.

        If this property isn't specified, the database engine is derived from the source DB cluster specified by the ``SourceDBClusterIdentifier`` property.
        .. epigraph::

           If the ``SourceDBClusterIdentifier`` property isn't specified, this property is required. If the ``SourceDBClusterIdentifier`` property is specified, make sure this property isn't specified.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-globalcluster.html#cfn-rds-globalcluster-engine
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "engine"))

    @engine.setter
    def engine(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__11793b1b5cfe55c098492415e704345c828d180b0c1b8def3e86ffaa75a906b8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "engine", value)

    @builtins.property
    @jsii.member(jsii_name="engineVersion")
    def engine_version(self) -> typing.Optional[builtins.str]:
        '''The engine version of the Aurora global database.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-globalcluster.html#cfn-rds-globalcluster-engineversion
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "engineVersion"))

    @engine_version.setter
    def engine_version(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__38526cc6dd5999bcf4ca969144f23a78cfb178880382de7106d5338a23a43e4f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "engineVersion", value)

    @builtins.property
    @jsii.member(jsii_name="globalClusterIdentifier")
    def global_cluster_identifier(self) -> typing.Optional[builtins.str]:
        '''The cluster identifier of the global database cluster.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-globalcluster.html#cfn-rds-globalcluster-globalclusteridentifier
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "globalClusterIdentifier"))

    @global_cluster_identifier.setter
    def global_cluster_identifier(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4fdf7243cdbc7d1df7f21d36c3828d9432f614671dded8de5bfbc66c96b750fe)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "globalClusterIdentifier", value)

    @builtins.property
    @jsii.member(jsii_name="sourceDbClusterIdentifier")
    def source_db_cluster_identifier(self) -> typing.Optional[builtins.str]:
        '''The DB cluster identifier or Amazon Resource Name (ARN) to use as the primary cluster of the global database.

        .. epigraph::

           If the ``Engine`` property isn't specified, this property is required. If the ``Engine`` property is specified, make sure this property isn't specified.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-globalcluster.html#cfn-rds-globalcluster-sourcedbclusteridentifier
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "sourceDbClusterIdentifier"))

    @source_db_cluster_identifier.setter
    def source_db_cluster_identifier(
        self,
        value: typing.Optional[builtins.str],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8baf66e854a64fb717ad03390d2efc852a627ead9fb4059246c36d647b2aedc6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "sourceDbClusterIdentifier", value)

    @builtins.property
    @jsii.member(jsii_name="storageEncrypted")
    def storage_encrypted(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''The storage encryption setting for the global database cluster.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-globalcluster.html#cfn-rds-globalcluster-storageencrypted
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], jsii.get(self, "storageEncrypted"))

    @storage_encrypted.setter
    def storage_encrypted(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__84f519a003b5b3ad210294778f51fae18f203e6c5fd1cddce9e2ab6d82b077b1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "storageEncrypted", value)


@jsii.data_type(
    jsii_type="monocdk.aws_rds.CfnGlobalClusterProps",
    jsii_struct_bases=[],
    name_mapping={
        "deletion_protection": "deletionProtection",
        "engine": "engine",
        "engine_version": "engineVersion",
        "global_cluster_identifier": "globalClusterIdentifier",
        "source_db_cluster_identifier": "sourceDbClusterIdentifier",
        "storage_encrypted": "storageEncrypted",
    },
)
class CfnGlobalClusterProps:
    def __init__(
        self,
        *,
        deletion_protection: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
        engine: typing.Optional[builtins.str] = None,
        engine_version: typing.Optional[builtins.str] = None,
        global_cluster_identifier: typing.Optional[builtins.str] = None,
        source_db_cluster_identifier: typing.Optional[builtins.str] = None,
        storage_encrypted: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    ) -> None:
        '''Properties for defining a ``CfnGlobalCluster``.

        :param deletion_protection: The deletion protection setting for the new global database. The global database can't be deleted when deletion protection is enabled.
        :param engine: The name of the database engine to be used for this DB cluster. If this property isn't specified, the database engine is derived from the source DB cluster specified by the ``SourceDBClusterIdentifier`` property. .. epigraph:: If the ``SourceDBClusterIdentifier`` property isn't specified, this property is required. If the ``SourceDBClusterIdentifier`` property is specified, make sure this property isn't specified.
        :param engine_version: The engine version of the Aurora global database.
        :param global_cluster_identifier: The cluster identifier of the global database cluster.
        :param source_db_cluster_identifier: The DB cluster identifier or Amazon Resource Name (ARN) to use as the primary cluster of the global database. .. epigraph:: If the ``Engine`` property isn't specified, this property is required. If the ``Engine`` property is specified, make sure this property isn't specified.
        :param storage_encrypted: The storage encryption setting for the global database cluster.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-globalcluster.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_rds as rds
            
            cfn_global_cluster_props = rds.CfnGlobalClusterProps(
                deletion_protection=False,
                engine="engine",
                engine_version="engineVersion",
                global_cluster_identifier="globalClusterIdentifier",
                source_db_cluster_identifier="sourceDbClusterIdentifier",
                storage_encrypted=False
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d5da71038ecfa7d978e9c386e8e79d53829a6ef257753703d1fb52f4172cbec4)
            check_type(argname="argument deletion_protection", value=deletion_protection, expected_type=type_hints["deletion_protection"])
            check_type(argname="argument engine", value=engine, expected_type=type_hints["engine"])
            check_type(argname="argument engine_version", value=engine_version, expected_type=type_hints["engine_version"])
            check_type(argname="argument global_cluster_identifier", value=global_cluster_identifier, expected_type=type_hints["global_cluster_identifier"])
            check_type(argname="argument source_db_cluster_identifier", value=source_db_cluster_identifier, expected_type=type_hints["source_db_cluster_identifier"])
            check_type(argname="argument storage_encrypted", value=storage_encrypted, expected_type=type_hints["storage_encrypted"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if deletion_protection is not None:
            self._values["deletion_protection"] = deletion_protection
        if engine is not None:
            self._values["engine"] = engine
        if engine_version is not None:
            self._values["engine_version"] = engine_version
        if global_cluster_identifier is not None:
            self._values["global_cluster_identifier"] = global_cluster_identifier
        if source_db_cluster_identifier is not None:
            self._values["source_db_cluster_identifier"] = source_db_cluster_identifier
        if storage_encrypted is not None:
            self._values["storage_encrypted"] = storage_encrypted

    @builtins.property
    def deletion_protection(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''The deletion protection setting for the new global database.

        The global database can't be deleted when deletion protection is enabled.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-globalcluster.html#cfn-rds-globalcluster-deletionprotection
        '''
        result = self._values.get("deletion_protection")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], result)

    @builtins.property
    def engine(self) -> typing.Optional[builtins.str]:
        '''The name of the database engine to be used for this DB cluster.

        If this property isn't specified, the database engine is derived from the source DB cluster specified by the ``SourceDBClusterIdentifier`` property.
        .. epigraph::

           If the ``SourceDBClusterIdentifier`` property isn't specified, this property is required. If the ``SourceDBClusterIdentifier`` property is specified, make sure this property isn't specified.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-globalcluster.html#cfn-rds-globalcluster-engine
        '''
        result = self._values.get("engine")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def engine_version(self) -> typing.Optional[builtins.str]:
        '''The engine version of the Aurora global database.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-globalcluster.html#cfn-rds-globalcluster-engineversion
        '''
        result = self._values.get("engine_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def global_cluster_identifier(self) -> typing.Optional[builtins.str]:
        '''The cluster identifier of the global database cluster.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-globalcluster.html#cfn-rds-globalcluster-globalclusteridentifier
        '''
        result = self._values.get("global_cluster_identifier")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def source_db_cluster_identifier(self) -> typing.Optional[builtins.str]:
        '''The DB cluster identifier or Amazon Resource Name (ARN) to use as the primary cluster of the global database.

        .. epigraph::

           If the ``Engine`` property isn't specified, this property is required. If the ``Engine`` property is specified, make sure this property isn't specified.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-globalcluster.html#cfn-rds-globalcluster-sourcedbclusteridentifier
        '''
        result = self._values.get("source_db_cluster_identifier")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def storage_encrypted(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]]:
        '''The storage encryption setting for the global database cluster.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-globalcluster.html#cfn-rds-globalcluster-storageencrypted
        '''
        result = self._values.get("storage_encrypted")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnGlobalClusterProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_82c04a63)
class CfnOptionGroup(
    _CfnResource_e0a482dc,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_rds.CfnOptionGroup",
):
    '''A CloudFormation ``AWS::RDS::OptionGroup``.

    The ``AWS::RDS::OptionGroup`` resource creates or updates an option group, to enable and configure features that are specific to a particular DB engine.

    :cloudformationResource: AWS::RDS::OptionGroup
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-optiongroup.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from monocdk import aws_rds as rds
        
        cfn_option_group = rds.CfnOptionGroup(self, "MyCfnOptionGroup",
            engine_name="engineName",
            major_engine_version="majorEngineVersion",
            option_group_description="optionGroupDescription",
        
            # the properties below are optional
            option_configurations=[rds.CfnOptionGroup.OptionConfigurationProperty(
                option_name="optionName",
        
                # the properties below are optional
                db_security_group_memberships=["dbSecurityGroupMemberships"],
                option_settings=[rds.CfnOptionGroup.OptionSettingProperty(
                    name="name",
                    value="value"
                )],
                option_version="optionVersion",
                port=123,
                vpc_security_group_memberships=["vpcSecurityGroupMemberships"]
            )],
            option_group_name="optionGroupName",
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        )
    '''

    def __init__(
        self,
        scope: _Construct_e78e779f,
        id: builtins.str,
        *,
        engine_name: builtins.str,
        major_engine_version: builtins.str,
        option_group_description: builtins.str,
        option_configurations: typing.Optional[typing.Union[_IResolvable_a771d0ef, typing.Sequence[typing.Union[typing.Union["CfnOptionGroup.OptionConfigurationProperty", typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]]]] = None,
        option_group_name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union[_CfnTag_95fbdc29, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Create a new ``AWS::RDS::OptionGroup``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param engine_name: Specifies the name of the engine that this option group should be associated with. Valid Values: - ``mariadb`` - ``mysql`` - ``oracle-ee`` - ``oracle-ee-cdb`` - ``oracle-se2`` - ``oracle-se2-cdb`` - ``postgres`` - ``sqlserver-ee`` - ``sqlserver-se`` - ``sqlserver-ex`` - ``sqlserver-web``
        :param major_engine_version: Specifies the major version of the engine that this option group should be associated with.
        :param option_group_description: The description of the option group.
        :param option_configurations: A list of options and the settings for each option.
        :param option_group_name: The name of the option group to be created. Constraints: - Must be 1 to 255 letters, numbers, or hyphens - First character must be a letter - Can't end with a hyphen or contain two consecutive hyphens Example: ``myoptiongroup`` If you don't specify a value for ``OptionGroupName`` property, a name is automatically created for the option group. .. epigraph:: This value is stored as a lowercase string.
        :param tags: An optional array of key-value pairs to apply to this option group.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2a0b9d6d3d8a1eb0eb82d4455dc137909ef139f94873bbecb138bbf459382fca)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = CfnOptionGroupProps(
            engine_name=engine_name,
            major_engine_version=major_engine_version,
            option_group_description=option_group_description,
            option_configurations=option_configurations,
            option_group_name=option_group_name,
            tags=tags,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_1cd1894e) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d48d0842f1f578354852904a78ae6f043ab83ae86fd5519791c55a6cb5ede132)
            check_type(argname="argument inspector", value=inspector, expected_type=type_hints["inspector"])
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2e85aeafffe82278bee63c041f4b210cbca109ce323cfd0f7ca5ece56de2c511)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property
    @jsii.member(jsii_name="tags")
    def tags(self) -> _TagManager_0b7ab120:
        '''An optional array of key-value pairs to apply to this option group.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-optiongroup.html#cfn-rds-optiongroup-tags
        '''
        return typing.cast(_TagManager_0b7ab120, jsii.get(self, "tags"))

    @builtins.property
    @jsii.member(jsii_name="engineName")
    def engine_name(self) -> builtins.str:
        '''Specifies the name of the engine that this option group should be associated with.

        Valid Values:

        - ``mariadb``
        - ``mysql``
        - ``oracle-ee``
        - ``oracle-ee-cdb``
        - ``oracle-se2``
        - ``oracle-se2-cdb``
        - ``postgres``
        - ``sqlserver-ee``
        - ``sqlserver-se``
        - ``sqlserver-ex``
        - ``sqlserver-web``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-optiongroup.html#cfn-rds-optiongroup-enginename
        '''
        return typing.cast(builtins.str, jsii.get(self, "engineName"))

    @engine_name.setter
    def engine_name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6369a2038fd63f7723283f19243cc81a2b1287f2f3be89d6e033926127f5648f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "engineName", value)

    @builtins.property
    @jsii.member(jsii_name="majorEngineVersion")
    def major_engine_version(self) -> builtins.str:
        '''Specifies the major version of the engine that this option group should be associated with.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-optiongroup.html#cfn-rds-optiongroup-majorengineversion
        '''
        return typing.cast(builtins.str, jsii.get(self, "majorEngineVersion"))

    @major_engine_version.setter
    def major_engine_version(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__64089ffeab1594291746166310ffacb9492993d73fe3b3c1ad3adc88e012ce83)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "majorEngineVersion", value)

    @builtins.property
    @jsii.member(jsii_name="optionGroupDescription")
    def option_group_description(self) -> builtins.str:
        '''The description of the option group.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-optiongroup.html#cfn-rds-optiongroup-optiongroupdescription
        '''
        return typing.cast(builtins.str, jsii.get(self, "optionGroupDescription"))

    @option_group_description.setter
    def option_group_description(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dd647832781d8856ba01ec5125c99ed33b77a8018ab376f17abee2f931cff637)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "optionGroupDescription", value)

    @builtins.property
    @jsii.member(jsii_name="optionConfigurations")
    def option_configurations(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_a771d0ef, typing.List[typing.Union["CfnOptionGroup.OptionConfigurationProperty", _IResolvable_a771d0ef]]]]:
        '''A list of options and the settings for each option.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-optiongroup.html#cfn-rds-optiongroup-optionconfigurations
        '''
        return typing.cast(typing.Optional[typing.Union[_IResolvable_a771d0ef, typing.List[typing.Union["CfnOptionGroup.OptionConfigurationProperty", _IResolvable_a771d0ef]]]], jsii.get(self, "optionConfigurations"))

    @option_configurations.setter
    def option_configurations(
        self,
        value: typing.Optional[typing.Union[_IResolvable_a771d0ef, typing.List[typing.Union["CfnOptionGroup.OptionConfigurationProperty", _IResolvable_a771d0ef]]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eb4bda085f49d880f349dec55ee8a8751bd3f0c64662ec7abdcbb9fb97da7da7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "optionConfigurations", value)

    @builtins.property
    @jsii.member(jsii_name="optionGroupName")
    def option_group_name(self) -> typing.Optional[builtins.str]:
        '''The name of the option group to be created.

        Constraints:

        - Must be 1 to 255 letters, numbers, or hyphens
        - First character must be a letter
        - Can't end with a hyphen or contain two consecutive hyphens

        Example: ``myoptiongroup``

        If you don't specify a value for ``OptionGroupName`` property, a name is automatically created for the option group.
        .. epigraph::

           This value is stored as a lowercase string.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-optiongroup.html#cfn-rds-optiongroup-optiongroupname
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "optionGroupName"))

    @option_group_name.setter
    def option_group_name(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__96bc998f1d91cdd8552d199fb99c14e3c33917b660c8aadf32330ce363a91a94)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "optionGroupName", value)

    @jsii.data_type(
        jsii_type="monocdk.aws_rds.CfnOptionGroup.OptionConfigurationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "option_name": "optionName",
            "db_security_group_memberships": "dbSecurityGroupMemberships",
            "option_settings": "optionSettings",
            "option_version": "optionVersion",
            "port": "port",
            "vpc_security_group_memberships": "vpcSecurityGroupMemberships",
        },
    )
    class OptionConfigurationProperty:
        def __init__(
            self,
            *,
            option_name: builtins.str,
            db_security_group_memberships: typing.Optional[typing.Sequence[builtins.str]] = None,
            option_settings: typing.Optional[typing.Union[_IResolvable_a771d0ef, typing.Sequence[typing.Union[typing.Union["CfnOptionGroup.OptionSettingProperty", typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]]]] = None,
            option_version: typing.Optional[builtins.str] = None,
            port: typing.Optional[jsii.Number] = None,
            vpc_security_group_memberships: typing.Optional[typing.Sequence[builtins.str]] = None,
        ) -> None:
            '''The ``OptionConfiguration`` property type specifies an individual option, and its settings, within an ``AWS::RDS::OptionGroup`` resource.

            :param option_name: The configuration of options to include in a group.
            :param db_security_group_memberships: A list of DBSecurityGroupMembership name strings used for this option.
            :param option_settings: The option settings to include in an option group.
            :param option_version: The version for the option.
            :param port: The optional port for the option.
            :param vpc_security_group_memberships: A list of VpcSecurityGroupMembership name strings used for this option.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-optiongroup-optionconfiguration.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from monocdk import aws_rds as rds
                
                option_configuration_property = rds.CfnOptionGroup.OptionConfigurationProperty(
                    option_name="optionName",
                
                    # the properties below are optional
                    db_security_group_memberships=["dbSecurityGroupMemberships"],
                    option_settings=[rds.CfnOptionGroup.OptionSettingProperty(
                        name="name",
                        value="value"
                    )],
                    option_version="optionVersion",
                    port=123,
                    vpc_security_group_memberships=["vpcSecurityGroupMemberships"]
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__c2253264debd5cb2dec17b7d6c5de6edcea91e79feeb9bc217e75c6c60e8d174)
                check_type(argname="argument option_name", value=option_name, expected_type=type_hints["option_name"])
                check_type(argname="argument db_security_group_memberships", value=db_security_group_memberships, expected_type=type_hints["db_security_group_memberships"])
                check_type(argname="argument option_settings", value=option_settings, expected_type=type_hints["option_settings"])
                check_type(argname="argument option_version", value=option_version, expected_type=type_hints["option_version"])
                check_type(argname="argument port", value=port, expected_type=type_hints["port"])
                check_type(argname="argument vpc_security_group_memberships", value=vpc_security_group_memberships, expected_type=type_hints["vpc_security_group_memberships"])
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "option_name": option_name,
            }
            if db_security_group_memberships is not None:
                self._values["db_security_group_memberships"] = db_security_group_memberships
            if option_settings is not None:
                self._values["option_settings"] = option_settings
            if option_version is not None:
                self._values["option_version"] = option_version
            if port is not None:
                self._values["port"] = port
            if vpc_security_group_memberships is not None:
                self._values["vpc_security_group_memberships"] = vpc_security_group_memberships

        @builtins.property
        def option_name(self) -> builtins.str:
            '''The configuration of options to include in a group.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-optiongroup-optionconfiguration.html#cfn-rds-optiongroup-optionconfiguration-optionname
            '''
            result = self._values.get("option_name")
            assert result is not None, "Required property 'option_name' is missing"
            return typing.cast(builtins.str, result)

        @builtins.property
        def db_security_group_memberships(
            self,
        ) -> typing.Optional[typing.List[builtins.str]]:
            '''A list of DBSecurityGroupMembership name strings used for this option.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-optiongroup-optionconfiguration.html#cfn-rds-optiongroup-optionconfiguration-dbsecuritygroupmemberships
            '''
            result = self._values.get("db_security_group_memberships")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def option_settings(
            self,
        ) -> typing.Optional[typing.Union[_IResolvable_a771d0ef, typing.List[typing.Union["CfnOptionGroup.OptionSettingProperty", _IResolvable_a771d0ef]]]]:
            '''The option settings to include in an option group.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-optiongroup-optionconfiguration.html#cfn-rds-optiongroup-optionconfiguration-optionsettings
            '''
            result = self._values.get("option_settings")
            return typing.cast(typing.Optional[typing.Union[_IResolvable_a771d0ef, typing.List[typing.Union["CfnOptionGroup.OptionSettingProperty", _IResolvable_a771d0ef]]]], result)

        @builtins.property
        def option_version(self) -> typing.Optional[builtins.str]:
            '''The version for the option.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-optiongroup-optionconfiguration.html#cfn-rds-optiongroup-optionconfiguration-optionversion
            '''
            result = self._values.get("option_version")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def port(self) -> typing.Optional[jsii.Number]:
            '''The optional port for the option.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-optiongroup-optionconfiguration.html#cfn-rds-optiongroup-optionconfiguration-port
            '''
            result = self._values.get("port")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def vpc_security_group_memberships(
            self,
        ) -> typing.Optional[typing.List[builtins.str]]:
            '''A list of VpcSecurityGroupMembership name strings used for this option.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-optiongroup-optionconfiguration.html#cfn-rds-optiongroup-optionconfiguration-vpcsecuritygroupmemberships
            '''
            result = self._values.get("vpc_security_group_memberships")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "OptionConfigurationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="monocdk.aws_rds.CfnOptionGroup.OptionSettingProperty",
        jsii_struct_bases=[],
        name_mapping={"name": "name", "value": "value"},
    )
    class OptionSettingProperty:
        def __init__(
            self,
            *,
            name: typing.Optional[builtins.str] = None,
            value: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The ``OptionSetting`` property type specifies the value for an option within an ``OptionSetting`` property.

            :param name: The name of the option that has settings that you can set.
            :param value: The current value of the option setting.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-optiongroup-optionsetting.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from monocdk import aws_rds as rds
                
                option_setting_property = rds.CfnOptionGroup.OptionSettingProperty(
                    name="name",
                    value="value"
                )
            '''
            if __debug__:
                type_hints = typing.get_type_hints(_typecheckingstub__a9c24cce3b6bb39fb92389cf0fcbf2943b151c9fda59ca8639b4311a9ce19522)
                check_type(argname="argument name", value=name, expected_type=type_hints["name"])
                check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            self._values: typing.Dict[builtins.str, typing.Any] = {}
            if name is not None:
                self._values["name"] = name
            if value is not None:
                self._values["value"] = value

        @builtins.property
        def name(self) -> typing.Optional[builtins.str]:
            '''The name of the option that has settings that you can set.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-optiongroup-optionsetting.html#cfn-rds-optiongroup-optionsetting-name
            '''
            result = self._values.get("name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def value(self) -> typing.Optional[builtins.str]:
            '''The current value of the option setting.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-optiongroup-optionsetting.html#cfn-rds-optiongroup-optionsetting-value
            '''
            result = self._values.get("value")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "OptionSettingProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="monocdk.aws_rds.CfnOptionGroupProps",
    jsii_struct_bases=[],
    name_mapping={
        "engine_name": "engineName",
        "major_engine_version": "majorEngineVersion",
        "option_group_description": "optionGroupDescription",
        "option_configurations": "optionConfigurations",
        "option_group_name": "optionGroupName",
        "tags": "tags",
    },
)
class CfnOptionGroupProps:
    def __init__(
        self,
        *,
        engine_name: builtins.str,
        major_engine_version: builtins.str,
        option_group_description: builtins.str,
        option_configurations: typing.Optional[typing.Union[_IResolvable_a771d0ef, typing.Sequence[typing.Union[typing.Union[CfnOptionGroup.OptionConfigurationProperty, typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]]]] = None,
        option_group_name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union[_CfnTag_95fbdc29, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for defining a ``CfnOptionGroup``.

        :param engine_name: Specifies the name of the engine that this option group should be associated with. Valid Values: - ``mariadb`` - ``mysql`` - ``oracle-ee`` - ``oracle-ee-cdb`` - ``oracle-se2`` - ``oracle-se2-cdb`` - ``postgres`` - ``sqlserver-ee`` - ``sqlserver-se`` - ``sqlserver-ex`` - ``sqlserver-web``
        :param major_engine_version: Specifies the major version of the engine that this option group should be associated with.
        :param option_group_description: The description of the option group.
        :param option_configurations: A list of options and the settings for each option.
        :param option_group_name: The name of the option group to be created. Constraints: - Must be 1 to 255 letters, numbers, or hyphens - First character must be a letter - Can't end with a hyphen or contain two consecutive hyphens Example: ``myoptiongroup`` If you don't specify a value for ``OptionGroupName`` property, a name is automatically created for the option group. .. epigraph:: This value is stored as a lowercase string.
        :param tags: An optional array of key-value pairs to apply to this option group.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-optiongroup.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_rds as rds
            
            cfn_option_group_props = rds.CfnOptionGroupProps(
                engine_name="engineName",
                major_engine_version="majorEngineVersion",
                option_group_description="optionGroupDescription",
            
                # the properties below are optional
                option_configurations=[rds.CfnOptionGroup.OptionConfigurationProperty(
                    option_name="optionName",
            
                    # the properties below are optional
                    db_security_group_memberships=["dbSecurityGroupMemberships"],
                    option_settings=[rds.CfnOptionGroup.OptionSettingProperty(
                        name="name",
                        value="value"
                    )],
                    option_version="optionVersion",
                    port=123,
                    vpc_security_group_memberships=["vpcSecurityGroupMemberships"]
                )],
                option_group_name="optionGroupName",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__123a3d5bfb53653a73305970f4739068b614557f3fd637bd36a641ef0a966bea)
            check_type(argname="argument engine_name", value=engine_name, expected_type=type_hints["engine_name"])
            check_type(argname="argument major_engine_version", value=major_engine_version, expected_type=type_hints["major_engine_version"])
            check_type(argname="argument option_group_description", value=option_group_description, expected_type=type_hints["option_group_description"])
            check_type(argname="argument option_configurations", value=option_configurations, expected_type=type_hints["option_configurations"])
            check_type(argname="argument option_group_name", value=option_group_name, expected_type=type_hints["option_group_name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "engine_name": engine_name,
            "major_engine_version": major_engine_version,
            "option_group_description": option_group_description,
        }
        if option_configurations is not None:
            self._values["option_configurations"] = option_configurations
        if option_group_name is not None:
            self._values["option_group_name"] = option_group_name
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def engine_name(self) -> builtins.str:
        '''Specifies the name of the engine that this option group should be associated with.

        Valid Values:

        - ``mariadb``
        - ``mysql``
        - ``oracle-ee``
        - ``oracle-ee-cdb``
        - ``oracle-se2``
        - ``oracle-se2-cdb``
        - ``postgres``
        - ``sqlserver-ee``
        - ``sqlserver-se``
        - ``sqlserver-ex``
        - ``sqlserver-web``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-optiongroup.html#cfn-rds-optiongroup-enginename
        '''
        result = self._values.get("engine_name")
        assert result is not None, "Required property 'engine_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def major_engine_version(self) -> builtins.str:
        '''Specifies the major version of the engine that this option group should be associated with.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-optiongroup.html#cfn-rds-optiongroup-majorengineversion
        '''
        result = self._values.get("major_engine_version")
        assert result is not None, "Required property 'major_engine_version' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def option_group_description(self) -> builtins.str:
        '''The description of the option group.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-optiongroup.html#cfn-rds-optiongroup-optiongroupdescription
        '''
        result = self._values.get("option_group_description")
        assert result is not None, "Required property 'option_group_description' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def option_configurations(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_a771d0ef, typing.List[typing.Union[CfnOptionGroup.OptionConfigurationProperty, _IResolvable_a771d0ef]]]]:
        '''A list of options and the settings for each option.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-optiongroup.html#cfn-rds-optiongroup-optionconfigurations
        '''
        result = self._values.get("option_configurations")
        return typing.cast(typing.Optional[typing.Union[_IResolvable_a771d0ef, typing.List[typing.Union[CfnOptionGroup.OptionConfigurationProperty, _IResolvable_a771d0ef]]]], result)

    @builtins.property
    def option_group_name(self) -> typing.Optional[builtins.str]:
        '''The name of the option group to be created.

        Constraints:

        - Must be 1 to 255 letters, numbers, or hyphens
        - First character must be a letter
        - Can't end with a hyphen or contain two consecutive hyphens

        Example: ``myoptiongroup``

        If you don't specify a value for ``OptionGroupName`` property, a name is automatically created for the option group.
        .. epigraph::

           This value is stored as a lowercase string.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-optiongroup.html#cfn-rds-optiongroup-optiongroupname
        '''
        result = self._values.get("option_group_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[_CfnTag_95fbdc29]]:
        '''An optional array of key-value pairs to apply to this option group.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-optiongroup.html#cfn-rds-optiongroup-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[_CfnTag_95fbdc29]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnOptionGroupProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_rds.ClusterEngineBindOptions",
    jsii_struct_bases=[],
    name_mapping={
        "parameter_group": "parameterGroup",
        "s3_export_role": "s3ExportRole",
        "s3_import_role": "s3ImportRole",
    },
)
class ClusterEngineBindOptions:
    def __init__(
        self,
        *,
        parameter_group: typing.Optional["IParameterGroup"] = None,
        s3_export_role: typing.Optional[_IRole_59af6f50] = None,
        s3_import_role: typing.Optional[_IRole_59af6f50] = None,
    ) -> None:
        '''(experimental) The extra options passed to the {@link IClusterEngine.bindToCluster} method.

        :param parameter_group: (experimental) The customer-provided ParameterGroup. Default: - none
        :param s3_export_role: (experimental) The role used for S3 exporting. Default: - none
        :param s3_import_role: (experimental) The role used for S3 importing. Default: - none

        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_iam as iam
            from monocdk import aws_rds as rds
            
            # parameter_group: rds.ParameterGroup
            # role: iam.Role
            
            cluster_engine_bind_options = rds.ClusterEngineBindOptions(
                parameter_group=parameter_group,
                s3_export_role=role,
                s3_import_role=role
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0ebe255ef0a32e69b21915f181f2df84868d2e33760202b7257403c1c94790e5)
            check_type(argname="argument parameter_group", value=parameter_group, expected_type=type_hints["parameter_group"])
            check_type(argname="argument s3_export_role", value=s3_export_role, expected_type=type_hints["s3_export_role"])
            check_type(argname="argument s3_import_role", value=s3_import_role, expected_type=type_hints["s3_import_role"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if parameter_group is not None:
            self._values["parameter_group"] = parameter_group
        if s3_export_role is not None:
            self._values["s3_export_role"] = s3_export_role
        if s3_import_role is not None:
            self._values["s3_import_role"] = s3_import_role

    @builtins.property
    def parameter_group(self) -> typing.Optional["IParameterGroup"]:
        '''(experimental) The customer-provided ParameterGroup.

        :default: - none

        :stability: experimental
        '''
        result = self._values.get("parameter_group")
        return typing.cast(typing.Optional["IParameterGroup"], result)

    @builtins.property
    def s3_export_role(self) -> typing.Optional[_IRole_59af6f50]:
        '''(experimental) The role used for S3 exporting.

        :default: - none

        :stability: experimental
        '''
        result = self._values.get("s3_export_role")
        return typing.cast(typing.Optional[_IRole_59af6f50], result)

    @builtins.property
    def s3_import_role(self) -> typing.Optional[_IRole_59af6f50]:
        '''(experimental) The role used for S3 importing.

        :default: - none

        :stability: experimental
        '''
        result = self._values.get("s3_import_role")
        return typing.cast(typing.Optional[_IRole_59af6f50], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterEngineBindOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_rds.ClusterEngineConfig",
    jsii_struct_bases=[],
    name_mapping={
        "features": "features",
        "parameter_group": "parameterGroup",
        "port": "port",
    },
)
class ClusterEngineConfig:
    def __init__(
        self,
        *,
        features: typing.Optional[typing.Union["ClusterEngineFeatures", typing.Dict[builtins.str, typing.Any]]] = None,
        parameter_group: typing.Optional["IParameterGroup"] = None,
        port: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''(experimental) The type returned from the {@link IClusterEngine.bindToCluster} method.

        :param features: (experimental) Features supported by the database engine. Default: - no features
        :param parameter_group: (experimental) The ParameterGroup to use for the cluster. Default: - no ParameterGroup will be used
        :param port: (experimental) The port to use for this cluster, unless the customer specified the port directly. Default: - use the default port for clusters (3306)

        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_rds as rds
            
            # parameter_group: rds.ParameterGroup
            
            cluster_engine_config = rds.ClusterEngineConfig(
                features=rds.ClusterEngineFeatures(
                    s3_export="s3Export",
                    s3_import="s3Import"
                ),
                parameter_group=parameter_group,
                port=123
            )
        '''
        if isinstance(features, dict):
            features = ClusterEngineFeatures(**features)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4080c5e394ab90cb412fd554598e910b54c9967289123325e367a5e5abb5aebb)
            check_type(argname="argument features", value=features, expected_type=type_hints["features"])
            check_type(argname="argument parameter_group", value=parameter_group, expected_type=type_hints["parameter_group"])
            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if features is not None:
            self._values["features"] = features
        if parameter_group is not None:
            self._values["parameter_group"] = parameter_group
        if port is not None:
            self._values["port"] = port

    @builtins.property
    def features(self) -> typing.Optional["ClusterEngineFeatures"]:
        '''(experimental) Features supported by the database engine.

        :default: - no features

        :see: https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_DBEngineVersion.html
        :stability: experimental
        '''
        result = self._values.get("features")
        return typing.cast(typing.Optional["ClusterEngineFeatures"], result)

    @builtins.property
    def parameter_group(self) -> typing.Optional["IParameterGroup"]:
        '''(experimental) The ParameterGroup to use for the cluster.

        :default: - no ParameterGroup will be used

        :stability: experimental
        '''
        result = self._values.get("parameter_group")
        return typing.cast(typing.Optional["IParameterGroup"], result)

    @builtins.property
    def port(self) -> typing.Optional[jsii.Number]:
        '''(experimental) The port to use for this cluster, unless the customer specified the port directly.

        :default: - use the default port for clusters (3306)

        :stability: experimental
        '''
        result = self._values.get("port")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterEngineConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_rds.ClusterEngineFeatures",
    jsii_struct_bases=[],
    name_mapping={"s3_export": "s3Export", "s3_import": "s3Import"},
)
class ClusterEngineFeatures:
    def __init__(
        self,
        *,
        s3_export: typing.Optional[builtins.str] = None,
        s3_import: typing.Optional[builtins.str] = None,
    ) -> None:
        '''(experimental) Represents Database Engine features.

        :param s3_export: (experimental) Feature name for the DB instance that the IAM role to export to S3 bucket is to be associated with. Default: - no s3Export feature name
        :param s3_import: (experimental) Feature name for the DB instance that the IAM role to access the S3 bucket for import is to be associated with. Default: - no s3Import feature name

        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_rds as rds
            
            cluster_engine_features = rds.ClusterEngineFeatures(
                s3_export="s3Export",
                s3_import="s3Import"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dc323a86d68f75c8fa4b776b469fc599385f8420dd13a5b9f964eea1d02a0e7b)
            check_type(argname="argument s3_export", value=s3_export, expected_type=type_hints["s3_export"])
            check_type(argname="argument s3_import", value=s3_import, expected_type=type_hints["s3_import"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if s3_export is not None:
            self._values["s3_export"] = s3_export
        if s3_import is not None:
            self._values["s3_import"] = s3_import

    @builtins.property
    def s3_export(self) -> typing.Optional[builtins.str]:
        '''(experimental) Feature name for the DB instance that the IAM role to export to S3 bucket is to be associated with.

        :default: - no s3Export feature name

        :stability: experimental
        '''
        result = self._values.get("s3_export")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def s3_import(self) -> typing.Optional[builtins.str]:
        '''(experimental) Feature name for the DB instance that the IAM role to access the S3 bucket for import is to be associated with.

        :default: - no s3Import feature name

        :stability: experimental
        '''
        result = self._values.get("s3_import")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterEngineFeatures(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_rds.CommonRotationUserOptions",
    jsii_struct_bases=[],
    name_mapping={
        "automatically_after": "automaticallyAfter",
        "endpoint": "endpoint",
        "exclude_characters": "excludeCharacters",
        "vpc_subnets": "vpcSubnets",
    },
)
class CommonRotationUserOptions:
    def __init__(
        self,
        *,
        automatically_after: typing.Optional[_Duration_070aa057] = None,
        endpoint: typing.Optional[_IInterfaceVpcEndpoint_6081623d] = None,
        exclude_characters: typing.Optional[builtins.str] = None,
        vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''(experimental) Properties common to single-user and multi-user rotation options.

        :param automatically_after: (experimental) Specifies the number of days after the previous rotation before Secrets Manager triggers the next automatic rotation. Default: - 30 days
        :param endpoint: (experimental) The VPC interface endpoint to use for the Secrets Manager API. If you enable private DNS hostnames for your VPC private endpoint (the default), you don't need to specify an endpoint. The standard Secrets Manager DNS hostname the Secrets Manager CLI and SDKs use by default (https://secretsmanager..amazonaws.com) automatically resolves to your VPC endpoint. Default: https://secretsmanager..amazonaws.com
        :param exclude_characters: (experimental) Specifies characters to not include in generated passwords. Default: " %+~`#$&*()|[]{}:;<>?!'/
        :param vpc_subnets: (experimental) Where to place the rotation Lambda function. Default: - same placement as instance or cluster

        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            import monocdk as monocdk
            from monocdk import aws_ec2 as ec2
            from monocdk import aws_rds as rds
            
            # duration: monocdk.Duration
            # interface_vpc_endpoint: ec2.InterfaceVpcEndpoint
            # subnet: ec2.Subnet
            # subnet_filter: ec2.SubnetFilter
            
            common_rotation_user_options = rds.CommonRotationUserOptions(
                automatically_after=duration,
                endpoint=interface_vpc_endpoint,
                exclude_characters="excludeCharacters",
                vpc_subnets=ec2.SubnetSelection(
                    availability_zones=["availabilityZones"],
                    one_per_az=False,
                    subnet_filters=[subnet_filter],
                    subnet_group_name="subnetGroupName",
                    subnet_name="subnetName",
                    subnets=[subnet],
                    subnet_type=ec2.SubnetType.ISOLATED
                )
            )
        '''
        if isinstance(vpc_subnets, dict):
            vpc_subnets = _SubnetSelection_1284e62c(**vpc_subnets)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ce752cb488ff55d96c25fdf7c1801594f1205821f5d24b695b0aee71ca83b81d)
            check_type(argname="argument automatically_after", value=automatically_after, expected_type=type_hints["automatically_after"])
            check_type(argname="argument endpoint", value=endpoint, expected_type=type_hints["endpoint"])
            check_type(argname="argument exclude_characters", value=exclude_characters, expected_type=type_hints["exclude_characters"])
            check_type(argname="argument vpc_subnets", value=vpc_subnets, expected_type=type_hints["vpc_subnets"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if automatically_after is not None:
            self._values["automatically_after"] = automatically_after
        if endpoint is not None:
            self._values["endpoint"] = endpoint
        if exclude_characters is not None:
            self._values["exclude_characters"] = exclude_characters
        if vpc_subnets is not None:
            self._values["vpc_subnets"] = vpc_subnets

    @builtins.property
    def automatically_after(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Specifies the number of days after the previous rotation before Secrets Manager triggers the next automatic rotation.

        :default: - 30 days

        :stability: experimental
        '''
        result = self._values.get("automatically_after")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def endpoint(self) -> typing.Optional[_IInterfaceVpcEndpoint_6081623d]:
        '''(experimental) The VPC interface endpoint to use for the Secrets Manager API.

        If you enable private DNS hostnames for your VPC private endpoint (the default), you don't
        need to specify an endpoint. The standard Secrets Manager DNS hostname the Secrets Manager
        CLI and SDKs use by default (https://secretsmanager..amazonaws.com) automatically
        resolves to your VPC endpoint.

        :default: https://secretsmanager..amazonaws.com

        :stability: experimental
        '''
        result = self._values.get("endpoint")
        return typing.cast(typing.Optional[_IInterfaceVpcEndpoint_6081623d], result)

    @builtins.property
    def exclude_characters(self) -> typing.Optional[builtins.str]:
        '''(experimental) Specifies characters to not include in generated passwords.

        :default: " %+~`#$&*()|[]{}:;<>?!'/

        :stability: experimental
        :: "\\"
        '''
        result = self._values.get("exclude_characters")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vpc_subnets(self) -> typing.Optional[_SubnetSelection_1284e62c]:
        '''(experimental) Where to place the rotation Lambda function.

        :default: - same placement as instance or cluster

        :stability: experimental
        '''
        result = self._values.get("vpc_subnets")
        return typing.cast(typing.Optional[_SubnetSelection_1284e62c], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CommonRotationUserOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class Credentials(
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="monocdk.aws_rds.Credentials",
):
    '''(experimental) Username and password combination.

    :stability: experimental
    :exampleMetadata: infused

    Example::

        # Build a data source for AppSync to access the database.
        # api: appsync.GraphqlApi
        # Create username and password secret for DB Cluster
        secret = rds.DatabaseSecret(self, "AuroraSecret",
            username="clusteradmin"
        )
        
        # The VPC to place the cluster in
        vpc = ec2.Vpc(self, "AuroraVpc")
        
        # Create the serverless cluster, provide all values needed to customise the database.
        cluster = rds.ServerlessCluster(self, "AuroraCluster",
            engine=rds.DatabaseClusterEngine.AURORA_MYSQL,
            vpc=vpc,
            credentials={"username": "clusteradmin"},
            cluster_identifier="db-endpoint-test",
            default_database_name="demos"
        )
        rds_dS = api.add_rds_data_source("rds", cluster, secret, "demos")
        
        # Set up a resolver for an RDS query.
        rds_dS.create_resolver(
            type_name="Query",
            field_name="getDemosRds",
            request_mapping_template=appsync.MappingTemplate.from_string("""
                  {
                    "version": "2018-05-29",
                    "statements": [
                      "SELECT * FROM demos"
                    ]
                  }
                  """),
            response_mapping_template=appsync.MappingTemplate.from_string("""
                    $utils.toJson($utils.rds.toJsonObject($ctx.result)[0])
                  """)
        )
        
        # Set up a resolver for an RDS mutation.
        rds_dS.create_resolver(
            type_name="Mutation",
            field_name="addDemoRds",
            request_mapping_template=appsync.MappingTemplate.from_string("""
                  {
                    "version": "2018-05-29",
                    "statements": [
                      "INSERT INTO demos VALUES (:id, :version)",
                      "SELECT * WHERE id = :id"
                    ],
                    "variableMap": {
                      ":id": $util.toJson($util.autoId()),
                      ":version": $util.toJson($ctx.args.version)
                    }
                  }
                  """),
            response_mapping_template=appsync.MappingTemplate.from_string("""
                    $utils.toJson($utils.rds.toJsonObject($ctx.result)[1][0])
                  """)
        )
    '''

    def __init__(self) -> None:
        '''
        :stability: experimental
        '''
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="fromGeneratedSecret")
    @builtins.classmethod
    def from_generated_secret(
        cls,
        username: builtins.str,
        *,
        encryption_key: typing.Optional[_IKey_36930160] = None,
        exclude_characters: typing.Optional[builtins.str] = None,
        replica_regions: typing.Optional[typing.Sequence[typing.Union[_ReplicaRegion_ad1a6d2e, typing.Dict[builtins.str, typing.Any]]]] = None,
        secret_name: typing.Optional[builtins.str] = None,
    ) -> "Credentials":
        '''(experimental) Creates Credentials with a password generated and stored in Secrets Manager.

        :param username: -
        :param encryption_key: (experimental) KMS encryption key to encrypt the generated secret. Default: - default master key
        :param exclude_characters: (experimental) The characters to exclude from the generated password. Has no effect if {@link password} has been provided. Default: - the DatabaseSecret default exclude character set (" %+~`#$&*()|[]{}:;<>?!'/
        :param replica_regions: (experimental) A list of regions where to replicate this secret. Default: - Secret is not replicated
        :param secret_name: (experimental) The name of the secret. Default: - A name is generated by CloudFormation.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__17d4e6cd9004f729a10d723bc6a7c1ae57e715478ccd0710097bc468e6e6a8d7)
            check_type(argname="argument username", value=username, expected_type=type_hints["username"])
        options = CredentialsBaseOptions(
            encryption_key=encryption_key,
            exclude_characters=exclude_characters,
            replica_regions=replica_regions,
            secret_name=secret_name,
        )

        return typing.cast("Credentials", jsii.sinvoke(cls, "fromGeneratedSecret", [username, options]))

    @jsii.member(jsii_name="fromPassword")
    @builtins.classmethod
    def from_password(
        cls,
        username: builtins.str,
        password: _SecretValue_c18506ef,
    ) -> "Credentials":
        '''(experimental) Creates Credentials from a password.

        Do not put passwords in your CDK code directly.

        :param username: -
        :param password: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e80ffe6dc03fe1872a9918ca9ae89d4f229cafc6a45c1f144ba07e035c6676d6)
            check_type(argname="argument username", value=username, expected_type=type_hints["username"])
            check_type(argname="argument password", value=password, expected_type=type_hints["password"])
        return typing.cast("Credentials", jsii.sinvoke(cls, "fromPassword", [username, password]))

    @jsii.member(jsii_name="fromSecret")
    @builtins.classmethod
    def from_secret(
        cls,
        secret: _ISecret_22fb8757,
        username: typing.Optional[builtins.str] = None,
    ) -> "Credentials":
        '''(experimental) Creates Credentials from an existing Secrets Manager ``Secret`` (or ``DatabaseSecret``).

        The Secret must be a JSON string with a ``username`` and ``password`` field::

           {
              ...
              "username": <required: username>,
              "password": <required: password>,
           }

        :param secret: The secret where the credentials are stored.
        :param username: The username defined in the secret. If specified the username will be referenced as a string and not a dynamic reference to the username field in the secret. This allows to replace the secret without replacing the instance or cluster.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__046b717ff081b63304a4655291073452bcac4fd782b3119509bd301b85dc1c30)
            check_type(argname="argument secret", value=secret, expected_type=type_hints["secret"])
            check_type(argname="argument username", value=username, expected_type=type_hints["username"])
        return typing.cast("Credentials", jsii.sinvoke(cls, "fromSecret", [secret, username]))

    @jsii.member(jsii_name="fromUsername")
    @builtins.classmethod
    def from_username(
        cls,
        username: builtins.str,
        *,
        password: typing.Optional[_SecretValue_c18506ef] = None,
        encryption_key: typing.Optional[_IKey_36930160] = None,
        exclude_characters: typing.Optional[builtins.str] = None,
        replica_regions: typing.Optional[typing.Sequence[typing.Union[_ReplicaRegion_ad1a6d2e, typing.Dict[builtins.str, typing.Any]]]] = None,
        secret_name: typing.Optional[builtins.str] = None,
    ) -> "Credentials":
        '''(experimental) Creates Credentials for the given username, and optional password and key.

        If no password is provided, one will be generated and stored in Secrets Manager.

        :param username: -
        :param password: (experimental) Password. Do not put passwords in your CDK code directly. Default: - a Secrets Manager generated password
        :param encryption_key: (experimental) KMS encryption key to encrypt the generated secret. Default: - default master key
        :param exclude_characters: (experimental) The characters to exclude from the generated password. Has no effect if {@link password} has been provided. Default: - the DatabaseSecret default exclude character set (" %+~`#$&*()|[]{}:;<>?!'/
        :param replica_regions: (experimental) A list of regions where to replicate this secret. Default: - Secret is not replicated
        :param secret_name: (experimental) The name of the secret. Default: - A name is generated by CloudFormation.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cc18f4f28cad27d9206d2399c07f91796e289b0995618f784142e4df41487306)
            check_type(argname="argument username", value=username, expected_type=type_hints["username"])
        options = CredentialsFromUsernameOptions(
            password=password,
            encryption_key=encryption_key,
            exclude_characters=exclude_characters,
            replica_regions=replica_regions,
            secret_name=secret_name,
        )

        return typing.cast("Credentials", jsii.sinvoke(cls, "fromUsername", [username, options]))

    @builtins.property
    @jsii.member(jsii_name="username")
    @abc.abstractmethod
    def username(self) -> builtins.str:
        '''(experimental) Username.

        :stability: experimental
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="encryptionKey")
    @abc.abstractmethod
    def encryption_key(self) -> typing.Optional[_IKey_36930160]:
        '''(experimental) KMS encryption key to encrypt the generated secret.

        :default: - default master key

        :stability: experimental
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="excludeCharacters")
    @abc.abstractmethod
    def exclude_characters(self) -> typing.Optional[builtins.str]:
        '''(experimental) The characters to exclude from the generated password.

        Only used if {@link password} has not been set.

        :default: - the DatabaseSecret default exclude character set (" %+~`#$&*()|[]{}:;<>?!'/

        :stability: experimental
        :: "\\")
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="password")
    @abc.abstractmethod
    def password(self) -> typing.Optional[_SecretValue_c18506ef]:
        '''(experimental) Password.

        Do not put passwords in your CDK code directly.

        :default: - a Secrets Manager generated password

        :stability: experimental
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="replicaRegions")
    @abc.abstractmethod
    def replica_regions(self) -> typing.Optional[typing.List[_ReplicaRegion_ad1a6d2e]]:
        '''(experimental) A list of regions where to replicate the generated secret.

        :default: - Secret is not replicated

        :stability: experimental
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="secret")
    @abc.abstractmethod
    def secret(self) -> typing.Optional[_ISecret_22fb8757]:
        '''(experimental) Secret used to instantiate this Login.

        :default: - none

        :stability: experimental
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="secretName")
    @abc.abstractmethod
    def secret_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) The name to use for the Secret if a new Secret is to be generated in SecretsManager for these Credentials.

        :default: - A name is generated by CloudFormation.

        :stability: experimental
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="usernameAsString")
    @abc.abstractmethod
    def username_as_string(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Whether the username should be referenced as a string and not as a dynamic reference to the username in the secret.

        :default: false

        :stability: experimental
        '''
        ...


class _CredentialsProxy(Credentials):
    @builtins.property
    @jsii.member(jsii_name="username")
    def username(self) -> builtins.str:
        '''(experimental) Username.

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "username"))

    @builtins.property
    @jsii.member(jsii_name="encryptionKey")
    def encryption_key(self) -> typing.Optional[_IKey_36930160]:
        '''(experimental) KMS encryption key to encrypt the generated secret.

        :default: - default master key

        :stability: experimental
        '''
        return typing.cast(typing.Optional[_IKey_36930160], jsii.get(self, "encryptionKey"))

    @builtins.property
    @jsii.member(jsii_name="excludeCharacters")
    def exclude_characters(self) -> typing.Optional[builtins.str]:
        '''(experimental) The characters to exclude from the generated password.

        Only used if {@link password} has not been set.

        :default: - the DatabaseSecret default exclude character set (" %+~`#$&*()|[]{}:;<>?!'/

        :stability: experimental
        :: "\\")
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "excludeCharacters"))

    @builtins.property
    @jsii.member(jsii_name="password")
    def password(self) -> typing.Optional[_SecretValue_c18506ef]:
        '''(experimental) Password.

        Do not put passwords in your CDK code directly.

        :default: - a Secrets Manager generated password

        :stability: experimental
        '''
        return typing.cast(typing.Optional[_SecretValue_c18506ef], jsii.get(self, "password"))

    @builtins.property
    @jsii.member(jsii_name="replicaRegions")
    def replica_regions(self) -> typing.Optional[typing.List[_ReplicaRegion_ad1a6d2e]]:
        '''(experimental) A list of regions where to replicate the generated secret.

        :default: - Secret is not replicated

        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.List[_ReplicaRegion_ad1a6d2e]], jsii.get(self, "replicaRegions"))

    @builtins.property
    @jsii.member(jsii_name="secret")
    def secret(self) -> typing.Optional[_ISecret_22fb8757]:
        '''(experimental) Secret used to instantiate this Login.

        :default: - none

        :stability: experimental
        '''
        return typing.cast(typing.Optional[_ISecret_22fb8757], jsii.get(self, "secret"))

    @builtins.property
    @jsii.member(jsii_name="secretName")
    def secret_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) The name to use for the Secret if a new Secret is to be generated in SecretsManager for these Credentials.

        :default: - A name is generated by CloudFormation.

        :stability: experimental
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "secretName"))

    @builtins.property
    @jsii.member(jsii_name="usernameAsString")
    def username_as_string(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Whether the username should be referenced as a string and not as a dynamic reference to the username in the secret.

        :default: false

        :stability: experimental
        '''
        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "usernameAsString"))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, Credentials).__jsii_proxy_class__ = lambda : _CredentialsProxy


@jsii.data_type(
    jsii_type="monocdk.aws_rds.CredentialsBaseOptions",
    jsii_struct_bases=[],
    name_mapping={
        "encryption_key": "encryptionKey",
        "exclude_characters": "excludeCharacters",
        "replica_regions": "replicaRegions",
        "secret_name": "secretName",
    },
)
class CredentialsBaseOptions:
    def __init__(
        self,
        *,
        encryption_key: typing.Optional[_IKey_36930160] = None,
        exclude_characters: typing.Optional[builtins.str] = None,
        replica_regions: typing.Optional[typing.Sequence[typing.Union[_ReplicaRegion_ad1a6d2e, typing.Dict[builtins.str, typing.Any]]]] = None,
        secret_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''(experimental) Base options for creating Credentials.

        :param encryption_key: (experimental) KMS encryption key to encrypt the generated secret. Default: - default master key
        :param exclude_characters: (experimental) The characters to exclude from the generated password. Has no effect if {@link password} has been provided. Default: - the DatabaseSecret default exclude character set (" %+~`#$&*()|[]{}:;<>?!'/
        :param replica_regions: (experimental) A list of regions where to replicate this secret. Default: - Secret is not replicated
        :param secret_name: (experimental) The name of the secret. Default: - A name is generated by CloudFormation.

        :stability: experimental
        :exampleMetadata: infused

        Example::

            # vpc: ec2.Vpc
            
            engine = rds.DatabaseInstanceEngine.postgres(version=rds.PostgresEngineVersion.VER_12_3)
            my_key = kms.Key(self, "MyKey")
            
            rds.DatabaseInstance(self, "InstanceWithCustomizedSecret",
                engine=engine,
                vpc=vpc,
                credentials=rds.Credentials.from_generated_secret("postgres",
                    secret_name="my-cool-name",
                    encryption_key=my_key,
                    exclude_characters="!&*^#@()",
                    replica_regions=[ec2.aws_secretsmanager.ReplicaRegion(region="eu-west-1"), ec2.aws_secretsmanager.ReplicaRegion(region="eu-west-2")]
                )
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a0e1890f6a5f0a3246af72af2a7014a46bab1ebd56f5b68c97b165295535106f)
            check_type(argname="argument encryption_key", value=encryption_key, expected_type=type_hints["encryption_key"])
            check_type(argname="argument exclude_characters", value=exclude_characters, expected_type=type_hints["exclude_characters"])
            check_type(argname="argument replica_regions", value=replica_regions, expected_type=type_hints["replica_regions"])
            check_type(argname="argument secret_name", value=secret_name, expected_type=type_hints["secret_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if encryption_key is not None:
            self._values["encryption_key"] = encryption_key
        if exclude_characters is not None:
            self._values["exclude_characters"] = exclude_characters
        if replica_regions is not None:
            self._values["replica_regions"] = replica_regions
        if secret_name is not None:
            self._values["secret_name"] = secret_name

    @builtins.property
    def encryption_key(self) -> typing.Optional[_IKey_36930160]:
        '''(experimental) KMS encryption key to encrypt the generated secret.

        :default: - default master key

        :stability: experimental
        '''
        result = self._values.get("encryption_key")
        return typing.cast(typing.Optional[_IKey_36930160], result)

    @builtins.property
    def exclude_characters(self) -> typing.Optional[builtins.str]:
        '''(experimental) The characters to exclude from the generated password.

        Has no effect if {@link password} has been provided.

        :default: - the DatabaseSecret default exclude character set (" %+~`#$&*()|[]{}:;<>?!'/

        :stability: experimental
        :: "\\")
        '''
        result = self._values.get("exclude_characters")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def replica_regions(self) -> typing.Optional[typing.List[_ReplicaRegion_ad1a6d2e]]:
        '''(experimental) A list of regions where to replicate this secret.

        :default: - Secret is not replicated

        :stability: experimental
        '''
        result = self._values.get("replica_regions")
        return typing.cast(typing.Optional[typing.List[_ReplicaRegion_ad1a6d2e]], result)

    @builtins.property
    def secret_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) The name of the secret.

        :default: - A name is generated by CloudFormation.

        :stability: experimental
        '''
        result = self._values.get("secret_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CredentialsBaseOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_rds.CredentialsFromUsernameOptions",
    jsii_struct_bases=[CredentialsBaseOptions],
    name_mapping={
        "encryption_key": "encryptionKey",
        "exclude_characters": "excludeCharacters",
        "replica_regions": "replicaRegions",
        "secret_name": "secretName",
        "password": "password",
    },
)
class CredentialsFromUsernameOptions(CredentialsBaseOptions):
    def __init__(
        self,
        *,
        encryption_key: typing.Optional[_IKey_36930160] = None,
        exclude_characters: typing.Optional[builtins.str] = None,
        replica_regions: typing.Optional[typing.Sequence[typing.Union[_ReplicaRegion_ad1a6d2e, typing.Dict[builtins.str, typing.Any]]]] = None,
        secret_name: typing.Optional[builtins.str] = None,
        password: typing.Optional[_SecretValue_c18506ef] = None,
    ) -> None:
        '''(experimental) Options for creating Credentials from a username.

        :param encryption_key: (experimental) KMS encryption key to encrypt the generated secret. Default: - default master key
        :param exclude_characters: (experimental) The characters to exclude from the generated password. Has no effect if {@link password} has been provided. Default: - the DatabaseSecret default exclude character set (" %+~`#$&*()|[]{}:;<>?!'/
        :param replica_regions: (experimental) A list of regions where to replicate this secret. Default: - Secret is not replicated
        :param secret_name: (experimental) The name of the secret. Default: - A name is generated by CloudFormation.
        :param password: (experimental) Password. Do not put passwords in your CDK code directly. Default: - a Secrets Manager generated password

        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            import monocdk as monocdk
            from monocdk import aws_kms as kms
            from monocdk import aws_rds as rds
            
            # key: kms.Key
            # secret_value: monocdk.SecretValue
            
            credentials_from_username_options = rds.CredentialsFromUsernameOptions(
                encryption_key=key,
                exclude_characters="excludeCharacters",
                password=secret_value,
                replica_regions=[monocdk.aws_secretsmanager.ReplicaRegion(
                    region="region",
            
                    # the properties below are optional
                    encryption_key=key
                )],
                secret_name="secretName"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__126eafb985242873bf988963c4853dbb0fb11ac0550e95124ac9dc4aaebab8e3)
            check_type(argname="argument encryption_key", value=encryption_key, expected_type=type_hints["encryption_key"])
            check_type(argname="argument exclude_characters", value=exclude_characters, expected_type=type_hints["exclude_characters"])
            check_type(argname="argument replica_regions", value=replica_regions, expected_type=type_hints["replica_regions"])
            check_type(argname="argument secret_name", value=secret_name, expected_type=type_hints["secret_name"])
            check_type(argname="argument password", value=password, expected_type=type_hints["password"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if encryption_key is not None:
            self._values["encryption_key"] = encryption_key
        if exclude_characters is not None:
            self._values["exclude_characters"] = exclude_characters
        if replica_regions is not None:
            self._values["replica_regions"] = replica_regions
        if secret_name is not None:
            self._values["secret_name"] = secret_name
        if password is not None:
            self._values["password"] = password

    @builtins.property
    def encryption_key(self) -> typing.Optional[_IKey_36930160]:
        '''(experimental) KMS encryption key to encrypt the generated secret.

        :default: - default master key

        :stability: experimental
        '''
        result = self._values.get("encryption_key")
        return typing.cast(typing.Optional[_IKey_36930160], result)

    @builtins.property
    def exclude_characters(self) -> typing.Optional[builtins.str]:
        '''(experimental) The characters to exclude from the generated password.

        Has no effect if {@link password} has been provided.

        :default: - the DatabaseSecret default exclude character set (" %+~`#$&*()|[]{}:;<>?!'/

        :stability: experimental
        :: "\\")
        '''
        result = self._values.get("exclude_characters")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def replica_regions(self) -> typing.Optional[typing.List[_ReplicaRegion_ad1a6d2e]]:
        '''(experimental) A list of regions where to replicate this secret.

        :default: - Secret is not replicated

        :stability: experimental
        '''
        result = self._values.get("replica_regions")
        return typing.cast(typing.Optional[typing.List[_ReplicaRegion_ad1a6d2e]], result)

    @builtins.property
    def secret_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) The name of the secret.

        :default: - A name is generated by CloudFormation.

        :stability: experimental
        '''
        result = self._values.get("secret_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def password(self) -> typing.Optional[_SecretValue_c18506ef]:
        '''(experimental) Password.

        Do not put passwords in your CDK code directly.

        :default: - a Secrets Manager generated password

        :stability: experimental
        '''
        result = self._values.get("password")
        return typing.cast(typing.Optional[_SecretValue_c18506ef], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CredentialsFromUsernameOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_rds.DatabaseClusterAttributes",
    jsii_struct_bases=[],
    name_mapping={
        "cluster_identifier": "clusterIdentifier",
        "cluster_endpoint_address": "clusterEndpointAddress",
        "engine": "engine",
        "instance_endpoint_addresses": "instanceEndpointAddresses",
        "instance_identifiers": "instanceIdentifiers",
        "port": "port",
        "reader_endpoint_address": "readerEndpointAddress",
        "security_groups": "securityGroups",
    },
)
class DatabaseClusterAttributes:
    def __init__(
        self,
        *,
        cluster_identifier: builtins.str,
        cluster_endpoint_address: typing.Optional[builtins.str] = None,
        engine: typing.Optional["IClusterEngine"] = None,
        instance_endpoint_addresses: typing.Optional[typing.Sequence[builtins.str]] = None,
        instance_identifiers: typing.Optional[typing.Sequence[builtins.str]] = None,
        port: typing.Optional[jsii.Number] = None,
        reader_endpoint_address: typing.Optional[builtins.str] = None,
        security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
    ) -> None:
        '''(experimental) Properties that describe an existing cluster instance.

        :param cluster_identifier: (experimental) Identifier for the cluster.
        :param cluster_endpoint_address: (experimental) Cluster endpoint address. Default: - no endpoint address
        :param engine: (experimental) The engine of the existing Cluster. Default: - the imported Cluster's engine is unknown
        :param instance_endpoint_addresses: (experimental) Endpoint addresses of individual instances. Default: - no instance endpoints
        :param instance_identifiers: (experimental) Identifier for the instances. Default: - no instance identifiers
        :param port: (experimental) The database port. Default: - none
        :param reader_endpoint_address: (experimental) Reader endpoint address. Default: - no reader address
        :param security_groups: (experimental) The security groups of the database cluster. Default: - no security groups

        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_ec2 as ec2
            from monocdk import aws_rds as rds
            
            # cluster_engine: rds.IClusterEngine
            # security_group: ec2.SecurityGroup
            
            database_cluster_attributes = rds.DatabaseClusterAttributes(
                cluster_identifier="clusterIdentifier",
            
                # the properties below are optional
                cluster_endpoint_address="clusterEndpointAddress",
                engine=cluster_engine,
                instance_endpoint_addresses=["instanceEndpointAddresses"],
                instance_identifiers=["instanceIdentifiers"],
                port=123,
                reader_endpoint_address="readerEndpointAddress",
                security_groups=[security_group]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__03bd8a06157ebdd9114eeddbc0fdacdd29b0136f15cbb0cc5ed0afce21bdeb7f)
            check_type(argname="argument cluster_identifier", value=cluster_identifier, expected_type=type_hints["cluster_identifier"])
            check_type(argname="argument cluster_endpoint_address", value=cluster_endpoint_address, expected_type=type_hints["cluster_endpoint_address"])
            check_type(argname="argument engine", value=engine, expected_type=type_hints["engine"])
            check_type(argname="argument instance_endpoint_addresses", value=instance_endpoint_addresses, expected_type=type_hints["instance_endpoint_addresses"])
            check_type(argname="argument instance_identifiers", value=instance_identifiers, expected_type=type_hints["instance_identifiers"])
            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
            check_type(argname="argument reader_endpoint_address", value=reader_endpoint_address, expected_type=type_hints["reader_endpoint_address"])
            check_type(argname="argument security_groups", value=security_groups, expected_type=type_hints["security_groups"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "cluster_identifier": cluster_identifier,
        }
        if cluster_endpoint_address is not None:
            self._values["cluster_endpoint_address"] = cluster_endpoint_address
        if engine is not None:
            self._values["engine"] = engine
        if instance_endpoint_addresses is not None:
            self._values["instance_endpoint_addresses"] = instance_endpoint_addresses
        if instance_identifiers is not None:
            self._values["instance_identifiers"] = instance_identifiers
        if port is not None:
            self._values["port"] = port
        if reader_endpoint_address is not None:
            self._values["reader_endpoint_address"] = reader_endpoint_address
        if security_groups is not None:
            self._values["security_groups"] = security_groups

    @builtins.property
    def cluster_identifier(self) -> builtins.str:
        '''(experimental) Identifier for the cluster.

        :stability: experimental
        '''
        result = self._values.get("cluster_identifier")
        assert result is not None, "Required property 'cluster_identifier' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def cluster_endpoint_address(self) -> typing.Optional[builtins.str]:
        '''(experimental) Cluster endpoint address.

        :default: - no endpoint address

        :stability: experimental
        '''
        result = self._values.get("cluster_endpoint_address")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def engine(self) -> typing.Optional["IClusterEngine"]:
        '''(experimental) The engine of the existing Cluster.

        :default: - the imported Cluster's engine is unknown

        :stability: experimental
        '''
        result = self._values.get("engine")
        return typing.cast(typing.Optional["IClusterEngine"], result)

    @builtins.property
    def instance_endpoint_addresses(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) Endpoint addresses of individual instances.

        :default: - no instance endpoints

        :stability: experimental
        '''
        result = self._values.get("instance_endpoint_addresses")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def instance_identifiers(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) Identifier for the instances.

        :default: - no instance identifiers

        :stability: experimental
        '''
        result = self._values.get("instance_identifiers")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def port(self) -> typing.Optional[jsii.Number]:
        '''(experimental) The database port.

        :default: - none

        :stability: experimental
        '''
        result = self._values.get("port")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def reader_endpoint_address(self) -> typing.Optional[builtins.str]:
        '''(experimental) Reader endpoint address.

        :default: - no reader address

        :stability: experimental
        '''
        result = self._values.get("reader_endpoint_address")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def security_groups(self) -> typing.Optional[typing.List[_ISecurityGroup_cdbba9d3]]:
        '''(experimental) The security groups of the database cluster.

        :default: - no security groups

        :stability: experimental
        '''
        result = self._values.get("security_groups")
        return typing.cast(typing.Optional[typing.List[_ISecurityGroup_cdbba9d3]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DatabaseClusterAttributes(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DatabaseClusterEngine(
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_rds.DatabaseClusterEngine",
):
    '''(experimental) A database cluster engine.

    Provides mapping to the serverless application
    used for secret rotation.

    :stability: experimental
    :exampleMetadata: infused

    Example::

        # vpc: ec2.Vpc
        
        
        cluster = rds.ServerlessCluster(self, "AnotherCluster",
            engine=rds.DatabaseClusterEngine.AURORA_POSTGRESQL,
            parameter_group=rds.ParameterGroup.from_parameter_group_name(self, "ParameterGroup", "default.aurora-postgresql10"),
            vpc=vpc,
            scaling=ec2.aws_rds.ServerlessScalingOptions(
                auto_pause=Duration.minutes(10),  # default is to pause after 5 minutes of idle time
                min_capacity=rds.AuroraCapacityUnit.ACU_8,  # default is 2 Aurora capacity units (ACUs)
                max_capacity=rds.AuroraCapacityUnit.ACU_32
            )
        )
    '''

    def __init__(self) -> None:
        '''
        :stability: experimental
        '''
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="aurora")
    @builtins.classmethod
    def aurora(cls, *, version: AuroraEngineVersion) -> "IClusterEngine":
        '''(experimental) Creates a new plain Aurora database cluster engine.

        :param version: (experimental) The version of the Aurora cluster engine.

        :stability: experimental
        '''
        props = AuroraClusterEngineProps(version=version)

        return typing.cast("IClusterEngine", jsii.sinvoke(cls, "aurora", [props]))

    @jsii.member(jsii_name="auroraMysql")
    @builtins.classmethod
    def aurora_mysql(cls, *, version: AuroraMysqlEngineVersion) -> "IClusterEngine":
        '''(experimental) Creates a new Aurora MySQL database cluster engine.

        :param version: (experimental) The version of the Aurora MySQL cluster engine.

        :stability: experimental
        '''
        props = AuroraMysqlClusterEngineProps(version=version)

        return typing.cast("IClusterEngine", jsii.sinvoke(cls, "auroraMysql", [props]))

    @jsii.member(jsii_name="auroraPostgres")
    @builtins.classmethod
    def aurora_postgres(
        cls,
        *,
        version: AuroraPostgresEngineVersion,
    ) -> "IClusterEngine":
        '''(experimental) Creates a new Aurora PostgreSQL database cluster engine.

        :param version: (experimental) The version of the Aurora PostgreSQL cluster engine.

        :stability: experimental
        '''
        props = AuroraPostgresClusterEngineProps(version=version)

        return typing.cast("IClusterEngine", jsii.sinvoke(cls, "auroraPostgres", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="AURORA")
    def AURORA(cls) -> "IClusterEngine":
        '''(experimental) The unversioned 'aurora' cluster engine.

        **Note**: we do not recommend using unversioned engines for non-serverless Clusters,
        as that can pose an availability risk.
        We recommend using versioned engines created using the {@link aurora()} method

        :stability: experimental
        '''
        return typing.cast("IClusterEngine", jsii.sget(cls, "AURORA"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="AURORA_MYSQL")
    def AURORA_MYSQL(cls) -> "IClusterEngine":
        '''(experimental) The unversioned 'aurora-msql' cluster engine.

        **Note**: we do not recommend using unversioned engines for non-serverless Clusters,
        as that can pose an availability risk.
        We recommend using versioned engines created using the {@link auroraMysql()} method

        :stability: experimental
        '''
        return typing.cast("IClusterEngine", jsii.sget(cls, "AURORA_MYSQL"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="AURORA_POSTGRESQL")
    def AURORA_POSTGRESQL(cls) -> "IClusterEngine":
        '''(experimental) The unversioned 'aurora-postgresql' cluster engine.

        **Note**: we do not recommend using unversioned engines for non-serverless Clusters,
        as that can pose an availability risk.
        We recommend using versioned engines created using the {@link auroraPostgres()} method

        :stability: experimental
        '''
        return typing.cast("IClusterEngine", jsii.sget(cls, "AURORA_POSTGRESQL"))


@jsii.data_type(
    jsii_type="monocdk.aws_rds.DatabaseClusterFromSnapshotProps",
    jsii_struct_bases=[],
    name_mapping={
        "engine": "engine",
        "instance_props": "instanceProps",
        "snapshot_identifier": "snapshotIdentifier",
        "backtrack_window": "backtrackWindow",
        "backup": "backup",
        "cloudwatch_logs_exports": "cloudwatchLogsExports",
        "cloudwatch_logs_retention": "cloudwatchLogsRetention",
        "cloudwatch_logs_retention_role": "cloudwatchLogsRetentionRole",
        "cluster_identifier": "clusterIdentifier",
        "copy_tags_to_snapshot": "copyTagsToSnapshot",
        "credentials": "credentials",
        "default_database_name": "defaultDatabaseName",
        "deletion_protection": "deletionProtection",
        "iam_authentication": "iamAuthentication",
        "instance_identifier_base": "instanceIdentifierBase",
        "instances": "instances",
        "monitoring_interval": "monitoringInterval",
        "monitoring_role": "monitoringRole",
        "parameter_group": "parameterGroup",
        "parameters": "parameters",
        "port": "port",
        "preferred_maintenance_window": "preferredMaintenanceWindow",
        "removal_policy": "removalPolicy",
        "s3_export_buckets": "s3ExportBuckets",
        "s3_export_role": "s3ExportRole",
        "s3_import_buckets": "s3ImportBuckets",
        "s3_import_role": "s3ImportRole",
        "storage_encrypted": "storageEncrypted",
        "storage_encryption_key": "storageEncryptionKey",
        "subnet_group": "subnetGroup",
    },
)
class DatabaseClusterFromSnapshotProps:
    def __init__(
        self,
        *,
        engine: "IClusterEngine",
        instance_props: typing.Union["InstanceProps", typing.Dict[builtins.str, typing.Any]],
        snapshot_identifier: builtins.str,
        backtrack_window: typing.Optional[_Duration_070aa057] = None,
        backup: typing.Optional[typing.Union[BackupProps, typing.Dict[builtins.str, typing.Any]]] = None,
        cloudwatch_logs_exports: typing.Optional[typing.Sequence[builtins.str]] = None,
        cloudwatch_logs_retention: typing.Optional[_RetentionDays_6c560d31] = None,
        cloudwatch_logs_retention_role: typing.Optional[_IRole_59af6f50] = None,
        cluster_identifier: typing.Optional[builtins.str] = None,
        copy_tags_to_snapshot: typing.Optional[builtins.bool] = None,
        credentials: typing.Optional[Credentials] = None,
        default_database_name: typing.Optional[builtins.str] = None,
        deletion_protection: typing.Optional[builtins.bool] = None,
        iam_authentication: typing.Optional[builtins.bool] = None,
        instance_identifier_base: typing.Optional[builtins.str] = None,
        instances: typing.Optional[jsii.Number] = None,
        monitoring_interval: typing.Optional[_Duration_070aa057] = None,
        monitoring_role: typing.Optional[_IRole_59af6f50] = None,
        parameter_group: typing.Optional["IParameterGroup"] = None,
        parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        port: typing.Optional[jsii.Number] = None,
        preferred_maintenance_window: typing.Optional[builtins.str] = None,
        removal_policy: typing.Optional[_RemovalPolicy_c97e7a20] = None,
        s3_export_buckets: typing.Optional[typing.Sequence[_IBucket_73486e29]] = None,
        s3_export_role: typing.Optional[_IRole_59af6f50] = None,
        s3_import_buckets: typing.Optional[typing.Sequence[_IBucket_73486e29]] = None,
        s3_import_role: typing.Optional[_IRole_59af6f50] = None,
        storage_encrypted: typing.Optional[builtins.bool] = None,
        storage_encryption_key: typing.Optional[_IKey_36930160] = None,
        subnet_group: typing.Optional["ISubnetGroup"] = None,
    ) -> None:
        '''(experimental) Properties for ``DatabaseClusterFromSnapshot``.

        :param engine: (experimental) What kind of database to start.
        :param instance_props: (experimental) Settings for the individual instances that are launched.
        :param snapshot_identifier: (experimental) The identifier for the DB instance snapshot or DB cluster snapshot to restore from. You can use either the name or the Amazon Resource Name (ARN) to specify a DB cluster snapshot. However, you can use only the ARN to specify a DB instance snapshot.
        :param backtrack_window: (experimental) The number of seconds to set a cluster's target backtrack window to. This feature is only supported by the Aurora MySQL database engine and cannot be enabled on existing clusters. Default: 0 seconds (no backtrack)
        :param backup: (experimental) Backup settings. Default: - Backup retention period for automated backups is 1 day. Backup preferred window is set to a 30-minute window selected at random from an 8-hour block of time for each AWS Region, occurring on a random day of the week.
        :param cloudwatch_logs_exports: (experimental) The list of log types that need to be enabled for exporting to CloudWatch Logs. Default: - no log exports
        :param cloudwatch_logs_retention: (experimental) The number of days log events are kept in CloudWatch Logs. When updating this property, unsetting it doesn't remove the log retention policy. To remove the retention policy, set the value to ``Infinity``. Default: - logs never expire
        :param cloudwatch_logs_retention_role: (experimental) The IAM role for the Lambda function associated with the custom resource that sets the retention policy. Default: - a new role is created.
        :param cluster_identifier: (experimental) An optional identifier for the cluster. Default: - A name is automatically generated.
        :param copy_tags_to_snapshot: (experimental) Whether to copy tags to the snapshot when a snapshot is created. Default: - true
        :param credentials: (experimental) Credentials for the administrative user. Default: - A username of 'admin' (or 'postgres' for PostgreSQL) and SecretsManager-generated password
        :param default_database_name: (experimental) Name of a database which is automatically created inside the cluster. Default: - Database is not created in cluster.
        :param deletion_protection: (experimental) Indicates whether the DB cluster should have deletion protection enabled. Default: - true if ``removalPolicy`` is RETAIN, false otherwise
        :param iam_authentication: (experimental) Whether to enable mapping of AWS Identity and Access Management (IAM) accounts to database accounts. Default: false
        :param instance_identifier_base: (experimental) Base identifier for instances. Every replica is named by appending the replica number to this string, 1-based. Default: - clusterIdentifier is used with the word "Instance" appended. If clusterIdentifier is not provided, the identifier is automatically generated.
        :param instances: (experimental) How many replicas/instances to create. Has to be at least 1. Default: 2
        :param monitoring_interval: (experimental) The interval, in seconds, between points when Amazon RDS collects enhanced monitoring metrics for the DB instances. Default: no enhanced monitoring
        :param monitoring_role: (experimental) Role that will be used to manage DB instances monitoring. Default: - A role is automatically created for you
        :param parameter_group: (experimental) Additional parameters to pass to the database engine. Default: - No parameter group.
        :param parameters: (experimental) The parameters in the DBClusterParameterGroup to create automatically. You can only specify parameterGroup or parameters but not both. You need to use a versioned engine to auto-generate a DBClusterParameterGroup. Default: - None
        :param port: (experimental) What port to listen on. Default: - The default for the engine is used.
        :param preferred_maintenance_window: (experimental) A preferred maintenance window day/time range. Should be specified as a range ddd:hh24:mi-ddd:hh24:mi (24H Clock UTC). Example: 'Sun:23:45-Mon:00:15' Default: - 30-minute window selected at random from an 8-hour block of time for each AWS Region, occurring on a random day of the week.
        :param removal_policy: (experimental) The removal policy to apply when the cluster and its instances are removed from the stack or replaced during an update. Default: - RemovalPolicy.SNAPSHOT (remove the cluster and instances, but retain a snapshot of the data)
        :param s3_export_buckets: (experimental) S3 buckets that you want to load data into. This feature is only supported by the Aurora database engine. This property must not be used if ``s3ExportRole`` is used. For MySQL: Default: - None
        :param s3_export_role: (experimental) Role that will be associated with this DB cluster to enable S3 export. This feature is only supported by the Aurora database engine. This property must not be used if ``s3ExportBuckets`` is used. For MySQL: Default: - New role is created if ``s3ExportBuckets`` is set, no role is defined otherwise
        :param s3_import_buckets: (experimental) S3 buckets that you want to load data from. This feature is only supported by the Aurora database engine. This property must not be used if ``s3ImportRole`` is used. For MySQL: Default: - None
        :param s3_import_role: (experimental) Role that will be associated with this DB cluster to enable S3 import. This feature is only supported by the Aurora database engine. This property must not be used if ``s3ImportBuckets`` is used. For MySQL: Default: - New role is created if ``s3ImportBuckets`` is set, no role is defined otherwise
        :param storage_encrypted: (experimental) Whether to enable storage encryption. Default: - true if storageEncryptionKey is provided, false otherwise
        :param storage_encryption_key: (experimental) The KMS key for storage encryption. If specified, {@link storageEncrypted} will be set to ``true``. Default: - if storageEncrypted is true then the default master key, no key otherwise
        :param subnet_group: (experimental) Existing subnet group for the cluster. Default: - a new subnet group will be created.

        :stability: experimental
        :exampleMetadata: infused

        Example::

            # vpc: ec2.Vpc
            
            rds.DatabaseClusterFromSnapshot(self, "Database",
                engine=rds.DatabaseClusterEngine.aurora(version=rds.AuroraEngineVersion.VER_1_22_2),
                instance_props=ec2.aws_rds.InstanceProps(
                    vpc=vpc
                ),
                snapshot_identifier="mySnapshot"
            )
        '''
        if isinstance(instance_props, dict):
            instance_props = InstanceProps(**instance_props)
        if isinstance(backup, dict):
            backup = BackupProps(**backup)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bc8cb6c6d22968105f85dbbe075c7927fc3c68d40f5110d1f010b7aa6fee22ee)
            check_type(argname="argument engine", value=engine, expected_type=type_hints["engine"])
            check_type(argname="argument instance_props", value=instance_props, expected_type=type_hints["instance_props"])
            check_type(argname="argument snapshot_identifier", value=snapshot_identifier, expected_type=type_hints["snapshot_identifier"])
            check_type(argname="argument backtrack_window", value=backtrack_window, expected_type=type_hints["backtrack_window"])
            check_type(argname="argument backup", value=backup, expected_type=type_hints["backup"])
            check_type(argname="argument cloudwatch_logs_exports", value=cloudwatch_logs_exports, expected_type=type_hints["cloudwatch_logs_exports"])
            check_type(argname="argument cloudwatch_logs_retention", value=cloudwatch_logs_retention, expected_type=type_hints["cloudwatch_logs_retention"])
            check_type(argname="argument cloudwatch_logs_retention_role", value=cloudwatch_logs_retention_role, expected_type=type_hints["cloudwatch_logs_retention_role"])
            check_type(argname="argument cluster_identifier", value=cluster_identifier, expected_type=type_hints["cluster_identifier"])
            check_type(argname="argument copy_tags_to_snapshot", value=copy_tags_to_snapshot, expected_type=type_hints["copy_tags_to_snapshot"])
            check_type(argname="argument credentials", value=credentials, expected_type=type_hints["credentials"])
            check_type(argname="argument default_database_name", value=default_database_name, expected_type=type_hints["default_database_name"])
            check_type(argname="argument deletion_protection", value=deletion_protection, expected_type=type_hints["deletion_protection"])
            check_type(argname="argument iam_authentication", value=iam_authentication, expected_type=type_hints["iam_authentication"])
            check_type(argname="argument instance_identifier_base", value=instance_identifier_base, expected_type=type_hints["instance_identifier_base"])
            check_type(argname="argument instances", value=instances, expected_type=type_hints["instances"])
            check_type(argname="argument monitoring_interval", value=monitoring_interval, expected_type=type_hints["monitoring_interval"])
            check_type(argname="argument monitoring_role", value=monitoring_role, expected_type=type_hints["monitoring_role"])
            check_type(argname="argument parameter_group", value=parameter_group, expected_type=type_hints["parameter_group"])
            check_type(argname="argument parameters", value=parameters, expected_type=type_hints["parameters"])
            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
            check_type(argname="argument preferred_maintenance_window", value=preferred_maintenance_window, expected_type=type_hints["preferred_maintenance_window"])
            check_type(argname="argument removal_policy", value=removal_policy, expected_type=type_hints["removal_policy"])
            check_type(argname="argument s3_export_buckets", value=s3_export_buckets, expected_type=type_hints["s3_export_buckets"])
            check_type(argname="argument s3_export_role", value=s3_export_role, expected_type=type_hints["s3_export_role"])
            check_type(argname="argument s3_import_buckets", value=s3_import_buckets, expected_type=type_hints["s3_import_buckets"])
            check_type(argname="argument s3_import_role", value=s3_import_role, expected_type=type_hints["s3_import_role"])
            check_type(argname="argument storage_encrypted", value=storage_encrypted, expected_type=type_hints["storage_encrypted"])
            check_type(argname="argument storage_encryption_key", value=storage_encryption_key, expected_type=type_hints["storage_encryption_key"])
            check_type(argname="argument subnet_group", value=subnet_group, expected_type=type_hints["subnet_group"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "engine": engine,
            "instance_props": instance_props,
            "snapshot_identifier": snapshot_identifier,
        }
        if backtrack_window is not None:
            self._values["backtrack_window"] = backtrack_window
        if backup is not None:
            self._values["backup"] = backup
        if cloudwatch_logs_exports is not None:
            self._values["cloudwatch_logs_exports"] = cloudwatch_logs_exports
        if cloudwatch_logs_retention is not None:
            self._values["cloudwatch_logs_retention"] = cloudwatch_logs_retention
        if cloudwatch_logs_retention_role is not None:
            self._values["cloudwatch_logs_retention_role"] = cloudwatch_logs_retention_role
        if cluster_identifier is not None:
            self._values["cluster_identifier"] = cluster_identifier
        if copy_tags_to_snapshot is not None:
            self._values["copy_tags_to_snapshot"] = copy_tags_to_snapshot
        if credentials is not None:
            self._values["credentials"] = credentials
        if default_database_name is not None:
            self._values["default_database_name"] = default_database_name
        if deletion_protection is not None:
            self._values["deletion_protection"] = deletion_protection
        if iam_authentication is not None:
            self._values["iam_authentication"] = iam_authentication
        if instance_identifier_base is not None:
            self._values["instance_identifier_base"] = instance_identifier_base
        if instances is not None:
            self._values["instances"] = instances
        if monitoring_interval is not None:
            self._values["monitoring_interval"] = monitoring_interval
        if monitoring_role is not None:
            self._values["monitoring_role"] = monitoring_role
        if parameter_group is not None:
            self._values["parameter_group"] = parameter_group
        if parameters is not None:
            self._values["parameters"] = parameters
        if port is not None:
            self._values["port"] = port
        if preferred_maintenance_window is not None:
            self._values["preferred_maintenance_window"] = preferred_maintenance_window
        if removal_policy is not None:
            self._values["removal_policy"] = removal_policy
        if s3_export_buckets is not None:
            self._values["s3_export_buckets"] = s3_export_buckets
        if s3_export_role is not None:
            self._values["s3_export_role"] = s3_export_role
        if s3_import_buckets is not None:
            self._values["s3_import_buckets"] = s3_import_buckets
        if s3_import_role is not None:
            self._values["s3_import_role"] = s3_import_role
        if storage_encrypted is not None:
            self._values["storage_encrypted"] = storage_encrypted
        if storage_encryption_key is not None:
            self._values["storage_encryption_key"] = storage_encryption_key
        if subnet_group is not None:
            self._values["subnet_group"] = subnet_group

    @builtins.property
    def engine(self) -> "IClusterEngine":
        '''(experimental) What kind of database to start.

        :stability: experimental
        '''
        result = self._values.get("engine")
        assert result is not None, "Required property 'engine' is missing"
        return typing.cast("IClusterEngine", result)

    @builtins.property
    def instance_props(self) -> "InstanceProps":
        '''(experimental) Settings for the individual instances that are launched.

        :stability: experimental
        '''
        result = self._values.get("instance_props")
        assert result is not None, "Required property 'instance_props' is missing"
        return typing.cast("InstanceProps", result)

    @builtins.property
    def snapshot_identifier(self) -> builtins.str:
        '''(experimental) The identifier for the DB instance snapshot or DB cluster snapshot to restore from.

        You can use either the name or the Amazon Resource Name (ARN) to specify a DB cluster snapshot.
        However, you can use only the ARN to specify a DB instance snapshot.

        :stability: experimental
        '''
        result = self._values.get("snapshot_identifier")
        assert result is not None, "Required property 'snapshot_identifier' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def backtrack_window(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) The number of seconds to set a cluster's target backtrack window to.

        This feature is only supported by the Aurora MySQL database engine and
        cannot be enabled on existing clusters.

        :default: 0 seconds (no backtrack)

        :see: https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/AuroraMySQL.Managing.Backtrack.html
        :stability: experimental
        '''
        result = self._values.get("backtrack_window")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def backup(self) -> typing.Optional[BackupProps]:
        '''(experimental) Backup settings.

        :default:

        - Backup retention period for automated backups is 1 day.
        Backup preferred window is set to a 30-minute window selected at random from an
        8-hour block of time for each AWS Region, occurring on a random day of the week.

        :see: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithAutomatedBackups.html#USER_WorkingWithAutomatedBackups.BackupWindow
        :stability: experimental
        '''
        result = self._values.get("backup")
        return typing.cast(typing.Optional[BackupProps], result)

    @builtins.property
    def cloudwatch_logs_exports(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) The list of log types that need to be enabled for exporting to CloudWatch Logs.

        :default: - no log exports

        :stability: experimental
        '''
        result = self._values.get("cloudwatch_logs_exports")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def cloudwatch_logs_retention(self) -> typing.Optional[_RetentionDays_6c560d31]:
        '''(experimental) The number of days log events are kept in CloudWatch Logs.

        When updating
        this property, unsetting it doesn't remove the log retention policy. To
        remove the retention policy, set the value to ``Infinity``.

        :default: - logs never expire

        :stability: experimental
        '''
        result = self._values.get("cloudwatch_logs_retention")
        return typing.cast(typing.Optional[_RetentionDays_6c560d31], result)

    @builtins.property
    def cloudwatch_logs_retention_role(self) -> typing.Optional[_IRole_59af6f50]:
        '''(experimental) The IAM role for the Lambda function associated with the custom resource that sets the retention policy.

        :default: - a new role is created.

        :stability: experimental
        '''
        result = self._values.get("cloudwatch_logs_retention_role")
        return typing.cast(typing.Optional[_IRole_59af6f50], result)

    @builtins.property
    def cluster_identifier(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional identifier for the cluster.

        :default: - A name is automatically generated.

        :stability: experimental
        '''
        result = self._values.get("cluster_identifier")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def copy_tags_to_snapshot(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Whether to copy tags to the snapshot when a snapshot is created.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("copy_tags_to_snapshot")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def credentials(self) -> typing.Optional[Credentials]:
        '''(experimental) Credentials for the administrative user.

        :default: - A username of 'admin' (or 'postgres' for PostgreSQL) and SecretsManager-generated password

        :stability: experimental
        '''
        result = self._values.get("credentials")
        return typing.cast(typing.Optional[Credentials], result)

    @builtins.property
    def default_database_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Name of a database which is automatically created inside the cluster.

        :default: - Database is not created in cluster.

        :stability: experimental
        '''
        result = self._values.get("default_database_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def deletion_protection(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the DB cluster should have deletion protection enabled.

        :default: - true if ``removalPolicy`` is RETAIN, false otherwise

        :stability: experimental
        '''
        result = self._values.get("deletion_protection")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def iam_authentication(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Whether to enable mapping of AWS Identity and Access Management (IAM) accounts to database accounts.

        :default: false

        :stability: experimental
        '''
        result = self._values.get("iam_authentication")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def instance_identifier_base(self) -> typing.Optional[builtins.str]:
        '''(experimental) Base identifier for instances.

        Every replica is named by appending the replica number to this string, 1-based.

        :default:

        - clusterIdentifier is used with the word "Instance" appended.
        If clusterIdentifier is not provided, the identifier is automatically generated.

        :stability: experimental
        '''
        result = self._values.get("instance_identifier_base")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def instances(self) -> typing.Optional[jsii.Number]:
        '''(experimental) How many replicas/instances to create.

        Has to be at least 1.

        :default: 2

        :stability: experimental
        '''
        result = self._values.get("instances")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def monitoring_interval(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) The interval, in seconds, between points when Amazon RDS collects enhanced monitoring metrics for the DB instances.

        :default: no enhanced monitoring

        :stability: experimental
        '''
        result = self._values.get("monitoring_interval")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def monitoring_role(self) -> typing.Optional[_IRole_59af6f50]:
        '''(experimental) Role that will be used to manage DB instances monitoring.

        :default: - A role is automatically created for you

        :stability: experimental
        '''
        result = self._values.get("monitoring_role")
        return typing.cast(typing.Optional[_IRole_59af6f50], result)

    @builtins.property
    def parameter_group(self) -> typing.Optional["IParameterGroup"]:
        '''(experimental) Additional parameters to pass to the database engine.

        :default: - No parameter group.

        :stability: experimental
        '''
        result = self._values.get("parameter_group")
        return typing.cast(typing.Optional["IParameterGroup"], result)

    @builtins.property
    def parameters(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''(experimental) The parameters in the DBClusterParameterGroup to create automatically.

        You can only specify parameterGroup or parameters but not both.
        You need to use a versioned engine to auto-generate a DBClusterParameterGroup.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("parameters")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def port(self) -> typing.Optional[jsii.Number]:
        '''(experimental) What port to listen on.

        :default: - The default for the engine is used.

        :stability: experimental
        '''
        result = self._values.get("port")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def preferred_maintenance_window(self) -> typing.Optional[builtins.str]:
        '''(experimental) A preferred maintenance window day/time range. Should be specified as a range ddd:hh24:mi-ddd:hh24:mi (24H Clock UTC).

        Example: 'Sun:23:45-Mon:00:15'

        :default:

        - 30-minute window selected at random from an 8-hour block of time for
        each AWS Region, occurring on a random day of the week.

        :see: https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_UpgradeDBInstance.Maintenance.html#Concepts.DBMaintenance
        :stability: experimental
        '''
        result = self._values.get("preferred_maintenance_window")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def removal_policy(self) -> typing.Optional[_RemovalPolicy_c97e7a20]:
        '''(experimental) The removal policy to apply when the cluster and its instances are removed from the stack or replaced during an update.

        :default: - RemovalPolicy.SNAPSHOT (remove the cluster and instances, but retain a snapshot of the data)

        :stability: experimental
        '''
        result = self._values.get("removal_policy")
        return typing.cast(typing.Optional[_RemovalPolicy_c97e7a20], result)

    @builtins.property
    def s3_export_buckets(self) -> typing.Optional[typing.List[_IBucket_73486e29]]:
        '''(experimental) S3 buckets that you want to load data into. This feature is only supported by the Aurora database engine.

        This property must not be used if ``s3ExportRole`` is used.

        For MySQL:

        :default: - None

        :see: https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/postgresql-s3-export.html
        :stability: experimental
        '''
        result = self._values.get("s3_export_buckets")
        return typing.cast(typing.Optional[typing.List[_IBucket_73486e29]], result)

    @builtins.property
    def s3_export_role(self) -> typing.Optional[_IRole_59af6f50]:
        '''(experimental) Role that will be associated with this DB cluster to enable S3 export.

        This feature is only supported by the Aurora database engine.

        This property must not be used if ``s3ExportBuckets`` is used.

        For MySQL:

        :default: - New role is created if ``s3ExportBuckets`` is set, no role is defined otherwise

        :see: https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/postgresql-s3-export.html
        :stability: experimental
        '''
        result = self._values.get("s3_export_role")
        return typing.cast(typing.Optional[_IRole_59af6f50], result)

    @builtins.property
    def s3_import_buckets(self) -> typing.Optional[typing.List[_IBucket_73486e29]]:
        '''(experimental) S3 buckets that you want to load data from. This feature is only supported by the Aurora database engine.

        This property must not be used if ``s3ImportRole`` is used.

        For MySQL:

        :default: - None

        :see: https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/AuroraPostgreSQL.Migrating.html
        :stability: experimental
        '''
        result = self._values.get("s3_import_buckets")
        return typing.cast(typing.Optional[typing.List[_IBucket_73486e29]], result)

    @builtins.property
    def s3_import_role(self) -> typing.Optional[_IRole_59af6f50]:
        '''(experimental) Role that will be associated with this DB cluster to enable S3 import.

        This feature is only supported by the Aurora database engine.

        This property must not be used if ``s3ImportBuckets`` is used.

        For MySQL:

        :default: - New role is created if ``s3ImportBuckets`` is set, no role is defined otherwise

        :see: https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/AuroraPostgreSQL.Migrating.html
        :stability: experimental
        '''
        result = self._values.get("s3_import_role")
        return typing.cast(typing.Optional[_IRole_59af6f50], result)

    @builtins.property
    def storage_encrypted(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Whether to enable storage encryption.

        :default: - true if storageEncryptionKey is provided, false otherwise

        :stability: experimental
        '''
        result = self._values.get("storage_encrypted")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def storage_encryption_key(self) -> typing.Optional[_IKey_36930160]:
        '''(experimental) The KMS key for storage encryption.

        If specified, {@link storageEncrypted} will be set to ``true``.

        :default: - if storageEncrypted is true then the default master key, no key otherwise

        :stability: experimental
        '''
        result = self._values.get("storage_encryption_key")
        return typing.cast(typing.Optional[_IKey_36930160], result)

    @builtins.property
    def subnet_group(self) -> typing.Optional["ISubnetGroup"]:
        '''(experimental) Existing subnet group for the cluster.

        :default: - a new subnet group will be created.

        :stability: experimental
        '''
        result = self._values.get("subnet_group")
        return typing.cast(typing.Optional["ISubnetGroup"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DatabaseClusterFromSnapshotProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_rds.DatabaseClusterProps",
    jsii_struct_bases=[],
    name_mapping={
        "engine": "engine",
        "instance_props": "instanceProps",
        "backtrack_window": "backtrackWindow",
        "backup": "backup",
        "cloudwatch_logs_exports": "cloudwatchLogsExports",
        "cloudwatch_logs_retention": "cloudwatchLogsRetention",
        "cloudwatch_logs_retention_role": "cloudwatchLogsRetentionRole",
        "cluster_identifier": "clusterIdentifier",
        "copy_tags_to_snapshot": "copyTagsToSnapshot",
        "credentials": "credentials",
        "default_database_name": "defaultDatabaseName",
        "deletion_protection": "deletionProtection",
        "iam_authentication": "iamAuthentication",
        "instance_identifier_base": "instanceIdentifierBase",
        "instances": "instances",
        "monitoring_interval": "monitoringInterval",
        "monitoring_role": "monitoringRole",
        "parameter_group": "parameterGroup",
        "parameters": "parameters",
        "port": "port",
        "preferred_maintenance_window": "preferredMaintenanceWindow",
        "removal_policy": "removalPolicy",
        "s3_export_buckets": "s3ExportBuckets",
        "s3_export_role": "s3ExportRole",
        "s3_import_buckets": "s3ImportBuckets",
        "s3_import_role": "s3ImportRole",
        "storage_encrypted": "storageEncrypted",
        "storage_encryption_key": "storageEncryptionKey",
        "subnet_group": "subnetGroup",
    },
)
class DatabaseClusterProps:
    def __init__(
        self,
        *,
        engine: "IClusterEngine",
        instance_props: typing.Union["InstanceProps", typing.Dict[builtins.str, typing.Any]],
        backtrack_window: typing.Optional[_Duration_070aa057] = None,
        backup: typing.Optional[typing.Union[BackupProps, typing.Dict[builtins.str, typing.Any]]] = None,
        cloudwatch_logs_exports: typing.Optional[typing.Sequence[builtins.str]] = None,
        cloudwatch_logs_retention: typing.Optional[_RetentionDays_6c560d31] = None,
        cloudwatch_logs_retention_role: typing.Optional[_IRole_59af6f50] = None,
        cluster_identifier: typing.Optional[builtins.str] = None,
        copy_tags_to_snapshot: typing.Optional[builtins.bool] = None,
        credentials: typing.Optional[Credentials] = None,
        default_database_name: typing.Optional[builtins.str] = None,
        deletion_protection: typing.Optional[builtins.bool] = None,
        iam_authentication: typing.Optional[builtins.bool] = None,
        instance_identifier_base: typing.Optional[builtins.str] = None,
        instances: typing.Optional[jsii.Number] = None,
        monitoring_interval: typing.Optional[_Duration_070aa057] = None,
        monitoring_role: typing.Optional[_IRole_59af6f50] = None,
        parameter_group: typing.Optional["IParameterGroup"] = None,
        parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        port: typing.Optional[jsii.Number] = None,
        preferred_maintenance_window: typing.Optional[builtins.str] = None,
        removal_policy: typing.Optional[_RemovalPolicy_c97e7a20] = None,
        s3_export_buckets: typing.Optional[typing.Sequence[_IBucket_73486e29]] = None,
        s3_export_role: typing.Optional[_IRole_59af6f50] = None,
        s3_import_buckets: typing.Optional[typing.Sequence[_IBucket_73486e29]] = None,
        s3_import_role: typing.Optional[_IRole_59af6f50] = None,
        storage_encrypted: typing.Optional[builtins.bool] = None,
        storage_encryption_key: typing.Optional[_IKey_36930160] = None,
        subnet_group: typing.Optional["ISubnetGroup"] = None,
    ) -> None:
        '''(experimental) Properties for a new database cluster.

        :param engine: (experimental) What kind of database to start.
        :param instance_props: (experimental) Settings for the individual instances that are launched.
        :param backtrack_window: (experimental) The number of seconds to set a cluster's target backtrack window to. This feature is only supported by the Aurora MySQL database engine and cannot be enabled on existing clusters. Default: 0 seconds (no backtrack)
        :param backup: (experimental) Backup settings. Default: - Backup retention period for automated backups is 1 day. Backup preferred window is set to a 30-minute window selected at random from an 8-hour block of time for each AWS Region, occurring on a random day of the week.
        :param cloudwatch_logs_exports: (experimental) The list of log types that need to be enabled for exporting to CloudWatch Logs. Default: - no log exports
        :param cloudwatch_logs_retention: (experimental) The number of days log events are kept in CloudWatch Logs. When updating this property, unsetting it doesn't remove the log retention policy. To remove the retention policy, set the value to ``Infinity``. Default: - logs never expire
        :param cloudwatch_logs_retention_role: (experimental) The IAM role for the Lambda function associated with the custom resource that sets the retention policy. Default: - a new role is created.
        :param cluster_identifier: (experimental) An optional identifier for the cluster. Default: - A name is automatically generated.
        :param copy_tags_to_snapshot: (experimental) Whether to copy tags to the snapshot when a snapshot is created. Default: - true
        :param credentials: (experimental) Credentials for the administrative user. Default: - A username of 'admin' (or 'postgres' for PostgreSQL) and SecretsManager-generated password
        :param default_database_name: (experimental) Name of a database which is automatically created inside the cluster. Default: - Database is not created in cluster.
        :param deletion_protection: (experimental) Indicates whether the DB cluster should have deletion protection enabled. Default: - true if ``removalPolicy`` is RETAIN, false otherwise
        :param iam_authentication: (experimental) Whether to enable mapping of AWS Identity and Access Management (IAM) accounts to database accounts. Default: false
        :param instance_identifier_base: (experimental) Base identifier for instances. Every replica is named by appending the replica number to this string, 1-based. Default: - clusterIdentifier is used with the word "Instance" appended. If clusterIdentifier is not provided, the identifier is automatically generated.
        :param instances: (experimental) How many replicas/instances to create. Has to be at least 1. Default: 2
        :param monitoring_interval: (experimental) The interval, in seconds, between points when Amazon RDS collects enhanced monitoring metrics for the DB instances. Default: no enhanced monitoring
        :param monitoring_role: (experimental) Role that will be used to manage DB instances monitoring. Default: - A role is automatically created for you
        :param parameter_group: (experimental) Additional parameters to pass to the database engine. Default: - No parameter group.
        :param parameters: (experimental) The parameters in the DBClusterParameterGroup to create automatically. You can only specify parameterGroup or parameters but not both. You need to use a versioned engine to auto-generate a DBClusterParameterGroup. Default: - None
        :param port: (experimental) What port to listen on. Default: - The default for the engine is used.
        :param preferred_maintenance_window: (experimental) A preferred maintenance window day/time range. Should be specified as a range ddd:hh24:mi-ddd:hh24:mi (24H Clock UTC). Example: 'Sun:23:45-Mon:00:15' Default: - 30-minute window selected at random from an 8-hour block of time for each AWS Region, occurring on a random day of the week.
        :param removal_policy: (experimental) The removal policy to apply when the cluster and its instances are removed from the stack or replaced during an update. Default: - RemovalPolicy.SNAPSHOT (remove the cluster and instances, but retain a snapshot of the data)
        :param s3_export_buckets: (experimental) S3 buckets that you want to load data into. This feature is only supported by the Aurora database engine. This property must not be used if ``s3ExportRole`` is used. For MySQL: Default: - None
        :param s3_export_role: (experimental) Role that will be associated with this DB cluster to enable S3 export. This feature is only supported by the Aurora database engine. This property must not be used if ``s3ExportBuckets`` is used. For MySQL: Default: - New role is created if ``s3ExportBuckets`` is set, no role is defined otherwise
        :param s3_import_buckets: (experimental) S3 buckets that you want to load data from. This feature is only supported by the Aurora database engine. This property must not be used if ``s3ImportRole`` is used. For MySQL: Default: - None
        :param s3_import_role: (experimental) Role that will be associated with this DB cluster to enable S3 import. This feature is only supported by the Aurora database engine. This property must not be used if ``s3ImportBuckets`` is used. For MySQL: Default: - New role is created if ``s3ImportBuckets`` is set, no role is defined otherwise
        :param storage_encrypted: (experimental) Whether to enable storage encryption. Default: - true if storageEncryptionKey is provided, false otherwise
        :param storage_encryption_key: (experimental) The KMS key for storage encryption. If specified, {@link storageEncrypted} will be set to ``true``. Default: - if storageEncrypted is true then the default master key, no key otherwise
        :param subnet_group: (experimental) Existing subnet group for the cluster. Default: - a new subnet group will be created.

        :stability: experimental
        :exampleMetadata: infused

        Example::

            # vpc: ec2.Vpc
            
            cluster = rds.DatabaseCluster(self, "Database",
                engine=rds.DatabaseClusterEngine.AURORA,
                instance_props=ec2.aws_rds.InstanceProps(vpc=vpc)
            )
            
            proxy = rds.DatabaseProxy(self, "Proxy",
                proxy_target=rds.ProxyTarget.from_cluster(cluster),
                secrets=[cluster.secret],
                vpc=vpc
            )
            
            role = iam.Role(self, "DBProxyRole", assumed_by=iam.AccountPrincipal(self.account))
            proxy.grant_connect(role, "admin")
        '''
        if isinstance(instance_props, dict):
            instance_props = InstanceProps(**instance_props)
        if isinstance(backup, dict):
            backup = BackupProps(**backup)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f07e3cdd76b0f7dfadadcf92b3410f8a1ac363c84a485a58d06d53aa090a81b3)
            check_type(argname="argument engine", value=engine, expected_type=type_hints["engine"])
            check_type(argname="argument instance_props", value=instance_props, expected_type=type_hints["instance_props"])
            check_type(argname="argument backtrack_window", value=backtrack_window, expected_type=type_hints["backtrack_window"])
            check_type(argname="argument backup", value=backup, expected_type=type_hints["backup"])
            check_type(argname="argument cloudwatch_logs_exports", value=cloudwatch_logs_exports, expected_type=type_hints["cloudwatch_logs_exports"])
            check_type(argname="argument cloudwatch_logs_retention", value=cloudwatch_logs_retention, expected_type=type_hints["cloudwatch_logs_retention"])
            check_type(argname="argument cloudwatch_logs_retention_role", value=cloudwatch_logs_retention_role, expected_type=type_hints["cloudwatch_logs_retention_role"])
            check_type(argname="argument cluster_identifier", value=cluster_identifier, expected_type=type_hints["cluster_identifier"])
            check_type(argname="argument copy_tags_to_snapshot", value=copy_tags_to_snapshot, expected_type=type_hints["copy_tags_to_snapshot"])
            check_type(argname="argument credentials", value=credentials, expected_type=type_hints["credentials"])
            check_type(argname="argument default_database_name", value=default_database_name, expected_type=type_hints["default_database_name"])
            check_type(argname="argument deletion_protection", value=deletion_protection, expected_type=type_hints["deletion_protection"])
            check_type(argname="argument iam_authentication", value=iam_authentication, expected_type=type_hints["iam_authentication"])
            check_type(argname="argument instance_identifier_base", value=instance_identifier_base, expected_type=type_hints["instance_identifier_base"])
            check_type(argname="argument instances", value=instances, expected_type=type_hints["instances"])
            check_type(argname="argument monitoring_interval", value=monitoring_interval, expected_type=type_hints["monitoring_interval"])
            check_type(argname="argument monitoring_role", value=monitoring_role, expected_type=type_hints["monitoring_role"])
            check_type(argname="argument parameter_group", value=parameter_group, expected_type=type_hints["parameter_group"])
            check_type(argname="argument parameters", value=parameters, expected_type=type_hints["parameters"])
            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
            check_type(argname="argument preferred_maintenance_window", value=preferred_maintenance_window, expected_type=type_hints["preferred_maintenance_window"])
            check_type(argname="argument removal_policy", value=removal_policy, expected_type=type_hints["removal_policy"])
            check_type(argname="argument s3_export_buckets", value=s3_export_buckets, expected_type=type_hints["s3_export_buckets"])
            check_type(argname="argument s3_export_role", value=s3_export_role, expected_type=type_hints["s3_export_role"])
            check_type(argname="argument s3_import_buckets", value=s3_import_buckets, expected_type=type_hints["s3_import_buckets"])
            check_type(argname="argument s3_import_role", value=s3_import_role, expected_type=type_hints["s3_import_role"])
            check_type(argname="argument storage_encrypted", value=storage_encrypted, expected_type=type_hints["storage_encrypted"])
            check_type(argname="argument storage_encryption_key", value=storage_encryption_key, expected_type=type_hints["storage_encryption_key"])
            check_type(argname="argument subnet_group", value=subnet_group, expected_type=type_hints["subnet_group"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "engine": engine,
            "instance_props": instance_props,
        }
        if backtrack_window is not None:
            self._values["backtrack_window"] = backtrack_window
        if backup is not None:
            self._values["backup"] = backup
        if cloudwatch_logs_exports is not None:
            self._values["cloudwatch_logs_exports"] = cloudwatch_logs_exports
        if cloudwatch_logs_retention is not None:
            self._values["cloudwatch_logs_retention"] = cloudwatch_logs_retention
        if cloudwatch_logs_retention_role is not None:
            self._values["cloudwatch_logs_retention_role"] = cloudwatch_logs_retention_role
        if cluster_identifier is not None:
            self._values["cluster_identifier"] = cluster_identifier
        if copy_tags_to_snapshot is not None:
            self._values["copy_tags_to_snapshot"] = copy_tags_to_snapshot
        if credentials is not None:
            self._values["credentials"] = credentials
        if default_database_name is not None:
            self._values["default_database_name"] = default_database_name
        if deletion_protection is not None:
            self._values["deletion_protection"] = deletion_protection
        if iam_authentication is not None:
            self._values["iam_authentication"] = iam_authentication
        if instance_identifier_base is not None:
            self._values["instance_identifier_base"] = instance_identifier_base
        if instances is not None:
            self._values["instances"] = instances
        if monitoring_interval is not None:
            self._values["monitoring_interval"] = monitoring_interval
        if monitoring_role is not None:
            self._values["monitoring_role"] = monitoring_role
        if parameter_group is not None:
            self._values["parameter_group"] = parameter_group
        if parameters is not None:
            self._values["parameters"] = parameters
        if port is not None:
            self._values["port"] = port
        if preferred_maintenance_window is not None:
            self._values["preferred_maintenance_window"] = preferred_maintenance_window
        if removal_policy is not None:
            self._values["removal_policy"] = removal_policy
        if s3_export_buckets is not None:
            self._values["s3_export_buckets"] = s3_export_buckets
        if s3_export_role is not None:
            self._values["s3_export_role"] = s3_export_role
        if s3_import_buckets is not None:
            self._values["s3_import_buckets"] = s3_import_buckets
        if s3_import_role is not None:
            self._values["s3_import_role"] = s3_import_role
        if storage_encrypted is not None:
            self._values["storage_encrypted"] = storage_encrypted
        if storage_encryption_key is not None:
            self._values["storage_encryption_key"] = storage_encryption_key
        if subnet_group is not None:
            self._values["subnet_group"] = subnet_group

    @builtins.property
    def engine(self) -> "IClusterEngine":
        '''(experimental) What kind of database to start.

        :stability: experimental
        '''
        result = self._values.get("engine")
        assert result is not None, "Required property 'engine' is missing"
        return typing.cast("IClusterEngine", result)

    @builtins.property
    def instance_props(self) -> "InstanceProps":
        '''(experimental) Settings for the individual instances that are launched.

        :stability: experimental
        '''
        result = self._values.get("instance_props")
        assert result is not None, "Required property 'instance_props' is missing"
        return typing.cast("InstanceProps", result)

    @builtins.property
    def backtrack_window(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) The number of seconds to set a cluster's target backtrack window to.

        This feature is only supported by the Aurora MySQL database engine and
        cannot be enabled on existing clusters.

        :default: 0 seconds (no backtrack)

        :see: https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/AuroraMySQL.Managing.Backtrack.html
        :stability: experimental
        '''
        result = self._values.get("backtrack_window")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def backup(self) -> typing.Optional[BackupProps]:
        '''(experimental) Backup settings.

        :default:

        - Backup retention period for automated backups is 1 day.
        Backup preferred window is set to a 30-minute window selected at random from an
        8-hour block of time for each AWS Region, occurring on a random day of the week.

        :see: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithAutomatedBackups.html#USER_WorkingWithAutomatedBackups.BackupWindow
        :stability: experimental
        '''
        result = self._values.get("backup")
        return typing.cast(typing.Optional[BackupProps], result)

    @builtins.property
    def cloudwatch_logs_exports(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) The list of log types that need to be enabled for exporting to CloudWatch Logs.

        :default: - no log exports

        :stability: experimental
        '''
        result = self._values.get("cloudwatch_logs_exports")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def cloudwatch_logs_retention(self) -> typing.Optional[_RetentionDays_6c560d31]:
        '''(experimental) The number of days log events are kept in CloudWatch Logs.

        When updating
        this property, unsetting it doesn't remove the log retention policy. To
        remove the retention policy, set the value to ``Infinity``.

        :default: - logs never expire

        :stability: experimental
        '''
        result = self._values.get("cloudwatch_logs_retention")
        return typing.cast(typing.Optional[_RetentionDays_6c560d31], result)

    @builtins.property
    def cloudwatch_logs_retention_role(self) -> typing.Optional[_IRole_59af6f50]:
        '''(experimental) The IAM role for the Lambda function associated with the custom resource that sets the retention policy.

        :default: - a new role is created.

        :stability: experimental
        '''
        result = self._values.get("cloudwatch_logs_retention_role")
        return typing.cast(typing.Optional[_IRole_59af6f50], result)

    @builtins.property
    def cluster_identifier(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional identifier for the cluster.

        :default: - A name is automatically generated.

        :stability: experimental
        '''
        result = self._values.get("cluster_identifier")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def copy_tags_to_snapshot(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Whether to copy tags to the snapshot when a snapshot is created.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("copy_tags_to_snapshot")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def credentials(self) -> typing.Optional[Credentials]:
        '''(experimental) Credentials for the administrative user.

        :default: - A username of 'admin' (or 'postgres' for PostgreSQL) and SecretsManager-generated password

        :stability: experimental
        '''
        result = self._values.get("credentials")
        return typing.cast(typing.Optional[Credentials], result)

    @builtins.property
    def default_database_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Name of a database which is automatically created inside the cluster.

        :default: - Database is not created in cluster.

        :stability: experimental
        '''
        result = self._values.get("default_database_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def deletion_protection(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the DB cluster should have deletion protection enabled.

        :default: - true if ``removalPolicy`` is RETAIN, false otherwise

        :stability: experimental
        '''
        result = self._values.get("deletion_protection")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def iam_authentication(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Whether to enable mapping of AWS Identity and Access Management (IAM) accounts to database accounts.

        :default: false

        :stability: experimental
        '''
        result = self._values.get("iam_authentication")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def instance_identifier_base(self) -> typing.Optional[builtins.str]:
        '''(experimental) Base identifier for instances.

        Every replica is named by appending the replica number to this string, 1-based.

        :default:

        - clusterIdentifier is used with the word "Instance" appended.
        If clusterIdentifier is not provided, the identifier is automatically generated.

        :stability: experimental
        '''
        result = self._values.get("instance_identifier_base")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def instances(self) -> typing.Optional[jsii.Number]:
        '''(experimental) How many replicas/instances to create.

        Has to be at least 1.

        :default: 2

        :stability: experimental
        '''
        result = self._values.get("instances")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def monitoring_interval(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) The interval, in seconds, between points when Amazon RDS collects enhanced monitoring metrics for the DB instances.

        :default: no enhanced monitoring

        :stability: experimental
        '''
        result = self._values.get("monitoring_interval")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def monitoring_role(self) -> typing.Optional[_IRole_59af6f50]:
        '''(experimental) Role that will be used to manage DB instances monitoring.

        :default: - A role is automatically created for you

        :stability: experimental
        '''
        result = self._values.get("monitoring_role")
        return typing.cast(typing.Optional[_IRole_59af6f50], result)

    @builtins.property
    def parameter_group(self) -> typing.Optional["IParameterGroup"]:
        '''(experimental) Additional parameters to pass to the database engine.

        :default: - No parameter group.

        :stability: experimental
        '''
        result = self._values.get("parameter_group")
        return typing.cast(typing.Optional["IParameterGroup"], result)

    @builtins.property
    def parameters(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''(experimental) The parameters in the DBClusterParameterGroup to create automatically.

        You can only specify parameterGroup or parameters but not both.
        You need to use a versioned engine to auto-generate a DBClusterParameterGroup.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("parameters")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def port(self) -> typing.Optional[jsii.Number]:
        '''(experimental) What port to listen on.

        :default: - The default for the engine is used.

        :stability: experimental
        '''
        result = self._values.get("port")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def preferred_maintenance_window(self) -> typing.Optional[builtins.str]:
        '''(experimental) A preferred maintenance window day/time range. Should be specified as a range ddd:hh24:mi-ddd:hh24:mi (24H Clock UTC).

        Example: 'Sun:23:45-Mon:00:15'

        :default:

        - 30-minute window selected at random from an 8-hour block of time for
        each AWS Region, occurring on a random day of the week.

        :see: https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_UpgradeDBInstance.Maintenance.html#Concepts.DBMaintenance
        :stability: experimental
        '''
        result = self._values.get("preferred_maintenance_window")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def removal_policy(self) -> typing.Optional[_RemovalPolicy_c97e7a20]:
        '''(experimental) The removal policy to apply when the cluster and its instances are removed from the stack or replaced during an update.

        :default: - RemovalPolicy.SNAPSHOT (remove the cluster and instances, but retain a snapshot of the data)

        :stability: experimental
        '''
        result = self._values.get("removal_policy")
        return typing.cast(typing.Optional[_RemovalPolicy_c97e7a20], result)

    @builtins.property
    def s3_export_buckets(self) -> typing.Optional[typing.List[_IBucket_73486e29]]:
        '''(experimental) S3 buckets that you want to load data into. This feature is only supported by the Aurora database engine.

        This property must not be used if ``s3ExportRole`` is used.

        For MySQL:

        :default: - None

        :see: https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/postgresql-s3-export.html
        :stability: experimental
        '''
        result = self._values.get("s3_export_buckets")
        return typing.cast(typing.Optional[typing.List[_IBucket_73486e29]], result)

    @builtins.property
    def s3_export_role(self) -> typing.Optional[_IRole_59af6f50]:
        '''(experimental) Role that will be associated with this DB cluster to enable S3 export.

        This feature is only supported by the Aurora database engine.

        This property must not be used if ``s3ExportBuckets`` is used.

        For MySQL:

        :default: - New role is created if ``s3ExportBuckets`` is set, no role is defined otherwise

        :see: https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/postgresql-s3-export.html
        :stability: experimental
        '''
        result = self._values.get("s3_export_role")
        return typing.cast(typing.Optional[_IRole_59af6f50], result)

    @builtins.property
    def s3_import_buckets(self) -> typing.Optional[typing.List[_IBucket_73486e29]]:
        '''(experimental) S3 buckets that you want to load data from. This feature is only supported by the Aurora database engine.

        This property must not be used if ``s3ImportRole`` is used.

        For MySQL:

        :default: - None

        :see: https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/AuroraPostgreSQL.Migrating.html
        :stability: experimental
        '''
        result = self._values.get("s3_import_buckets")
        return typing.cast(typing.Optional[typing.List[_IBucket_73486e29]], result)

    @builtins.property
    def s3_import_role(self) -> typing.Optional[_IRole_59af6f50]:
        '''(experimental) Role that will be associated with this DB cluster to enable S3 import.

        This feature is only supported by the Aurora database engine.

        This property must not be used if ``s3ImportBuckets`` is used.

        For MySQL:

        :default: - New role is created if ``s3ImportBuckets`` is set, no role is defined otherwise

        :see: https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/AuroraPostgreSQL.Migrating.html
        :stability: experimental
        '''
        result = self._values.get("s3_import_role")
        return typing.cast(typing.Optional[_IRole_59af6f50], result)

    @builtins.property
    def storage_encrypted(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Whether to enable storage encryption.

        :default: - true if storageEncryptionKey is provided, false otherwise

        :stability: experimental
        '''
        result = self._values.get("storage_encrypted")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def storage_encryption_key(self) -> typing.Optional[_IKey_36930160]:
        '''(experimental) The KMS key for storage encryption.

        If specified, {@link storageEncrypted} will be set to ``true``.

        :default: - if storageEncrypted is true then the default master key, no key otherwise

        :stability: experimental
        '''
        result = self._values.get("storage_encryption_key")
        return typing.cast(typing.Optional[_IKey_36930160], result)

    @builtins.property
    def subnet_group(self) -> typing.Optional["ISubnetGroup"]:
        '''(experimental) Existing subnet group for the cluster.

        :default: - a new subnet group will be created.

        :stability: experimental
        '''
        result = self._values.get("subnet_group")
        return typing.cast(typing.Optional["ISubnetGroup"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DatabaseClusterProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_rds.DatabaseInstanceAttributes",
    jsii_struct_bases=[],
    name_mapping={
        "instance_endpoint_address": "instanceEndpointAddress",
        "instance_identifier": "instanceIdentifier",
        "port": "port",
        "security_groups": "securityGroups",
        "engine": "engine",
    },
)
class DatabaseInstanceAttributes:
    def __init__(
        self,
        *,
        instance_endpoint_address: builtins.str,
        instance_identifier: builtins.str,
        port: jsii.Number,
        security_groups: typing.Sequence[_ISecurityGroup_cdbba9d3],
        engine: typing.Optional["IInstanceEngine"] = None,
    ) -> None:
        '''(experimental) Properties that describe an existing instance.

        :param instance_endpoint_address: (experimental) The endpoint address.
        :param instance_identifier: (experimental) The instance identifier.
        :param port: (experimental) The database port.
        :param security_groups: (experimental) The security groups of the instance.
        :param engine: (experimental) The engine of the existing database Instance. Default: - the imported Instance's engine is unknown

        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_ec2 as ec2
            from monocdk import aws_rds as rds
            
            # instance_engine: rds.IInstanceEngine
            # security_group: ec2.SecurityGroup
            
            database_instance_attributes = rds.DatabaseInstanceAttributes(
                instance_endpoint_address="instanceEndpointAddress",
                instance_identifier="instanceIdentifier",
                port=123,
                security_groups=[security_group],
            
                # the properties below are optional
                engine=instance_engine
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ae7f96b20cfd66bed5a8eaa1761f0cffed70aa44fae44e7e2a60e78a1fa9d990)
            check_type(argname="argument instance_endpoint_address", value=instance_endpoint_address, expected_type=type_hints["instance_endpoint_address"])
            check_type(argname="argument instance_identifier", value=instance_identifier, expected_type=type_hints["instance_identifier"])
            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
            check_type(argname="argument security_groups", value=security_groups, expected_type=type_hints["security_groups"])
            check_type(argname="argument engine", value=engine, expected_type=type_hints["engine"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "instance_endpoint_address": instance_endpoint_address,
            "instance_identifier": instance_identifier,
            "port": port,
            "security_groups": security_groups,
        }
        if engine is not None:
            self._values["engine"] = engine

    @builtins.property
    def instance_endpoint_address(self) -> builtins.str:
        '''(experimental) The endpoint address.

        :stability: experimental
        '''
        result = self._values.get("instance_endpoint_address")
        assert result is not None, "Required property 'instance_endpoint_address' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def instance_identifier(self) -> builtins.str:
        '''(experimental) The instance identifier.

        :stability: experimental
        '''
        result = self._values.get("instance_identifier")
        assert result is not None, "Required property 'instance_identifier' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def port(self) -> jsii.Number:
        '''(experimental) The database port.

        :stability: experimental
        '''
        result = self._values.get("port")
        assert result is not None, "Required property 'port' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def security_groups(self) -> typing.List[_ISecurityGroup_cdbba9d3]:
        '''(experimental) The security groups of the instance.

        :stability: experimental
        '''
        result = self._values.get("security_groups")
        assert result is not None, "Required property 'security_groups' is missing"
        return typing.cast(typing.List[_ISecurityGroup_cdbba9d3], result)

    @builtins.property
    def engine(self) -> typing.Optional["IInstanceEngine"]:
        '''(experimental) The engine of the existing database Instance.

        :default: - the imported Instance's engine is unknown

        :stability: experimental
        '''
        result = self._values.get("engine")
        return typing.cast(typing.Optional["IInstanceEngine"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DatabaseInstanceAttributes(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DatabaseInstanceEngine(
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_rds.DatabaseInstanceEngine",
):
    '''(experimental) A database instance engine.

    Provides mapping to DatabaseEngine used for
    secret rotation.

    :stability: experimental
    :exampleMetadata: infused

    Example::

        # vpc: ec2.Vpc
        
        # source_instance: rds.DatabaseInstance
        
        rds.DatabaseInstanceFromSnapshot(self, "Instance",
            snapshot_identifier="my-snapshot",
            engine=rds.DatabaseInstanceEngine.postgres(version=rds.PostgresEngineVersion.VER_12_3),
            # optional, defaults to m5.large
            instance_type=ec2.InstanceType.of(ec2.InstanceClass.BURSTABLE2, ec2.InstanceSize.LARGE),
            vpc=vpc
        )
        rds.DatabaseInstanceReadReplica(self, "ReadReplica",
            source_database_instance=source_instance,
            instance_type=ec2.InstanceType.of(ec2.InstanceClass.BURSTABLE2, ec2.InstanceSize.LARGE),
            vpc=vpc
        )
    '''

    def __init__(self) -> None:
        '''
        :stability: experimental
        '''
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="mariaDb")
    @builtins.classmethod
    def maria_db(cls, *, version: "MariaDbEngineVersion") -> "IInstanceEngine":
        '''(experimental) Creates a new MariaDB instance engine.

        :param version: (experimental) The exact version of the engine to use.

        :stability: experimental
        '''
        props = MariaDbInstanceEngineProps(version=version)

        return typing.cast("IInstanceEngine", jsii.sinvoke(cls, "mariaDb", [props]))

    @jsii.member(jsii_name="mysql")
    @builtins.classmethod
    def mysql(cls, *, version: "MysqlEngineVersion") -> "IInstanceEngine":
        '''(experimental) Creates a new MySQL instance engine.

        :param version: (experimental) The exact version of the engine to use.

        :stability: experimental
        '''
        props = MySqlInstanceEngineProps(version=version)

        return typing.cast("IInstanceEngine", jsii.sinvoke(cls, "mysql", [props]))

    @jsii.member(jsii_name="oracleEe")
    @builtins.classmethod
    def oracle_ee(cls, *, version: "OracleEngineVersion") -> "IInstanceEngine":
        '''(experimental) Creates a new Oracle Enterprise Edition instance engine.

        :param version: (experimental) The exact version of the engine to use.

        :stability: experimental
        '''
        props = OracleEeInstanceEngineProps(version=version)

        return typing.cast("IInstanceEngine", jsii.sinvoke(cls, "oracleEe", [props]))

    @jsii.member(jsii_name="oracleSe")
    @builtins.classmethod
    def oracle_se(cls, *, version: "OracleLegacyEngineVersion") -> "IInstanceEngine":
        '''(deprecated) Creates a new Oracle Standard Edition instance engine.

        :param version: (deprecated) The exact version of the engine to use.

        :deprecated: instances can no longer be created with this engine. See https://forums.aws.amazon.com/ann.jspa?annID=7341

        :stability: deprecated
        '''
        props = OracleSeInstanceEngineProps(version=version)

        return typing.cast("IInstanceEngine", jsii.sinvoke(cls, "oracleSe", [props]))

    @jsii.member(jsii_name="oracleSe1")
    @builtins.classmethod
    def oracle_se1(cls, *, version: "OracleLegacyEngineVersion") -> "IInstanceEngine":
        '''(deprecated) Creates a new Oracle Standard Edition 1 instance engine.

        :param version: (deprecated) The exact version of the engine to use.

        :deprecated: instances can no longer be created with this engine. See https://forums.aws.amazon.com/ann.jspa?annID=7341

        :stability: deprecated
        '''
        props = OracleSe1InstanceEngineProps(version=version)

        return typing.cast("IInstanceEngine", jsii.sinvoke(cls, "oracleSe1", [props]))

    @jsii.member(jsii_name="oracleSe2")
    @builtins.classmethod
    def oracle_se2(cls, *, version: "OracleEngineVersion") -> "IInstanceEngine":
        '''(experimental) Creates a new Oracle Standard Edition 1 instance engine.

        :param version: (experimental) The exact version of the engine to use.

        :stability: experimental
        '''
        props = OracleSe2InstanceEngineProps(version=version)

        return typing.cast("IInstanceEngine", jsii.sinvoke(cls, "oracleSe2", [props]))

    @jsii.member(jsii_name="postgres")
    @builtins.classmethod
    def postgres(cls, *, version: "PostgresEngineVersion") -> "IInstanceEngine":
        '''(experimental) Creates a new PostgreSQL instance engine.

        :param version: (experimental) The exact version of the engine to use.

        :stability: experimental
        '''
        props = PostgresInstanceEngineProps(version=version)

        return typing.cast("IInstanceEngine", jsii.sinvoke(cls, "postgres", [props]))

    @jsii.member(jsii_name="sqlServerEe")
    @builtins.classmethod
    def sql_server_ee(cls, *, version: "SqlServerEngineVersion") -> "IInstanceEngine":
        '''(experimental) Creates a new SQL Server Enterprise Edition instance engine.

        :param version: (experimental) The exact version of the engine to use.

        :stability: experimental
        '''
        props = SqlServerEeInstanceEngineProps(version=version)

        return typing.cast("IInstanceEngine", jsii.sinvoke(cls, "sqlServerEe", [props]))

    @jsii.member(jsii_name="sqlServerEx")
    @builtins.classmethod
    def sql_server_ex(cls, *, version: "SqlServerEngineVersion") -> "IInstanceEngine":
        '''(experimental) Creates a new SQL Server Express Edition instance engine.

        :param version: (experimental) The exact version of the engine to use.

        :stability: experimental
        '''
        props = SqlServerExInstanceEngineProps(version=version)

        return typing.cast("IInstanceEngine", jsii.sinvoke(cls, "sqlServerEx", [props]))

    @jsii.member(jsii_name="sqlServerSe")
    @builtins.classmethod
    def sql_server_se(cls, *, version: "SqlServerEngineVersion") -> "IInstanceEngine":
        '''(experimental) Creates a new SQL Server Standard Edition instance engine.

        :param version: (experimental) The exact version of the engine to use.

        :stability: experimental
        '''
        props = SqlServerSeInstanceEngineProps(version=version)

        return typing.cast("IInstanceEngine", jsii.sinvoke(cls, "sqlServerSe", [props]))

    @jsii.member(jsii_name="sqlServerWeb")
    @builtins.classmethod
    def sql_server_web(cls, *, version: "SqlServerEngineVersion") -> "IInstanceEngine":
        '''(experimental) Creates a new SQL Server Web Edition instance engine.

        :param version: (experimental) The exact version of the engine to use.

        :stability: experimental
        '''
        props = SqlServerWebInstanceEngineProps(version=version)

        return typing.cast("IInstanceEngine", jsii.sinvoke(cls, "sqlServerWeb", [props]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="MARIADB")
    def MARIADB(cls) -> "IInstanceEngine":
        '''(experimental) The unversioned 'mariadb' instance engine.

        NOTE: using unversioned engines is an availability risk.
        We recommend using versioned engines created using the {@link mariaDb()} method

        :stability: experimental
        '''
        return typing.cast("IInstanceEngine", jsii.sget(cls, "MARIADB"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="MYSQL")
    def MYSQL(cls) -> "IInstanceEngine":
        '''(experimental) The unversioned 'mysql' instance engine.

        NOTE: using unversioned engines is an availability risk.
        We recommend using versioned engines created using the {@link mysql()} method

        :stability: experimental
        '''
        return typing.cast("IInstanceEngine", jsii.sget(cls, "MYSQL"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ORACLE_EE")
    def ORACLE_EE(cls) -> "IInstanceEngine":
        '''(experimental) The unversioned 'oracle-ee' instance engine.

        NOTE: using unversioned engines is an availability risk.
        We recommend using versioned engines created using the {@link oracleEe()} method

        :stability: experimental
        '''
        return typing.cast("IInstanceEngine", jsii.sget(cls, "ORACLE_EE"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ORACLE_SE")
    def ORACLE_SE(cls) -> "IInstanceEngine":
        '''(deprecated) The unversioned 'oracle-se' instance engine.

        :deprecated: instances can no longer be created with this engine. See https://forums.aws.amazon.com/ann.jspa?annID=7341

        :stability: deprecated
        '''
        return typing.cast("IInstanceEngine", jsii.sget(cls, "ORACLE_SE"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ORACLE_SE1")
    def ORACLE_SE1(cls) -> "IInstanceEngine":
        '''(deprecated) The unversioned 'oracle-se1' instance engine.

        :deprecated: instances can no longer be created with this engine. See https://forums.aws.amazon.com/ann.jspa?annID=7341

        :stability: deprecated
        '''
        return typing.cast("IInstanceEngine", jsii.sget(cls, "ORACLE_SE1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ORACLE_SE2")
    def ORACLE_SE2(cls) -> "IInstanceEngine":
        '''(experimental) The unversioned 'oracle-se2' instance engine.

        NOTE: using unversioned engines is an availability risk.
        We recommend using versioned engines created using the {@link oracleSe2()} method

        :stability: experimental
        '''
        return typing.cast("IInstanceEngine", jsii.sget(cls, "ORACLE_SE2"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="POSTGRES")
    def POSTGRES(cls) -> "IInstanceEngine":
        '''(experimental) The unversioned 'postgres' instance engine.

        NOTE: using unversioned engines is an availability risk.
        We recommend using versioned engines created using the {@link postgres()} method

        :stability: experimental
        '''
        return typing.cast("IInstanceEngine", jsii.sget(cls, "POSTGRES"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="SQL_SERVER_EE")
    def SQL_SERVER_EE(cls) -> "IInstanceEngine":
        '''(experimental) The unversioned 'sqlserver-ee' instance engine.

        NOTE: using unversioned engines is an availability risk.
        We recommend using versioned engines created using the {@link sqlServerEe()} method

        :stability: experimental
        '''
        return typing.cast("IInstanceEngine", jsii.sget(cls, "SQL_SERVER_EE"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="SQL_SERVER_EX")
    def SQL_SERVER_EX(cls) -> "IInstanceEngine":
        '''(experimental) The unversioned 'sqlserver-ex' instance engine.

        NOTE: using unversioned engines is an availability risk.
        We recommend using versioned engines created using the {@link sqlServerEx()} method

        :stability: experimental
        '''
        return typing.cast("IInstanceEngine", jsii.sget(cls, "SQL_SERVER_EX"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="SQL_SERVER_SE")
    def SQL_SERVER_SE(cls) -> "IInstanceEngine":
        '''(experimental) The unversioned 'sqlserver-se' instance engine.

        NOTE: using unversioned engines is an availability risk.
        We recommend using versioned engines created using the {@link sqlServerSe()} method

        :stability: experimental
        '''
        return typing.cast("IInstanceEngine", jsii.sget(cls, "SQL_SERVER_SE"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="SQL_SERVER_WEB")
    def SQL_SERVER_WEB(cls) -> "IInstanceEngine":
        '''(experimental) The unversioned 'sqlserver-web' instance engine.

        NOTE: using unversioned engines is an availability risk.
        We recommend using versioned engines created using the {@link sqlServerWeb()} method

        :stability: experimental
        '''
        return typing.cast("IInstanceEngine", jsii.sget(cls, "SQL_SERVER_WEB"))


@jsii.data_type(
    jsii_type="monocdk.aws_rds.DatabaseInstanceNewProps",
    jsii_struct_bases=[],
    name_mapping={
        "vpc": "vpc",
        "auto_minor_version_upgrade": "autoMinorVersionUpgrade",
        "availability_zone": "availabilityZone",
        "backup_retention": "backupRetention",
        "cloudwatch_logs_exports": "cloudwatchLogsExports",
        "cloudwatch_logs_retention": "cloudwatchLogsRetention",
        "cloudwatch_logs_retention_role": "cloudwatchLogsRetentionRole",
        "copy_tags_to_snapshot": "copyTagsToSnapshot",
        "delete_automated_backups": "deleteAutomatedBackups",
        "deletion_protection": "deletionProtection",
        "domain": "domain",
        "domain_role": "domainRole",
        "enable_performance_insights": "enablePerformanceInsights",
        "iam_authentication": "iamAuthentication",
        "instance_identifier": "instanceIdentifier",
        "iops": "iops",
        "max_allocated_storage": "maxAllocatedStorage",
        "monitoring_interval": "monitoringInterval",
        "monitoring_role": "monitoringRole",
        "multi_az": "multiAz",
        "option_group": "optionGroup",
        "parameter_group": "parameterGroup",
        "performance_insight_encryption_key": "performanceInsightEncryptionKey",
        "performance_insight_retention": "performanceInsightRetention",
        "port": "port",
        "preferred_backup_window": "preferredBackupWindow",
        "preferred_maintenance_window": "preferredMaintenanceWindow",
        "processor_features": "processorFeatures",
        "publicly_accessible": "publiclyAccessible",
        "removal_policy": "removalPolicy",
        "s3_export_buckets": "s3ExportBuckets",
        "s3_export_role": "s3ExportRole",
        "s3_import_buckets": "s3ImportBuckets",
        "s3_import_role": "s3ImportRole",
        "security_groups": "securityGroups",
        "storage_type": "storageType",
        "subnet_group": "subnetGroup",
        "vpc_placement": "vpcPlacement",
        "vpc_subnets": "vpcSubnets",
    },
)
class DatabaseInstanceNewProps:
    def __init__(
        self,
        *,
        vpc: _IVpc_6d1f76c4,
        auto_minor_version_upgrade: typing.Optional[builtins.bool] = None,
        availability_zone: typing.Optional[builtins.str] = None,
        backup_retention: typing.Optional[_Duration_070aa057] = None,
        cloudwatch_logs_exports: typing.Optional[typing.Sequence[builtins.str]] = None,
        cloudwatch_logs_retention: typing.Optional[_RetentionDays_6c560d31] = None,
        cloudwatch_logs_retention_role: typing.Optional[_IRole_59af6f50] = None,
        copy_tags_to_snapshot: typing.Optional[builtins.bool] = None,
        delete_automated_backups: typing.Optional[builtins.bool] = None,
        deletion_protection: typing.Optional[builtins.bool] = None,
        domain: typing.Optional[builtins.str] = None,
        domain_role: typing.Optional[_IRole_59af6f50] = None,
        enable_performance_insights: typing.Optional[builtins.bool] = None,
        iam_authentication: typing.Optional[builtins.bool] = None,
        instance_identifier: typing.Optional[builtins.str] = None,
        iops: typing.Optional[jsii.Number] = None,
        max_allocated_storage: typing.Optional[jsii.Number] = None,
        monitoring_interval: typing.Optional[_Duration_070aa057] = None,
        monitoring_role: typing.Optional[_IRole_59af6f50] = None,
        multi_az: typing.Optional[builtins.bool] = None,
        option_group: typing.Optional["IOptionGroup"] = None,
        parameter_group: typing.Optional["IParameterGroup"] = None,
        performance_insight_encryption_key: typing.Optional[_IKey_36930160] = None,
        performance_insight_retention: typing.Optional["PerformanceInsightRetention"] = None,
        port: typing.Optional[jsii.Number] = None,
        preferred_backup_window: typing.Optional[builtins.str] = None,
        preferred_maintenance_window: typing.Optional[builtins.str] = None,
        processor_features: typing.Optional[typing.Union["ProcessorFeatures", typing.Dict[builtins.str, typing.Any]]] = None,
        publicly_accessible: typing.Optional[builtins.bool] = None,
        removal_policy: typing.Optional[_RemovalPolicy_c97e7a20] = None,
        s3_export_buckets: typing.Optional[typing.Sequence[_IBucket_73486e29]] = None,
        s3_export_role: typing.Optional[_IRole_59af6f50] = None,
        s3_import_buckets: typing.Optional[typing.Sequence[_IBucket_73486e29]] = None,
        s3_import_role: typing.Optional[_IRole_59af6f50] = None,
        security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
        storage_type: typing.Optional["StorageType"] = None,
        subnet_group: typing.Optional["ISubnetGroup"] = None,
        vpc_placement: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
        vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''(experimental) Construction properties for a DatabaseInstanceNew.

        :param vpc: (experimental) The VPC network where the DB subnet group should be created.
        :param auto_minor_version_upgrade: (experimental) Indicates that minor engine upgrades are applied automatically to the DB instance during the maintenance window. Default: true
        :param availability_zone: (experimental) The name of the Availability Zone where the DB instance will be located. Default: - no preference
        :param backup_retention: (experimental) The number of days during which automatic DB snapshots are retained. Set to zero to disable backups. When creating a read replica, you must enable automatic backups on the source database instance by setting the backup retention to a value other than zero. Default: - Duration.days(1) for source instances, disabled for read replicas
        :param cloudwatch_logs_exports: (experimental) The list of log types that need to be enabled for exporting to CloudWatch Logs. Default: - no log exports
        :param cloudwatch_logs_retention: (experimental) The number of days log events are kept in CloudWatch Logs. When updating this property, unsetting it doesn't remove the log retention policy. To remove the retention policy, set the value to ``Infinity``. Default: - logs never expire
        :param cloudwatch_logs_retention_role: (experimental) The IAM role for the Lambda function associated with the custom resource that sets the retention policy. Default: - a new role is created.
        :param copy_tags_to_snapshot: (experimental) Indicates whether to copy all of the user-defined tags from the DB instance to snapshots of the DB instance. Default: true
        :param delete_automated_backups: (experimental) Indicates whether automated backups should be deleted or retained when you delete a DB instance. Default: false
        :param deletion_protection: (experimental) Indicates whether the DB instance should have deletion protection enabled. Default: - true if ``removalPolicy`` is RETAIN, false otherwise
        :param domain: (experimental) The Active Directory directory ID to create the DB instance in. Default: - Do not join domain
        :param domain_role: (experimental) The IAM role to be used when making API calls to the Directory Service. The role needs the AWS-managed policy AmazonRDSDirectoryServiceAccess or equivalent. Default: - The role will be created for you if {@link DatabaseInstanceNewProps#domain} is specified
        :param enable_performance_insights: (experimental) Whether to enable Performance Insights for the DB instance. Default: - false, unless ``performanceInsightRentention`` or ``performanceInsightEncryptionKey`` is set.
        :param iam_authentication: (experimental) Whether to enable mapping of AWS Identity and Access Management (IAM) accounts to database accounts. Default: false
        :param instance_identifier: (experimental) A name for the DB instance. If you specify a name, AWS CloudFormation converts it to lowercase. Default: - a CloudFormation generated name
        :param iops: (experimental) The number of I/O operations per second (IOPS) that the database provisions. The value must be equal to or greater than 1000. Default: - no provisioned iops
        :param max_allocated_storage: (experimental) Upper limit to which RDS can scale the storage in GiB(Gibibyte). Default: - No autoscaling of RDS instance
        :param monitoring_interval: (experimental) The interval, in seconds, between points when Amazon RDS collects enhanced monitoring metrics for the DB instance. Default: - no enhanced monitoring
        :param monitoring_role: (experimental) Role that will be used to manage DB instance monitoring. Default: - A role is automatically created for you
        :param multi_az: (experimental) Specifies if the database instance is a multiple Availability Zone deployment. Default: false
        :param option_group: (experimental) The option group to associate with the instance. Default: - no option group
        :param parameter_group: (experimental) The DB parameter group to associate with the instance. Default: - no parameter group
        :param performance_insight_encryption_key: (experimental) The AWS KMS key for encryption of Performance Insights data. Default: - default master key
        :param performance_insight_retention: (experimental) The amount of time, in days, to retain Performance Insights data. Default: 7
        :param port: (experimental) The port for the instance. Default: - the default port for the chosen engine.
        :param preferred_backup_window: (experimental) The daily time range during which automated backups are performed. Constraints: - Must be in the format ``hh24:mi-hh24:mi``. - Must be in Universal Coordinated Time (UTC). - Must not conflict with the preferred maintenance window. - Must be at least 30 minutes. Default: - a 30-minute window selected at random from an 8-hour block of time for each AWS Region. To see the time blocks available, see https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithAutomatedBackups.html#USER_WorkingWithAutomatedBackups.BackupWindow
        :param preferred_maintenance_window: (experimental) The weekly time range (in UTC) during which system maintenance can occur. Format: ``ddd:hh24:mi-ddd:hh24:mi`` Constraint: Minimum 30-minute window Default: - a 30-minute window selected at random from an 8-hour block of time for each AWS Region, occurring on a random day of the week. To see the time blocks available, see https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_UpgradeDBInstance.Maintenance.html#Concepts.DBMaintenance
        :param processor_features: (experimental) The number of CPU cores and the number of threads per core. Default: - the default number of CPU cores and threads per core for the chosen instance class. See https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html#USER_ConfigureProcessor
        :param publicly_accessible: (experimental) Indicates whether the DB instance is an internet-facing instance. Default: - ``true`` if ``vpcSubnets`` is ``subnetType: SubnetType.PUBLIC``, ``false`` otherwise
        :param removal_policy: (experimental) The CloudFormation policy to apply when the instance is removed from the stack or replaced during an update. Default: - RemovalPolicy.SNAPSHOT (remove the resource, but retain a snapshot of the data)
        :param s3_export_buckets: (experimental) S3 buckets that you want to load data into. This property must not be used if ``s3ExportRole`` is used. For Microsoft SQL Server: Default: - None
        :param s3_export_role: (experimental) Role that will be associated with this DB instance to enable S3 export. This property must not be used if ``s3ExportBuckets`` is used. For Microsoft SQL Server: Default: - New role is created if ``s3ExportBuckets`` is set, no role is defined otherwise
        :param s3_import_buckets: (experimental) S3 buckets that you want to load data from. This feature is only supported by the Microsoft SQL Server, Oracle, and PostgreSQL engines. This property must not be used if ``s3ImportRole`` is used. For Microsoft SQL Server: Default: - None
        :param s3_import_role: (experimental) Role that will be associated with this DB instance to enable S3 import. This feature is only supported by the Microsoft SQL Server, Oracle, and PostgreSQL engines. This property must not be used if ``s3ImportBuckets`` is used. For Microsoft SQL Server: Default: - New role is created if ``s3ImportBuckets`` is set, no role is defined otherwise
        :param security_groups: (experimental) The security groups to assign to the DB instance. Default: - a new security group is created
        :param storage_type: (experimental) The storage type. Storage types supported are gp2, io1, standard. Default: GP2
        :param subnet_group: (experimental) Existing subnet group for the instance. Default: - a new subnet group will be created.
        :param vpc_placement: (deprecated) The type of subnets to add to the created DB subnet group. Default: - private subnets
        :param vpc_subnets: (experimental) The type of subnets to add to the created DB subnet group. Default: - private subnets

        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            import monocdk as monocdk
            from monocdk import aws_ec2 as ec2
            from monocdk import aws_iam as iam
            from monocdk import aws_kms as kms
            from monocdk import aws_logs as logs
            from monocdk import aws_rds as rds
            from monocdk import aws_s3 as s3
            
            # bucket: s3.Bucket
            # duration: monocdk.Duration
            # key: kms.Key
            # option_group: rds.OptionGroup
            # parameter_group: rds.ParameterGroup
            # role: iam.Role
            # security_group: ec2.SecurityGroup
            # subnet: ec2.Subnet
            # subnet_filter: ec2.SubnetFilter
            # subnet_group: rds.SubnetGroup
            # vpc: ec2.Vpc
            
            database_instance_new_props = rds.DatabaseInstanceNewProps(
                vpc=vpc,
            
                # the properties below are optional
                auto_minor_version_upgrade=False,
                availability_zone="availabilityZone",
                backup_retention=duration,
                cloudwatch_logs_exports=["cloudwatchLogsExports"],
                cloudwatch_logs_retention=logs.RetentionDays.ONE_DAY,
                cloudwatch_logs_retention_role=role,
                copy_tags_to_snapshot=False,
                delete_automated_backups=False,
                deletion_protection=False,
                domain="domain",
                domain_role=role,
                enable_performance_insights=False,
                iam_authentication=False,
                instance_identifier="instanceIdentifier",
                iops=123,
                max_allocated_storage=123,
                monitoring_interval=duration,
                monitoring_role=role,
                multi_az=False,
                option_group=option_group,
                parameter_group=parameter_group,
                performance_insight_encryption_key=key,
                performance_insight_retention=rds.PerformanceInsightRetention.DEFAULT,
                port=123,
                preferred_backup_window="preferredBackupWindow",
                preferred_maintenance_window="preferredMaintenanceWindow",
                processor_features=rds.ProcessorFeatures(
                    core_count=123,
                    threads_per_core=123
                ),
                publicly_accessible=False,
                removal_policy=monocdk.RemovalPolicy.DESTROY,
                s3_export_buckets=[bucket],
                s3_export_role=role,
                s3_import_buckets=[bucket],
                s3_import_role=role,
                security_groups=[security_group],
                storage_type=rds.StorageType.STANDARD,
                subnet_group=subnet_group,
                vpc_placement=ec2.SubnetSelection(
                    availability_zones=["availabilityZones"],
                    one_per_az=False,
                    subnet_filters=[subnet_filter],
                    subnet_group_name="subnetGroupName",
                    subnet_name="subnetName",
                    subnets=[subnet],
                    subnet_type=ec2.SubnetType.ISOLATED
                ),
                vpc_subnets=ec2.SubnetSelection(
                    availability_zones=["availabilityZones"],
                    one_per_az=False,
                    subnet_filters=[subnet_filter],
                    subnet_group_name="subnetGroupName",
                    subnet_name="subnetName",
                    subnets=[subnet],
                    subnet_type=ec2.SubnetType.ISOLATED
                )
            )
        '''
        if isinstance(processor_features, dict):
            processor_features = ProcessorFeatures(**processor_features)
        if isinstance(vpc_placement, dict):
            vpc_placement = _SubnetSelection_1284e62c(**vpc_placement)
        if isinstance(vpc_subnets, dict):
            vpc_subnets = _SubnetSelection_1284e62c(**vpc_subnets)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__559e2e018326d446df6e743bdf88debcde44bd9fe897c5ca76b2494aa57811bc)
            check_type(argname="argument vpc", value=vpc, expected_type=type_hints["vpc"])
            check_type(argname="argument auto_minor_version_upgrade", value=auto_minor_version_upgrade, expected_type=type_hints["auto_minor_version_upgrade"])
            check_type(argname="argument availability_zone", value=availability_zone, expected_type=type_hints["availability_zone"])
            check_type(argname="argument backup_retention", value=backup_retention, expected_type=type_hints["backup_retention"])
            check_type(argname="argument cloudwatch_logs_exports", value=cloudwatch_logs_exports, expected_type=type_hints["cloudwatch_logs_exports"])
            check_type(argname="argument cloudwatch_logs_retention", value=cloudwatch_logs_retention, expected_type=type_hints["cloudwatch_logs_retention"])
            check_type(argname="argument cloudwatch_logs_retention_role", value=cloudwatch_logs_retention_role, expected_type=type_hints["cloudwatch_logs_retention_role"])
            check_type(argname="argument copy_tags_to_snapshot", value=copy_tags_to_snapshot, expected_type=type_hints["copy_tags_to_snapshot"])
            check_type(argname="argument delete_automated_backups", value=delete_automated_backups, expected_type=type_hints["delete_automated_backups"])
            check_type(argname="argument deletion_protection", value=deletion_protection, expected_type=type_hints["deletion_protection"])
            check_type(argname="argument domain", value=domain, expected_type=type_hints["domain"])
            check_type(argname="argument domain_role", value=domain_role, expected_type=type_hints["domain_role"])
            check_type(argname="argument enable_performance_insights", value=enable_performance_insights, expected_type=type_hints["enable_performance_insights"])
            check_type(argname="argument iam_authentication", value=iam_authentication, expected_type=type_hints["iam_authentication"])
            check_type(argname="argument instance_identifier", value=instance_identifier, expected_type=type_hints["instance_identifier"])
            check_type(argname="argument iops", value=iops, expected_type=type_hints["iops"])
            check_type(argname="argument max_allocated_storage", value=max_allocated_storage, expected_type=type_hints["max_allocated_storage"])
            check_type(argname="argument monitoring_interval", value=monitoring_interval, expected_type=type_hints["monitoring_interval"])
            check_type(argname="argument monitoring_role", value=monitoring_role, expected_type=type_hints["monitoring_role"])
            check_type(argname="argument multi_az", value=multi_az, expected_type=type_hints["multi_az"])
            check_type(argname="argument option_group", value=option_group, expected_type=type_hints["option_group"])
            check_type(argname="argument parameter_group", value=parameter_group, expected_type=type_hints["parameter_group"])
            check_type(argname="argument performance_insight_encryption_key", value=performance_insight_encryption_key, expected_type=type_hints["performance_insight_encryption_key"])
            check_type(argname="argument performance_insight_retention", value=performance_insight_retention, expected_type=type_hints["performance_insight_retention"])
            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
            check_type(argname="argument preferred_backup_window", value=preferred_backup_window, expected_type=type_hints["preferred_backup_window"])
            check_type(argname="argument preferred_maintenance_window", value=preferred_maintenance_window, expected_type=type_hints["preferred_maintenance_window"])
            check_type(argname="argument processor_features", value=processor_features, expected_type=type_hints["processor_features"])
            check_type(argname="argument publicly_accessible", value=publicly_accessible, expected_type=type_hints["publicly_accessible"])
            check_type(argname="argument removal_policy", value=removal_policy, expected_type=type_hints["removal_policy"])
            check_type(argname="argument s3_export_buckets", value=s3_export_buckets, expected_type=type_hints["s3_export_buckets"])
            check_type(argname="argument s3_export_role", value=s3_export_role, expected_type=type_hints["s3_export_role"])
            check_type(argname="argument s3_import_buckets", value=s3_import_buckets, expected_type=type_hints["s3_import_buckets"])
            check_type(argname="argument s3_import_role", value=s3_import_role, expected_type=type_hints["s3_import_role"])
            check_type(argname="argument security_groups", value=security_groups, expected_type=type_hints["security_groups"])
            check_type(argname="argument storage_type", value=storage_type, expected_type=type_hints["storage_type"])
            check_type(argname="argument subnet_group", value=subnet_group, expected_type=type_hints["subnet_group"])
            check_type(argname="argument vpc_placement", value=vpc_placement, expected_type=type_hints["vpc_placement"])
            check_type(argname="argument vpc_subnets", value=vpc_subnets, expected_type=type_hints["vpc_subnets"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "vpc": vpc,
        }
        if auto_minor_version_upgrade is not None:
            self._values["auto_minor_version_upgrade"] = auto_minor_version_upgrade
        if availability_zone is not None:
            self._values["availability_zone"] = availability_zone
        if backup_retention is not None:
            self._values["backup_retention"] = backup_retention
        if cloudwatch_logs_exports is not None:
            self._values["cloudwatch_logs_exports"] = cloudwatch_logs_exports
        if cloudwatch_logs_retention is not None:
            self._values["cloudwatch_logs_retention"] = cloudwatch_logs_retention
        if cloudwatch_logs_retention_role is not None:
            self._values["cloudwatch_logs_retention_role"] = cloudwatch_logs_retention_role
        if copy_tags_to_snapshot is not None:
            self._values["copy_tags_to_snapshot"] = copy_tags_to_snapshot
        if delete_automated_backups is not None:
            self._values["delete_automated_backups"] = delete_automated_backups
        if deletion_protection is not None:
            self._values["deletion_protection"] = deletion_protection
        if domain is not None:
            self._values["domain"] = domain
        if domain_role is not None:
            self._values["domain_role"] = domain_role
        if enable_performance_insights is not None:
            self._values["enable_performance_insights"] = enable_performance_insights
        if iam_authentication is not None:
            self._values["iam_authentication"] = iam_authentication
        if instance_identifier is not None:
            self._values["instance_identifier"] = instance_identifier
        if iops is not None:
            self._values["iops"] = iops
        if max_allocated_storage is not None:
            self._values["max_allocated_storage"] = max_allocated_storage
        if monitoring_interval is not None:
            self._values["monitoring_interval"] = monitoring_interval
        if monitoring_role is not None:
            self._values["monitoring_role"] = monitoring_role
        if multi_az is not None:
            self._values["multi_az"] = multi_az
        if option_group is not None:
            self._values["option_group"] = option_group
        if parameter_group is not None:
            self._values["parameter_group"] = parameter_group
        if performance_insight_encryption_key is not None:
            self._values["performance_insight_encryption_key"] = performance_insight_encryption_key
        if performance_insight_retention is not None:
            self._values["performance_insight_retention"] = performance_insight_retention
        if port is not None:
            self._values["port"] = port
        if preferred_backup_window is not None:
            self._values["preferred_backup_window"] = preferred_backup_window
        if preferred_maintenance_window is not None:
            self._values["preferred_maintenance_window"] = preferred_maintenance_window
        if processor_features is not None:
            self._values["processor_features"] = processor_features
        if publicly_accessible is not None:
            self._values["publicly_accessible"] = publicly_accessible
        if removal_policy is not None:
            self._values["removal_policy"] = removal_policy
        if s3_export_buckets is not None:
            self._values["s3_export_buckets"] = s3_export_buckets
        if s3_export_role is not None:
            self._values["s3_export_role"] = s3_export_role
        if s3_import_buckets is not None:
            self._values["s3_import_buckets"] = s3_import_buckets
        if s3_import_role is not None:
            self._values["s3_import_role"] = s3_import_role
        if security_groups is not None:
            self._values["security_groups"] = security_groups
        if storage_type is not None:
            self._values["storage_type"] = storage_type
        if subnet_group is not None:
            self._values["subnet_group"] = subnet_group
        if vpc_placement is not None:
            self._values["vpc_placement"] = vpc_placement
        if vpc_subnets is not None:
            self._values["vpc_subnets"] = vpc_subnets

    @builtins.property
    def vpc(self) -> _IVpc_6d1f76c4:
        '''(experimental) The VPC network where the DB subnet group should be created.

        :stability: experimental
        '''
        result = self._values.get("vpc")
        assert result is not None, "Required property 'vpc' is missing"
        return typing.cast(_IVpc_6d1f76c4, result)

    @builtins.property
    def auto_minor_version_upgrade(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates that minor engine upgrades are applied automatically to the DB instance during the maintenance window.

        :default: true

        :stability: experimental
        '''
        result = self._values.get("auto_minor_version_upgrade")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def availability_zone(self) -> typing.Optional[builtins.str]:
        '''(experimental) The name of the Availability Zone where the DB instance will be located.

        :default: - no preference

        :stability: experimental
        '''
        result = self._values.get("availability_zone")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def backup_retention(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) The number of days during which automatic DB snapshots are retained.

        Set to zero to disable backups.
        When creating a read replica, you must enable automatic backups on the source
        database instance by setting the backup retention to a value other than zero.

        :default: - Duration.days(1) for source instances, disabled for read replicas

        :stability: experimental
        '''
        result = self._values.get("backup_retention")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def cloudwatch_logs_exports(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) The list of log types that need to be enabled for exporting to CloudWatch Logs.

        :default: - no log exports

        :stability: experimental
        '''
        result = self._values.get("cloudwatch_logs_exports")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def cloudwatch_logs_retention(self) -> typing.Optional[_RetentionDays_6c560d31]:
        '''(experimental) The number of days log events are kept in CloudWatch Logs.

        When updating
        this property, unsetting it doesn't remove the log retention policy. To
        remove the retention policy, set the value to ``Infinity``.

        :default: - logs never expire

        :stability: experimental
        '''
        result = self._values.get("cloudwatch_logs_retention")
        return typing.cast(typing.Optional[_RetentionDays_6c560d31], result)

    @builtins.property
    def cloudwatch_logs_retention_role(self) -> typing.Optional[_IRole_59af6f50]:
        '''(experimental) The IAM role for the Lambda function associated with the custom resource that sets the retention policy.

        :default: - a new role is created.

        :stability: experimental
        '''
        result = self._values.get("cloudwatch_logs_retention_role")
        return typing.cast(typing.Optional[_IRole_59af6f50], result)

    @builtins.property
    def copy_tags_to_snapshot(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether to copy all of the user-defined tags from the DB instance to snapshots of the DB instance.

        :default: true

        :stability: experimental
        '''
        result = self._values.get("copy_tags_to_snapshot")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def delete_automated_backups(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether automated backups should be deleted or retained when you delete a DB instance.

        :default: false

        :stability: experimental
        '''
        result = self._values.get("delete_automated_backups")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def deletion_protection(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the DB instance should have deletion protection enabled.

        :default: - true if ``removalPolicy`` is RETAIN, false otherwise

        :stability: experimental
        '''
        result = self._values.get("deletion_protection")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def domain(self) -> typing.Optional[builtins.str]:
        '''(experimental) The Active Directory directory ID to create the DB instance in.

        :default: - Do not join domain

        :stability: experimental
        '''
        result = self._values.get("domain")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def domain_role(self) -> typing.Optional[_IRole_59af6f50]:
        '''(experimental) The IAM role to be used when making API calls to the Directory Service.

        The role needs the AWS-managed policy
        AmazonRDSDirectoryServiceAccess or equivalent.

        :default: - The role will be created for you if {@link DatabaseInstanceNewProps#domain} is specified

        :stability: experimental
        '''
        result = self._values.get("domain_role")
        return typing.cast(typing.Optional[_IRole_59af6f50], result)

    @builtins.property
    def enable_performance_insights(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Whether to enable Performance Insights for the DB instance.

        :default: - false, unless ``performanceInsightRentention`` or ``performanceInsightEncryptionKey`` is set.

        :stability: experimental
        '''
        result = self._values.get("enable_performance_insights")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def iam_authentication(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Whether to enable mapping of AWS Identity and Access Management (IAM) accounts to database accounts.

        :default: false

        :stability: experimental
        '''
        result = self._values.get("iam_authentication")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def instance_identifier(self) -> typing.Optional[builtins.str]:
        '''(experimental) A name for the DB instance.

        If you specify a name, AWS CloudFormation
        converts it to lowercase.

        :default: - a CloudFormation generated name

        :stability: experimental
        '''
        result = self._values.get("instance_identifier")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def iops(self) -> typing.Optional[jsii.Number]:
        '''(experimental) The number of I/O operations per second (IOPS) that the database provisions.

        The value must be equal to or greater than 1000.

        :default: - no provisioned iops

        :stability: experimental
        '''
        result = self._values.get("iops")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def max_allocated_storage(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Upper limit to which RDS can scale the storage in GiB(Gibibyte).

        :default: - No autoscaling of RDS instance

        :see: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PIOPS.StorageTypes.html#USER_PIOPS.Autoscaling
        :stability: experimental
        '''
        result = self._values.get("max_allocated_storage")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def monitoring_interval(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) The interval, in seconds, between points when Amazon RDS collects enhanced monitoring metrics for the DB instance.

        :default: - no enhanced monitoring

        :stability: experimental
        '''
        result = self._values.get("monitoring_interval")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def monitoring_role(self) -> typing.Optional[_IRole_59af6f50]:
        '''(experimental) Role that will be used to manage DB instance monitoring.

        :default: - A role is automatically created for you

        :stability: experimental
        '''
        result = self._values.get("monitoring_role")
        return typing.cast(typing.Optional[_IRole_59af6f50], result)

    @builtins.property
    def multi_az(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Specifies if the database instance is a multiple Availability Zone deployment.

        :default: false

        :stability: experimental
        '''
        result = self._values.get("multi_az")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def option_group(self) -> typing.Optional["IOptionGroup"]:
        '''(experimental) The option group to associate with the instance.

        :default: - no option group

        :stability: experimental
        '''
        result = self._values.get("option_group")
        return typing.cast(typing.Optional["IOptionGroup"], result)

    @builtins.property
    def parameter_group(self) -> typing.Optional["IParameterGroup"]:
        '''(experimental) The DB parameter group to associate with the instance.

        :default: - no parameter group

        :stability: experimental
        '''
        result = self._values.get("parameter_group")
        return typing.cast(typing.Optional["IParameterGroup"], result)

    @builtins.property
    def performance_insight_encryption_key(self) -> typing.Optional[_IKey_36930160]:
        '''(experimental) The AWS KMS key for encryption of Performance Insights data.

        :default: - default master key

        :stability: experimental
        '''
        result = self._values.get("performance_insight_encryption_key")
        return typing.cast(typing.Optional[_IKey_36930160], result)

    @builtins.property
    def performance_insight_retention(
        self,
    ) -> typing.Optional["PerformanceInsightRetention"]:
        '''(experimental) The amount of time, in days, to retain Performance Insights data.

        :default: 7

        :stability: experimental
        '''
        result = self._values.get("performance_insight_retention")
        return typing.cast(typing.Optional["PerformanceInsightRetention"], result)

    @builtins.property
    def port(self) -> typing.Optional[jsii.Number]:
        '''(experimental) The port for the instance.

        :default: - the default port for the chosen engine.

        :stability: experimental
        '''
        result = self._values.get("port")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def preferred_backup_window(self) -> typing.Optional[builtins.str]:
        '''(experimental) The daily time range during which automated backups are performed.

        Constraints:

        - Must be in the format ``hh24:mi-hh24:mi``.
        - Must be in Universal Coordinated Time (UTC).
        - Must not conflict with the preferred maintenance window.
        - Must be at least 30 minutes.

        :default:

        - a 30-minute window selected at random from an 8-hour block of
        time for each AWS Region. To see the time blocks available, see
        https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithAutomatedBackups.html#USER_WorkingWithAutomatedBackups.BackupWindow

        :stability: experimental
        '''
        result = self._values.get("preferred_backup_window")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def preferred_maintenance_window(self) -> typing.Optional[builtins.str]:
        '''(experimental) The weekly time range (in UTC) during which system maintenance can occur.

        Format: ``ddd:hh24:mi-ddd:hh24:mi``
        Constraint: Minimum 30-minute window

        :default:

        - a 30-minute window selected at random from an 8-hour block of
        time for each AWS Region, occurring on a random day of the week. To see
        the time blocks available, see https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_UpgradeDBInstance.Maintenance.html#Concepts.DBMaintenance

        :stability: experimental
        '''
        result = self._values.get("preferred_maintenance_window")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def processor_features(self) -> typing.Optional["ProcessorFeatures"]:
        '''(experimental) The number of CPU cores and the number of threads per core.

        :default:

        - the default number of CPU cores and threads per core for the
        chosen instance class.

        See https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html#USER_ConfigureProcessor

        :stability: experimental
        '''
        result = self._values.get("processor_features")
        return typing.cast(typing.Optional["ProcessorFeatures"], result)

    @builtins.property
    def publicly_accessible(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the DB instance is an internet-facing instance.

        :default: - ``true`` if ``vpcSubnets`` is ``subnetType: SubnetType.PUBLIC``, ``false`` otherwise

        :stability: experimental
        '''
        result = self._values.get("publicly_accessible")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def removal_policy(self) -> typing.Optional[_RemovalPolicy_c97e7a20]:
        '''(experimental) The CloudFormation policy to apply when the instance is removed from the stack or replaced during an update.

        :default: - RemovalPolicy.SNAPSHOT (remove the resource, but retain a snapshot of the data)

        :stability: experimental
        '''
        result = self._values.get("removal_policy")
        return typing.cast(typing.Optional[_RemovalPolicy_c97e7a20], result)

    @builtins.property
    def s3_export_buckets(self) -> typing.Optional[typing.List[_IBucket_73486e29]]:
        '''(experimental) S3 buckets that you want to load data into.

        This property must not be used if ``s3ExportRole`` is used.

        For Microsoft SQL Server:

        :default: - None

        :see: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/oracle-s3-integration.html
        :stability: experimental
        '''
        result = self._values.get("s3_export_buckets")
        return typing.cast(typing.Optional[typing.List[_IBucket_73486e29]], result)

    @builtins.property
    def s3_export_role(self) -> typing.Optional[_IRole_59af6f50]:
        '''(experimental) Role that will be associated with this DB instance to enable S3 export.

        This property must not be used if ``s3ExportBuckets`` is used.

        For Microsoft SQL Server:

        :default: - New role is created if ``s3ExportBuckets`` is set, no role is defined otherwise

        :see: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/oracle-s3-integration.html
        :stability: experimental
        '''
        result = self._values.get("s3_export_role")
        return typing.cast(typing.Optional[_IRole_59af6f50], result)

    @builtins.property
    def s3_import_buckets(self) -> typing.Optional[typing.List[_IBucket_73486e29]]:
        '''(experimental) S3 buckets that you want to load data from.

        This feature is only supported by the Microsoft SQL Server, Oracle, and PostgreSQL engines.

        This property must not be used if ``s3ImportRole`` is used.

        For Microsoft SQL Server:

        :default: - None

        :see: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/PostgreSQL.Procedural.Importing.html
        :stability: experimental
        '''
        result = self._values.get("s3_import_buckets")
        return typing.cast(typing.Optional[typing.List[_IBucket_73486e29]], result)

    @builtins.property
    def s3_import_role(self) -> typing.Optional[_IRole_59af6f50]:
        '''(experimental) Role that will be associated with this DB instance to enable S3 import.

        This feature is only supported by the Microsoft SQL Server, Oracle, and PostgreSQL engines.

        This property must not be used if ``s3ImportBuckets`` is used.

        For Microsoft SQL Server:

        :default: - New role is created if ``s3ImportBuckets`` is set, no role is defined otherwise

        :see: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/PostgreSQL.Procedural.Importing.html
        :stability: experimental
        '''
        result = self._values.get("s3_import_role")
        return typing.cast(typing.Optional[_IRole_59af6f50], result)

    @builtins.property
    def security_groups(self) -> typing.Optional[typing.List[_ISecurityGroup_cdbba9d3]]:
        '''(experimental) The security groups to assign to the DB instance.

        :default: - a new security group is created

        :stability: experimental
        '''
        result = self._values.get("security_groups")
        return typing.cast(typing.Optional[typing.List[_ISecurityGroup_cdbba9d3]], result)

    @builtins.property
    def storage_type(self) -> typing.Optional["StorageType"]:
        '''(experimental) The storage type.

        Storage types supported are gp2, io1, standard.

        :default: GP2

        :see: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Storage.html#Concepts.Storage.GeneralSSD
        :stability: experimental
        '''
        result = self._values.get("storage_type")
        return typing.cast(typing.Optional["StorageType"], result)

    @builtins.property
    def subnet_group(self) -> typing.Optional["ISubnetGroup"]:
        '''(experimental) Existing subnet group for the instance.

        :default: - a new subnet group will be created.

        :stability: experimental
        '''
        result = self._values.get("subnet_group")
        return typing.cast(typing.Optional["ISubnetGroup"], result)

    @builtins.property
    def vpc_placement(self) -> typing.Optional[_SubnetSelection_1284e62c]:
        '''(deprecated) The type of subnets to add to the created DB subnet group.

        :default: - private subnets

        :deprecated: use ``vpcSubnets``

        :stability: deprecated
        '''
        result = self._values.get("vpc_placement")
        return typing.cast(typing.Optional[_SubnetSelection_1284e62c], result)

    @builtins.property
    def vpc_subnets(self) -> typing.Optional[_SubnetSelection_1284e62c]:
        '''(experimental) The type of subnets to add to the created DB subnet group.

        :default: - private subnets

        :stability: experimental
        '''
        result = self._values.get("vpc_subnets")
        return typing.cast(typing.Optional[_SubnetSelection_1284e62c], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DatabaseInstanceNewProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_rds.DatabaseInstanceReadReplicaProps",
    jsii_struct_bases=[DatabaseInstanceNewProps],
    name_mapping={
        "vpc": "vpc",
        "auto_minor_version_upgrade": "autoMinorVersionUpgrade",
        "availability_zone": "availabilityZone",
        "backup_retention": "backupRetention",
        "cloudwatch_logs_exports": "cloudwatchLogsExports",
        "cloudwatch_logs_retention": "cloudwatchLogsRetention",
        "cloudwatch_logs_retention_role": "cloudwatchLogsRetentionRole",
        "copy_tags_to_snapshot": "copyTagsToSnapshot",
        "delete_automated_backups": "deleteAutomatedBackups",
        "deletion_protection": "deletionProtection",
        "domain": "domain",
        "domain_role": "domainRole",
        "enable_performance_insights": "enablePerformanceInsights",
        "iam_authentication": "iamAuthentication",
        "instance_identifier": "instanceIdentifier",
        "iops": "iops",
        "max_allocated_storage": "maxAllocatedStorage",
        "monitoring_interval": "monitoringInterval",
        "monitoring_role": "monitoringRole",
        "multi_az": "multiAz",
        "option_group": "optionGroup",
        "parameter_group": "parameterGroup",
        "performance_insight_encryption_key": "performanceInsightEncryptionKey",
        "performance_insight_retention": "performanceInsightRetention",
        "port": "port",
        "preferred_backup_window": "preferredBackupWindow",
        "preferred_maintenance_window": "preferredMaintenanceWindow",
        "processor_features": "processorFeatures",
        "publicly_accessible": "publiclyAccessible",
        "removal_policy": "removalPolicy",
        "s3_export_buckets": "s3ExportBuckets",
        "s3_export_role": "s3ExportRole",
        "s3_import_buckets": "s3ImportBuckets",
        "s3_import_role": "s3ImportRole",
        "security_groups": "securityGroups",
        "storage_type": "storageType",
        "subnet_group": "subnetGroup",
        "vpc_placement": "vpcPlacement",
        "vpc_subnets": "vpcSubnets",
        "instance_type": "instanceType",
        "source_database_instance": "sourceDatabaseInstance",
        "storage_encrypted": "storageEncrypted",
        "storage_encryption_key": "storageEncryptionKey",
    },
)
class DatabaseInstanceReadReplicaProps(DatabaseInstanceNewProps):
    def __init__(
        self,
        *,
        vpc: _IVpc_6d1f76c4,
        auto_minor_version_upgrade: typing.Optional[builtins.bool] = None,
        availability_zone: typing.Optional[builtins.str] = None,
        backup_retention: typing.Optional[_Duration_070aa057] = None,
        cloudwatch_logs_exports: typing.Optional[typing.Sequence[builtins.str]] = None,
        cloudwatch_logs_retention: typing.Optional[_RetentionDays_6c560d31] = None,
        cloudwatch_logs_retention_role: typing.Optional[_IRole_59af6f50] = None,
        copy_tags_to_snapshot: typing.Optional[builtins.bool] = None,
        delete_automated_backups: typing.Optional[builtins.bool] = None,
        deletion_protection: typing.Optional[builtins.bool] = None,
        domain: typing.Optional[builtins.str] = None,
        domain_role: typing.Optional[_IRole_59af6f50] = None,
        enable_performance_insights: typing.Optional[builtins.bool] = None,
        iam_authentication: typing.Optional[builtins.bool] = None,
        instance_identifier: typing.Optional[builtins.str] = None,
        iops: typing.Optional[jsii.Number] = None,
        max_allocated_storage: typing.Optional[jsii.Number] = None,
        monitoring_interval: typing.Optional[_Duration_070aa057] = None,
        monitoring_role: typing.Optional[_IRole_59af6f50] = None,
        multi_az: typing.Optional[builtins.bool] = None,
        option_group: typing.Optional["IOptionGroup"] = None,
        parameter_group: typing.Optional["IParameterGroup"] = None,
        performance_insight_encryption_key: typing.Optional[_IKey_36930160] = None,
        performance_insight_retention: typing.Optional["PerformanceInsightRetention"] = None,
        port: typing.Optional[jsii.Number] = None,
        preferred_backup_window: typing.Optional[builtins.str] = None,
        preferred_maintenance_window: typing.Optional[builtins.str] = None,
        processor_features: typing.Optional[typing.Union["ProcessorFeatures", typing.Dict[builtins.str, typing.Any]]] = None,
        publicly_accessible: typing.Optional[builtins.bool] = None,
        removal_policy: typing.Optional[_RemovalPolicy_c97e7a20] = None,
        s3_export_buckets: typing.Optional[typing.Sequence[_IBucket_73486e29]] = None,
        s3_export_role: typing.Optional[_IRole_59af6f50] = None,
        s3_import_buckets: typing.Optional[typing.Sequence[_IBucket_73486e29]] = None,
        s3_import_role: typing.Optional[_IRole_59af6f50] = None,
        security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
        storage_type: typing.Optional["StorageType"] = None,
        subnet_group: typing.Optional["ISubnetGroup"] = None,
        vpc_placement: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
        vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
        instance_type: _InstanceType_072ad323,
        source_database_instance: "IDatabaseInstance",
        storage_encrypted: typing.Optional[builtins.bool] = None,
        storage_encryption_key: typing.Optional[_IKey_36930160] = None,
    ) -> None:
        '''(experimental) Construction properties for a DatabaseInstanceReadReplica.

        :param vpc: (experimental) The VPC network where the DB subnet group should be created.
        :param auto_minor_version_upgrade: (experimental) Indicates that minor engine upgrades are applied automatically to the DB instance during the maintenance window. Default: true
        :param availability_zone: (experimental) The name of the Availability Zone where the DB instance will be located. Default: - no preference
        :param backup_retention: (experimental) The number of days during which automatic DB snapshots are retained. Set to zero to disable backups. When creating a read replica, you must enable automatic backups on the source database instance by setting the backup retention to a value other than zero. Default: - Duration.days(1) for source instances, disabled for read replicas
        :param cloudwatch_logs_exports: (experimental) The list of log types that need to be enabled for exporting to CloudWatch Logs. Default: - no log exports
        :param cloudwatch_logs_retention: (experimental) The number of days log events are kept in CloudWatch Logs. When updating this property, unsetting it doesn't remove the log retention policy. To remove the retention policy, set the value to ``Infinity``. Default: - logs never expire
        :param cloudwatch_logs_retention_role: (experimental) The IAM role for the Lambda function associated with the custom resource that sets the retention policy. Default: - a new role is created.
        :param copy_tags_to_snapshot: (experimental) Indicates whether to copy all of the user-defined tags from the DB instance to snapshots of the DB instance. Default: true
        :param delete_automated_backups: (experimental) Indicates whether automated backups should be deleted or retained when you delete a DB instance. Default: false
        :param deletion_protection: (experimental) Indicates whether the DB instance should have deletion protection enabled. Default: - true if ``removalPolicy`` is RETAIN, false otherwise
        :param domain: (experimental) The Active Directory directory ID to create the DB instance in. Default: - Do not join domain
        :param domain_role: (experimental) The IAM role to be used when making API calls to the Directory Service. The role needs the AWS-managed policy AmazonRDSDirectoryServiceAccess or equivalent. Default: - The role will be created for you if {@link DatabaseInstanceNewProps#domain} is specified
        :param enable_performance_insights: (experimental) Whether to enable Performance Insights for the DB instance. Default: - false, unless ``performanceInsightRentention`` or ``performanceInsightEncryptionKey`` is set.
        :param iam_authentication: (experimental) Whether to enable mapping of AWS Identity and Access Management (IAM) accounts to database accounts. Default: false
        :param instance_identifier: (experimental) A name for the DB instance. If you specify a name, AWS CloudFormation converts it to lowercase. Default: - a CloudFormation generated name
        :param iops: (experimental) The number of I/O operations per second (IOPS) that the database provisions. The value must be equal to or greater than 1000. Default: - no provisioned iops
        :param max_allocated_storage: (experimental) Upper limit to which RDS can scale the storage in GiB(Gibibyte). Default: - No autoscaling of RDS instance
        :param monitoring_interval: (experimental) The interval, in seconds, between points when Amazon RDS collects enhanced monitoring metrics for the DB instance. Default: - no enhanced monitoring
        :param monitoring_role: (experimental) Role that will be used to manage DB instance monitoring. Default: - A role is automatically created for you
        :param multi_az: (experimental) Specifies if the database instance is a multiple Availability Zone deployment. Default: false
        :param option_group: (experimental) The option group to associate with the instance. Default: - no option group
        :param parameter_group: (experimental) The DB parameter group to associate with the instance. Default: - no parameter group
        :param performance_insight_encryption_key: (experimental) The AWS KMS key for encryption of Performance Insights data. Default: - default master key
        :param performance_insight_retention: (experimental) The amount of time, in days, to retain Performance Insights data. Default: 7
        :param port: (experimental) The port for the instance. Default: - the default port for the chosen engine.
        :param preferred_backup_window: (experimental) The daily time range during which automated backups are performed. Constraints: - Must be in the format ``hh24:mi-hh24:mi``. - Must be in Universal Coordinated Time (UTC). - Must not conflict with the preferred maintenance window. - Must be at least 30 minutes. Default: - a 30-minute window selected at random from an 8-hour block of time for each AWS Region. To see the time blocks available, see https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithAutomatedBackups.html#USER_WorkingWithAutomatedBackups.BackupWindow
        :param preferred_maintenance_window: (experimental) The weekly time range (in UTC) during which system maintenance can occur. Format: ``ddd:hh24:mi-ddd:hh24:mi`` Constraint: Minimum 30-minute window Default: - a 30-minute window selected at random from an 8-hour block of time for each AWS Region, occurring on a random day of the week. To see the time blocks available, see https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_UpgradeDBInstance.Maintenance.html#Concepts.DBMaintenance
        :param processor_features: (experimental) The number of CPU cores and the number of threads per core. Default: - the default number of CPU cores and threads per core for the chosen instance class. See https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html#USER_ConfigureProcessor
        :param publicly_accessible: (experimental) Indicates whether the DB instance is an internet-facing instance. Default: - ``true`` if ``vpcSubnets`` is ``subnetType: SubnetType.PUBLIC``, ``false`` otherwise
        :param removal_policy: (experimental) The CloudFormation policy to apply when the instance is removed from the stack or replaced during an update. Default: - RemovalPolicy.SNAPSHOT (remove the resource, but retain a snapshot of the data)
        :param s3_export_buckets: (experimental) S3 buckets that you want to load data into. This property must not be used if ``s3ExportRole`` is used. For Microsoft SQL Server: Default: - None
        :param s3_export_role: (experimental) Role that will be associated with this DB instance to enable S3 export. This property must not be used if ``s3ExportBuckets`` is used. For Microsoft SQL Server: Default: - New role is created if ``s3ExportBuckets`` is set, no role is defined otherwise
        :param s3_import_buckets: (experimental) S3 buckets that you want to load data from. This feature is only supported by the Microsoft SQL Server, Oracle, and PostgreSQL engines. This property must not be used if ``s3ImportRole`` is used. For Microsoft SQL Server: Default: - None
        :param s3_import_role: (experimental) Role that will be associated with this DB instance to enable S3 import. This feature is only supported by the Microsoft SQL Server, Oracle, and PostgreSQL engines. This property must not be used if ``s3ImportBuckets`` is used. For Microsoft SQL Server: Default: - New role is created if ``s3ImportBuckets`` is set, no role is defined otherwise
        :param security_groups: (experimental) The security groups to assign to the DB instance. Default: - a new security group is created
        :param storage_type: (experimental) The storage type. Storage types supported are gp2, io1, standard. Default: GP2
        :param subnet_group: (experimental) Existing subnet group for the instance. Default: - a new subnet group will be created.
        :param vpc_placement: (deprecated) The type of subnets to add to the created DB subnet group. Default: - private subnets
        :param vpc_subnets: (experimental) The type of subnets to add to the created DB subnet group. Default: - private subnets
        :param instance_type: (experimental) The name of the compute and memory capacity classes.
        :param source_database_instance: (experimental) The source database instance. Each DB instance can have a limited number of read replicas. For more information, see https://docs.aws.amazon.com/AmazonRDS/latest/DeveloperGuide/USER_ReadRepl.html.
        :param storage_encrypted: (experimental) Indicates whether the DB instance is encrypted. Default: - true if storageEncryptionKey has been provided, false otherwise
        :param storage_encryption_key: (experimental) The KMS key that's used to encrypt the DB instance. Default: - default master key if storageEncrypted is true, no key otherwise

        :stability: experimental
        :exampleMetadata: infused

        Example::

            # vpc: ec2.Vpc
            
            # source_instance: rds.DatabaseInstance
            
            rds.DatabaseInstanceFromSnapshot(self, "Instance",
                snapshot_identifier="my-snapshot",
                engine=rds.DatabaseInstanceEngine.postgres(version=rds.PostgresEngineVersion.VER_12_3),
                # optional, defaults to m5.large
                instance_type=ec2.InstanceType.of(ec2.InstanceClass.BURSTABLE2, ec2.InstanceSize.LARGE),
                vpc=vpc
            )
            rds.DatabaseInstanceReadReplica(self, "ReadReplica",
                source_database_instance=source_instance,
                instance_type=ec2.InstanceType.of(ec2.InstanceClass.BURSTABLE2, ec2.InstanceSize.LARGE),
                vpc=vpc
            )
        '''
        if isinstance(processor_features, dict):
            processor_features = ProcessorFeatures(**processor_features)
        if isinstance(vpc_placement, dict):
            vpc_placement = _SubnetSelection_1284e62c(**vpc_placement)
        if isinstance(vpc_subnets, dict):
            vpc_subnets = _SubnetSelection_1284e62c(**vpc_subnets)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__58b0dd09fe25ca35225a9ea6db9d11e0447bfd08008e23c086631857d9c6d3d5)
            check_type(argname="argument vpc", value=vpc, expected_type=type_hints["vpc"])
            check_type(argname="argument auto_minor_version_upgrade", value=auto_minor_version_upgrade, expected_type=type_hints["auto_minor_version_upgrade"])
            check_type(argname="argument availability_zone", value=availability_zone, expected_type=type_hints["availability_zone"])
            check_type(argname="argument backup_retention", value=backup_retention, expected_type=type_hints["backup_retention"])
            check_type(argname="argument cloudwatch_logs_exports", value=cloudwatch_logs_exports, expected_type=type_hints["cloudwatch_logs_exports"])
            check_type(argname="argument cloudwatch_logs_retention", value=cloudwatch_logs_retention, expected_type=type_hints["cloudwatch_logs_retention"])
            check_type(argname="argument cloudwatch_logs_retention_role", value=cloudwatch_logs_retention_role, expected_type=type_hints["cloudwatch_logs_retention_role"])
            check_type(argname="argument copy_tags_to_snapshot", value=copy_tags_to_snapshot, expected_type=type_hints["copy_tags_to_snapshot"])
            check_type(argname="argument delete_automated_backups", value=delete_automated_backups, expected_type=type_hints["delete_automated_backups"])
            check_type(argname="argument deletion_protection", value=deletion_protection, expected_type=type_hints["deletion_protection"])
            check_type(argname="argument domain", value=domain, expected_type=type_hints["domain"])
            check_type(argname="argument domain_role", value=domain_role, expected_type=type_hints["domain_role"])
            check_type(argname="argument enable_performance_insights", value=enable_performance_insights, expected_type=type_hints["enable_performance_insights"])
            check_type(argname="argument iam_authentication", value=iam_authentication, expected_type=type_hints["iam_authentication"])
            check_type(argname="argument instance_identifier", value=instance_identifier, expected_type=type_hints["instance_identifier"])
            check_type(argname="argument iops", value=iops, expected_type=type_hints["iops"])
            check_type(argname="argument max_allocated_storage", value=max_allocated_storage, expected_type=type_hints["max_allocated_storage"])
            check_type(argname="argument monitoring_interval", value=monitoring_interval, expected_type=type_hints["monitoring_interval"])
            check_type(argname="argument monitoring_role", value=monitoring_role, expected_type=type_hints["monitoring_role"])
            check_type(argname="argument multi_az", value=multi_az, expected_type=type_hints["multi_az"])
            check_type(argname="argument option_group", value=option_group, expected_type=type_hints["option_group"])
            check_type(argname="argument parameter_group", value=parameter_group, expected_type=type_hints["parameter_group"])
            check_type(argname="argument performance_insight_encryption_key", value=performance_insight_encryption_key, expected_type=type_hints["performance_insight_encryption_key"])
            check_type(argname="argument performance_insight_retention", value=performance_insight_retention, expected_type=type_hints["performance_insight_retention"])
            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
            check_type(argname="argument preferred_backup_window", value=preferred_backup_window, expected_type=type_hints["preferred_backup_window"])
            check_type(argname="argument preferred_maintenance_window", value=preferred_maintenance_window, expected_type=type_hints["preferred_maintenance_window"])
            check_type(argname="argument processor_features", value=processor_features, expected_type=type_hints["processor_features"])
            check_type(argname="argument publicly_accessible", value=publicly_accessible, expected_type=type_hints["publicly_accessible"])
            check_type(argname="argument removal_policy", value=removal_policy, expected_type=type_hints["removal_policy"])
            check_type(argname="argument s3_export_buckets", value=s3_export_buckets, expected_type=type_hints["s3_export_buckets"])
            check_type(argname="argument s3_export_role", value=s3_export_role, expected_type=type_hints["s3_export_role"])
            check_type(argname="argument s3_import_buckets", value=s3_import_buckets, expected_type=type_hints["s3_import_buckets"])
            check_type(argname="argument s3_import_role", value=s3_import_role, expected_type=type_hints["s3_import_role"])
            check_type(argname="argument security_groups", value=security_groups, expected_type=type_hints["security_groups"])
            check_type(argname="argument storage_type", value=storage_type, expected_type=type_hints["storage_type"])
            check_type(argname="argument subnet_group", value=subnet_group, expected_type=type_hints["subnet_group"])
            check_type(argname="argument vpc_placement", value=vpc_placement, expected_type=type_hints["vpc_placement"])
            check_type(argname="argument vpc_subnets", value=vpc_subnets, expected_type=type_hints["vpc_subnets"])
            check_type(argname="argument instance_type", value=instance_type, expected_type=type_hints["instance_type"])
            check_type(argname="argument source_database_instance", value=source_database_instance, expected_type=type_hints["source_database_instance"])
            check_type(argname="argument storage_encrypted", value=storage_encrypted, expected_type=type_hints["storage_encrypted"])
            check_type(argname="argument storage_encryption_key", value=storage_encryption_key, expected_type=type_hints["storage_encryption_key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "vpc": vpc,
            "instance_type": instance_type,
            "source_database_instance": source_database_instance,
        }
        if auto_minor_version_upgrade is not None:
            self._values["auto_minor_version_upgrade"] = auto_minor_version_upgrade
        if availability_zone is not None:
            self._values["availability_zone"] = availability_zone
        if backup_retention is not None:
            self._values["backup_retention"] = backup_retention
        if cloudwatch_logs_exports is not None:
            self._values["cloudwatch_logs_exports"] = cloudwatch_logs_exports
        if cloudwatch_logs_retention is not None:
            self._values["cloudwatch_logs_retention"] = cloudwatch_logs_retention
        if cloudwatch_logs_retention_role is not None:
            self._values["cloudwatch_logs_retention_role"] = cloudwatch_logs_retention_role
        if copy_tags_to_snapshot is not None:
            self._values["copy_tags_to_snapshot"] = copy_tags_to_snapshot
        if delete_automated_backups is not None:
            self._values["delete_automated_backups"] = delete_automated_backups
        if deletion_protection is not None:
            self._values["deletion_protection"] = deletion_protection
        if domain is not None:
            self._values["domain"] = domain
        if domain_role is not None:
            self._values["domain_role"] = domain_role
        if enable_performance_insights is not None:
            self._values["enable_performance_insights"] = enable_performance_insights
        if iam_authentication is not None:
            self._values["iam_authentication"] = iam_authentication
        if instance_identifier is not None:
            self._values["instance_identifier"] = instance_identifier
        if iops is not None:
            self._values["iops"] = iops
        if max_allocated_storage is not None:
            self._values["max_allocated_storage"] = max_allocated_storage
        if monitoring_interval is not None:
            self._values["monitoring_interval"] = monitoring_interval
        if monitoring_role is not None:
            self._values["monitoring_role"] = monitoring_role
        if multi_az is not None:
            self._values["multi_az"] = multi_az
        if option_group is not None:
            self._values["option_group"] = option_group
        if parameter_group is not None:
            self._values["parameter_group"] = parameter_group
        if performance_insight_encryption_key is not None:
            self._values["performance_insight_encryption_key"] = performance_insight_encryption_key
        if performance_insight_retention is not None:
            self._values["performance_insight_retention"] = performance_insight_retention
        if port is not None:
            self._values["port"] = port
        if preferred_backup_window is not None:
            self._values["preferred_backup_window"] = preferred_backup_window
        if preferred_maintenance_window is not None:
            self._values["preferred_maintenance_window"] = preferred_maintenance_window
        if processor_features is not None:
            self._values["processor_features"] = processor_features
        if publicly_accessible is not None:
            self._values["publicly_accessible"] = publicly_accessible
        if removal_policy is not None:
            self._values["removal_policy"] = removal_policy
        if s3_export_buckets is not None:
            self._values["s3_export_buckets"] = s3_export_buckets
        if s3_export_role is not None:
            self._values["s3_export_role"] = s3_export_role
        if s3_import_buckets is not None:
            self._values["s3_import_buckets"] = s3_import_buckets
        if s3_import_role is not None:
            self._values["s3_import_role"] = s3_import_role
        if security_groups is not None:
            self._values["security_groups"] = security_groups
        if storage_type is not None:
            self._values["storage_type"] = storage_type
        if subnet_group is not None:
            self._values["subnet_group"] = subnet_group
        if vpc_placement is not None:
            self._values["vpc_placement"] = vpc_placement
        if vpc_subnets is not None:
            self._values["vpc_subnets"] = vpc_subnets
        if storage_encrypted is not None:
            self._values["storage_encrypted"] = storage_encrypted
        if storage_encryption_key is not None:
            self._values["storage_encryption_key"] = storage_encryption_key

    @builtins.property
    def vpc(self) -> _IVpc_6d1f76c4:
        '''(experimental) The VPC network where the DB subnet group should be created.

        :stability: experimental
        '''
        result = self._values.get("vpc")
        assert result is not None, "Required property 'vpc' is missing"
        return typing.cast(_IVpc_6d1f76c4, result)

    @builtins.property
    def auto_minor_version_upgrade(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates that minor engine upgrades are applied automatically to the DB instance during the maintenance window.

        :default: true

        :stability: experimental
        '''
        result = self._values.get("auto_minor_version_upgrade")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def availability_zone(self) -> typing.Optional[builtins.str]:
        '''(experimental) The name of the Availability Zone where the DB instance will be located.

        :default: - no preference

        :stability: experimental
        '''
        result = self._values.get("availability_zone")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def backup_retention(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) The number of days during which automatic DB snapshots are retained.

        Set to zero to disable backups.
        When creating a read replica, you must enable automatic backups on the source
        database instance by setting the backup retention to a value other than zero.

        :default: - Duration.days(1) for source instances, disabled for read replicas

        :stability: experimental
        '''
        result = self._values.get("backup_retention")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def cloudwatch_logs_exports(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) The list of log types that need to be enabled for exporting to CloudWatch Logs.

        :default: - no log exports

        :stability: experimental
        '''
        result = self._values.get("cloudwatch_logs_exports")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def cloudwatch_logs_retention(self) -> typing.Optional[_RetentionDays_6c560d31]:
        '''(experimental) The number of days log events are kept in CloudWatch Logs.

        When updating
        this property, unsetting it doesn't remove the log retention policy. To
        remove the retention policy, set the value to ``Infinity``.

        :default: - logs never expire

        :stability: experimental
        '''
        result = self._values.get("cloudwatch_logs_retention")
        return typing.cast(typing.Optional[_RetentionDays_6c560d31], result)

    @builtins.property
    def cloudwatch_logs_retention_role(self) -> typing.Optional[_IRole_59af6f50]:
        '''(experimental) The IAM role for the Lambda function associated with the custom resource that sets the retention policy.

        :default: - a new role is created.

        :stability: experimental
        '''
        result = self._values.get("cloudwatch_logs_retention_role")
        return typing.cast(typing.Optional[_IRole_59af6f50], result)

    @builtins.property
    def copy_tags_to_snapshot(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether to copy all of the user-defined tags from the DB instance to snapshots of the DB instance.

        :default: true

        :stability: experimental
        '''
        result = self._values.get("copy_tags_to_snapshot")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def delete_automated_backups(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether automated backups should be deleted or retained when you delete a DB instance.

        :default: false

        :stability: experimental
        '''
        result = self._values.get("delete_automated_backups")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def deletion_protection(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the DB instance should have deletion protection enabled.

        :default: - true if ``removalPolicy`` is RETAIN, false otherwise

        :stability: experimental
        '''
        result = self._values.get("deletion_protection")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def domain(self) -> typing.Optional[builtins.str]:
        '''(experimental) The Active Directory directory ID to create the DB instance in.

        :default: - Do not join domain

        :stability: experimental
        '''
        result = self._values.get("domain")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def domain_role(self) -> typing.Optional[_IRole_59af6f50]:
        '''(experimental) The IAM role to be used when making API calls to the Directory Service.

        The role needs the AWS-managed policy
        AmazonRDSDirectoryServiceAccess or equivalent.

        :default: - The role will be created for you if {@link DatabaseInstanceNewProps#domain} is specified

        :stability: experimental
        '''
        result = self._values.get("domain_role")
        return typing.cast(typing.Optional[_IRole_59af6f50], result)

    @builtins.property
    def enable_performance_insights(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Whether to enable Performance Insights for the DB instance.

        :default: - false, unless ``performanceInsightRentention`` or ``performanceInsightEncryptionKey`` is set.

        :stability: experimental
        '''
        result = self._values.get("enable_performance_insights")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def iam_authentication(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Whether to enable mapping of AWS Identity and Access Management (IAM) accounts to database accounts.

        :default: false

        :stability: experimental
        '''
        result = self._values.get("iam_authentication")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def instance_identifier(self) -> typing.Optional[builtins.str]:
        '''(experimental) A name for the DB instance.

        If you specify a name, AWS CloudFormation
        converts it to lowercase.

        :default: - a CloudFormation generated name

        :stability: experimental
        '''
        result = self._values.get("instance_identifier")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def iops(self) -> typing.Optional[jsii.Number]:
        '''(experimental) The number of I/O operations per second (IOPS) that the database provisions.

        The value must be equal to or greater than 1000.

        :default: - no provisioned iops

        :stability: experimental
        '''
        result = self._values.get("iops")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def max_allocated_storage(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Upper limit to which RDS can scale the storage in GiB(Gibibyte).

        :default: - No autoscaling of RDS instance

        :see: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PIOPS.StorageTypes.html#USER_PIOPS.Autoscaling
        :stability: experimental
        '''
        result = self._values.get("max_allocated_storage")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def monitoring_interval(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) The interval, in seconds, between points when Amazon RDS collects enhanced monitoring metrics for the DB instance.

        :default: - no enhanced monitoring

        :stability: experimental
        '''
        result = self._values.get("monitoring_interval")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def monitoring_role(self) -> typing.Optional[_IRole_59af6f50]:
        '''(experimental) Role that will be used to manage DB instance monitoring.

        :default: - A role is automatically created for you

        :stability: experimental
        '''
        result = self._values.get("monitoring_role")
        return typing.cast(typing.Optional[_IRole_59af6f50], result)

    @builtins.property
    def multi_az(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Specifies if the database instance is a multiple Availability Zone deployment.

        :default: false

        :stability: experimental
        '''
        result = self._values.get("multi_az")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def option_group(self) -> typing.Optional["IOptionGroup"]:
        '''(experimental) The option group to associate with the instance.

        :default: - no option group

        :stability: experimental
        '''
        result = self._values.get("option_group")
        return typing.cast(typing.Optional["IOptionGroup"], result)

    @builtins.property
    def parameter_group(self) -> typing.Optional["IParameterGroup"]:
        '''(experimental) The DB parameter group to associate with the instance.

        :default: - no parameter group

        :stability: experimental
        '''
        result = self._values.get("parameter_group")
        return typing.cast(typing.Optional["IParameterGroup"], result)

    @builtins.property
    def performance_insight_encryption_key(self) -> typing.Optional[_IKey_36930160]:
        '''(experimental) The AWS KMS key for encryption of Performance Insights data.

        :default: - default master key

        :stability: experimental
        '''
        result = self._values.get("performance_insight_encryption_key")
        return typing.cast(typing.Optional[_IKey_36930160], result)

    @builtins.property
    def performance_insight_retention(
        self,
    ) -> typing.Optional["PerformanceInsightRetention"]:
        '''(experimental) The amount of time, in days, to retain Performance Insights data.

        :default: 7

        :stability: experimental
        '''
        result = self._values.get("performance_insight_retention")
        return typing.cast(typing.Optional["PerformanceInsightRetention"], result)

    @builtins.property
    def port(self) -> typing.Optional[jsii.Number]:
        '''(experimental) The port for the instance.

        :default: - the default port for the chosen engine.

        :stability: experimental
        '''
        result = self._values.get("port")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def preferred_backup_window(self) -> typing.Optional[builtins.str]:
        '''(experimental) The daily time range during which automated backups are performed.

        Constraints:

        - Must be in the format ``hh24:mi-hh24:mi``.
        - Must be in Universal Coordinated Time (UTC).
        - Must not conflict with the preferred maintenance window.
        - Must be at least 30 minutes.

        :default:

        - a 30-minute window selected at random from an 8-hour block of
        time for each AWS Region. To see the time blocks available, see
        https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithAutomatedBackups.html#USER_WorkingWithAutomatedBackups.BackupWindow

        :stability: experimental
        '''
        result = self._values.get("preferred_backup_window")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def preferred_maintenance_window(self) -> typing.Optional[builtins.str]:
        '''(experimental) The weekly time range (in UTC) during which system maintenance can occur.

        Format: ``ddd:hh24:mi-ddd:hh24:mi``
        Constraint: Minimum 30-minute window

        :default:

        - a 30-minute window selected at random from an 8-hour block of
        time for each AWS Region, occurring on a random day of the week. To see
        the time blocks available, see https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_UpgradeDBInstance.Maintenance.html#Concepts.DBMaintenance

        :stability: experimental
        '''
        result = self._values.get("preferred_maintenance_window")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def processor_features(self) -> typing.Optional["ProcessorFeatures"]:
        '''(experimental) The number of CPU cores and the number of threads per core.

        :default:

        - the default number of CPU cores and threads per core for the
        chosen instance class.

        See https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html#USER_ConfigureProcessor

        :stability: experimental
        '''
        result = self._values.get("processor_features")
        return typing.cast(typing.Optional["ProcessorFeatures"], result)

    @builtins.property
    def publicly_accessible(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the DB instance is an internet-facing instance.

        :default: - ``true`` if ``vpcSubnets`` is ``subnetType: SubnetType.PUBLIC``, ``false`` otherwise

        :stability: experimental
        '''
        result = self._values.get("publicly_accessible")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def removal_policy(self) -> typing.Optional[_RemovalPolicy_c97e7a20]:
        '''(experimental) The CloudFormation policy to apply when the instance is removed from the stack or replaced during an update.

        :default: - RemovalPolicy.SNAPSHOT (remove the resource, but retain a snapshot of the data)

        :stability: experimental
        '''
        result = self._values.get("removal_policy")
        return typing.cast(typing.Optional[_RemovalPolicy_c97e7a20], result)

    @builtins.property
    def s3_export_buckets(self) -> typing.Optional[typing.List[_IBucket_73486e29]]:
        '''(experimental) S3 buckets that you want to load data into.

        This property must not be used if ``s3ExportRole`` is used.

        For Microsoft SQL Server:

        :default: - None

        :see: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/oracle-s3-integration.html
        :stability: experimental
        '''
        result = self._values.get("s3_export_buckets")
        return typing.cast(typing.Optional[typing.List[_IBucket_73486e29]], result)

    @builtins.property
    def s3_export_role(self) -> typing.Optional[_IRole_59af6f50]:
        '''(experimental) Role that will be associated with this DB instance to enable S3 export.

        This property must not be used if ``s3ExportBuckets`` is used.

        For Microsoft SQL Server:

        :default: - New role is created if ``s3ExportBuckets`` is set, no role is defined otherwise

        :see: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/oracle-s3-integration.html
        :stability: experimental
        '''
        result = self._values.get("s3_export_role")
        return typing.cast(typing.Optional[_IRole_59af6f50], result)

    @builtins.property
    def s3_import_buckets(self) -> typing.Optional[typing.List[_IBucket_73486e29]]:
        '''(experimental) S3 buckets that you want to load data from.

        This feature is only supported by the Microsoft SQL Server, Oracle, and PostgreSQL engines.

        This property must not be used if ``s3ImportRole`` is used.

        For Microsoft SQL Server:

        :default: - None

        :see: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/PostgreSQL.Procedural.Importing.html
        :stability: experimental
        '''
        result = self._values.get("s3_import_buckets")
        return typing.cast(typing.Optional[typing.List[_IBucket_73486e29]], result)

    @builtins.property
    def s3_import_role(self) -> typing.Optional[_IRole_59af6f50]:
        '''(experimental) Role that will be associated with this DB instance to enable S3 import.

        This feature is only supported by the Microsoft SQL Server, Oracle, and PostgreSQL engines.

        This property must not be used if ``s3ImportBuckets`` is used.

        For Microsoft SQL Server:

        :default: - New role is created if ``s3ImportBuckets`` is set, no role is defined otherwise

        :see: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/PostgreSQL.Procedural.Importing.html
        :stability: experimental
        '''
        result = self._values.get("s3_import_role")
        return typing.cast(typing.Optional[_IRole_59af6f50], result)

    @builtins.property
    def security_groups(self) -> typing.Optional[typing.List[_ISecurityGroup_cdbba9d3]]:
        '''(experimental) The security groups to assign to the DB instance.

        :default: - a new security group is created

        :stability: experimental
        '''
        result = self._values.get("security_groups")
        return typing.cast(typing.Optional[typing.List[_ISecurityGroup_cdbba9d3]], result)

    @builtins.property
    def storage_type(self) -> typing.Optional["StorageType"]:
        '''(experimental) The storage type.

        Storage types supported are gp2, io1, standard.

        :default: GP2

        :see: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Storage.html#Concepts.Storage.GeneralSSD
        :stability: experimental
        '''
        result = self._values.get("storage_type")
        return typing.cast(typing.Optional["StorageType"], result)

    @builtins.property
    def subnet_group(self) -> typing.Optional["ISubnetGroup"]:
        '''(experimental) Existing subnet group for the instance.

        :default: - a new subnet group will be created.

        :stability: experimental
        '''
        result = self._values.get("subnet_group")
        return typing.cast(typing.Optional["ISubnetGroup"], result)

    @builtins.property
    def vpc_placement(self) -> typing.Optional[_SubnetSelection_1284e62c]:
        '''(deprecated) The type of subnets to add to the created DB subnet group.

        :default: - private subnets

        :deprecated: use ``vpcSubnets``

        :stability: deprecated
        '''
        result = self._values.get("vpc_placement")
        return typing.cast(typing.Optional[_SubnetSelection_1284e62c], result)

    @builtins.property
    def vpc_subnets(self) -> typing.Optional[_SubnetSelection_1284e62c]:
        '''(experimental) The type of subnets to add to the created DB subnet group.

        :default: - private subnets

        :stability: experimental
        '''
        result = self._values.get("vpc_subnets")
        return typing.cast(typing.Optional[_SubnetSelection_1284e62c], result)

    @builtins.property
    def instance_type(self) -> _InstanceType_072ad323:
        '''(experimental) The name of the compute and memory capacity classes.

        :stability: experimental
        '''
        result = self._values.get("instance_type")
        assert result is not None, "Required property 'instance_type' is missing"
        return typing.cast(_InstanceType_072ad323, result)

    @builtins.property
    def source_database_instance(self) -> "IDatabaseInstance":
        '''(experimental) The source database instance.

        Each DB instance can have a limited number of read replicas. For more
        information, see https://docs.aws.amazon.com/AmazonRDS/latest/DeveloperGuide/USER_ReadRepl.html.

        :stability: experimental
        '''
        result = self._values.get("source_database_instance")
        assert result is not None, "Required property 'source_database_instance' is missing"
        return typing.cast("IDatabaseInstance", result)

    @builtins.property
    def storage_encrypted(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the DB instance is encrypted.

        :default: - true if storageEncryptionKey has been provided, false otherwise

        :stability: experimental
        '''
        result = self._values.get("storage_encrypted")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def storage_encryption_key(self) -> typing.Optional[_IKey_36930160]:
        '''(experimental) The KMS key that's used to encrypt the DB instance.

        :default: - default master key if storageEncrypted is true, no key otherwise

        :stability: experimental
        '''
        result = self._values.get("storage_encryption_key")
        return typing.cast(typing.Optional[_IKey_36930160], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DatabaseInstanceReadReplicaProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_rds.DatabaseInstanceSourceProps",
    jsii_struct_bases=[DatabaseInstanceNewProps],
    name_mapping={
        "vpc": "vpc",
        "auto_minor_version_upgrade": "autoMinorVersionUpgrade",
        "availability_zone": "availabilityZone",
        "backup_retention": "backupRetention",
        "cloudwatch_logs_exports": "cloudwatchLogsExports",
        "cloudwatch_logs_retention": "cloudwatchLogsRetention",
        "cloudwatch_logs_retention_role": "cloudwatchLogsRetentionRole",
        "copy_tags_to_snapshot": "copyTagsToSnapshot",
        "delete_automated_backups": "deleteAutomatedBackups",
        "deletion_protection": "deletionProtection",
        "domain": "domain",
        "domain_role": "domainRole",
        "enable_performance_insights": "enablePerformanceInsights",
        "iam_authentication": "iamAuthentication",
        "instance_identifier": "instanceIdentifier",
        "iops": "iops",
        "max_allocated_storage": "maxAllocatedStorage",
        "monitoring_interval": "monitoringInterval",
        "monitoring_role": "monitoringRole",
        "multi_az": "multiAz",
        "option_group": "optionGroup",
        "parameter_group": "parameterGroup",
        "performance_insight_encryption_key": "performanceInsightEncryptionKey",
        "performance_insight_retention": "performanceInsightRetention",
        "port": "port",
        "preferred_backup_window": "preferredBackupWindow",
        "preferred_maintenance_window": "preferredMaintenanceWindow",
        "processor_features": "processorFeatures",
        "publicly_accessible": "publiclyAccessible",
        "removal_policy": "removalPolicy",
        "s3_export_buckets": "s3ExportBuckets",
        "s3_export_role": "s3ExportRole",
        "s3_import_buckets": "s3ImportBuckets",
        "s3_import_role": "s3ImportRole",
        "security_groups": "securityGroups",
        "storage_type": "storageType",
        "subnet_group": "subnetGroup",
        "vpc_placement": "vpcPlacement",
        "vpc_subnets": "vpcSubnets",
        "engine": "engine",
        "allocated_storage": "allocatedStorage",
        "allow_major_version_upgrade": "allowMajorVersionUpgrade",
        "database_name": "databaseName",
        "instance_type": "instanceType",
        "license_model": "licenseModel",
        "parameters": "parameters",
        "timezone": "timezone",
    },
)
class DatabaseInstanceSourceProps(DatabaseInstanceNewProps):
    def __init__(
        self,
        *,
        vpc: _IVpc_6d1f76c4,
        auto_minor_version_upgrade: typing.Optional[builtins.bool] = None,
        availability_zone: typing.Optional[builtins.str] = None,
        backup_retention: typing.Optional[_Duration_070aa057] = None,
        cloudwatch_logs_exports: typing.Optional[typing.Sequence[builtins.str]] = None,
        cloudwatch_logs_retention: typing.Optional[_RetentionDays_6c560d31] = None,
        cloudwatch_logs_retention_role: typing.Optional[_IRole_59af6f50] = None,
        copy_tags_to_snapshot: typing.Optional[builtins.bool] = None,
        delete_automated_backups: typing.Optional[builtins.bool] = None,
        deletion_protection: typing.Optional[builtins.bool] = None,
        domain: typing.Optional[builtins.str] = None,
        domain_role: typing.Optional[_IRole_59af6f50] = None,
        enable_performance_insights: typing.Optional[builtins.bool] = None,
        iam_authentication: typing.Optional[builtins.bool] = None,
        instance_identifier: typing.Optional[builtins.str] = None,
        iops: typing.Optional[jsii.Number] = None,
        max_allocated_storage: typing.Optional[jsii.Number] = None,
        monitoring_interval: typing.Optional[_Duration_070aa057] = None,
        monitoring_role: typing.Optional[_IRole_59af6f50] = None,
        multi_az: typing.Optional[builtins.bool] = None,
        option_group: typing.Optional["IOptionGroup"] = None,
        parameter_group: typing.Optional["IParameterGroup"] = None,
        performance_insight_encryption_key: typing.Optional[_IKey_36930160] = None,
        performance_insight_retention: typing.Optional["PerformanceInsightRetention"] = None,
        port: typing.Optional[jsii.Number] = None,
        preferred_backup_window: typing.Optional[builtins.str] = None,
        preferred_maintenance_window: typing.Optional[builtins.str] = None,
        processor_features: typing.Optional[typing.Union["ProcessorFeatures", typing.Dict[builtins.str, typing.Any]]] = None,
        publicly_accessible: typing.Optional[builtins.bool] = None,
        removal_policy: typing.Optional[_RemovalPolicy_c97e7a20] = None,
        s3_export_buckets: typing.Optional[typing.Sequence[_IBucket_73486e29]] = None,
        s3_export_role: typing.Optional[_IRole_59af6f50] = None,
        s3_import_buckets: typing.Optional[typing.Sequence[_IBucket_73486e29]] = None,
        s3_import_role: typing.Optional[_IRole_59af6f50] = None,
        security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
        storage_type: typing.Optional["StorageType"] = None,
        subnet_group: typing.Optional["ISubnetGroup"] = None,
        vpc_placement: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
        vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
        engine: "IInstanceEngine",
        allocated_storage: typing.Optional[jsii.Number] = None,
        allow_major_version_upgrade: typing.Optional[builtins.bool] = None,
        database_name: typing.Optional[builtins.str] = None,
        instance_type: typing.Optional[_InstanceType_072ad323] = None,
        license_model: typing.Optional["LicenseModel"] = None,
        parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        timezone: typing.Optional[builtins.str] = None,
    ) -> None:
        '''(experimental) Construction properties for a DatabaseInstanceSource.

        :param vpc: (experimental) The VPC network where the DB subnet group should be created.
        :param auto_minor_version_upgrade: (experimental) Indicates that minor engine upgrades are applied automatically to the DB instance during the maintenance window. Default: true
        :param availability_zone: (experimental) The name of the Availability Zone where the DB instance will be located. Default: - no preference
        :param backup_retention: (experimental) The number of days during which automatic DB snapshots are retained. Set to zero to disable backups. When creating a read replica, you must enable automatic backups on the source database instance by setting the backup retention to a value other than zero. Default: - Duration.days(1) for source instances, disabled for read replicas
        :param cloudwatch_logs_exports: (experimental) The list of log types that need to be enabled for exporting to CloudWatch Logs. Default: - no log exports
        :param cloudwatch_logs_retention: (experimental) The number of days log events are kept in CloudWatch Logs. When updating this property, unsetting it doesn't remove the log retention policy. To remove the retention policy, set the value to ``Infinity``. Default: - logs never expire
        :param cloudwatch_logs_retention_role: (experimental) The IAM role for the Lambda function associated with the custom resource that sets the retention policy. Default: - a new role is created.
        :param copy_tags_to_snapshot: (experimental) Indicates whether to copy all of the user-defined tags from the DB instance to snapshots of the DB instance. Default: true
        :param delete_automated_backups: (experimental) Indicates whether automated backups should be deleted or retained when you delete a DB instance. Default: false
        :param deletion_protection: (experimental) Indicates whether the DB instance should have deletion protection enabled. Default: - true if ``removalPolicy`` is RETAIN, false otherwise
        :param domain: (experimental) The Active Directory directory ID to create the DB instance in. Default: - Do not join domain
        :param domain_role: (experimental) The IAM role to be used when making API calls to the Directory Service. The role needs the AWS-managed policy AmazonRDSDirectoryServiceAccess or equivalent. Default: - The role will be created for you if {@link DatabaseInstanceNewProps#domain} is specified
        :param enable_performance_insights: (experimental) Whether to enable Performance Insights for the DB instance. Default: - false, unless ``performanceInsightRentention`` or ``performanceInsightEncryptionKey`` is set.
        :param iam_authentication: (experimental) Whether to enable mapping of AWS Identity and Access Management (IAM) accounts to database accounts. Default: false
        :param instance_identifier: (experimental) A name for the DB instance. If you specify a name, AWS CloudFormation converts it to lowercase. Default: - a CloudFormation generated name
        :param iops: (experimental) The number of I/O operations per second (IOPS) that the database provisions. The value must be equal to or greater than 1000. Default: - no provisioned iops
        :param max_allocated_storage: (experimental) Upper limit to which RDS can scale the storage in GiB(Gibibyte). Default: - No autoscaling of RDS instance
        :param monitoring_interval: (experimental) The interval, in seconds, between points when Amazon RDS collects enhanced monitoring metrics for the DB instance. Default: - no enhanced monitoring
        :param monitoring_role: (experimental) Role that will be used to manage DB instance monitoring. Default: - A role is automatically created for you
        :param multi_az: (experimental) Specifies if the database instance is a multiple Availability Zone deployment. Default: false
        :param option_group: (experimental) The option group to associate with the instance. Default: - no option group
        :param parameter_group: (experimental) The DB parameter group to associate with the instance. Default: - no parameter group
        :param performance_insight_encryption_key: (experimental) The AWS KMS key for encryption of Performance Insights data. Default: - default master key
        :param performance_insight_retention: (experimental) The amount of time, in days, to retain Performance Insights data. Default: 7
        :param port: (experimental) The port for the instance. Default: - the default port for the chosen engine.
        :param preferred_backup_window: (experimental) The daily time range during which automated backups are performed. Constraints: - Must be in the format ``hh24:mi-hh24:mi``. - Must be in Universal Coordinated Time (UTC). - Must not conflict with the preferred maintenance window. - Must be at least 30 minutes. Default: - a 30-minute window selected at random from an 8-hour block of time for each AWS Region. To see the time blocks available, see https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithAutomatedBackups.html#USER_WorkingWithAutomatedBackups.BackupWindow
        :param preferred_maintenance_window: (experimental) The weekly time range (in UTC) during which system maintenance can occur. Format: ``ddd:hh24:mi-ddd:hh24:mi`` Constraint: Minimum 30-minute window Default: - a 30-minute window selected at random from an 8-hour block of time for each AWS Region, occurring on a random day of the week. To see the time blocks available, see https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_UpgradeDBInstance.Maintenance.html#Concepts.DBMaintenance
        :param processor_features: (experimental) The number of CPU cores and the number of threads per core. Default: - the default number of CPU cores and threads per core for the chosen instance class. See https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html#USER_ConfigureProcessor
        :param publicly_accessible: (experimental) Indicates whether the DB instance is an internet-facing instance. Default: - ``true`` if ``vpcSubnets`` is ``subnetType: SubnetType.PUBLIC``, ``false`` otherwise
        :param removal_policy: (experimental) The CloudFormation policy to apply when the instance is removed from the stack or replaced during an update. Default: - RemovalPolicy.SNAPSHOT (remove the resource, but retain a snapshot of the data)
        :param s3_export_buckets: (experimental) S3 buckets that you want to load data into. This property must not be used if ``s3ExportRole`` is used. For Microsoft SQL Server: Default: - None
        :param s3_export_role: (experimental) Role that will be associated with this DB instance to enable S3 export. This property must not be used if ``s3ExportBuckets`` is used. For Microsoft SQL Server: Default: - New role is created if ``s3ExportBuckets`` is set, no role is defined otherwise
        :param s3_import_buckets: (experimental) S3 buckets that you want to load data from. This feature is only supported by the Microsoft SQL Server, Oracle, and PostgreSQL engines. This property must not be used if ``s3ImportRole`` is used. For Microsoft SQL Server: Default: - None
        :param s3_import_role: (experimental) Role that will be associated with this DB instance to enable S3 import. This feature is only supported by the Microsoft SQL Server, Oracle, and PostgreSQL engines. This property must not be used if ``s3ImportBuckets`` is used. For Microsoft SQL Server: Default: - New role is created if ``s3ImportBuckets`` is set, no role is defined otherwise
        :param security_groups: (experimental) The security groups to assign to the DB instance. Default: - a new security group is created
        :param storage_type: (experimental) The storage type. Storage types supported are gp2, io1, standard. Default: GP2
        :param subnet_group: (experimental) Existing subnet group for the instance. Default: - a new subnet group will be created.
        :param vpc_placement: (deprecated) The type of subnets to add to the created DB subnet group. Default: - private subnets
        :param vpc_subnets: (experimental) The type of subnets to add to the created DB subnet group. Default: - private subnets
        :param engine: (experimental) The database engine.
        :param allocated_storage: (experimental) The allocated storage size, specified in gigabytes (GB). Default: 100
        :param allow_major_version_upgrade: (experimental) Whether to allow major version upgrades. Default: false
        :param database_name: (experimental) The name of the database. Default: - no name
        :param instance_type: (experimental) The name of the compute and memory capacity for the instance. Default: - m5.large (or, more specifically, db.m5.large)
        :param license_model: (experimental) The license model. Default: - RDS default license model
        :param parameters: (experimental) The parameters in the DBParameterGroup to create automatically. You can only specify parameterGroup or parameters but not both. You need to use a versioned engine to auto-generate a DBParameterGroup. Default: - None
        :param timezone: (experimental) The time zone of the instance. This is currently supported only by Microsoft Sql Server. Default: - RDS default timezone

        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            import monocdk as monocdk
            from monocdk import aws_ec2 as ec2
            from monocdk import aws_iam as iam
            from monocdk import aws_kms as kms
            from monocdk import aws_logs as logs
            from monocdk import aws_rds as rds
            from monocdk import aws_s3 as s3
            
            # bucket: s3.Bucket
            # duration: monocdk.Duration
            # instance_engine: rds.IInstanceEngine
            # instance_type: ec2.InstanceType
            # key: kms.Key
            # option_group: rds.OptionGroup
            # parameter_group: rds.ParameterGroup
            # role: iam.Role
            # security_group: ec2.SecurityGroup
            # subnet: ec2.Subnet
            # subnet_filter: ec2.SubnetFilter
            # subnet_group: rds.SubnetGroup
            # vpc: ec2.Vpc
            
            database_instance_source_props = rds.DatabaseInstanceSourceProps(
                engine=instance_engine,
                vpc=vpc,
            
                # the properties below are optional
                allocated_storage=123,
                allow_major_version_upgrade=False,
                auto_minor_version_upgrade=False,
                availability_zone="availabilityZone",
                backup_retention=duration,
                cloudwatch_logs_exports=["cloudwatchLogsExports"],
                cloudwatch_logs_retention=logs.RetentionDays.ONE_DAY,
                cloudwatch_logs_retention_role=role,
                copy_tags_to_snapshot=False,
                database_name="databaseName",
                delete_automated_backups=False,
                deletion_protection=False,
                domain="domain",
                domain_role=role,
                enable_performance_insights=False,
                iam_authentication=False,
                instance_identifier="instanceIdentifier",
                instance_type=instance_type,
                iops=123,
                license_model=rds.LicenseModel.LICENSE_INCLUDED,
                max_allocated_storage=123,
                monitoring_interval=duration,
                monitoring_role=role,
                multi_az=False,
                option_group=option_group,
                parameter_group=parameter_group,
                parameters={
                    "parameters_key": "parameters"
                },
                performance_insight_encryption_key=key,
                performance_insight_retention=rds.PerformanceInsightRetention.DEFAULT,
                port=123,
                preferred_backup_window="preferredBackupWindow",
                preferred_maintenance_window="preferredMaintenanceWindow",
                processor_features=rds.ProcessorFeatures(
                    core_count=123,
                    threads_per_core=123
                ),
                publicly_accessible=False,
                removal_policy=monocdk.RemovalPolicy.DESTROY,
                s3_export_buckets=[bucket],
                s3_export_role=role,
                s3_import_buckets=[bucket],
                s3_import_role=role,
                security_groups=[security_group],
                storage_type=rds.StorageType.STANDARD,
                subnet_group=subnet_group,
                timezone="timezone",
                vpc_placement=ec2.SubnetSelection(
                    availability_zones=["availabilityZones"],
                    one_per_az=False,
                    subnet_filters=[subnet_filter],
                    subnet_group_name="subnetGroupName",
                    subnet_name="subnetName",
                    subnets=[subnet],
                    subnet_type=ec2.SubnetType.ISOLATED
                ),
                vpc_subnets=ec2.SubnetSelection(
                    availability_zones=["availabilityZones"],
                    one_per_az=False,
                    subnet_filters=[subnet_filter],
                    subnet_group_name="subnetGroupName",
                    subnet_name="subnetName",
                    subnets=[subnet],
                    subnet_type=ec2.SubnetType.ISOLATED
                )
            )
        '''
        if isinstance(processor_features, dict):
            processor_features = ProcessorFeatures(**processor_features)
        if isinstance(vpc_placement, dict):
            vpc_placement = _SubnetSelection_1284e62c(**vpc_placement)
        if isinstance(vpc_subnets, dict):
            vpc_subnets = _SubnetSelection_1284e62c(**vpc_subnets)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__667843d9cf0d0baaf429a0d6a5f46f200dc58e17e3ad3b79a0b494806f49a514)
            check_type(argname="argument vpc", value=vpc, expected_type=type_hints["vpc"])
            check_type(argname="argument auto_minor_version_upgrade", value=auto_minor_version_upgrade, expected_type=type_hints["auto_minor_version_upgrade"])
            check_type(argname="argument availability_zone", value=availability_zone, expected_type=type_hints["availability_zone"])
            check_type(argname="argument backup_retention", value=backup_retention, expected_type=type_hints["backup_retention"])
            check_type(argname="argument cloudwatch_logs_exports", value=cloudwatch_logs_exports, expected_type=type_hints["cloudwatch_logs_exports"])
            check_type(argname="argument cloudwatch_logs_retention", value=cloudwatch_logs_retention, expected_type=type_hints["cloudwatch_logs_retention"])
            check_type(argname="argument cloudwatch_logs_retention_role", value=cloudwatch_logs_retention_role, expected_type=type_hints["cloudwatch_logs_retention_role"])
            check_type(argname="argument copy_tags_to_snapshot", value=copy_tags_to_snapshot, expected_type=type_hints["copy_tags_to_snapshot"])
            check_type(argname="argument delete_automated_backups", value=delete_automated_backups, expected_type=type_hints["delete_automated_backups"])
            check_type(argname="argument deletion_protection", value=deletion_protection, expected_type=type_hints["deletion_protection"])
            check_type(argname="argument domain", value=domain, expected_type=type_hints["domain"])
            check_type(argname="argument domain_role", value=domain_role, expected_type=type_hints["domain_role"])
            check_type(argname="argument enable_performance_insights", value=enable_performance_insights, expected_type=type_hints["enable_performance_insights"])
            check_type(argname="argument iam_authentication", value=iam_authentication, expected_type=type_hints["iam_authentication"])
            check_type(argname="argument instance_identifier", value=instance_identifier, expected_type=type_hints["instance_identifier"])
            check_type(argname="argument iops", value=iops, expected_type=type_hints["iops"])
            check_type(argname="argument max_allocated_storage", value=max_allocated_storage, expected_type=type_hints["max_allocated_storage"])
            check_type(argname="argument monitoring_interval", value=monitoring_interval, expected_type=type_hints["monitoring_interval"])
            check_type(argname="argument monitoring_role", value=monitoring_role, expected_type=type_hints["monitoring_role"])
            check_type(argname="argument multi_az", value=multi_az, expected_type=type_hints["multi_az"])
            check_type(argname="argument option_group", value=option_group, expected_type=type_hints["option_group"])
            check_type(argname="argument parameter_group", value=parameter_group, expected_type=type_hints["parameter_group"])
            check_type(argname="argument performance_insight_encryption_key", value=performance_insight_encryption_key, expected_type=type_hints["performance_insight_encryption_key"])
            check_type(argname="argument performance_insight_retention", value=performance_insight_retention, expected_type=type_hints["performance_insight_retention"])
            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
            check_type(argname="argument preferred_backup_window", value=preferred_backup_window, expected_type=type_hints["preferred_backup_window"])
            check_type(argname="argument preferred_maintenance_window", value=preferred_maintenance_window, expected_type=type_hints["preferred_maintenance_window"])
            check_type(argname="argument processor_features", value=processor_features, expected_type=type_hints["processor_features"])
            check_type(argname="argument publicly_accessible", value=publicly_accessible, expected_type=type_hints["publicly_accessible"])
            check_type(argname="argument removal_policy", value=removal_policy, expected_type=type_hints["removal_policy"])
            check_type(argname="argument s3_export_buckets", value=s3_export_buckets, expected_type=type_hints["s3_export_buckets"])
            check_type(argname="argument s3_export_role", value=s3_export_role, expected_type=type_hints["s3_export_role"])
            check_type(argname="argument s3_import_buckets", value=s3_import_buckets, expected_type=type_hints["s3_import_buckets"])
            check_type(argname="argument s3_import_role", value=s3_import_role, expected_type=type_hints["s3_import_role"])
            check_type(argname="argument security_groups", value=security_groups, expected_type=type_hints["security_groups"])
            check_type(argname="argument storage_type", value=storage_type, expected_type=type_hints["storage_type"])
            check_type(argname="argument subnet_group", value=subnet_group, expected_type=type_hints["subnet_group"])
            check_type(argname="argument vpc_placement", value=vpc_placement, expected_type=type_hints["vpc_placement"])
            check_type(argname="argument vpc_subnets", value=vpc_subnets, expected_type=type_hints["vpc_subnets"])
            check_type(argname="argument engine", value=engine, expected_type=type_hints["engine"])
            check_type(argname="argument allocated_storage", value=allocated_storage, expected_type=type_hints["allocated_storage"])
            check_type(argname="argument allow_major_version_upgrade", value=allow_major_version_upgrade, expected_type=type_hints["allow_major_version_upgrade"])
            check_type(argname="argument database_name", value=database_name, expected_type=type_hints["database_name"])
            check_type(argname="argument instance_type", value=instance_type, expected_type=type_hints["instance_type"])
            check_type(argname="argument license_model", value=license_model, expected_type=type_hints["license_model"])
            check_type(argname="argument parameters", value=parameters, expected_type=type_hints["parameters"])
            check_type(argname="argument timezone", value=timezone, expected_type=type_hints["timezone"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "vpc": vpc,
            "engine": engine,
        }
        if auto_minor_version_upgrade is not None:
            self._values["auto_minor_version_upgrade"] = auto_minor_version_upgrade
        if availability_zone is not None:
            self._values["availability_zone"] = availability_zone
        if backup_retention is not None:
            self._values["backup_retention"] = backup_retention
        if cloudwatch_logs_exports is not None:
            self._values["cloudwatch_logs_exports"] = cloudwatch_logs_exports
        if cloudwatch_logs_retention is not None:
            self._values["cloudwatch_logs_retention"] = cloudwatch_logs_retention
        if cloudwatch_logs_retention_role is not None:
            self._values["cloudwatch_logs_retention_role"] = cloudwatch_logs_retention_role
        if copy_tags_to_snapshot is not None:
            self._values["copy_tags_to_snapshot"] = copy_tags_to_snapshot
        if delete_automated_backups is not None:
            self._values["delete_automated_backups"] = delete_automated_backups
        if deletion_protection is not None:
            self._values["deletion_protection"] = deletion_protection
        if domain is not None:
            self._values["domain"] = domain
        if domain_role is not None:
            self._values["domain_role"] = domain_role
        if enable_performance_insights is not None:
            self._values["enable_performance_insights"] = enable_performance_insights
        if iam_authentication is not None:
            self._values["iam_authentication"] = iam_authentication
        if instance_identifier is not None:
            self._values["instance_identifier"] = instance_identifier
        if iops is not None:
            self._values["iops"] = iops
        if max_allocated_storage is not None:
            self._values["max_allocated_storage"] = max_allocated_storage
        if monitoring_interval is not None:
            self._values["monitoring_interval"] = monitoring_interval
        if monitoring_role is not None:
            self._values["monitoring_role"] = monitoring_role
        if multi_az is not None:
            self._values["multi_az"] = multi_az
        if option_group is not None:
            self._values["option_group"] = option_group
        if parameter_group is not None:
            self._values["parameter_group"] = parameter_group
        if performance_insight_encryption_key is not None:
            self._values["performance_insight_encryption_key"] = performance_insight_encryption_key
        if performance_insight_retention is not None:
            self._values["performance_insight_retention"] = performance_insight_retention
        if port is not None:
            self._values["port"] = port
        if preferred_backup_window is not None:
            self._values["preferred_backup_window"] = preferred_backup_window
        if preferred_maintenance_window is not None:
            self._values["preferred_maintenance_window"] = preferred_maintenance_window
        if processor_features is not None:
            self._values["processor_features"] = processor_features
        if publicly_accessible is not None:
            self._values["publicly_accessible"] = publicly_accessible
        if removal_policy is not None:
            self._values["removal_policy"] = removal_policy
        if s3_export_buckets is not None:
            self._values["s3_export_buckets"] = s3_export_buckets
        if s3_export_role is not None:
            self._values["s3_export_role"] = s3_export_role
        if s3_import_buckets is not None:
            self._values["s3_import_buckets"] = s3_import_buckets
        if s3_import_role is not None:
            self._values["s3_import_role"] = s3_import_role
        if security_groups is not None:
            self._values["security_groups"] = security_groups
        if storage_type is not None:
            self._values["storage_type"] = storage_type
        if subnet_group is not None:
            self._values["subnet_group"] = subnet_group
        if vpc_placement is not None:
            self._values["vpc_placement"] = vpc_placement
        if vpc_subnets is not None:
            self._values["vpc_subnets"] = vpc_subnets
        if allocated_storage is not None:
            self._values["allocated_storage"] = allocated_storage
        if allow_major_version_upgrade is not None:
            self._values["allow_major_version_upgrade"] = allow_major_version_upgrade
        if database_name is not None:
            self._values["database_name"] = database_name
        if instance_type is not None:
            self._values["instance_type"] = instance_type
        if license_model is not None:
            self._values["license_model"] = license_model
        if parameters is not None:
            self._values["parameters"] = parameters
        if timezone is not None:
            self._values["timezone"] = timezone

    @builtins.property
    def vpc(self) -> _IVpc_6d1f76c4:
        '''(experimental) The VPC network where the DB subnet group should be created.

        :stability: experimental
        '''
        result = self._values.get("vpc")
        assert result is not None, "Required property 'vpc' is missing"
        return typing.cast(_IVpc_6d1f76c4, result)

    @builtins.property
    def auto_minor_version_upgrade(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates that minor engine upgrades are applied automatically to the DB instance during the maintenance window.

        :default: true

        :stability: experimental
        '''
        result = self._values.get("auto_minor_version_upgrade")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def availability_zone(self) -> typing.Optional[builtins.str]:
        '''(experimental) The name of the Availability Zone where the DB instance will be located.

        :default: - no preference

        :stability: experimental
        '''
        result = self._values.get("availability_zone")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def backup_retention(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) The number of days during which automatic DB snapshots are retained.

        Set to zero to disable backups.
        When creating a read replica, you must enable automatic backups on the source
        database instance by setting the backup retention to a value other than zero.

        :default: - Duration.days(1) for source instances, disabled for read replicas

        :stability: experimental
        '''
        result = self._values.get("backup_retention")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def cloudwatch_logs_exports(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) The list of log types that need to be enabled for exporting to CloudWatch Logs.

        :default: - no log exports

        :stability: experimental
        '''
        result = self._values.get("cloudwatch_logs_exports")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def cloudwatch_logs_retention(self) -> typing.Optional[_RetentionDays_6c560d31]:
        '''(experimental) The number of days log events are kept in CloudWatch Logs.

        When updating
        this property, unsetting it doesn't remove the log retention policy. To
        remove the retention policy, set the value to ``Infinity``.

        :default: - logs never expire

        :stability: experimental
        '''
        result = self._values.get("cloudwatch_logs_retention")
        return typing.cast(typing.Optional[_RetentionDays_6c560d31], result)

    @builtins.property
    def cloudwatch_logs_retention_role(self) -> typing.Optional[_IRole_59af6f50]:
        '''(experimental) The IAM role for the Lambda function associated with the custom resource that sets the retention policy.

        :default: - a new role is created.

        :stability: experimental
        '''
        result = self._values.get("cloudwatch_logs_retention_role")
        return typing.cast(typing.Optional[_IRole_59af6f50], result)

    @builtins.property
    def copy_tags_to_snapshot(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether to copy all of the user-defined tags from the DB instance to snapshots of the DB instance.

        :default: true

        :stability: experimental
        '''
        result = self._values.get("copy_tags_to_snapshot")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def delete_automated_backups(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether automated backups should be deleted or retained when you delete a DB instance.

        :default: false

        :stability: experimental
        '''
        result = self._values.get("delete_automated_backups")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def deletion_protection(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the DB instance should have deletion protection enabled.

        :default: - true if ``removalPolicy`` is RETAIN, false otherwise

        :stability: experimental
        '''
        result = self._values.get("deletion_protection")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def domain(self) -> typing.Optional[builtins.str]:
        '''(experimental) The Active Directory directory ID to create the DB instance in.

        :default: - Do not join domain

        :stability: experimental
        '''
        result = self._values.get("domain")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def domain_role(self) -> typing.Optional[_IRole_59af6f50]:
        '''(experimental) The IAM role to be used when making API calls to the Directory Service.

        The role needs the AWS-managed policy
        AmazonRDSDirectoryServiceAccess or equivalent.

        :default: - The role will be created for you if {@link DatabaseInstanceNewProps#domain} is specified

        :stability: experimental
        '''
        result = self._values.get("domain_role")
        return typing.cast(typing.Optional[_IRole_59af6f50], result)

    @builtins.property
    def enable_performance_insights(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Whether to enable Performance Insights for the DB instance.

        :default: - false, unless ``performanceInsightRentention`` or ``performanceInsightEncryptionKey`` is set.

        :stability: experimental
        '''
        result = self._values.get("enable_performance_insights")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def iam_authentication(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Whether to enable mapping of AWS Identity and Access Management (IAM) accounts to database accounts.

        :default: false

        :stability: experimental
        '''
        result = self._values.get("iam_authentication")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def instance_identifier(self) -> typing.Optional[builtins.str]:
        '''(experimental) A name for the DB instance.

        If you specify a name, AWS CloudFormation
        converts it to lowercase.

        :default: - a CloudFormation generated name

        :stability: experimental
        '''
        result = self._values.get("instance_identifier")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def iops(self) -> typing.Optional[jsii.Number]:
        '''(experimental) The number of I/O operations per second (IOPS) that the database provisions.

        The value must be equal to or greater than 1000.

        :default: - no provisioned iops

        :stability: experimental
        '''
        result = self._values.get("iops")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def max_allocated_storage(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Upper limit to which RDS can scale the storage in GiB(Gibibyte).

        :default: - No autoscaling of RDS instance

        :see: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PIOPS.StorageTypes.html#USER_PIOPS.Autoscaling
        :stability: experimental
        '''
        result = self._values.get("max_allocated_storage")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def monitoring_interval(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) The interval, in seconds, between points when Amazon RDS collects enhanced monitoring metrics for the DB instance.

        :default: - no enhanced monitoring

        :stability: experimental
        '''
        result = self._values.get("monitoring_interval")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def monitoring_role(self) -> typing.Optional[_IRole_59af6f50]:
        '''(experimental) Role that will be used to manage DB instance monitoring.

        :default: - A role is automatically created for you

        :stability: experimental
        '''
        result = self._values.get("monitoring_role")
        return typing.cast(typing.Optional[_IRole_59af6f50], result)

    @builtins.property
    def multi_az(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Specifies if the database instance is a multiple Availability Zone deployment.

        :default: false

        :stability: experimental
        '''
        result = self._values.get("multi_az")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def option_group(self) -> typing.Optional["IOptionGroup"]:
        '''(experimental) The option group to associate with the instance.

        :default: - no option group

        :stability: experimental
        '''
        result = self._values.get("option_group")
        return typing.cast(typing.Optional["IOptionGroup"], result)

    @builtins.property
    def parameter_group(self) -> typing.Optional["IParameterGroup"]:
        '''(experimental) The DB parameter group to associate with the instance.

        :default: - no parameter group

        :stability: experimental
        '''
        result = self._values.get("parameter_group")
        return typing.cast(typing.Optional["IParameterGroup"], result)

    @builtins.property
    def performance_insight_encryption_key(self) -> typing.Optional[_IKey_36930160]:
        '''(experimental) The AWS KMS key for encryption of Performance Insights data.

        :default: - default master key

        :stability: experimental
        '''
        result = self._values.get("performance_insight_encryption_key")
        return typing.cast(typing.Optional[_IKey_36930160], result)

    @builtins.property
    def performance_insight_retention(
        self,
    ) -> typing.Optional["PerformanceInsightRetention"]:
        '''(experimental) The amount of time, in days, to retain Performance Insights data.

        :default: 7

        :stability: experimental
        '''
        result = self._values.get("performance_insight_retention")
        return typing.cast(typing.Optional["PerformanceInsightRetention"], result)

    @builtins.property
    def port(self) -> typing.Optional[jsii.Number]:
        '''(experimental) The port for the instance.

        :default: - the default port for the chosen engine.

        :stability: experimental
        '''
        result = self._values.get("port")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def preferred_backup_window(self) -> typing.Optional[builtins.str]:
        '''(experimental) The daily time range during which automated backups are performed.

        Constraints:

        - Must be in the format ``hh24:mi-hh24:mi``.
        - Must be in Universal Coordinated Time (UTC).
        - Must not conflict with the preferred maintenance window.
        - Must be at least 30 minutes.

        :default:

        - a 30-minute window selected at random from an 8-hour block of
        time for each AWS Region. To see the time blocks available, see
        https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithAutomatedBackups.html#USER_WorkingWithAutomatedBackups.BackupWindow

        :stability: experimental
        '''
        result = self._values.get("preferred_backup_window")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def preferred_maintenance_window(self) -> typing.Optional[builtins.str]:
        '''(experimental) The weekly time range (in UTC) during which system maintenance can occur.

        Format: ``ddd:hh24:mi-ddd:hh24:mi``
        Constraint: Minimum 30-minute window

        :default:

        - a 30-minute window selected at random from an 8-hour block of
        time for each AWS Region, occurring on a random day of the week. To see
        the time blocks available, see https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_UpgradeDBInstance.Maintenance.html#Concepts.DBMaintenance

        :stability: experimental
        '''
        result = self._values.get("preferred_maintenance_window")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def processor_features(self) -> typing.Optional["ProcessorFeatures"]:
        '''(experimental) The number of CPU cores and the number of threads per core.

        :default:

        - the default number of CPU cores and threads per core for the
        chosen instance class.

        See https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html#USER_ConfigureProcessor

        :stability: experimental
        '''
        result = self._values.get("processor_features")
        return typing.cast(typing.Optional["ProcessorFeatures"], result)

    @builtins.property
    def publicly_accessible(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the DB instance is an internet-facing instance.

        :default: - ``true`` if ``vpcSubnets`` is ``subnetType: SubnetType.PUBLIC``, ``false`` otherwise

        :stability: experimental
        '''
        result = self._values.get("publicly_accessible")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def removal_policy(self) -> typing.Optional[_RemovalPolicy_c97e7a20]:
        '''(experimental) The CloudFormation policy to apply when the instance is removed from the stack or replaced during an update.

        :default: - RemovalPolicy.SNAPSHOT (remove the resource, but retain a snapshot of the data)

        :stability: experimental
        '''
        result = self._values.get("removal_policy")
        return typing.cast(typing.Optional[_RemovalPolicy_c97e7a20], result)

    @builtins.property
    def s3_export_buckets(self) -> typing.Optional[typing.List[_IBucket_73486e29]]:
        '''(experimental) S3 buckets that you want to load data into.

        This property must not be used if ``s3ExportRole`` is used.

        For Microsoft SQL Server:

        :default: - None

        :see: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/oracle-s3-integration.html
        :stability: experimental
        '''
        result = self._values.get("s3_export_buckets")
        return typing.cast(typing.Optional[typing.List[_IBucket_73486e29]], result)

    @builtins.property
    def s3_export_role(self) -> typing.Optional[_IRole_59af6f50]:
        '''(experimental) Role that will be associated with this DB instance to enable S3 export.

        This property must not be used if ``s3ExportBuckets`` is used.

        For Microsoft SQL Server:

        :default: - New role is created if ``s3ExportBuckets`` is set, no role is defined otherwise

        :see: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/oracle-s3-integration.html
        :stability: experimental
        '''
        result = self._values.get("s3_export_role")
        return typing.cast(typing.Optional[_IRole_59af6f50], result)

    @builtins.property
    def s3_import_buckets(self) -> typing.Optional[typing.List[_IBucket_73486e29]]:
        '''(experimental) S3 buckets that you want to load data from.

        This feature is only supported by the Microsoft SQL Server, Oracle, and PostgreSQL engines.

        This property must not be used if ``s3ImportRole`` is used.

        For Microsoft SQL Server:

        :default: - None

        :see: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/PostgreSQL.Procedural.Importing.html
        :stability: experimental
        '''
        result = self._values.get("s3_import_buckets")
        return typing.cast(typing.Optional[typing.List[_IBucket_73486e29]], result)

    @builtins.property
    def s3_import_role(self) -> typing.Optional[_IRole_59af6f50]:
        '''(experimental) Role that will be associated with this DB instance to enable S3 import.

        This feature is only supported by the Microsoft SQL Server, Oracle, and PostgreSQL engines.

        This property must not be used if ``s3ImportBuckets`` is used.

        For Microsoft SQL Server:

        :default: - New role is created if ``s3ImportBuckets`` is set, no role is defined otherwise

        :see: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/PostgreSQL.Procedural.Importing.html
        :stability: experimental
        '''
        result = self._values.get("s3_import_role")
        return typing.cast(typing.Optional[_IRole_59af6f50], result)

    @builtins.property
    def security_groups(self) -> typing.Optional[typing.List[_ISecurityGroup_cdbba9d3]]:
        '''(experimental) The security groups to assign to the DB instance.

        :default: - a new security group is created

        :stability: experimental
        '''
        result = self._values.get("security_groups")
        return typing.cast(typing.Optional[typing.List[_ISecurityGroup_cdbba9d3]], result)

    @builtins.property
    def storage_type(self) -> typing.Optional["StorageType"]:
        '''(experimental) The storage type.

        Storage types supported are gp2, io1, standard.

        :default: GP2

        :see: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Storage.html#Concepts.Storage.GeneralSSD
        :stability: experimental
        '''
        result = self._values.get("storage_type")
        return typing.cast(typing.Optional["StorageType"], result)

    @builtins.property
    def subnet_group(self) -> typing.Optional["ISubnetGroup"]:
        '''(experimental) Existing subnet group for the instance.

        :default: - a new subnet group will be created.

        :stability: experimental
        '''
        result = self._values.get("subnet_group")
        return typing.cast(typing.Optional["ISubnetGroup"], result)

    @builtins.property
    def vpc_placement(self) -> typing.Optional[_SubnetSelection_1284e62c]:
        '''(deprecated) The type of subnets to add to the created DB subnet group.

        :default: - private subnets

        :deprecated: use ``vpcSubnets``

        :stability: deprecated
        '''
        result = self._values.get("vpc_placement")
        return typing.cast(typing.Optional[_SubnetSelection_1284e62c], result)

    @builtins.property
    def vpc_subnets(self) -> typing.Optional[_SubnetSelection_1284e62c]:
        '''(experimental) The type of subnets to add to the created DB subnet group.

        :default: - private subnets

        :stability: experimental
        '''
        result = self._values.get("vpc_subnets")
        return typing.cast(typing.Optional[_SubnetSelection_1284e62c], result)

    @builtins.property
    def engine(self) -> "IInstanceEngine":
        '''(experimental) The database engine.

        :stability: experimental
        '''
        result = self._values.get("engine")
        assert result is not None, "Required property 'engine' is missing"
        return typing.cast("IInstanceEngine", result)

    @builtins.property
    def allocated_storage(self) -> typing.Optional[jsii.Number]:
        '''(experimental) The allocated storage size, specified in gigabytes (GB).

        :default: 100

        :stability: experimental
        '''
        result = self._values.get("allocated_storage")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def allow_major_version_upgrade(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Whether to allow major version upgrades.

        :default: false

        :stability: experimental
        '''
        result = self._values.get("allow_major_version_upgrade")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def database_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) The name of the database.

        :default: - no name

        :stability: experimental
        '''
        result = self._values.get("database_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def instance_type(self) -> typing.Optional[_InstanceType_072ad323]:
        '''(experimental) The name of the compute and memory capacity for the instance.

        :default: - m5.large (or, more specifically, db.m5.large)

        :stability: experimental
        '''
        result = self._values.get("instance_type")
        return typing.cast(typing.Optional[_InstanceType_072ad323], result)

    @builtins.property
    def license_model(self) -> typing.Optional["LicenseModel"]:
        '''(experimental) The license model.

        :default: - RDS default license model

        :stability: experimental
        '''
        result = self._values.get("license_model")
        return typing.cast(typing.Optional["LicenseModel"], result)

    @builtins.property
    def parameters(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''(experimental) The parameters in the DBParameterGroup to create automatically.

        You can only specify parameterGroup or parameters but not both.
        You need to use a versioned engine to auto-generate a DBParameterGroup.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("parameters")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def timezone(self) -> typing.Optional[builtins.str]:
        '''(experimental) The time zone of the instance.

        This is currently supported only by Microsoft Sql Server.

        :default: - RDS default timezone

        :stability: experimental
        '''
        result = self._values.get("timezone")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DatabaseInstanceSourceProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_rds.DatabaseProxyAttributes",
    jsii_struct_bases=[],
    name_mapping={
        "db_proxy_arn": "dbProxyArn",
        "db_proxy_name": "dbProxyName",
        "endpoint": "endpoint",
        "security_groups": "securityGroups",
    },
)
class DatabaseProxyAttributes:
    def __init__(
        self,
        *,
        db_proxy_arn: builtins.str,
        db_proxy_name: builtins.str,
        endpoint: builtins.str,
        security_groups: typing.Sequence[_ISecurityGroup_cdbba9d3],
    ) -> None:
        '''(experimental) Properties that describe an existing DB Proxy.

        :param db_proxy_arn: (experimental) DB Proxy ARN.
        :param db_proxy_name: (experimental) DB Proxy Name.
        :param endpoint: (experimental) Endpoint.
        :param security_groups: (experimental) The security groups of the instance.

        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_ec2 as ec2
            from monocdk import aws_rds as rds
            
            # security_group: ec2.SecurityGroup
            
            database_proxy_attributes = rds.DatabaseProxyAttributes(
                db_proxy_arn="dbProxyArn",
                db_proxy_name="dbProxyName",
                endpoint="endpoint",
                security_groups=[security_group]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3ba2a1dbbef0ddd5132e4d6504cf129a65440bbb9c5ce01a4eb19ec7affb8ff1)
            check_type(argname="argument db_proxy_arn", value=db_proxy_arn, expected_type=type_hints["db_proxy_arn"])
            check_type(argname="argument db_proxy_name", value=db_proxy_name, expected_type=type_hints["db_proxy_name"])
            check_type(argname="argument endpoint", value=endpoint, expected_type=type_hints["endpoint"])
            check_type(argname="argument security_groups", value=security_groups, expected_type=type_hints["security_groups"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "db_proxy_arn": db_proxy_arn,
            "db_proxy_name": db_proxy_name,
            "endpoint": endpoint,
            "security_groups": security_groups,
        }

    @builtins.property
    def db_proxy_arn(self) -> builtins.str:
        '''(experimental) DB Proxy ARN.

        :stability: experimental
        '''
        result = self._values.get("db_proxy_arn")
        assert result is not None, "Required property 'db_proxy_arn' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def db_proxy_name(self) -> builtins.str:
        '''(experimental) DB Proxy Name.

        :stability: experimental
        '''
        result = self._values.get("db_proxy_name")
        assert result is not None, "Required property 'db_proxy_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def endpoint(self) -> builtins.str:
        '''(experimental) Endpoint.

        :stability: experimental
        '''
        result = self._values.get("endpoint")
        assert result is not None, "Required property 'endpoint' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def security_groups(self) -> typing.List[_ISecurityGroup_cdbba9d3]:
        '''(experimental) The security groups of the instance.

        :stability: experimental
        '''
        result = self._values.get("security_groups")
        assert result is not None, "Required property 'security_groups' is missing"
        return typing.cast(typing.List[_ISecurityGroup_cdbba9d3], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DatabaseProxyAttributes(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_rds.DatabaseProxyOptions",
    jsii_struct_bases=[],
    name_mapping={
        "secrets": "secrets",
        "vpc": "vpc",
        "borrow_timeout": "borrowTimeout",
        "db_proxy_name": "dbProxyName",
        "debug_logging": "debugLogging",
        "iam_auth": "iamAuth",
        "idle_client_timeout": "idleClientTimeout",
        "init_query": "initQuery",
        "max_connections_percent": "maxConnectionsPercent",
        "max_idle_connections_percent": "maxIdleConnectionsPercent",
        "require_tls": "requireTLS",
        "role": "role",
        "security_groups": "securityGroups",
        "session_pinning_filters": "sessionPinningFilters",
        "vpc_subnets": "vpcSubnets",
    },
)
class DatabaseProxyOptions:
    def __init__(
        self,
        *,
        secrets: typing.Sequence[_ISecret_22fb8757],
        vpc: _IVpc_6d1f76c4,
        borrow_timeout: typing.Optional[_Duration_070aa057] = None,
        db_proxy_name: typing.Optional[builtins.str] = None,
        debug_logging: typing.Optional[builtins.bool] = None,
        iam_auth: typing.Optional[builtins.bool] = None,
        idle_client_timeout: typing.Optional[_Duration_070aa057] = None,
        init_query: typing.Optional[builtins.str] = None,
        max_connections_percent: typing.Optional[jsii.Number] = None,
        max_idle_connections_percent: typing.Optional[jsii.Number] = None,
        require_tls: typing.Optional[builtins.bool] = None,
        role: typing.Optional[_IRole_59af6f50] = None,
        security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
        session_pinning_filters: typing.Optional[typing.Sequence["SessionPinningFilter"]] = None,
        vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''(experimental) Options for a new DatabaseProxy.

        :param secrets: (experimental) The secret that the proxy uses to authenticate to the RDS DB instance or Aurora DB cluster. These secrets are stored within Amazon Secrets Manager. One or more secrets are required.
        :param vpc: (experimental) The VPC to associate with the new proxy.
        :param borrow_timeout: (experimental) The duration for a proxy to wait for a connection to become available in the connection pool. Only applies when the proxy has opened its maximum number of connections and all connections are busy with client sessions. Value must be between 1 second and 1 hour, or ``Duration.seconds(0)`` to represent unlimited. Default: cdk.Duration.seconds(120)
        :param db_proxy_name: (experimental) The identifier for the proxy. This name must be unique for all proxies owned by your AWS account in the specified AWS Region. An identifier must begin with a letter and must contain only ASCII letters, digits, and hyphens; it can't end with a hyphen or contain two consecutive hyphens. Default: - Generated by CloudFormation (recommended)
        :param debug_logging: (experimental) Whether the proxy includes detailed information about SQL statements in its logs. This information helps you to debug issues involving SQL behavior or the performance and scalability of the proxy connections. The debug information includes the text of SQL statements that you submit through the proxy. Thus, only enable this setting when needed for debugging, and only when you have security measures in place to safeguard any sensitive information that appears in the logs. Default: false
        :param iam_auth: (experimental) Whether to require or disallow AWS Identity and Access Management (IAM) authentication for connections to the proxy. Default: false
        :param idle_client_timeout: (experimental) The number of seconds that a connection to the proxy can be inactive before the proxy disconnects it. You can set this value higher or lower than the connection timeout limit for the associated database. Default: cdk.Duration.minutes(30)
        :param init_query: (experimental) One or more SQL statements for the proxy to run when opening each new database connection. Typically used with SET statements to make sure that each connection has identical settings such as time zone and character set. For multiple statements, use semicolons as the separator. You can also include multiple variables in a single SET statement, such as SET x=1, y=2. not currently supported for PostgreSQL. Default: - no initialization query
        :param max_connections_percent: (experimental) The maximum size of the connection pool for each target in a target group. For Aurora MySQL, it is expressed as a percentage of the max_connections setting for the RDS DB instance or Aurora DB cluster used by the target group. 1-100 Default: 100
        :param max_idle_connections_percent: (experimental) Controls how actively the proxy closes idle database connections in the connection pool. A high value enables the proxy to leave a high percentage of idle connections open. A low value causes the proxy to close idle client connections and return the underlying database connections to the connection pool. For Aurora MySQL, it is expressed as a percentage of the max_connections setting for the RDS DB instance or Aurora DB cluster used by the target group. between 0 and MaxConnectionsPercent Default: 50
        :param require_tls: (experimental) A Boolean parameter that specifies whether Transport Layer Security (TLS) encryption is required for connections to the proxy. By enabling this setting, you can enforce encrypted TLS connections to the proxy. Default: true
        :param role: (experimental) IAM role that the proxy uses to access secrets in AWS Secrets Manager. Default: - A role will automatically be created
        :param security_groups: (experimental) One or more VPC security groups to associate with the new proxy. Default: - No security groups
        :param session_pinning_filters: (experimental) Each item in the list represents a class of SQL operations that normally cause all later statements in a session using a proxy to be pinned to the same underlying database connection. Including an item in the list exempts that class of SQL operations from the pinning behavior. Default: - no session pinning filters
        :param vpc_subnets: (experimental) The subnets used by the proxy. Default: - the VPC default strategy if not specified.

        :stability: experimental
        :exampleMetadata: infused

        Example::

            # vpc: ec2.Vpc
            # security_group: ec2.SecurityGroup
            # secrets: List[secretsmanager.Secret[]]
            # db_instance: rds.DatabaseInstance
            
            
            proxy = db_instance.add_proxy("proxy",
                borrow_timeout=Duration.seconds(30),
                max_connections_percent=50,
                secrets=secrets,
                vpc=vpc
            )
        '''
        if isinstance(vpc_subnets, dict):
            vpc_subnets = _SubnetSelection_1284e62c(**vpc_subnets)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__22b95ec0c8fcd2e43cd6cc777e57247615ccad39445c198c6a3849f9ec288380)
            check_type(argname="argument secrets", value=secrets, expected_type=type_hints["secrets"])
            check_type(argname="argument vpc", value=vpc, expected_type=type_hints["vpc"])
            check_type(argname="argument borrow_timeout", value=borrow_timeout, expected_type=type_hints["borrow_timeout"])
            check_type(argname="argument db_proxy_name", value=db_proxy_name, expected_type=type_hints["db_proxy_name"])
            check_type(argname="argument debug_logging", value=debug_logging, expected_type=type_hints["debug_logging"])
            check_type(argname="argument iam_auth", value=iam_auth, expected_type=type_hints["iam_auth"])
            check_type(argname="argument idle_client_timeout", value=idle_client_timeout, expected_type=type_hints["idle_client_timeout"])
            check_type(argname="argument init_query", value=init_query, expected_type=type_hints["init_query"])
            check_type(argname="argument max_connections_percent", value=max_connections_percent, expected_type=type_hints["max_connections_percent"])
            check_type(argname="argument max_idle_connections_percent", value=max_idle_connections_percent, expected_type=type_hints["max_idle_connections_percent"])
            check_type(argname="argument require_tls", value=require_tls, expected_type=type_hints["require_tls"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            check_type(argname="argument security_groups", value=security_groups, expected_type=type_hints["security_groups"])
            check_type(argname="argument session_pinning_filters", value=session_pinning_filters, expected_type=type_hints["session_pinning_filters"])
            check_type(argname="argument vpc_subnets", value=vpc_subnets, expected_type=type_hints["vpc_subnets"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "secrets": secrets,
            "vpc": vpc,
        }
        if borrow_timeout is not None:
            self._values["borrow_timeout"] = borrow_timeout
        if db_proxy_name is not None:
            self._values["db_proxy_name"] = db_proxy_name
        if debug_logging is not None:
            self._values["debug_logging"] = debug_logging
        if iam_auth is not None:
            self._values["iam_auth"] = iam_auth
        if idle_client_timeout is not None:
            self._values["idle_client_timeout"] = idle_client_timeout
        if init_query is not None:
            self._values["init_query"] = init_query
        if max_connections_percent is not None:
            self._values["max_connections_percent"] = max_connections_percent
        if max_idle_connections_percent is not None:
            self._values["max_idle_connections_percent"] = max_idle_connections_percent
        if require_tls is not None:
            self._values["require_tls"] = require_tls
        if role is not None:
            self._values["role"] = role
        if security_groups is not None:
            self._values["security_groups"] = security_groups
        if session_pinning_filters is not None:
            self._values["session_pinning_filters"] = session_pinning_filters
        if vpc_subnets is not None:
            self._values["vpc_subnets"] = vpc_subnets

    @builtins.property
    def secrets(self) -> typing.List[_ISecret_22fb8757]:
        '''(experimental) The secret that the proxy uses to authenticate to the RDS DB instance or Aurora DB cluster.

        These secrets are stored within Amazon Secrets Manager.
        One or more secrets are required.

        :stability: experimental
        '''
        result = self._values.get("secrets")
        assert result is not None, "Required property 'secrets' is missing"
        return typing.cast(typing.List[_ISecret_22fb8757], result)

    @builtins.property
    def vpc(self) -> _IVpc_6d1f76c4:
        '''(experimental) The VPC to associate with the new proxy.

        :stability: experimental
        '''
        result = self._values.get("vpc")
        assert result is not None, "Required property 'vpc' is missing"
        return typing.cast(_IVpc_6d1f76c4, result)

    @builtins.property
    def borrow_timeout(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) The duration for a proxy to wait for a connection to become available in the connection pool.

        Only applies when the proxy has opened its maximum number of connections and all connections are busy with client
        sessions.

        Value must be between 1 second and 1 hour, or ``Duration.seconds(0)`` to represent unlimited.

        :default: cdk.Duration.seconds(120)

        :stability: experimental
        '''
        result = self._values.get("borrow_timeout")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def db_proxy_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) The identifier for the proxy.

        This name must be unique for all proxies owned by your AWS account in the specified AWS Region.
        An identifier must begin with a letter and must contain only ASCII letters, digits, and hyphens;
        it can't end with a hyphen or contain two consecutive hyphens.

        :default: - Generated by CloudFormation (recommended)

        :stability: experimental
        '''
        result = self._values.get("db_proxy_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def debug_logging(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Whether the proxy includes detailed information about SQL statements in its logs.

        This information helps you to debug issues involving SQL behavior or the performance and scalability of the proxy connections.
        The debug information includes the text of SQL statements that you submit through the proxy.
        Thus, only enable this setting when needed for debugging, and only when you have security measures in place to safeguard any sensitive
        information that appears in the logs.

        :default: false

        :stability: experimental
        '''
        result = self._values.get("debug_logging")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def iam_auth(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Whether to require or disallow AWS Identity and Access Management (IAM) authentication for connections to the proxy.

        :default: false

        :stability: experimental
        '''
        result = self._values.get("iam_auth")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def idle_client_timeout(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) The number of seconds that a connection to the proxy can be inactive before the proxy disconnects it.

        You can set this value higher or lower than the connection timeout limit for the associated database.

        :default: cdk.Duration.minutes(30)

        :stability: experimental
        '''
        result = self._values.get("idle_client_timeout")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def init_query(self) -> typing.Optional[builtins.str]:
        '''(experimental) One or more SQL statements for the proxy to run when opening each new database connection.

        Typically used with SET statements to make sure that each connection has identical settings such as time zone
        and character set.
        For multiple statements, use semicolons as the separator.
        You can also include multiple variables in a single SET statement, such as SET x=1, y=2.

        not currently supported for PostgreSQL.

        :default: - no initialization query

        :stability: experimental
        '''
        result = self._values.get("init_query")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def max_connections_percent(self) -> typing.Optional[jsii.Number]:
        '''(experimental) The maximum size of the connection pool for each target in a target group.

        For Aurora MySQL, it is expressed as a percentage of the max_connections setting for the RDS DB instance or Aurora DB
        cluster used by the target group.

        1-100

        :default: 100

        :stability: experimental
        '''
        result = self._values.get("max_connections_percent")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def max_idle_connections_percent(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Controls how actively the proxy closes idle database connections in the connection pool.

        A high value enables the proxy to leave a high percentage of idle connections open.
        A low value causes the proxy to close idle client connections and return the underlying database connections
        to the connection pool.
        For Aurora MySQL, it is expressed as a percentage of the max_connections setting for the RDS DB instance
        or Aurora DB cluster used by the target group.

        between 0 and MaxConnectionsPercent

        :default: 50

        :stability: experimental
        '''
        result = self._values.get("max_idle_connections_percent")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def require_tls(self) -> typing.Optional[builtins.bool]:
        '''(experimental) A Boolean parameter that specifies whether Transport Layer Security (TLS) encryption is required for connections to the proxy.

        By enabling this setting, you can enforce encrypted TLS connections to the proxy.

        :default: true

        :stability: experimental
        '''
        result = self._values.get("require_tls")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def role(self) -> typing.Optional[_IRole_59af6f50]:
        '''(experimental) IAM role that the proxy uses to access secrets in AWS Secrets Manager.

        :default: - A role will automatically be created

        :stability: experimental
        '''
        result = self._values.get("role")
        return typing.cast(typing.Optional[_IRole_59af6f50], result)

    @builtins.property
    def security_groups(self) -> typing.Optional[typing.List[_ISecurityGroup_cdbba9d3]]:
        '''(experimental) One or more VPC security groups to associate with the new proxy.

        :default: - No security groups

        :stability: experimental
        '''
        result = self._values.get("security_groups")
        return typing.cast(typing.Optional[typing.List[_ISecurityGroup_cdbba9d3]], result)

    @builtins.property
    def session_pinning_filters(
        self,
    ) -> typing.Optional[typing.List["SessionPinningFilter"]]:
        '''(experimental) Each item in the list represents a class of SQL operations that normally cause all later statements in a session using a proxy to be pinned to the same underlying database connection.

        Including an item in the list exempts that class of SQL operations from the pinning behavior.

        :default: - no session pinning filters

        :stability: experimental
        '''
        result = self._values.get("session_pinning_filters")
        return typing.cast(typing.Optional[typing.List["SessionPinningFilter"]], result)

    @builtins.property
    def vpc_subnets(self) -> typing.Optional[_SubnetSelection_1284e62c]:
        '''(experimental) The subnets used by the proxy.

        :default: - the VPC default strategy if not specified.

        :stability: experimental
        '''
        result = self._values.get("vpc_subnets")
        return typing.cast(typing.Optional[_SubnetSelection_1284e62c], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DatabaseProxyOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_rds.DatabaseProxyProps",
    jsii_struct_bases=[DatabaseProxyOptions],
    name_mapping={
        "secrets": "secrets",
        "vpc": "vpc",
        "borrow_timeout": "borrowTimeout",
        "db_proxy_name": "dbProxyName",
        "debug_logging": "debugLogging",
        "iam_auth": "iamAuth",
        "idle_client_timeout": "idleClientTimeout",
        "init_query": "initQuery",
        "max_connections_percent": "maxConnectionsPercent",
        "max_idle_connections_percent": "maxIdleConnectionsPercent",
        "require_tls": "requireTLS",
        "role": "role",
        "security_groups": "securityGroups",
        "session_pinning_filters": "sessionPinningFilters",
        "vpc_subnets": "vpcSubnets",
        "proxy_target": "proxyTarget",
    },
)
class DatabaseProxyProps(DatabaseProxyOptions):
    def __init__(
        self,
        *,
        secrets: typing.Sequence[_ISecret_22fb8757],
        vpc: _IVpc_6d1f76c4,
        borrow_timeout: typing.Optional[_Duration_070aa057] = None,
        db_proxy_name: typing.Optional[builtins.str] = None,
        debug_logging: typing.Optional[builtins.bool] = None,
        iam_auth: typing.Optional[builtins.bool] = None,
        idle_client_timeout: typing.Optional[_Duration_070aa057] = None,
        init_query: typing.Optional[builtins.str] = None,
        max_connections_percent: typing.Optional[jsii.Number] = None,
        max_idle_connections_percent: typing.Optional[jsii.Number] = None,
        require_tls: typing.Optional[builtins.bool] = None,
        role: typing.Optional[_IRole_59af6f50] = None,
        security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
        session_pinning_filters: typing.Optional[typing.Sequence["SessionPinningFilter"]] = None,
        vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
        proxy_target: "ProxyTarget",
    ) -> None:
        '''(experimental) Construction properties for a DatabaseProxy.

        :param secrets: (experimental) The secret that the proxy uses to authenticate to the RDS DB instance or Aurora DB cluster. These secrets are stored within Amazon Secrets Manager. One or more secrets are required.
        :param vpc: (experimental) The VPC to associate with the new proxy.
        :param borrow_timeout: (experimental) The duration for a proxy to wait for a connection to become available in the connection pool. Only applies when the proxy has opened its maximum number of connections and all connections are busy with client sessions. Value must be between 1 second and 1 hour, or ``Duration.seconds(0)`` to represent unlimited. Default: cdk.Duration.seconds(120)
        :param db_proxy_name: (experimental) The identifier for the proxy. This name must be unique for all proxies owned by your AWS account in the specified AWS Region. An identifier must begin with a letter and must contain only ASCII letters, digits, and hyphens; it can't end with a hyphen or contain two consecutive hyphens. Default: - Generated by CloudFormation (recommended)
        :param debug_logging: (experimental) Whether the proxy includes detailed information about SQL statements in its logs. This information helps you to debug issues involving SQL behavior or the performance and scalability of the proxy connections. The debug information includes the text of SQL statements that you submit through the proxy. Thus, only enable this setting when needed for debugging, and only when you have security measures in place to safeguard any sensitive information that appears in the logs. Default: false
        :param iam_auth: (experimental) Whether to require or disallow AWS Identity and Access Management (IAM) authentication for connections to the proxy. Default: false
        :param idle_client_timeout: (experimental) The number of seconds that a connection to the proxy can be inactive before the proxy disconnects it. You can set this value higher or lower than the connection timeout limit for the associated database. Default: cdk.Duration.minutes(30)
        :param init_query: (experimental) One or more SQL statements for the proxy to run when opening each new database connection. Typically used with SET statements to make sure that each connection has identical settings such as time zone and character set. For multiple statements, use semicolons as the separator. You can also include multiple variables in a single SET statement, such as SET x=1, y=2. not currently supported for PostgreSQL. Default: - no initialization query
        :param max_connections_percent: (experimental) The maximum size of the connection pool for each target in a target group. For Aurora MySQL, it is expressed as a percentage of the max_connections setting for the RDS DB instance or Aurora DB cluster used by the target group. 1-100 Default: 100
        :param max_idle_connections_percent: (experimental) Controls how actively the proxy closes idle database connections in the connection pool. A high value enables the proxy to leave a high percentage of idle connections open. A low value causes the proxy to close idle client connections and return the underlying database connections to the connection pool. For Aurora MySQL, it is expressed as a percentage of the max_connections setting for the RDS DB instance or Aurora DB cluster used by the target group. between 0 and MaxConnectionsPercent Default: 50
        :param require_tls: (experimental) A Boolean parameter that specifies whether Transport Layer Security (TLS) encryption is required for connections to the proxy. By enabling this setting, you can enforce encrypted TLS connections to the proxy. Default: true
        :param role: (experimental) IAM role that the proxy uses to access secrets in AWS Secrets Manager. Default: - A role will automatically be created
        :param security_groups: (experimental) One or more VPC security groups to associate with the new proxy. Default: - No security groups
        :param session_pinning_filters: (experimental) Each item in the list represents a class of SQL operations that normally cause all later statements in a session using a proxy to be pinned to the same underlying database connection. Including an item in the list exempts that class of SQL operations from the pinning behavior. Default: - no session pinning filters
        :param vpc_subnets: (experimental) The subnets used by the proxy. Default: - the VPC default strategy if not specified.
        :param proxy_target: (experimental) DB proxy target: Instance or Cluster.

        :stability: experimental
        :exampleMetadata: infused

        Example::

            # vpc: ec2.Vpc
            
            cluster = rds.DatabaseCluster(self, "Database",
                engine=rds.DatabaseClusterEngine.AURORA,
                instance_props=ec2.aws_rds.InstanceProps(vpc=vpc)
            )
            
            proxy = rds.DatabaseProxy(self, "Proxy",
                proxy_target=rds.ProxyTarget.from_cluster(cluster),
                secrets=[cluster.secret],
                vpc=vpc
            )
            
            role = iam.Role(self, "DBProxyRole", assumed_by=iam.AccountPrincipal(self.account))
            proxy.grant_connect(role, "admin")
        '''
        if isinstance(vpc_subnets, dict):
            vpc_subnets = _SubnetSelection_1284e62c(**vpc_subnets)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c4c0e996d5f4d6be1c6c0db0738431606cef8515b906fb5ac9b650b411f39e1a)
            check_type(argname="argument secrets", value=secrets, expected_type=type_hints["secrets"])
            check_type(argname="argument vpc", value=vpc, expected_type=type_hints["vpc"])
            check_type(argname="argument borrow_timeout", value=borrow_timeout, expected_type=type_hints["borrow_timeout"])
            check_type(argname="argument db_proxy_name", value=db_proxy_name, expected_type=type_hints["db_proxy_name"])
            check_type(argname="argument debug_logging", value=debug_logging, expected_type=type_hints["debug_logging"])
            check_type(argname="argument iam_auth", value=iam_auth, expected_type=type_hints["iam_auth"])
            check_type(argname="argument idle_client_timeout", value=idle_client_timeout, expected_type=type_hints["idle_client_timeout"])
            check_type(argname="argument init_query", value=init_query, expected_type=type_hints["init_query"])
            check_type(argname="argument max_connections_percent", value=max_connections_percent, expected_type=type_hints["max_connections_percent"])
            check_type(argname="argument max_idle_connections_percent", value=max_idle_connections_percent, expected_type=type_hints["max_idle_connections_percent"])
            check_type(argname="argument require_tls", value=require_tls, expected_type=type_hints["require_tls"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            check_type(argname="argument security_groups", value=security_groups, expected_type=type_hints["security_groups"])
            check_type(argname="argument session_pinning_filters", value=session_pinning_filters, expected_type=type_hints["session_pinning_filters"])
            check_type(argname="argument vpc_subnets", value=vpc_subnets, expected_type=type_hints["vpc_subnets"])
            check_type(argname="argument proxy_target", value=proxy_target, expected_type=type_hints["proxy_target"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "secrets": secrets,
            "vpc": vpc,
            "proxy_target": proxy_target,
        }
        if borrow_timeout is not None:
            self._values["borrow_timeout"] = borrow_timeout
        if db_proxy_name is not None:
            self._values["db_proxy_name"] = db_proxy_name
        if debug_logging is not None:
            self._values["debug_logging"] = debug_logging
        if iam_auth is not None:
            self._values["iam_auth"] = iam_auth
        if idle_client_timeout is not None:
            self._values["idle_client_timeout"] = idle_client_timeout
        if init_query is not None:
            self._values["init_query"] = init_query
        if max_connections_percent is not None:
            self._values["max_connections_percent"] = max_connections_percent
        if max_idle_connections_percent is not None:
            self._values["max_idle_connections_percent"] = max_idle_connections_percent
        if require_tls is not None:
            self._values["require_tls"] = require_tls
        if role is not None:
            self._values["role"] = role
        if security_groups is not None:
            self._values["security_groups"] = security_groups
        if session_pinning_filters is not None:
            self._values["session_pinning_filters"] = session_pinning_filters
        if vpc_subnets is not None:
            self._values["vpc_subnets"] = vpc_subnets

    @builtins.property
    def secrets(self) -> typing.List[_ISecret_22fb8757]:
        '''(experimental) The secret that the proxy uses to authenticate to the RDS DB instance or Aurora DB cluster.

        These secrets are stored within Amazon Secrets Manager.
        One or more secrets are required.

        :stability: experimental
        '''
        result = self._values.get("secrets")
        assert result is not None, "Required property 'secrets' is missing"
        return typing.cast(typing.List[_ISecret_22fb8757], result)

    @builtins.property
    def vpc(self) -> _IVpc_6d1f76c4:
        '''(experimental) The VPC to associate with the new proxy.

        :stability: experimental
        '''
        result = self._values.get("vpc")
        assert result is not None, "Required property 'vpc' is missing"
        return typing.cast(_IVpc_6d1f76c4, result)

    @builtins.property
    def borrow_timeout(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) The duration for a proxy to wait for a connection to become available in the connection pool.

        Only applies when the proxy has opened its maximum number of connections and all connections are busy with client
        sessions.

        Value must be between 1 second and 1 hour, or ``Duration.seconds(0)`` to represent unlimited.

        :default: cdk.Duration.seconds(120)

        :stability: experimental
        '''
        result = self._values.get("borrow_timeout")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def db_proxy_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) The identifier for the proxy.

        This name must be unique for all proxies owned by your AWS account in the specified AWS Region.
        An identifier must begin with a letter and must contain only ASCII letters, digits, and hyphens;
        it can't end with a hyphen or contain two consecutive hyphens.

        :default: - Generated by CloudFormation (recommended)

        :stability: experimental
        '''
        result = self._values.get("db_proxy_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def debug_logging(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Whether the proxy includes detailed information about SQL statements in its logs.

        This information helps you to debug issues involving SQL behavior or the performance and scalability of the proxy connections.
        The debug information includes the text of SQL statements that you submit through the proxy.
        Thus, only enable this setting when needed for debugging, and only when you have security measures in place to safeguard any sensitive
        information that appears in the logs.

        :default: false

        :stability: experimental
        '''
        result = self._values.get("debug_logging")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def iam_auth(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Whether to require or disallow AWS Identity and Access Management (IAM) authentication for connections to the proxy.

        :default: false

        :stability: experimental
        '''
        result = self._values.get("iam_auth")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def idle_client_timeout(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) The number of seconds that a connection to the proxy can be inactive before the proxy disconnects it.

        You can set this value higher or lower than the connection timeout limit for the associated database.

        :default: cdk.Duration.minutes(30)

        :stability: experimental
        '''
        result = self._values.get("idle_client_timeout")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def init_query(self) -> typing.Optional[builtins.str]:
        '''(experimental) One or more SQL statements for the proxy to run when opening each new database connection.

        Typically used with SET statements to make sure that each connection has identical settings such as time zone
        and character set.
        For multiple statements, use semicolons as the separator.
        You can also include multiple variables in a single SET statement, such as SET x=1, y=2.

        not currently supported for PostgreSQL.

        :default: - no initialization query

        :stability: experimental
        '''
        result = self._values.get("init_query")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def max_connections_percent(self) -> typing.Optional[jsii.Number]:
        '''(experimental) The maximum size of the connection pool for each target in a target group.

        For Aurora MySQL, it is expressed as a percentage of the max_connections setting for the RDS DB instance or Aurora DB
        cluster used by the target group.

        1-100

        :default: 100

        :stability: experimental
        '''
        result = self._values.get("max_connections_percent")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def max_idle_connections_percent(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Controls how actively the proxy closes idle database connections in the connection pool.

        A high value enables the proxy to leave a high percentage of idle connections open.
        A low value causes the proxy to close idle client connections and return the underlying database connections
        to the connection pool.
        For Aurora MySQL, it is expressed as a percentage of the max_connections setting for the RDS DB instance
        or Aurora DB cluster used by the target group.

        between 0 and MaxConnectionsPercent

        :default: 50

        :stability: experimental
        '''
        result = self._values.get("max_idle_connections_percent")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def require_tls(self) -> typing.Optional[builtins.bool]:
        '''(experimental) A Boolean parameter that specifies whether Transport Layer Security (TLS) encryption is required for connections to the proxy.

        By enabling this setting, you can enforce encrypted TLS connections to the proxy.

        :default: true

        :stability: experimental
        '''
        result = self._values.get("require_tls")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def role(self) -> typing.Optional[_IRole_59af6f50]:
        '''(experimental) IAM role that the proxy uses to access secrets in AWS Secrets Manager.

        :default: - A role will automatically be created

        :stability: experimental
        '''
        result = self._values.get("role")
        return typing.cast(typing.Optional[_IRole_59af6f50], result)

    @builtins.property
    def security_groups(self) -> typing.Optional[typing.List[_ISecurityGroup_cdbba9d3]]:
        '''(experimental) One or more VPC security groups to associate with the new proxy.

        :default: - No security groups

        :stability: experimental
        '''
        result = self._values.get("security_groups")
        return typing.cast(typing.Optional[typing.List[_ISecurityGroup_cdbba9d3]], result)

    @builtins.property
    def session_pinning_filters(
        self,
    ) -> typing.Optional[typing.List["SessionPinningFilter"]]:
        '''(experimental) Each item in the list represents a class of SQL operations that normally cause all later statements in a session using a proxy to be pinned to the same underlying database connection.

        Including an item in the list exempts that class of SQL operations from the pinning behavior.

        :default: - no session pinning filters

        :stability: experimental
        '''
        result = self._values.get("session_pinning_filters")
        return typing.cast(typing.Optional[typing.List["SessionPinningFilter"]], result)

    @builtins.property
    def vpc_subnets(self) -> typing.Optional[_SubnetSelection_1284e62c]:
        '''(experimental) The subnets used by the proxy.

        :default: - the VPC default strategy if not specified.

        :stability: experimental
        '''
        result = self._values.get("vpc_subnets")
        return typing.cast(typing.Optional[_SubnetSelection_1284e62c], result)

    @builtins.property
    def proxy_target(self) -> "ProxyTarget":
        '''(experimental) DB proxy target: Instance or Cluster.

        :stability: experimental
        '''
        result = self._values.get("proxy_target")
        assert result is not None, "Required property 'proxy_target' is missing"
        return typing.cast("ProxyTarget", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DatabaseProxyProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DatabaseSecret(
    _Secret_cb33d4cc,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_rds.DatabaseSecret",
):
    '''(experimental) A database secret.

    :stability: experimental
    :resource: AWS::SecretsManager::Secret
    :exampleMetadata: infused

    Example::

        # Build a data source for AppSync to access the database.
        # api: appsync.GraphqlApi
        # Create username and password secret for DB Cluster
        secret = rds.DatabaseSecret(self, "AuroraSecret",
            username="clusteradmin"
        )
        
        # The VPC to place the cluster in
        vpc = ec2.Vpc(self, "AuroraVpc")
        
        # Create the serverless cluster, provide all values needed to customise the database.
        cluster = rds.ServerlessCluster(self, "AuroraCluster",
            engine=rds.DatabaseClusterEngine.AURORA_MYSQL,
            vpc=vpc,
            credentials={"username": "clusteradmin"},
            cluster_identifier="db-endpoint-test",
            default_database_name="demos"
        )
        rds_dS = api.add_rds_data_source("rds", cluster, secret, "demos")
        
        # Set up a resolver for an RDS query.
        rds_dS.create_resolver(
            type_name="Query",
            field_name="getDemosRds",
            request_mapping_template=appsync.MappingTemplate.from_string("""
                  {
                    "version": "2018-05-29",
                    "statements": [
                      "SELECT * FROM demos"
                    ]
                  }
                  """),
            response_mapping_template=appsync.MappingTemplate.from_string("""
                    $utils.toJson($utils.rds.toJsonObject($ctx.result)[0])
                  """)
        )
        
        # Set up a resolver for an RDS mutation.
        rds_dS.create_resolver(
            type_name="Mutation",
            field_name="addDemoRds",
            request_mapping_template=appsync.MappingTemplate.from_string("""
                  {
                    "version": "2018-05-29",
                    "statements": [
                      "INSERT INTO demos VALUES (:id, :version)",
                      "SELECT * WHERE id = :id"
                    ],
                    "variableMap": {
                      ":id": $util.toJson($util.autoId()),
                      ":version": $util.toJson($ctx.args.version)
                    }
                  }
                  """),
            response_mapping_template=appsync.MappingTemplate.from_string("""
                    $utils.toJson($utils.rds.toJsonObject($ctx.result)[1][0])
                  """)
        )
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        username: builtins.str,
        encryption_key: typing.Optional[_IKey_36930160] = None,
        exclude_characters: typing.Optional[builtins.str] = None,
        master_secret: typing.Optional[_ISecret_22fb8757] = None,
        replace_on_password_criteria_changes: typing.Optional[builtins.bool] = None,
        replica_regions: typing.Optional[typing.Sequence[typing.Union[_ReplicaRegion_ad1a6d2e, typing.Dict[builtins.str, typing.Any]]]] = None,
        secret_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param username: (experimental) The username.
        :param encryption_key: (experimental) The KMS key to use to encrypt the secret. Default: default master key
        :param exclude_characters: (experimental) Characters to not include in the generated password. Default: " %+~`#$&*()|[]{}:;<>?!'/
        :param master_secret: (experimental) The master secret which will be used to rotate this secret. Default: - no master secret information will be included
        :param replace_on_password_criteria_changes: (experimental) Whether to replace this secret when the criteria for the password change. This is achieved by overriding the logical id of the AWS::SecretsManager::Secret with a hash of the options that influence the password generation. This way a new secret will be created when the password is regenerated and the cluster or instance consuming this secret will have its credentials updated. Default: false
        :param replica_regions: (experimental) A list of regions where to replicate this secret. Default: - Secret is not replicated
        :param secret_name: (experimental) A name for the secret. Default: - A name is generated by CloudFormation.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__35939bd400f370e8fbc6d6a25e87466fc4592a5ac435ab1de7a830e9ea153538)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = DatabaseSecretProps(
            username=username,
            encryption_key=encryption_key,
            exclude_characters=exclude_characters,
            master_secret=master_secret,
            replace_on_password_criteria_changes=replace_on_password_criteria_changes,
            replica_regions=replica_regions,
            secret_name=secret_name,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="monocdk.aws_rds.DatabaseSecretProps",
    jsii_struct_bases=[],
    name_mapping={
        "username": "username",
        "encryption_key": "encryptionKey",
        "exclude_characters": "excludeCharacters",
        "master_secret": "masterSecret",
        "replace_on_password_criteria_changes": "replaceOnPasswordCriteriaChanges",
        "replica_regions": "replicaRegions",
        "secret_name": "secretName",
    },
)
class DatabaseSecretProps:
    def __init__(
        self,
        *,
        username: builtins.str,
        encryption_key: typing.Optional[_IKey_36930160] = None,
        exclude_characters: typing.Optional[builtins.str] = None,
        master_secret: typing.Optional[_ISecret_22fb8757] = None,
        replace_on_password_criteria_changes: typing.Optional[builtins.bool] = None,
        replica_regions: typing.Optional[typing.Sequence[typing.Union[_ReplicaRegion_ad1a6d2e, typing.Dict[builtins.str, typing.Any]]]] = None,
        secret_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''(experimental) Construction properties for a DatabaseSecret.

        :param username: (experimental) The username.
        :param encryption_key: (experimental) The KMS key to use to encrypt the secret. Default: default master key
        :param exclude_characters: (experimental) Characters to not include in the generated password. Default: " %+~`#$&*()|[]{}:;<>?!'/
        :param master_secret: (experimental) The master secret which will be used to rotate this secret. Default: - no master secret information will be included
        :param replace_on_password_criteria_changes: (experimental) Whether to replace this secret when the criteria for the password change. This is achieved by overriding the logical id of the AWS::SecretsManager::Secret with a hash of the options that influence the password generation. This way a new secret will be created when the password is regenerated and the cluster or instance consuming this secret will have its credentials updated. Default: false
        :param replica_regions: (experimental) A list of regions where to replicate this secret. Default: - Secret is not replicated
        :param secret_name: (experimental) A name for the secret. Default: - A name is generated by CloudFormation.

        :stability: experimental
        :exampleMetadata: infused

        Example::

            # Build a data source for AppSync to access the database.
            # api: appsync.GraphqlApi
            # Create username and password secret for DB Cluster
            secret = rds.DatabaseSecret(self, "AuroraSecret",
                username="clusteradmin"
            )
            
            # The VPC to place the cluster in
            vpc = ec2.Vpc(self, "AuroraVpc")
            
            # Create the serverless cluster, provide all values needed to customise the database.
            cluster = rds.ServerlessCluster(self, "AuroraCluster",
                engine=rds.DatabaseClusterEngine.AURORA_MYSQL,
                vpc=vpc,
                credentials={"username": "clusteradmin"},
                cluster_identifier="db-endpoint-test",
                default_database_name="demos"
            )
            rds_dS = api.add_rds_data_source("rds", cluster, secret, "demos")
            
            # Set up a resolver for an RDS query.
            rds_dS.create_resolver(
                type_name="Query",
                field_name="getDemosRds",
                request_mapping_template=appsync.MappingTemplate.from_string("""
                      {
                        "version": "2018-05-29",
                        "statements": [
                          "SELECT * FROM demos"
                        ]
                      }
                      """),
                response_mapping_template=appsync.MappingTemplate.from_string("""
                        $utils.toJson($utils.rds.toJsonObject($ctx.result)[0])
                      """)
            )
            
            # Set up a resolver for an RDS mutation.
            rds_dS.create_resolver(
                type_name="Mutation",
                field_name="addDemoRds",
                request_mapping_template=appsync.MappingTemplate.from_string("""
                      {
                        "version": "2018-05-29",
                        "statements": [
                          "INSERT INTO demos VALUES (:id, :version)",
                          "SELECT * WHERE id = :id"
                        ],
                        "variableMap": {
                          ":id": $util.toJson($util.autoId()),
                          ":version": $util.toJson($ctx.args.version)
                        }
                      }
                      """),
                response_mapping_template=appsync.MappingTemplate.from_string("""
                        $utils.toJson($utils.rds.toJsonObject($ctx.result)[1][0])
                      """)
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__65b5ea5de1c30596b896d43622fdfde204227ada6b54015cd2cfe4a08251a13d)
            check_type(argname="argument username", value=username, expected_type=type_hints["username"])
            check_type(argname="argument encryption_key", value=encryption_key, expected_type=type_hints["encryption_key"])
            check_type(argname="argument exclude_characters", value=exclude_characters, expected_type=type_hints["exclude_characters"])
            check_type(argname="argument master_secret", value=master_secret, expected_type=type_hints["master_secret"])
            check_type(argname="argument replace_on_password_criteria_changes", value=replace_on_password_criteria_changes, expected_type=type_hints["replace_on_password_criteria_changes"])
            check_type(argname="argument replica_regions", value=replica_regions, expected_type=type_hints["replica_regions"])
            check_type(argname="argument secret_name", value=secret_name, expected_type=type_hints["secret_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "username": username,
        }
        if encryption_key is not None:
            self._values["encryption_key"] = encryption_key
        if exclude_characters is not None:
            self._values["exclude_characters"] = exclude_characters
        if master_secret is not None:
            self._values["master_secret"] = master_secret
        if replace_on_password_criteria_changes is not None:
            self._values["replace_on_password_criteria_changes"] = replace_on_password_criteria_changes
        if replica_regions is not None:
            self._values["replica_regions"] = replica_regions
        if secret_name is not None:
            self._values["secret_name"] = secret_name

    @builtins.property
    def username(self) -> builtins.str:
        '''(experimental) The username.

        :stability: experimental
        '''
        result = self._values.get("username")
        assert result is not None, "Required property 'username' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def encryption_key(self) -> typing.Optional[_IKey_36930160]:
        '''(experimental) The KMS key to use to encrypt the secret.

        :default: default master key

        :stability: experimental
        '''
        result = self._values.get("encryption_key")
        return typing.cast(typing.Optional[_IKey_36930160], result)

    @builtins.property
    def exclude_characters(self) -> typing.Optional[builtins.str]:
        '''(experimental) Characters to not include in the generated password.

        :default: " %+~`#$&*()|[]{}:;<>?!'/

        :stability: experimental
        :: "\\"
        '''
        result = self._values.get("exclude_characters")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def master_secret(self) -> typing.Optional[_ISecret_22fb8757]:
        '''(experimental) The master secret which will be used to rotate this secret.

        :default: - no master secret information will be included

        :stability: experimental
        '''
        result = self._values.get("master_secret")
        return typing.cast(typing.Optional[_ISecret_22fb8757], result)

    @builtins.property
    def replace_on_password_criteria_changes(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Whether to replace this secret when the criteria for the password change.

        This is achieved by overriding the logical id of the AWS::SecretsManager::Secret
        with a hash of the options that influence the password generation. This
        way a new secret will be created when the password is regenerated and the
        cluster or instance consuming this secret will have its credentials updated.

        :default: false

        :stability: experimental
        '''
        result = self._values.get("replace_on_password_criteria_changes")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def replica_regions(self) -> typing.Optional[typing.List[_ReplicaRegion_ad1a6d2e]]:
        '''(experimental) A list of regions where to replicate this secret.

        :default: - Secret is not replicated

        :stability: experimental
        '''
        result = self._values.get("replica_regions")
        return typing.cast(typing.Optional[typing.List[_ReplicaRegion_ad1a6d2e]], result)

    @builtins.property
    def secret_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) A name for the secret.

        :default: - A name is generated by CloudFormation.

        :stability: experimental
        '''
        result = self._values.get("secret_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DatabaseSecretProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class Endpoint(metaclass=jsii.JSIIMeta, jsii_type="monocdk.aws_rds.Endpoint"):
    '''(experimental) Connection endpoint of a database cluster or instance.

    Consists of a combination of hostname and port.

    :stability: experimental
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from monocdk import aws_rds as rds
        
        endpoint = rds.Endpoint("address", 123)
    '''

    def __init__(self, address: builtins.str, port: jsii.Number) -> None:
        '''
        :param address: -
        :param port: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a5f66272deaf48e941173f0a5ff66438e29db9586257638428fc54f2aa73687a)
            check_type(argname="argument address", value=address, expected_type=type_hints["address"])
            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
        jsii.create(self.__class__, self, [address, port])

    @builtins.property
    @jsii.member(jsii_name="hostname")
    def hostname(self) -> builtins.str:
        '''(experimental) The hostname of the endpoint.

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "hostname"))

    @builtins.property
    @jsii.member(jsii_name="port")
    def port(self) -> jsii.Number:
        '''(experimental) The port of the endpoint.

        :stability: experimental
        '''
        return typing.cast(jsii.Number, jsii.get(self, "port"))

    @builtins.property
    @jsii.member(jsii_name="socketAddress")
    def socket_address(self) -> builtins.str:
        '''(experimental) The combination of "HOSTNAME:PORT" for this endpoint.

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "socketAddress"))


@jsii.data_type(
    jsii_type="monocdk.aws_rds.EngineVersion",
    jsii_struct_bases=[],
    name_mapping={"major_version": "majorVersion", "full_version": "fullVersion"},
)
class EngineVersion:
    def __init__(
        self,
        *,
        major_version: builtins.str,
        full_version: typing.Optional[builtins.str] = None,
    ) -> None:
        '''(experimental) A version of an engine - for either a cluster, or instance.

        :param major_version: (experimental) The major version of the engine, for example, "5.6". Used in specifying the ParameterGroup family and OptionGroup version for this engine.
        :param full_version: (experimental) The full version string of the engine, for example, "5.6.mysql_aurora.1.22.1". It can be undefined, which means RDS should use whatever version it deems appropriate for the given engine type. Default: - no version specified

        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_rds as rds
            
            engine_version = rds.EngineVersion(
                major_version="majorVersion",
            
                # the properties below are optional
                full_version="fullVersion"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__020060e9440cc94a9d7fc55daa89c558756f987dc18605fcbe54526dda4affc7)
            check_type(argname="argument major_version", value=major_version, expected_type=type_hints["major_version"])
            check_type(argname="argument full_version", value=full_version, expected_type=type_hints["full_version"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "major_version": major_version,
        }
        if full_version is not None:
            self._values["full_version"] = full_version

    @builtins.property
    def major_version(self) -> builtins.str:
        '''(experimental) The major version of the engine, for example, "5.6". Used in specifying the ParameterGroup family and OptionGroup version for this engine.

        :stability: experimental
        '''
        result = self._values.get("major_version")
        assert result is not None, "Required property 'major_version' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def full_version(self) -> typing.Optional[builtins.str]:
        '''(experimental) The full version string of the engine, for example, "5.6.mysql_aurora.1.22.1". It can be undefined, which means RDS should use whatever version it deems appropriate for the given engine type.

        :default: - no version specified

        :stability: experimental
        '''
        result = self._values.get("full_version")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EngineVersion(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.interface(jsii_type="monocdk.aws_rds.IDatabaseCluster")
class IDatabaseCluster(
    _IResource_8c1dbbbd,
    _IConnectable_c1c0e72c,
    _ISecretAttachmentTarget_b6932462,
    typing_extensions.Protocol,
):
    '''(experimental) Create a clustered database with a given number of instances.

    :stability: experimental
    '''

    @builtins.property
    @jsii.member(jsii_name="clusterEndpoint")
    def cluster_endpoint(self) -> Endpoint:
        '''(experimental) The endpoint to use for read/write operations.

        :stability: experimental
        :attribute: EndpointAddress,EndpointPort
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="clusterIdentifier")
    def cluster_identifier(self) -> builtins.str:
        '''(experimental) Identifier of the cluster.

        :stability: experimental
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="clusterReadEndpoint")
    def cluster_read_endpoint(self) -> Endpoint:
        '''(experimental) Endpoint to use for load-balanced read-only operations.

        :stability: experimental
        :attribute: ReadEndpointAddress
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="instanceEndpoints")
    def instance_endpoints(self) -> typing.List[Endpoint]:
        '''(experimental) Endpoints which address each individual replica.

        :stability: experimental
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="instanceIdentifiers")
    def instance_identifiers(self) -> typing.List[builtins.str]:
        '''(experimental) Identifiers of the replicas.

        :stability: experimental
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="engine")
    def engine(self) -> typing.Optional["IClusterEngine"]:
        '''(experimental) The engine of this Cluster.

        May be not known for imported Clusters if it wasn't provided explicitly.

        :stability: experimental
        '''
        ...

    @jsii.member(jsii_name="addProxy")
    def add_proxy(
        self,
        id: builtins.str,
        *,
        secrets: typing.Sequence[_ISecret_22fb8757],
        vpc: _IVpc_6d1f76c4,
        borrow_timeout: typing.Optional[_Duration_070aa057] = None,
        db_proxy_name: typing.Optional[builtins.str] = None,
        debug_logging: typing.Optional[builtins.bool] = None,
        iam_auth: typing.Optional[builtins.bool] = None,
        idle_client_timeout: typing.Optional[_Duration_070aa057] = None,
        init_query: typing.Optional[builtins.str] = None,
        max_connections_percent: typing.Optional[jsii.Number] = None,
        max_idle_connections_percent: typing.Optional[jsii.Number] = None,
        require_tls: typing.Optional[builtins.bool] = None,
        role: typing.Optional[_IRole_59af6f50] = None,
        security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
        session_pinning_filters: typing.Optional[typing.Sequence["SessionPinningFilter"]] = None,
        vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> "DatabaseProxy":
        '''(experimental) Add a new db proxy to this cluster.

        :param id: -
        :param secrets: (experimental) The secret that the proxy uses to authenticate to the RDS DB instance or Aurora DB cluster. These secrets are stored within Amazon Secrets Manager. One or more secrets are required.
        :param vpc: (experimental) The VPC to associate with the new proxy.
        :param borrow_timeout: (experimental) The duration for a proxy to wait for a connection to become available in the connection pool. Only applies when the proxy has opened its maximum number of connections and all connections are busy with client sessions. Value must be between 1 second and 1 hour, or ``Duration.seconds(0)`` to represent unlimited. Default: cdk.Duration.seconds(120)
        :param db_proxy_name: (experimental) The identifier for the proxy. This name must be unique for all proxies owned by your AWS account in the specified AWS Region. An identifier must begin with a letter and must contain only ASCII letters, digits, and hyphens; it can't end with a hyphen or contain two consecutive hyphens. Default: - Generated by CloudFormation (recommended)
        :param debug_logging: (experimental) Whether the proxy includes detailed information about SQL statements in its logs. This information helps you to debug issues involving SQL behavior or the performance and scalability of the proxy connections. The debug information includes the text of SQL statements that you submit through the proxy. Thus, only enable this setting when needed for debugging, and only when you have security measures in place to safeguard any sensitive information that appears in the logs. Default: false
        :param iam_auth: (experimental) Whether to require or disallow AWS Identity and Access Management (IAM) authentication for connections to the proxy. Default: false
        :param idle_client_timeout: (experimental) The number of seconds that a connection to the proxy can be inactive before the proxy disconnects it. You can set this value higher or lower than the connection timeout limit for the associated database. Default: cdk.Duration.minutes(30)
        :param init_query: (experimental) One or more SQL statements for the proxy to run when opening each new database connection. Typically used with SET statements to make sure that each connection has identical settings such as time zone and character set. For multiple statements, use semicolons as the separator. You can also include multiple variables in a single SET statement, such as SET x=1, y=2. not currently supported for PostgreSQL. Default: - no initialization query
        :param max_connections_percent: (experimental) The maximum size of the connection pool for each target in a target group. For Aurora MySQL, it is expressed as a percentage of the max_connections setting for the RDS DB instance or Aurora DB cluster used by the target group. 1-100 Default: 100
        :param max_idle_connections_percent: (experimental) Controls how actively the proxy closes idle database connections in the connection pool. A high value enables the proxy to leave a high percentage of idle connections open. A low value causes the proxy to close idle client connections and return the underlying database connections to the connection pool. For Aurora MySQL, it is expressed as a percentage of the max_connections setting for the RDS DB instance or Aurora DB cluster used by the target group. between 0 and MaxConnectionsPercent Default: 50
        :param require_tls: (experimental) A Boolean parameter that specifies whether Transport Layer Security (TLS) encryption is required for connections to the proxy. By enabling this setting, you can enforce encrypted TLS connections to the proxy. Default: true
        :param role: (experimental) IAM role that the proxy uses to access secrets in AWS Secrets Manager. Default: - A role will automatically be created
        :param security_groups: (experimental) One or more VPC security groups to associate with the new proxy. Default: - No security groups
        :param session_pinning_filters: (experimental) Each item in the list represents a class of SQL operations that normally cause all later statements in a session using a proxy to be pinned to the same underlying database connection. Including an item in the list exempts that class of SQL operations from the pinning behavior. Default: - no session pinning filters
        :param vpc_subnets: (experimental) The subnets used by the proxy. Default: - the VPC default strategy if not specified.

        :stability: experimental
        '''
        ...

    @jsii.member(jsii_name="metric")
    def metric(
        self,
        metric_name: builtins.str,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) Return the given named metric for this DBCluster.

        :param metric_name: -
        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        ...

    @jsii.member(jsii_name="metricCPUUtilization")
    def metric_cpu_utilization(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The percentage of CPU utilization.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        ...

    @jsii.member(jsii_name="metricDatabaseConnections")
    def metric_database_connections(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The number of database connections in use.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        ...

    @jsii.member(jsii_name="metricDeadlocks")
    def metric_deadlocks(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The average number of deadlocks in the database per second.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        ...

    @jsii.member(jsii_name="metricEngineUptime")
    def metric_engine_uptime(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The amount of time that the instance has been running, in seconds.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        ...

    @jsii.member(jsii_name="metricFreeableMemory")
    def metric_freeable_memory(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The amount of available random access memory, in bytes.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        ...

    @jsii.member(jsii_name="metricFreeLocalStorage")
    def metric_free_local_storage(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The amount of local storage available, in bytes.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        ...

    @jsii.member(jsii_name="metricNetworkReceiveThroughput")
    def metric_network_receive_throughput(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The amount of network throughput received from clients by each instance, in bytes per second.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        ...

    @jsii.member(jsii_name="metricNetworkThroughput")
    def metric_network_throughput(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The amount of network throughput both received from and transmitted to clients by each instance, in bytes per second.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        ...

    @jsii.member(jsii_name="metricNetworkTransmitThroughput")
    def metric_network_transmit_throughput(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The amount of network throughput sent to clients by each instance, in bytes per second.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        ...

    @jsii.member(jsii_name="metricSnapshotStorageUsed")
    def metric_snapshot_storage_used(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The total amount of backup storage in bytes consumed by all Aurora snapshots outside its backup retention window.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        ...

    @jsii.member(jsii_name="metricTotalBackupStorageBilled")
    def metric_total_backup_storage_billed(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The total amount of backup storage in bytes for which you are billed.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        ...

    @jsii.member(jsii_name="metricVolumeBytesUsed")
    def metric_volume_bytes_used(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The amount of storage used by your Aurora DB instance, in bytes.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        ...

    @jsii.member(jsii_name="metricVolumeReadIOPs")
    def metric_volume_read_io_ps(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The number of billed read I/O operations from a cluster volume, reported at 5-minute intervals.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        ...

    @jsii.member(jsii_name="metricVolumeWriteIOPs")
    def metric_volume_write_io_ps(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The number of write disk I/O operations to the cluster volume, reported at 5-minute intervals.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        ...


class _IDatabaseClusterProxy(
    jsii.proxy_for(_IResource_8c1dbbbd), # type: ignore[misc]
    jsii.proxy_for(_IConnectable_c1c0e72c), # type: ignore[misc]
    jsii.proxy_for(_ISecretAttachmentTarget_b6932462), # type: ignore[misc]
):
    '''(experimental) Create a clustered database with a given number of instances.

    :stability: experimental
    '''

    __jsii_type__: typing.ClassVar[str] = "monocdk.aws_rds.IDatabaseCluster"

    @builtins.property
    @jsii.member(jsii_name="clusterEndpoint")
    def cluster_endpoint(self) -> Endpoint:
        '''(experimental) The endpoint to use for read/write operations.

        :stability: experimental
        :attribute: EndpointAddress,EndpointPort
        '''
        return typing.cast(Endpoint, jsii.get(self, "clusterEndpoint"))

    @builtins.property
    @jsii.member(jsii_name="clusterIdentifier")
    def cluster_identifier(self) -> builtins.str:
        '''(experimental) Identifier of the cluster.

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "clusterIdentifier"))

    @builtins.property
    @jsii.member(jsii_name="clusterReadEndpoint")
    def cluster_read_endpoint(self) -> Endpoint:
        '''(experimental) Endpoint to use for load-balanced read-only operations.

        :stability: experimental
        :attribute: ReadEndpointAddress
        '''
        return typing.cast(Endpoint, jsii.get(self, "clusterReadEndpoint"))

    @builtins.property
    @jsii.member(jsii_name="instanceEndpoints")
    def instance_endpoints(self) -> typing.List[Endpoint]:
        '''(experimental) Endpoints which address each individual replica.

        :stability: experimental
        '''
        return typing.cast(typing.List[Endpoint], jsii.get(self, "instanceEndpoints"))

    @builtins.property
    @jsii.member(jsii_name="instanceIdentifiers")
    def instance_identifiers(self) -> typing.List[builtins.str]:
        '''(experimental) Identifiers of the replicas.

        :stability: experimental
        '''
        return typing.cast(typing.List[builtins.str], jsii.get(self, "instanceIdentifiers"))

    @builtins.property
    @jsii.member(jsii_name="engine")
    def engine(self) -> typing.Optional["IClusterEngine"]:
        '''(experimental) The engine of this Cluster.

        May be not known for imported Clusters if it wasn't provided explicitly.

        :stability: experimental
        '''
        return typing.cast(typing.Optional["IClusterEngine"], jsii.get(self, "engine"))

    @jsii.member(jsii_name="addProxy")
    def add_proxy(
        self,
        id: builtins.str,
        *,
        secrets: typing.Sequence[_ISecret_22fb8757],
        vpc: _IVpc_6d1f76c4,
        borrow_timeout: typing.Optional[_Duration_070aa057] = None,
        db_proxy_name: typing.Optional[builtins.str] = None,
        debug_logging: typing.Optional[builtins.bool] = None,
        iam_auth: typing.Optional[builtins.bool] = None,
        idle_client_timeout: typing.Optional[_Duration_070aa057] = None,
        init_query: typing.Optional[builtins.str] = None,
        max_connections_percent: typing.Optional[jsii.Number] = None,
        max_idle_connections_percent: typing.Optional[jsii.Number] = None,
        require_tls: typing.Optional[builtins.bool] = None,
        role: typing.Optional[_IRole_59af6f50] = None,
        security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
        session_pinning_filters: typing.Optional[typing.Sequence["SessionPinningFilter"]] = None,
        vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> "DatabaseProxy":
        '''(experimental) Add a new db proxy to this cluster.

        :param id: -
        :param secrets: (experimental) The secret that the proxy uses to authenticate to the RDS DB instance or Aurora DB cluster. These secrets are stored within Amazon Secrets Manager. One or more secrets are required.
        :param vpc: (experimental) The VPC to associate with the new proxy.
        :param borrow_timeout: (experimental) The duration for a proxy to wait for a connection to become available in the connection pool. Only applies when the proxy has opened its maximum number of connections and all connections are busy with client sessions. Value must be between 1 second and 1 hour, or ``Duration.seconds(0)`` to represent unlimited. Default: cdk.Duration.seconds(120)
        :param db_proxy_name: (experimental) The identifier for the proxy. This name must be unique for all proxies owned by your AWS account in the specified AWS Region. An identifier must begin with a letter and must contain only ASCII letters, digits, and hyphens; it can't end with a hyphen or contain two consecutive hyphens. Default: - Generated by CloudFormation (recommended)
        :param debug_logging: (experimental) Whether the proxy includes detailed information about SQL statements in its logs. This information helps you to debug issues involving SQL behavior or the performance and scalability of the proxy connections. The debug information includes the text of SQL statements that you submit through the proxy. Thus, only enable this setting when needed for debugging, and only when you have security measures in place to safeguard any sensitive information that appears in the logs. Default: false
        :param iam_auth: (experimental) Whether to require or disallow AWS Identity and Access Management (IAM) authentication for connections to the proxy. Default: false
        :param idle_client_timeout: (experimental) The number of seconds that a connection to the proxy can be inactive before the proxy disconnects it. You can set this value higher or lower than the connection timeout limit for the associated database. Default: cdk.Duration.minutes(30)
        :param init_query: (experimental) One or more SQL statements for the proxy to run when opening each new database connection. Typically used with SET statements to make sure that each connection has identical settings such as time zone and character set. For multiple statements, use semicolons as the separator. You can also include multiple variables in a single SET statement, such as SET x=1, y=2. not currently supported for PostgreSQL. Default: - no initialization query
        :param max_connections_percent: (experimental) The maximum size of the connection pool for each target in a target group. For Aurora MySQL, it is expressed as a percentage of the max_connections setting for the RDS DB instance or Aurora DB cluster used by the target group. 1-100 Default: 100
        :param max_idle_connections_percent: (experimental) Controls how actively the proxy closes idle database connections in the connection pool. A high value enables the proxy to leave a high percentage of idle connections open. A low value causes the proxy to close idle client connections and return the underlying database connections to the connection pool. For Aurora MySQL, it is expressed as a percentage of the max_connections setting for the RDS DB instance or Aurora DB cluster used by the target group. between 0 and MaxConnectionsPercent Default: 50
        :param require_tls: (experimental) A Boolean parameter that specifies whether Transport Layer Security (TLS) encryption is required for connections to the proxy. By enabling this setting, you can enforce encrypted TLS connections to the proxy. Default: true
        :param role: (experimental) IAM role that the proxy uses to access secrets in AWS Secrets Manager. Default: - A role will automatically be created
        :param security_groups: (experimental) One or more VPC security groups to associate with the new proxy. Default: - No security groups
        :param session_pinning_filters: (experimental) Each item in the list represents a class of SQL operations that normally cause all later statements in a session using a proxy to be pinned to the same underlying database connection. Including an item in the list exempts that class of SQL operations from the pinning behavior. Default: - no session pinning filters
        :param vpc_subnets: (experimental) The subnets used by the proxy. Default: - the VPC default strategy if not specified.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9a44b9bde3fbd2c11633518cd49c67f61ee324968cac3a18ab42d8437f303410)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        options = DatabaseProxyOptions(
            secrets=secrets,
            vpc=vpc,
            borrow_timeout=borrow_timeout,
            db_proxy_name=db_proxy_name,
            debug_logging=debug_logging,
            iam_auth=iam_auth,
            idle_client_timeout=idle_client_timeout,
            init_query=init_query,
            max_connections_percent=max_connections_percent,
            max_idle_connections_percent=max_idle_connections_percent,
            require_tls=require_tls,
            role=role,
            security_groups=security_groups,
            session_pinning_filters=session_pinning_filters,
            vpc_subnets=vpc_subnets,
        )

        return typing.cast("DatabaseProxy", jsii.invoke(self, "addProxy", [id, options]))

    @jsii.member(jsii_name="metric")
    def metric(
        self,
        metric_name: builtins.str,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) Return the given named metric for this DBCluster.

        :param metric_name: -
        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1ccf7294b1a2d81a7849e7b695afbee877e597dcde2aedd7ea0ad94f7c8361d0)
            check_type(argname="argument metric_name", value=metric_name, expected_type=type_hints["metric_name"])
        props = _MetricOptions_1c185ae8(
            account=account,
            color=color,
            dimensions=dimensions,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_5b2b8e58, jsii.invoke(self, "metric", [metric_name, props]))

    @jsii.member(jsii_name="metricCPUUtilization")
    def metric_cpu_utilization(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The percentage of CPU utilization.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        props = _MetricOptions_1c185ae8(
            account=account,
            color=color,
            dimensions=dimensions,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_5b2b8e58, jsii.invoke(self, "metricCPUUtilization", [props]))

    @jsii.member(jsii_name="metricDatabaseConnections")
    def metric_database_connections(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The number of database connections in use.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        props = _MetricOptions_1c185ae8(
            account=account,
            color=color,
            dimensions=dimensions,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_5b2b8e58, jsii.invoke(self, "metricDatabaseConnections", [props]))

    @jsii.member(jsii_name="metricDeadlocks")
    def metric_deadlocks(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The average number of deadlocks in the database per second.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        props = _MetricOptions_1c185ae8(
            account=account,
            color=color,
            dimensions=dimensions,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_5b2b8e58, jsii.invoke(self, "metricDeadlocks", [props]))

    @jsii.member(jsii_name="metricEngineUptime")
    def metric_engine_uptime(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The amount of time that the instance has been running, in seconds.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        props = _MetricOptions_1c185ae8(
            account=account,
            color=color,
            dimensions=dimensions,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_5b2b8e58, jsii.invoke(self, "metricEngineUptime", [props]))

    @jsii.member(jsii_name="metricFreeableMemory")
    def metric_freeable_memory(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The amount of available random access memory, in bytes.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        props = _MetricOptions_1c185ae8(
            account=account,
            color=color,
            dimensions=dimensions,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_5b2b8e58, jsii.invoke(self, "metricFreeableMemory", [props]))

    @jsii.member(jsii_name="metricFreeLocalStorage")
    def metric_free_local_storage(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The amount of local storage available, in bytes.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        props = _MetricOptions_1c185ae8(
            account=account,
            color=color,
            dimensions=dimensions,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_5b2b8e58, jsii.invoke(self, "metricFreeLocalStorage", [props]))

    @jsii.member(jsii_name="metricNetworkReceiveThroughput")
    def metric_network_receive_throughput(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The amount of network throughput received from clients by each instance, in bytes per second.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        props = _MetricOptions_1c185ae8(
            account=account,
            color=color,
            dimensions=dimensions,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_5b2b8e58, jsii.invoke(self, "metricNetworkReceiveThroughput", [props]))

    @jsii.member(jsii_name="metricNetworkThroughput")
    def metric_network_throughput(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The amount of network throughput both received from and transmitted to clients by each instance, in bytes per second.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        props = _MetricOptions_1c185ae8(
            account=account,
            color=color,
            dimensions=dimensions,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_5b2b8e58, jsii.invoke(self, "metricNetworkThroughput", [props]))

    @jsii.member(jsii_name="metricNetworkTransmitThroughput")
    def metric_network_transmit_throughput(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The amount of network throughput sent to clients by each instance, in bytes per second.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        props = _MetricOptions_1c185ae8(
            account=account,
            color=color,
            dimensions=dimensions,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_5b2b8e58, jsii.invoke(self, "metricNetworkTransmitThroughput", [props]))

    @jsii.member(jsii_name="metricSnapshotStorageUsed")
    def metric_snapshot_storage_used(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The total amount of backup storage in bytes consumed by all Aurora snapshots outside its backup retention window.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        props = _MetricOptions_1c185ae8(
            account=account,
            color=color,
            dimensions=dimensions,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_5b2b8e58, jsii.invoke(self, "metricSnapshotStorageUsed", [props]))

    @jsii.member(jsii_name="metricTotalBackupStorageBilled")
    def metric_total_backup_storage_billed(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The total amount of backup storage in bytes for which you are billed.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        props = _MetricOptions_1c185ae8(
            account=account,
            color=color,
            dimensions=dimensions,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_5b2b8e58, jsii.invoke(self, "metricTotalBackupStorageBilled", [props]))

    @jsii.member(jsii_name="metricVolumeBytesUsed")
    def metric_volume_bytes_used(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The amount of storage used by your Aurora DB instance, in bytes.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        props = _MetricOptions_1c185ae8(
            account=account,
            color=color,
            dimensions=dimensions,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_5b2b8e58, jsii.invoke(self, "metricVolumeBytesUsed", [props]))

    @jsii.member(jsii_name="metricVolumeReadIOPs")
    def metric_volume_read_io_ps(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The number of billed read I/O operations from a cluster volume, reported at 5-minute intervals.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        props = _MetricOptions_1c185ae8(
            account=account,
            color=color,
            dimensions=dimensions,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_5b2b8e58, jsii.invoke(self, "metricVolumeReadIOPs", [props]))

    @jsii.member(jsii_name="metricVolumeWriteIOPs")
    def metric_volume_write_io_ps(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The number of write disk I/O operations to the cluster volume, reported at 5-minute intervals.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        props = _MetricOptions_1c185ae8(
            account=account,
            color=color,
            dimensions=dimensions,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_5b2b8e58, jsii.invoke(self, "metricVolumeWriteIOPs", [props]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IDatabaseCluster).__jsii_proxy_class__ = lambda : _IDatabaseClusterProxy


@jsii.interface(jsii_type="monocdk.aws_rds.IDatabaseInstance")
class IDatabaseInstance(
    _IResource_8c1dbbbd,
    _IConnectable_c1c0e72c,
    _ISecretAttachmentTarget_b6932462,
    typing_extensions.Protocol,
):
    '''(experimental) A database instance.

    :stability: experimental
    '''

    @builtins.property
    @jsii.member(jsii_name="dbInstanceEndpointAddress")
    def db_instance_endpoint_address(self) -> builtins.str:
        '''(experimental) The instance endpoint address.

        :stability: experimental
        :attribute: EndpointAddress
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="dbInstanceEndpointPort")
    def db_instance_endpoint_port(self) -> builtins.str:
        '''(experimental) The instance endpoint port.

        :stability: experimental
        :attribute: EndpointPort
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="instanceArn")
    def instance_arn(self) -> builtins.str:
        '''(experimental) The instance arn.

        :stability: experimental
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="instanceEndpoint")
    def instance_endpoint(self) -> Endpoint:
        '''(experimental) The instance endpoint.

        :stability: experimental
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="instanceIdentifier")
    def instance_identifier(self) -> builtins.str:
        '''(experimental) The instance identifier.

        :stability: experimental
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="engine")
    def engine(self) -> typing.Optional["IInstanceEngine"]:
        '''(experimental) The engine of this database Instance.

        May be not known for imported Instances if it wasn't provided explicitly,
        or for read replicas.

        :stability: experimental
        '''
        ...

    @jsii.member(jsii_name="addProxy")
    def add_proxy(
        self,
        id: builtins.str,
        *,
        secrets: typing.Sequence[_ISecret_22fb8757],
        vpc: _IVpc_6d1f76c4,
        borrow_timeout: typing.Optional[_Duration_070aa057] = None,
        db_proxy_name: typing.Optional[builtins.str] = None,
        debug_logging: typing.Optional[builtins.bool] = None,
        iam_auth: typing.Optional[builtins.bool] = None,
        idle_client_timeout: typing.Optional[_Duration_070aa057] = None,
        init_query: typing.Optional[builtins.str] = None,
        max_connections_percent: typing.Optional[jsii.Number] = None,
        max_idle_connections_percent: typing.Optional[jsii.Number] = None,
        require_tls: typing.Optional[builtins.bool] = None,
        role: typing.Optional[_IRole_59af6f50] = None,
        security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
        session_pinning_filters: typing.Optional[typing.Sequence["SessionPinningFilter"]] = None,
        vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> "DatabaseProxy":
        '''(experimental) Add a new db proxy to this instance.

        :param id: -
        :param secrets: (experimental) The secret that the proxy uses to authenticate to the RDS DB instance or Aurora DB cluster. These secrets are stored within Amazon Secrets Manager. One or more secrets are required.
        :param vpc: (experimental) The VPC to associate with the new proxy.
        :param borrow_timeout: (experimental) The duration for a proxy to wait for a connection to become available in the connection pool. Only applies when the proxy has opened its maximum number of connections and all connections are busy with client sessions. Value must be between 1 second and 1 hour, or ``Duration.seconds(0)`` to represent unlimited. Default: cdk.Duration.seconds(120)
        :param db_proxy_name: (experimental) The identifier for the proxy. This name must be unique for all proxies owned by your AWS account in the specified AWS Region. An identifier must begin with a letter and must contain only ASCII letters, digits, and hyphens; it can't end with a hyphen or contain two consecutive hyphens. Default: - Generated by CloudFormation (recommended)
        :param debug_logging: (experimental) Whether the proxy includes detailed information about SQL statements in its logs. This information helps you to debug issues involving SQL behavior or the performance and scalability of the proxy connections. The debug information includes the text of SQL statements that you submit through the proxy. Thus, only enable this setting when needed for debugging, and only when you have security measures in place to safeguard any sensitive information that appears in the logs. Default: false
        :param iam_auth: (experimental) Whether to require or disallow AWS Identity and Access Management (IAM) authentication for connections to the proxy. Default: false
        :param idle_client_timeout: (experimental) The number of seconds that a connection to the proxy can be inactive before the proxy disconnects it. You can set this value higher or lower than the connection timeout limit for the associated database. Default: cdk.Duration.minutes(30)
        :param init_query: (experimental) One or more SQL statements for the proxy to run when opening each new database connection. Typically used with SET statements to make sure that each connection has identical settings such as time zone and character set. For multiple statements, use semicolons as the separator. You can also include multiple variables in a single SET statement, such as SET x=1, y=2. not currently supported for PostgreSQL. Default: - no initialization query
        :param max_connections_percent: (experimental) The maximum size of the connection pool for each target in a target group. For Aurora MySQL, it is expressed as a percentage of the max_connections setting for the RDS DB instance or Aurora DB cluster used by the target group. 1-100 Default: 100
        :param max_idle_connections_percent: (experimental) Controls how actively the proxy closes idle database connections in the connection pool. A high value enables the proxy to leave a high percentage of idle connections open. A low value causes the proxy to close idle client connections and return the underlying database connections to the connection pool. For Aurora MySQL, it is expressed as a percentage of the max_connections setting for the RDS DB instance or Aurora DB cluster used by the target group. between 0 and MaxConnectionsPercent Default: 50
        :param require_tls: (experimental) A Boolean parameter that specifies whether Transport Layer Security (TLS) encryption is required for connections to the proxy. By enabling this setting, you can enforce encrypted TLS connections to the proxy. Default: true
        :param role: (experimental) IAM role that the proxy uses to access secrets in AWS Secrets Manager. Default: - A role will automatically be created
        :param security_groups: (experimental) One or more VPC security groups to associate with the new proxy. Default: - No security groups
        :param session_pinning_filters: (experimental) Each item in the list represents a class of SQL operations that normally cause all later statements in a session using a proxy to be pinned to the same underlying database connection. Including an item in the list exempts that class of SQL operations from the pinning behavior. Default: - no session pinning filters
        :param vpc_subnets: (experimental) The subnets used by the proxy. Default: - the VPC default strategy if not specified.

        :stability: experimental
        '''
        ...

    @jsii.member(jsii_name="grantConnect")
    def grant_connect(self, grantee: _IGrantable_4c5a91d1) -> _Grant_bcb5eae7:
        '''(experimental) Grant the given identity connection access to the database.

        **Note**: this method does not currently work, see https://github.com/aws/aws-cdk/issues/11851 for details.

        :param grantee: -

        :see: https://github.com/aws/aws-cdk/issues/11851
        :stability: experimental
        '''
        ...

    @jsii.member(jsii_name="metric")
    def metric(
        self,
        metric_name: builtins.str,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) Return the given named metric for this DBInstance.

        :param metric_name: -
        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        ...

    @jsii.member(jsii_name="metricCPUUtilization")
    def metric_cpu_utilization(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The percentage of CPU utilization.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        ...

    @jsii.member(jsii_name="metricDatabaseConnections")
    def metric_database_connections(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The number of database connections in use.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        ...

    @jsii.member(jsii_name="metricFreeableMemory")
    def metric_freeable_memory(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The amount of available random access memory.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        ...

    @jsii.member(jsii_name="metricFreeStorageSpace")
    def metric_free_storage_space(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The amount of available storage space.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        ...

    @jsii.member(jsii_name="metricReadIOPS")
    def metric_read_iops(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The average number of disk write I/O operations per second.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        ...

    @jsii.member(jsii_name="metricWriteIOPS")
    def metric_write_iops(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The average number of disk read I/O operations per second.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        ...

    @jsii.member(jsii_name="onEvent")
    def on_event(
        self,
        id: builtins.str,
        *,
        description: typing.Optional[builtins.str] = None,
        event_pattern: typing.Optional[typing.Union[_EventPattern_a23fbf37, typing.Dict[builtins.str, typing.Any]]] = None,
        rule_name: typing.Optional[builtins.str] = None,
        target: typing.Optional[_IRuleTarget_d45ec729] = None,
    ) -> _Rule_6cfff189:
        '''(experimental) Defines a CloudWatch event rule which triggers for instance events.

        Use
        ``rule.addEventPattern(pattern)`` to specify a filter.

        :param id: -
        :param description: (experimental) A description of the rule's purpose. Default: - No description
        :param event_pattern: (experimental) Additional restrictions for the event to route to the specified target. The method that generates the rule probably imposes some type of event filtering. The filtering implied by what you pass here is added on top of that filtering. Default: - No additional filtering based on an event pattern.
        :param rule_name: (experimental) A name for the rule. Default: AWS CloudFormation generates a unique physical ID.
        :param target: (experimental) The target to register for the event. Default: - No target is added to the rule. Use ``addTarget()`` to add a target.

        :stability: experimental
        '''
        ...


class _IDatabaseInstanceProxy(
    jsii.proxy_for(_IResource_8c1dbbbd), # type: ignore[misc]
    jsii.proxy_for(_IConnectable_c1c0e72c), # type: ignore[misc]
    jsii.proxy_for(_ISecretAttachmentTarget_b6932462), # type: ignore[misc]
):
    '''(experimental) A database instance.

    :stability: experimental
    '''

    __jsii_type__: typing.ClassVar[str] = "monocdk.aws_rds.IDatabaseInstance"

    @builtins.property
    @jsii.member(jsii_name="dbInstanceEndpointAddress")
    def db_instance_endpoint_address(self) -> builtins.str:
        '''(experimental) The instance endpoint address.

        :stability: experimental
        :attribute: EndpointAddress
        '''
        return typing.cast(builtins.str, jsii.get(self, "dbInstanceEndpointAddress"))

    @builtins.property
    @jsii.member(jsii_name="dbInstanceEndpointPort")
    def db_instance_endpoint_port(self) -> builtins.str:
        '''(experimental) The instance endpoint port.

        :stability: experimental
        :attribute: EndpointPort
        '''
        return typing.cast(builtins.str, jsii.get(self, "dbInstanceEndpointPort"))

    @builtins.property
    @jsii.member(jsii_name="instanceArn")
    def instance_arn(self) -> builtins.str:
        '''(experimental) The instance arn.

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "instanceArn"))

    @builtins.property
    @jsii.member(jsii_name="instanceEndpoint")
    def instance_endpoint(self) -> Endpoint:
        '''(experimental) The instance endpoint.

        :stability: experimental
        '''
        return typing.cast(Endpoint, jsii.get(self, "instanceEndpoint"))

    @builtins.property
    @jsii.member(jsii_name="instanceIdentifier")
    def instance_identifier(self) -> builtins.str:
        '''(experimental) The instance identifier.

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "instanceIdentifier"))

    @builtins.property
    @jsii.member(jsii_name="engine")
    def engine(self) -> typing.Optional["IInstanceEngine"]:
        '''(experimental) The engine of this database Instance.

        May be not known for imported Instances if it wasn't provided explicitly,
        or for read replicas.

        :stability: experimental
        '''
        return typing.cast(typing.Optional["IInstanceEngine"], jsii.get(self, "engine"))

    @jsii.member(jsii_name="addProxy")
    def add_proxy(
        self,
        id: builtins.str,
        *,
        secrets: typing.Sequence[_ISecret_22fb8757],
        vpc: _IVpc_6d1f76c4,
        borrow_timeout: typing.Optional[_Duration_070aa057] = None,
        db_proxy_name: typing.Optional[builtins.str] = None,
        debug_logging: typing.Optional[builtins.bool] = None,
        iam_auth: typing.Optional[builtins.bool] = None,
        idle_client_timeout: typing.Optional[_Duration_070aa057] = None,
        init_query: typing.Optional[builtins.str] = None,
        max_connections_percent: typing.Optional[jsii.Number] = None,
        max_idle_connections_percent: typing.Optional[jsii.Number] = None,
        require_tls: typing.Optional[builtins.bool] = None,
        role: typing.Optional[_IRole_59af6f50] = None,
        security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
        session_pinning_filters: typing.Optional[typing.Sequence["SessionPinningFilter"]] = None,
        vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> "DatabaseProxy":
        '''(experimental) Add a new db proxy to this instance.

        :param id: -
        :param secrets: (experimental) The secret that the proxy uses to authenticate to the RDS DB instance or Aurora DB cluster. These secrets are stored within Amazon Secrets Manager. One or more secrets are required.
        :param vpc: (experimental) The VPC to associate with the new proxy.
        :param borrow_timeout: (experimental) The duration for a proxy to wait for a connection to become available in the connection pool. Only applies when the proxy has opened its maximum number of connections and all connections are busy with client sessions. Value must be between 1 second and 1 hour, or ``Duration.seconds(0)`` to represent unlimited. Default: cdk.Duration.seconds(120)
        :param db_proxy_name: (experimental) The identifier for the proxy. This name must be unique for all proxies owned by your AWS account in the specified AWS Region. An identifier must begin with a letter and must contain only ASCII letters, digits, and hyphens; it can't end with a hyphen or contain two consecutive hyphens. Default: - Generated by CloudFormation (recommended)
        :param debug_logging: (experimental) Whether the proxy includes detailed information about SQL statements in its logs. This information helps you to debug issues involving SQL behavior or the performance and scalability of the proxy connections. The debug information includes the text of SQL statements that you submit through the proxy. Thus, only enable this setting when needed for debugging, and only when you have security measures in place to safeguard any sensitive information that appears in the logs. Default: false
        :param iam_auth: (experimental) Whether to require or disallow AWS Identity and Access Management (IAM) authentication for connections to the proxy. Default: false
        :param idle_client_timeout: (experimental) The number of seconds that a connection to the proxy can be inactive before the proxy disconnects it. You can set this value higher or lower than the connection timeout limit for the associated database. Default: cdk.Duration.minutes(30)
        :param init_query: (experimental) One or more SQL statements for the proxy to run when opening each new database connection. Typically used with SET statements to make sure that each connection has identical settings such as time zone and character set. For multiple statements, use semicolons as the separator. You can also include multiple variables in a single SET statement, such as SET x=1, y=2. not currently supported for PostgreSQL. Default: - no initialization query
        :param max_connections_percent: (experimental) The maximum size of the connection pool for each target in a target group. For Aurora MySQL, it is expressed as a percentage of the max_connections setting for the RDS DB instance or Aurora DB cluster used by the target group. 1-100 Default: 100
        :param max_idle_connections_percent: (experimental) Controls how actively the proxy closes idle database connections in the connection pool. A high value enables the proxy to leave a high percentage of idle connections open. A low value causes the proxy to close idle client connections and return the underlying database connections to the connection pool. For Aurora MySQL, it is expressed as a percentage of the max_connections setting for the RDS DB instance or Aurora DB cluster used by the target group. between 0 and MaxConnectionsPercent Default: 50
        :param require_tls: (experimental) A Boolean parameter that specifies whether Transport Layer Security (TLS) encryption is required for connections to the proxy. By enabling this setting, you can enforce encrypted TLS connections to the proxy. Default: true
        :param role: (experimental) IAM role that the proxy uses to access secrets in AWS Secrets Manager. Default: - A role will automatically be created
        :param security_groups: (experimental) One or more VPC security groups to associate with the new proxy. Default: - No security groups
        :param session_pinning_filters: (experimental) Each item in the list represents a class of SQL operations that normally cause all later statements in a session using a proxy to be pinned to the same underlying database connection. Including an item in the list exempts that class of SQL operations from the pinning behavior. Default: - no session pinning filters
        :param vpc_subnets: (experimental) The subnets used by the proxy. Default: - the VPC default strategy if not specified.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6188518c846fbe54982e9913b05af128f894dc1ddab533827304da029efd0581)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        options = DatabaseProxyOptions(
            secrets=secrets,
            vpc=vpc,
            borrow_timeout=borrow_timeout,
            db_proxy_name=db_proxy_name,
            debug_logging=debug_logging,
            iam_auth=iam_auth,
            idle_client_timeout=idle_client_timeout,
            init_query=init_query,
            max_connections_percent=max_connections_percent,
            max_idle_connections_percent=max_idle_connections_percent,
            require_tls=require_tls,
            role=role,
            security_groups=security_groups,
            session_pinning_filters=session_pinning_filters,
            vpc_subnets=vpc_subnets,
        )

        return typing.cast("DatabaseProxy", jsii.invoke(self, "addProxy", [id, options]))

    @jsii.member(jsii_name="grantConnect")
    def grant_connect(self, grantee: _IGrantable_4c5a91d1) -> _Grant_bcb5eae7:
        '''(experimental) Grant the given identity connection access to the database.

        **Note**: this method does not currently work, see https://github.com/aws/aws-cdk/issues/11851 for details.

        :param grantee: -

        :see: https://github.com/aws/aws-cdk/issues/11851
        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bfe9e239b6e9ac080d7e26d7f31bd6986baca2ff7b8c3755359b857751d23cf0)
            check_type(argname="argument grantee", value=grantee, expected_type=type_hints["grantee"])
        return typing.cast(_Grant_bcb5eae7, jsii.invoke(self, "grantConnect", [grantee]))

    @jsii.member(jsii_name="metric")
    def metric(
        self,
        metric_name: builtins.str,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) Return the given named metric for this DBInstance.

        :param metric_name: -
        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b25d9a45fb91674a69bf7430971692af0f294c589166cf054fdb2119d60b8f67)
            check_type(argname="argument metric_name", value=metric_name, expected_type=type_hints["metric_name"])
        props = _MetricOptions_1c185ae8(
            account=account,
            color=color,
            dimensions=dimensions,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_5b2b8e58, jsii.invoke(self, "metric", [metric_name, props]))

    @jsii.member(jsii_name="metricCPUUtilization")
    def metric_cpu_utilization(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The percentage of CPU utilization.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        props = _MetricOptions_1c185ae8(
            account=account,
            color=color,
            dimensions=dimensions,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_5b2b8e58, jsii.invoke(self, "metricCPUUtilization", [props]))

    @jsii.member(jsii_name="metricDatabaseConnections")
    def metric_database_connections(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The number of database connections in use.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        props = _MetricOptions_1c185ae8(
            account=account,
            color=color,
            dimensions=dimensions,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_5b2b8e58, jsii.invoke(self, "metricDatabaseConnections", [props]))

    @jsii.member(jsii_name="metricFreeableMemory")
    def metric_freeable_memory(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The amount of available random access memory.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        props = _MetricOptions_1c185ae8(
            account=account,
            color=color,
            dimensions=dimensions,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_5b2b8e58, jsii.invoke(self, "metricFreeableMemory", [props]))

    @jsii.member(jsii_name="metricFreeStorageSpace")
    def metric_free_storage_space(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The amount of available storage space.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        props = _MetricOptions_1c185ae8(
            account=account,
            color=color,
            dimensions=dimensions,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_5b2b8e58, jsii.invoke(self, "metricFreeStorageSpace", [props]))

    @jsii.member(jsii_name="metricReadIOPS")
    def metric_read_iops(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The average number of disk write I/O operations per second.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        props = _MetricOptions_1c185ae8(
            account=account,
            color=color,
            dimensions=dimensions,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_5b2b8e58, jsii.invoke(self, "metricReadIOPS", [props]))

    @jsii.member(jsii_name="metricWriteIOPS")
    def metric_write_iops(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The average number of disk read I/O operations per second.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        props = _MetricOptions_1c185ae8(
            account=account,
            color=color,
            dimensions=dimensions,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_5b2b8e58, jsii.invoke(self, "metricWriteIOPS", [props]))

    @jsii.member(jsii_name="onEvent")
    def on_event(
        self,
        id: builtins.str,
        *,
        description: typing.Optional[builtins.str] = None,
        event_pattern: typing.Optional[typing.Union[_EventPattern_a23fbf37, typing.Dict[builtins.str, typing.Any]]] = None,
        rule_name: typing.Optional[builtins.str] = None,
        target: typing.Optional[_IRuleTarget_d45ec729] = None,
    ) -> _Rule_6cfff189:
        '''(experimental) Defines a CloudWatch event rule which triggers for instance events.

        Use
        ``rule.addEventPattern(pattern)`` to specify a filter.

        :param id: -
        :param description: (experimental) A description of the rule's purpose. Default: - No description
        :param event_pattern: (experimental) Additional restrictions for the event to route to the specified target. The method that generates the rule probably imposes some type of event filtering. The filtering implied by what you pass here is added on top of that filtering. Default: - No additional filtering based on an event pattern.
        :param rule_name: (experimental) A name for the rule. Default: AWS CloudFormation generates a unique physical ID.
        :param target: (experimental) The target to register for the event. Default: - No target is added to the rule. Use ``addTarget()`` to add a target.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8d39e45bda44875b5e8ee2e2fa36fddee950863eb5620ca6852eeae398c82a44)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        options = _OnEventOptions_d5081088(
            description=description,
            event_pattern=event_pattern,
            rule_name=rule_name,
            target=target,
        )

        return typing.cast(_Rule_6cfff189, jsii.invoke(self, "onEvent", [id, options]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IDatabaseInstance).__jsii_proxy_class__ = lambda : _IDatabaseInstanceProxy


@jsii.interface(jsii_type="monocdk.aws_rds.IDatabaseProxy")
class IDatabaseProxy(_IResource_8c1dbbbd, typing_extensions.Protocol):
    '''(experimental) DB Proxy.

    :stability: experimental
    '''

    @builtins.property
    @jsii.member(jsii_name="dbProxyArn")
    def db_proxy_arn(self) -> builtins.str:
        '''(experimental) DB Proxy ARN.

        :stability: experimental
        :attribute: true
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="dbProxyName")
    def db_proxy_name(self) -> builtins.str:
        '''(experimental) DB Proxy Name.

        :stability: experimental
        :attribute: true
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="endpoint")
    def endpoint(self) -> builtins.str:
        '''(experimental) Endpoint.

        :stability: experimental
        :attribute: true
        '''
        ...

    @jsii.member(jsii_name="grantConnect")
    def grant_connect(
        self,
        grantee: _IGrantable_4c5a91d1,
        db_user: typing.Optional[builtins.str] = None,
    ) -> _Grant_bcb5eae7:
        '''(experimental) Grant the given identity connection access to the proxy.

        :param grantee: the Principal to grant the permissions to.
        :param db_user: the name of the database user to allow connecting as to the proxy.

        :default:

        - if the Proxy had been provided a single Secret value,
        the user will be taken from that Secret

        :stability: experimental
        '''
        ...


class _IDatabaseProxyProxy(
    jsii.proxy_for(_IResource_8c1dbbbd), # type: ignore[misc]
):
    '''(experimental) DB Proxy.

    :stability: experimental
    '''

    __jsii_type__: typing.ClassVar[str] = "monocdk.aws_rds.IDatabaseProxy"

    @builtins.property
    @jsii.member(jsii_name="dbProxyArn")
    def db_proxy_arn(self) -> builtins.str:
        '''(experimental) DB Proxy ARN.

        :stability: experimental
        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "dbProxyArn"))

    @builtins.property
    @jsii.member(jsii_name="dbProxyName")
    def db_proxy_name(self) -> builtins.str:
        '''(experimental) DB Proxy Name.

        :stability: experimental
        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "dbProxyName"))

    @builtins.property
    @jsii.member(jsii_name="endpoint")
    def endpoint(self) -> builtins.str:
        '''(experimental) Endpoint.

        :stability: experimental
        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "endpoint"))

    @jsii.member(jsii_name="grantConnect")
    def grant_connect(
        self,
        grantee: _IGrantable_4c5a91d1,
        db_user: typing.Optional[builtins.str] = None,
    ) -> _Grant_bcb5eae7:
        '''(experimental) Grant the given identity connection access to the proxy.

        :param grantee: the Principal to grant the permissions to.
        :param db_user: the name of the database user to allow connecting as to the proxy.

        :default:

        - if the Proxy had been provided a single Secret value,
        the user will be taken from that Secret

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7225ce884c29e3698d0b0fab87752984f27c235ab41f6e0142a7cfe721b8a124)
            check_type(argname="argument grantee", value=grantee, expected_type=type_hints["grantee"])
            check_type(argname="argument db_user", value=db_user, expected_type=type_hints["db_user"])
        return typing.cast(_Grant_bcb5eae7, jsii.invoke(self, "grantConnect", [grantee, db_user]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IDatabaseProxy).__jsii_proxy_class__ = lambda : _IDatabaseProxyProxy


@jsii.interface(jsii_type="monocdk.aws_rds.IEngine")
class IEngine(typing_extensions.Protocol):
    '''(experimental) A common interface for database engines.

    Don't implement this interface directly,
    instead implement one of the known sub-interfaces,
    like IClusterEngine and IInstanceEngine.

    :stability: experimental
    '''

    @builtins.property
    @jsii.member(jsii_name="engineType")
    def engine_type(self) -> builtins.str:
        '''(experimental) The type of the engine, for example "mysql".

        :stability: experimental
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="defaultUsername")
    def default_username(self) -> typing.Optional[builtins.str]:
        '''(experimental) The default name of the master database user if one was not provided explicitly.

        The global default of 'admin' will be used if this is ``undefined``.
        Note that 'admin' is a reserved word in PostgreSQL and cannot be used.

        :stability: experimental
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="engineFamily")
    def engine_family(self) -> typing.Optional[builtins.str]:
        '''(experimental) The family this engine belongs to, like "MYSQL", or "POSTGRESQL".

        This property is used when creating a Database Proxy.
        Most engines don't belong to any family
        (and because of that, you can't create Database Proxies for their Clusters or Instances).

        :default: - the engine doesn't belong to any family

        :stability: experimental
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="engineVersion")
    def engine_version(self) -> typing.Optional[EngineVersion]:
        '''(experimental) The exact version of the engine that is used, for example "5.1.42".

        :default: - use the default version for this engine type

        :stability: experimental
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="parameterGroupFamily")
    def parameter_group_family(self) -> typing.Optional[builtins.str]:
        '''(experimental) The family to use for ParameterGroups using this engine.

        This is usually equal to "",
        but can sometimes be a variation of that.
        You can pass this property when creating new ParameterGroup.

        :default:

        - the ParameterGroup family is not known
        (which means the major version of the engine is also not known)

        :stability: experimental
        '''
        ...


class _IEngineProxy:
    '''(experimental) A common interface for database engines.

    Don't implement this interface directly,
    instead implement one of the known sub-interfaces,
    like IClusterEngine and IInstanceEngine.

    :stability: experimental
    '''

    __jsii_type__: typing.ClassVar[str] = "monocdk.aws_rds.IEngine"

    @builtins.property
    @jsii.member(jsii_name="engineType")
    def engine_type(self) -> builtins.str:
        '''(experimental) The type of the engine, for example "mysql".

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "engineType"))

    @builtins.property
    @jsii.member(jsii_name="defaultUsername")
    def default_username(self) -> typing.Optional[builtins.str]:
        '''(experimental) The default name of the master database user if one was not provided explicitly.

        The global default of 'admin' will be used if this is ``undefined``.
        Note that 'admin' is a reserved word in PostgreSQL and cannot be used.

        :stability: experimental
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "defaultUsername"))

    @builtins.property
    @jsii.member(jsii_name="engineFamily")
    def engine_family(self) -> typing.Optional[builtins.str]:
        '''(experimental) The family this engine belongs to, like "MYSQL", or "POSTGRESQL".

        This property is used when creating a Database Proxy.
        Most engines don't belong to any family
        (and because of that, you can't create Database Proxies for their Clusters or Instances).

        :default: - the engine doesn't belong to any family

        :stability: experimental
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "engineFamily"))

    @builtins.property
    @jsii.member(jsii_name="engineVersion")
    def engine_version(self) -> typing.Optional[EngineVersion]:
        '''(experimental) The exact version of the engine that is used, for example "5.1.42".

        :default: - use the default version for this engine type

        :stability: experimental
        '''
        return typing.cast(typing.Optional[EngineVersion], jsii.get(self, "engineVersion"))

    @builtins.property
    @jsii.member(jsii_name="parameterGroupFamily")
    def parameter_group_family(self) -> typing.Optional[builtins.str]:
        '''(experimental) The family to use for ParameterGroups using this engine.

        This is usually equal to "",
        but can sometimes be a variation of that.
        You can pass this property when creating new ParameterGroup.

        :default:

        - the ParameterGroup family is not known
        (which means the major version of the engine is also not known)

        :stability: experimental
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "parameterGroupFamily"))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IEngine).__jsii_proxy_class__ = lambda : _IEngineProxy


@jsii.interface(jsii_type="monocdk.aws_rds.IInstanceEngine")
class IInstanceEngine(IEngine, typing_extensions.Protocol):
    '''(experimental) Interface representing a database instance (as opposed to cluster) engine.

    :stability: experimental
    '''

    @builtins.property
    @jsii.member(jsii_name="multiUserRotationApplication")
    def multi_user_rotation_application(self) -> _SecretRotationApplication_0ac7c5d5:
        '''(experimental) The application used by this engine to perform rotation for a multi-user scenario.

        :stability: experimental
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="singleUserRotationApplication")
    def single_user_rotation_application(self) -> _SecretRotationApplication_0ac7c5d5:
        '''(experimental) The application used by this engine to perform rotation for a single-user scenario.

        :stability: experimental
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="supportsReadReplicaBackups")
    def supports_read_replica_backups(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Whether this engine supports automatic backups of a read replica instance.

        :default: false

        :stability: experimental
        '''
        ...

    @jsii.member(jsii_name="bindToInstance")
    def bind_to_instance(
        self,
        scope: _Construct_e78e779f,
        *,
        domain: typing.Optional[builtins.str] = None,
        option_group: typing.Optional["IOptionGroup"] = None,
        s3_export_role: typing.Optional[_IRole_59af6f50] = None,
        s3_import_role: typing.Optional[_IRole_59af6f50] = None,
        timezone: typing.Optional[builtins.str] = None,
    ) -> "InstanceEngineConfig":
        '''(experimental) Method called when the engine is used to create a new instance.

        :param scope: -
        :param domain: (experimental) The Active Directory directory ID to create the DB instance in. Default: - none (it's an optional field)
        :param option_group: (experimental) The option group of the database. Default: - none
        :param s3_export_role: (experimental) The role used for S3 exporting. Default: - none
        :param s3_import_role: (experimental) The role used for S3 importing. Default: - none
        :param timezone: (experimental) The timezone of the database, set by the customer. Default: - none (it's an optional field)

        :stability: experimental
        '''
        ...


class _IInstanceEngineProxy(
    jsii.proxy_for(IEngine), # type: ignore[misc]
):
    '''(experimental) Interface representing a database instance (as opposed to cluster) engine.

    :stability: experimental
    '''

    __jsii_type__: typing.ClassVar[str] = "monocdk.aws_rds.IInstanceEngine"

    @builtins.property
    @jsii.member(jsii_name="multiUserRotationApplication")
    def multi_user_rotation_application(self) -> _SecretRotationApplication_0ac7c5d5:
        '''(experimental) The application used by this engine to perform rotation for a multi-user scenario.

        :stability: experimental
        '''
        return typing.cast(_SecretRotationApplication_0ac7c5d5, jsii.get(self, "multiUserRotationApplication"))

    @builtins.property
    @jsii.member(jsii_name="singleUserRotationApplication")
    def single_user_rotation_application(self) -> _SecretRotationApplication_0ac7c5d5:
        '''(experimental) The application used by this engine to perform rotation for a single-user scenario.

        :stability: experimental
        '''
        return typing.cast(_SecretRotationApplication_0ac7c5d5, jsii.get(self, "singleUserRotationApplication"))

    @builtins.property
    @jsii.member(jsii_name="supportsReadReplicaBackups")
    def supports_read_replica_backups(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Whether this engine supports automatic backups of a read replica instance.

        :default: false

        :stability: experimental
        '''
        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "supportsReadReplicaBackups"))

    @jsii.member(jsii_name="bindToInstance")
    def bind_to_instance(
        self,
        scope: _Construct_e78e779f,
        *,
        domain: typing.Optional[builtins.str] = None,
        option_group: typing.Optional["IOptionGroup"] = None,
        s3_export_role: typing.Optional[_IRole_59af6f50] = None,
        s3_import_role: typing.Optional[_IRole_59af6f50] = None,
        timezone: typing.Optional[builtins.str] = None,
    ) -> "InstanceEngineConfig":
        '''(experimental) Method called when the engine is used to create a new instance.

        :param scope: -
        :param domain: (experimental) The Active Directory directory ID to create the DB instance in. Default: - none (it's an optional field)
        :param option_group: (experimental) The option group of the database. Default: - none
        :param s3_export_role: (experimental) The role used for S3 exporting. Default: - none
        :param s3_import_role: (experimental) The role used for S3 importing. Default: - none
        :param timezone: (experimental) The timezone of the database, set by the customer. Default: - none (it's an optional field)

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__027a95a0176a5137e2d3b88f2d71290c32d245a6a6ef6311b8c1688b455fe35a)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        options = InstanceEngineBindOptions(
            domain=domain,
            option_group=option_group,
            s3_export_role=s3_export_role,
            s3_import_role=s3_import_role,
            timezone=timezone,
        )

        return typing.cast("InstanceEngineConfig", jsii.invoke(self, "bindToInstance", [scope, options]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IInstanceEngine).__jsii_proxy_class__ = lambda : _IInstanceEngineProxy


@jsii.interface(jsii_type="monocdk.aws_rds.IOptionGroup")
class IOptionGroup(_IResource_8c1dbbbd, typing_extensions.Protocol):
    '''(experimental) An option group.

    :stability: experimental
    '''

    @builtins.property
    @jsii.member(jsii_name="optionGroupName")
    def option_group_name(self) -> builtins.str:
        '''(experimental) The name of the option group.

        :stability: experimental
        :attribute: true
        '''
        ...

    @jsii.member(jsii_name="addConfiguration")
    def add_configuration(
        self,
        *,
        name: builtins.str,
        port: typing.Optional[jsii.Number] = None,
        security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
        settings: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        version: typing.Optional[builtins.str] = None,
        vpc: typing.Optional[_IVpc_6d1f76c4] = None,
    ) -> builtins.bool:
        '''(experimental) Adds a configuration to this OptionGroup.

        This method is a no-op for an imported OptionGroup.

        :param name: (experimental) The name of the option.
        :param port: (experimental) The port number that this option uses. If ``port`` is specified then ``vpc`` must also be specified. Default: - no port
        :param security_groups: (experimental) Optional list of security groups to use for this option, if ``vpc`` is specified. If no groups are provided, a default one will be created. Default: - a default group will be created if ``port`` or ``vpc`` are specified.
        :param settings: (experimental) The settings for the option. Default: - no settings
        :param version: (experimental) The version for the option. Default: - no version
        :param vpc: (experimental) The VPC where a security group should be created for this option. If ``vpc`` is specified then ``port`` must also be specified. Default: - no VPC

        :return: true if the OptionConfiguration was successfully added.

        :stability: experimental
        '''
        ...


class _IOptionGroupProxy(
    jsii.proxy_for(_IResource_8c1dbbbd), # type: ignore[misc]
):
    '''(experimental) An option group.

    :stability: experimental
    '''

    __jsii_type__: typing.ClassVar[str] = "monocdk.aws_rds.IOptionGroup"

    @builtins.property
    @jsii.member(jsii_name="optionGroupName")
    def option_group_name(self) -> builtins.str:
        '''(experimental) The name of the option group.

        :stability: experimental
        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "optionGroupName"))

    @jsii.member(jsii_name="addConfiguration")
    def add_configuration(
        self,
        *,
        name: builtins.str,
        port: typing.Optional[jsii.Number] = None,
        security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
        settings: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        version: typing.Optional[builtins.str] = None,
        vpc: typing.Optional[_IVpc_6d1f76c4] = None,
    ) -> builtins.bool:
        '''(experimental) Adds a configuration to this OptionGroup.

        This method is a no-op for an imported OptionGroup.

        :param name: (experimental) The name of the option.
        :param port: (experimental) The port number that this option uses. If ``port`` is specified then ``vpc`` must also be specified. Default: - no port
        :param security_groups: (experimental) Optional list of security groups to use for this option, if ``vpc`` is specified. If no groups are provided, a default one will be created. Default: - a default group will be created if ``port`` or ``vpc`` are specified.
        :param settings: (experimental) The settings for the option. Default: - no settings
        :param version: (experimental) The version for the option. Default: - no version
        :param vpc: (experimental) The VPC where a security group should be created for this option. If ``vpc`` is specified then ``port`` must also be specified. Default: - no VPC

        :return: true if the OptionConfiguration was successfully added.

        :stability: experimental
        '''
        configuration = OptionConfiguration(
            name=name,
            port=port,
            security_groups=security_groups,
            settings=settings,
            version=version,
            vpc=vpc,
        )

        return typing.cast(builtins.bool, jsii.invoke(self, "addConfiguration", [configuration]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IOptionGroup).__jsii_proxy_class__ = lambda : _IOptionGroupProxy


@jsii.interface(jsii_type="monocdk.aws_rds.IParameterGroup")
class IParameterGroup(_IResource_8c1dbbbd, typing_extensions.Protocol):
    '''(experimental) A parameter group.

    Represents both a cluster parameter group,
    and an instance parameter group.

    :stability: experimental
    '''

    @jsii.member(jsii_name="addParameter")
    def add_parameter(self, key: builtins.str, value: builtins.str) -> builtins.bool:
        '''(experimental) Adds a parameter to this group.

        If this is an imported parameter group,
        this method does nothing.

        :param key: -
        :param value: -

        :return:

        true if the parameter was actually added
        (i.e., this ParameterGroup is not imported),
        false otherwise

        :stability: experimental
        '''
        ...

    @jsii.member(jsii_name="bindToCluster")
    def bind_to_cluster(self) -> "ParameterGroupClusterConfig":
        '''(experimental) Method called when this Parameter Group is used when defining a database cluster.

        :stability: experimental
        '''
        ...

    @jsii.member(jsii_name="bindToInstance")
    def bind_to_instance(self) -> "ParameterGroupInstanceConfig":
        '''(experimental) Method called when this Parameter Group is used when defining a database instance.

        :stability: experimental
        '''
        ...


class _IParameterGroupProxy(
    jsii.proxy_for(_IResource_8c1dbbbd), # type: ignore[misc]
):
    '''(experimental) A parameter group.

    Represents both a cluster parameter group,
    and an instance parameter group.

    :stability: experimental
    '''

    __jsii_type__: typing.ClassVar[str] = "monocdk.aws_rds.IParameterGroup"

    @jsii.member(jsii_name="addParameter")
    def add_parameter(self, key: builtins.str, value: builtins.str) -> builtins.bool:
        '''(experimental) Adds a parameter to this group.

        If this is an imported parameter group,
        this method does nothing.

        :param key: -
        :param value: -

        :return:

        true if the parameter was actually added
        (i.e., this ParameterGroup is not imported),
        false otherwise

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9806a6d21521ad5e0ec67291a5af9ed2be285b98c722e96c91a31761d113bab3)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(builtins.bool, jsii.invoke(self, "addParameter", [key, value]))

    @jsii.member(jsii_name="bindToCluster")
    def bind_to_cluster(self) -> "ParameterGroupClusterConfig":
        '''(experimental) Method called when this Parameter Group is used when defining a database cluster.

        :stability: experimental
        '''
        options = ParameterGroupClusterBindOptions()

        return typing.cast("ParameterGroupClusterConfig", jsii.invoke(self, "bindToCluster", [options]))

    @jsii.member(jsii_name="bindToInstance")
    def bind_to_instance(self) -> "ParameterGroupInstanceConfig":
        '''(experimental) Method called when this Parameter Group is used when defining a database instance.

        :stability: experimental
        '''
        options = ParameterGroupInstanceBindOptions()

        return typing.cast("ParameterGroupInstanceConfig", jsii.invoke(self, "bindToInstance", [options]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IParameterGroup).__jsii_proxy_class__ = lambda : _IParameterGroupProxy


@jsii.interface(jsii_type="monocdk.aws_rds.IServerlessCluster")
class IServerlessCluster(
    _IResource_8c1dbbbd,
    _IConnectable_c1c0e72c,
    _ISecretAttachmentTarget_b6932462,
    typing_extensions.Protocol,
):
    '''(experimental) Interface representing a serverless database cluster.

    :stability: experimental
    '''

    @builtins.property
    @jsii.member(jsii_name="clusterArn")
    def cluster_arn(self) -> builtins.str:
        '''(experimental) The ARN of the cluster.

        :stability: experimental
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="clusterEndpoint")
    def cluster_endpoint(self) -> Endpoint:
        '''(experimental) The endpoint to use for read/write operations.

        :stability: experimental
        :attribute: EndpointAddress,EndpointPort
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="clusterIdentifier")
    def cluster_identifier(self) -> builtins.str:
        '''(experimental) Identifier of the cluster.

        :stability: experimental
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="clusterReadEndpoint")
    def cluster_read_endpoint(self) -> Endpoint:
        '''(experimental) Endpoint to use for load-balanced read-only operations.

        :stability: experimental
        :attribute: ReadEndpointAddress
        '''
        ...

    @jsii.member(jsii_name="grantDataApiAccess")
    def grant_data_api_access(self, grantee: _IGrantable_4c5a91d1) -> _Grant_bcb5eae7:
        '''(experimental) Grant the given identity to access to the Data API.

        :param grantee: The principal to grant access to.

        :stability: experimental
        '''
        ...


class _IServerlessClusterProxy(
    jsii.proxy_for(_IResource_8c1dbbbd), # type: ignore[misc]
    jsii.proxy_for(_IConnectable_c1c0e72c), # type: ignore[misc]
    jsii.proxy_for(_ISecretAttachmentTarget_b6932462), # type: ignore[misc]
):
    '''(experimental) Interface representing a serverless database cluster.

    :stability: experimental
    '''

    __jsii_type__: typing.ClassVar[str] = "monocdk.aws_rds.IServerlessCluster"

    @builtins.property
    @jsii.member(jsii_name="clusterArn")
    def cluster_arn(self) -> builtins.str:
        '''(experimental) The ARN of the cluster.

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "clusterArn"))

    @builtins.property
    @jsii.member(jsii_name="clusterEndpoint")
    def cluster_endpoint(self) -> Endpoint:
        '''(experimental) The endpoint to use for read/write operations.

        :stability: experimental
        :attribute: EndpointAddress,EndpointPort
        '''
        return typing.cast(Endpoint, jsii.get(self, "clusterEndpoint"))

    @builtins.property
    @jsii.member(jsii_name="clusterIdentifier")
    def cluster_identifier(self) -> builtins.str:
        '''(experimental) Identifier of the cluster.

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "clusterIdentifier"))

    @builtins.property
    @jsii.member(jsii_name="clusterReadEndpoint")
    def cluster_read_endpoint(self) -> Endpoint:
        '''(experimental) Endpoint to use for load-balanced read-only operations.

        :stability: experimental
        :attribute: ReadEndpointAddress
        '''
        return typing.cast(Endpoint, jsii.get(self, "clusterReadEndpoint"))

    @jsii.member(jsii_name="grantDataApiAccess")
    def grant_data_api_access(self, grantee: _IGrantable_4c5a91d1) -> _Grant_bcb5eae7:
        '''(experimental) Grant the given identity to access to the Data API.

        :param grantee: The principal to grant access to.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0dee857ceefd98c3a523c028d897a5967f524166f51e90fbb3e593a6296aa795)
            check_type(argname="argument grantee", value=grantee, expected_type=type_hints["grantee"])
        return typing.cast(_Grant_bcb5eae7, jsii.invoke(self, "grantDataApiAccess", [grantee]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IServerlessCluster).__jsii_proxy_class__ = lambda : _IServerlessClusterProxy


@jsii.interface(jsii_type="monocdk.aws_rds.ISubnetGroup")
class ISubnetGroup(_IResource_8c1dbbbd, typing_extensions.Protocol):
    '''(experimental) Interface for a subnet group.

    :stability: experimental
    '''

    @builtins.property
    @jsii.member(jsii_name="subnetGroupName")
    def subnet_group_name(self) -> builtins.str:
        '''(experimental) The name of the subnet group.

        :stability: experimental
        :attribute: true
        '''
        ...


class _ISubnetGroupProxy(
    jsii.proxy_for(_IResource_8c1dbbbd), # type: ignore[misc]
):
    '''(experimental) Interface for a subnet group.

    :stability: experimental
    '''

    __jsii_type__: typing.ClassVar[str] = "monocdk.aws_rds.ISubnetGroup"

    @builtins.property
    @jsii.member(jsii_name="subnetGroupName")
    def subnet_group_name(self) -> builtins.str:
        '''(experimental) The name of the subnet group.

        :stability: experimental
        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "subnetGroupName"))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, ISubnetGroup).__jsii_proxy_class__ = lambda : _ISubnetGroupProxy


@jsii.data_type(
    jsii_type="monocdk.aws_rds.InstanceEngineBindOptions",
    jsii_struct_bases=[],
    name_mapping={
        "domain": "domain",
        "option_group": "optionGroup",
        "s3_export_role": "s3ExportRole",
        "s3_import_role": "s3ImportRole",
        "timezone": "timezone",
    },
)
class InstanceEngineBindOptions:
    def __init__(
        self,
        *,
        domain: typing.Optional[builtins.str] = None,
        option_group: typing.Optional[IOptionGroup] = None,
        s3_export_role: typing.Optional[_IRole_59af6f50] = None,
        s3_import_role: typing.Optional[_IRole_59af6f50] = None,
        timezone: typing.Optional[builtins.str] = None,
    ) -> None:
        '''(experimental) The options passed to {@link IInstanceEngine.bind}.

        :param domain: (experimental) The Active Directory directory ID to create the DB instance in. Default: - none (it's an optional field)
        :param option_group: (experimental) The option group of the database. Default: - none
        :param s3_export_role: (experimental) The role used for S3 exporting. Default: - none
        :param s3_import_role: (experimental) The role used for S3 importing. Default: - none
        :param timezone: (experimental) The timezone of the database, set by the customer. Default: - none (it's an optional field)

        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_iam as iam
            from monocdk import aws_rds as rds
            
            # option_group: rds.OptionGroup
            # role: iam.Role
            
            instance_engine_bind_options = rds.InstanceEngineBindOptions(
                domain="domain",
                option_group=option_group,
                s3_export_role=role,
                s3_import_role=role,
                timezone="timezone"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5753200842ba0102e7f6150267872fd8c4c2bbd3d00daa9b3b69fc2ddc623bb0)
            check_type(argname="argument domain", value=domain, expected_type=type_hints["domain"])
            check_type(argname="argument option_group", value=option_group, expected_type=type_hints["option_group"])
            check_type(argname="argument s3_export_role", value=s3_export_role, expected_type=type_hints["s3_export_role"])
            check_type(argname="argument s3_import_role", value=s3_import_role, expected_type=type_hints["s3_import_role"])
            check_type(argname="argument timezone", value=timezone, expected_type=type_hints["timezone"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if domain is not None:
            self._values["domain"] = domain
        if option_group is not None:
            self._values["option_group"] = option_group
        if s3_export_role is not None:
            self._values["s3_export_role"] = s3_export_role
        if s3_import_role is not None:
            self._values["s3_import_role"] = s3_import_role
        if timezone is not None:
            self._values["timezone"] = timezone

    @builtins.property
    def domain(self) -> typing.Optional[builtins.str]:
        '''(experimental) The Active Directory directory ID to create the DB instance in.

        :default: - none (it's an optional field)

        :stability: experimental
        '''
        result = self._values.get("domain")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def option_group(self) -> typing.Optional[IOptionGroup]:
        '''(experimental) The option group of the database.

        :default: - none

        :stability: experimental
        '''
        result = self._values.get("option_group")
        return typing.cast(typing.Optional[IOptionGroup], result)

    @builtins.property
    def s3_export_role(self) -> typing.Optional[_IRole_59af6f50]:
        '''(experimental) The role used for S3 exporting.

        :default: - none

        :stability: experimental
        '''
        result = self._values.get("s3_export_role")
        return typing.cast(typing.Optional[_IRole_59af6f50], result)

    @builtins.property
    def s3_import_role(self) -> typing.Optional[_IRole_59af6f50]:
        '''(experimental) The role used for S3 importing.

        :default: - none

        :stability: experimental
        '''
        result = self._values.get("s3_import_role")
        return typing.cast(typing.Optional[_IRole_59af6f50], result)

    @builtins.property
    def timezone(self) -> typing.Optional[builtins.str]:
        '''(experimental) The timezone of the database, set by the customer.

        :default: - none (it's an optional field)

        :stability: experimental
        '''
        result = self._values.get("timezone")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "InstanceEngineBindOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_rds.InstanceEngineConfig",
    jsii_struct_bases=[],
    name_mapping={"features": "features", "option_group": "optionGroup"},
)
class InstanceEngineConfig:
    def __init__(
        self,
        *,
        features: typing.Optional[typing.Union["InstanceEngineFeatures", typing.Dict[builtins.str, typing.Any]]] = None,
        option_group: typing.Optional[IOptionGroup] = None,
    ) -> None:
        '''(experimental) The type returned from the {@link IInstanceEngine.bind} method.

        :param features: (experimental) Features supported by the database engine. Default: - no features
        :param option_group: (experimental) Option group of the database. Default: - none

        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_rds as rds
            
            # option_group: rds.OptionGroup
            
            instance_engine_config = rds.InstanceEngineConfig(
                features=rds.InstanceEngineFeatures(
                    s3_export="s3Export",
                    s3_import="s3Import"
                ),
                option_group=option_group
            )
        '''
        if isinstance(features, dict):
            features = InstanceEngineFeatures(**features)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4a3da857f470a63c68899fd33a29f9a056eff41e67ce1dcf7953207853ed985e)
            check_type(argname="argument features", value=features, expected_type=type_hints["features"])
            check_type(argname="argument option_group", value=option_group, expected_type=type_hints["option_group"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if features is not None:
            self._values["features"] = features
        if option_group is not None:
            self._values["option_group"] = option_group

    @builtins.property
    def features(self) -> typing.Optional["InstanceEngineFeatures"]:
        '''(experimental) Features supported by the database engine.

        :default: - no features

        :see: https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_DBEngineVersion.html
        :stability: experimental
        '''
        result = self._values.get("features")
        return typing.cast(typing.Optional["InstanceEngineFeatures"], result)

    @builtins.property
    def option_group(self) -> typing.Optional[IOptionGroup]:
        '''(experimental) Option group of the database.

        :default: - none

        :stability: experimental
        '''
        result = self._values.get("option_group")
        return typing.cast(typing.Optional[IOptionGroup], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "InstanceEngineConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_rds.InstanceEngineFeatures",
    jsii_struct_bases=[],
    name_mapping={"s3_export": "s3Export", "s3_import": "s3Import"},
)
class InstanceEngineFeatures:
    def __init__(
        self,
        *,
        s3_export: typing.Optional[builtins.str] = None,
        s3_import: typing.Optional[builtins.str] = None,
    ) -> None:
        '''(experimental) Represents Database Engine features.

        :param s3_export: (experimental) Feature name for the DB instance that the IAM role to export to S3 bucket is to be associated with. Default: - no s3Export feature name
        :param s3_import: (experimental) Feature name for the DB instance that the IAM role to access the S3 bucket for import is to be associated with. Default: - no s3Import feature name

        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_rds as rds
            
            instance_engine_features = rds.InstanceEngineFeatures(
                s3_export="s3Export",
                s3_import="s3Import"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__87773405f00fac26f3c90e97a557d50371038a28720f483b27d83e932fdf63ec)
            check_type(argname="argument s3_export", value=s3_export, expected_type=type_hints["s3_export"])
            check_type(argname="argument s3_import", value=s3_import, expected_type=type_hints["s3_import"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if s3_export is not None:
            self._values["s3_export"] = s3_export
        if s3_import is not None:
            self._values["s3_import"] = s3_import

    @builtins.property
    def s3_export(self) -> typing.Optional[builtins.str]:
        '''(experimental) Feature name for the DB instance that the IAM role to export to S3 bucket is to be associated with.

        :default: - no s3Export feature name

        :stability: experimental
        '''
        result = self._values.get("s3_export")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def s3_import(self) -> typing.Optional[builtins.str]:
        '''(experimental) Feature name for the DB instance that the IAM role to access the S3 bucket for import is to be associated with.

        :default: - no s3Import feature name

        :stability: experimental
        '''
        result = self._values.get("s3_import")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "InstanceEngineFeatures(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_rds.InstanceProps",
    jsii_struct_bases=[],
    name_mapping={
        "vpc": "vpc",
        "allow_major_version_upgrade": "allowMajorVersionUpgrade",
        "auto_minor_version_upgrade": "autoMinorVersionUpgrade",
        "delete_automated_backups": "deleteAutomatedBackups",
        "enable_performance_insights": "enablePerformanceInsights",
        "instance_type": "instanceType",
        "parameter_group": "parameterGroup",
        "parameters": "parameters",
        "performance_insight_encryption_key": "performanceInsightEncryptionKey",
        "performance_insight_retention": "performanceInsightRetention",
        "publicly_accessible": "publiclyAccessible",
        "security_groups": "securityGroups",
        "vpc_subnets": "vpcSubnets",
    },
)
class InstanceProps:
    def __init__(
        self,
        *,
        vpc: _IVpc_6d1f76c4,
        allow_major_version_upgrade: typing.Optional[builtins.bool] = None,
        auto_minor_version_upgrade: typing.Optional[builtins.bool] = None,
        delete_automated_backups: typing.Optional[builtins.bool] = None,
        enable_performance_insights: typing.Optional[builtins.bool] = None,
        instance_type: typing.Optional[_InstanceType_072ad323] = None,
        parameter_group: typing.Optional[IParameterGroup] = None,
        parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        performance_insight_encryption_key: typing.Optional[_IKey_36930160] = None,
        performance_insight_retention: typing.Optional["PerformanceInsightRetention"] = None,
        publicly_accessible: typing.Optional[builtins.bool] = None,
        security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
        vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''(experimental) Instance properties for database instances.

        :param vpc: (experimental) What subnets to run the RDS instances in. Must be at least 2 subnets in two different AZs.
        :param allow_major_version_upgrade: (experimental) Whether to allow upgrade of major version for the DB instance. Default: - false
        :param auto_minor_version_upgrade: (experimental) Whether to enable automatic upgrade of minor version for the DB instance. Default: - true
        :param delete_automated_backups: (experimental) Whether to remove automated backups immediately after the DB instance is deleted for the DB instance. Default: - true
        :param enable_performance_insights: (experimental) Whether to enable Performance Insights for the DB instance. Default: - false, unless ``performanceInsightRentention`` or ``performanceInsightEncryptionKey`` is set.
        :param instance_type: (experimental) What type of instance to start for the replicas. Default: - t3.medium (or, more precisely, db.t3.medium)
        :param parameter_group: (experimental) The DB parameter group to associate with the instance. Default: no parameter group
        :param parameters: (experimental) The parameters in the DBParameterGroup to create automatically. You can only specify parameterGroup or parameters but not both. You need to use a versioned engine to auto-generate a DBParameterGroup. Default: - None
        :param performance_insight_encryption_key: (experimental) The AWS KMS key for encryption of Performance Insights data. Default: - default master key
        :param performance_insight_retention: (experimental) The amount of time, in days, to retain Performance Insights data. Default: 7
        :param publicly_accessible: (experimental) Indicates whether the DB instance is an internet-facing instance. Default: - ``true`` if ``vpcSubnets`` is ``subnetType: SubnetType.PUBLIC``, ``false`` otherwise
        :param security_groups: (experimental) Security group. Default: a new security group is created.
        :param vpc_subnets: (experimental) Where to place the instances within the VPC. Default: - the Vpc default strategy if not specified.

        :stability: experimental
        :exampleMetadata: infused

        Example::

            # vpc: ec2.Vpc
            
            cluster = rds.DatabaseCluster(self, "Database",
                engine=rds.DatabaseClusterEngine.AURORA,
                instance_props=ec2.aws_rds.InstanceProps(vpc=vpc)
            )
            
            proxy = rds.DatabaseProxy(self, "Proxy",
                proxy_target=rds.ProxyTarget.from_cluster(cluster),
                secrets=[cluster.secret],
                vpc=vpc
            )
            
            role = iam.Role(self, "DBProxyRole", assumed_by=iam.AccountPrincipal(self.account))
            proxy.grant_connect(role, "admin")
        '''
        if isinstance(vpc_subnets, dict):
            vpc_subnets = _SubnetSelection_1284e62c(**vpc_subnets)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b308d2878231216f2cda103c16b475b34e49a2a94e392299d92c47e7bc96e489)
            check_type(argname="argument vpc", value=vpc, expected_type=type_hints["vpc"])
            check_type(argname="argument allow_major_version_upgrade", value=allow_major_version_upgrade, expected_type=type_hints["allow_major_version_upgrade"])
            check_type(argname="argument auto_minor_version_upgrade", value=auto_minor_version_upgrade, expected_type=type_hints["auto_minor_version_upgrade"])
            check_type(argname="argument delete_automated_backups", value=delete_automated_backups, expected_type=type_hints["delete_automated_backups"])
            check_type(argname="argument enable_performance_insights", value=enable_performance_insights, expected_type=type_hints["enable_performance_insights"])
            check_type(argname="argument instance_type", value=instance_type, expected_type=type_hints["instance_type"])
            check_type(argname="argument parameter_group", value=parameter_group, expected_type=type_hints["parameter_group"])
            check_type(argname="argument parameters", value=parameters, expected_type=type_hints["parameters"])
            check_type(argname="argument performance_insight_encryption_key", value=performance_insight_encryption_key, expected_type=type_hints["performance_insight_encryption_key"])
            check_type(argname="argument performance_insight_retention", value=performance_insight_retention, expected_type=type_hints["performance_insight_retention"])
            check_type(argname="argument publicly_accessible", value=publicly_accessible, expected_type=type_hints["publicly_accessible"])
            check_type(argname="argument security_groups", value=security_groups, expected_type=type_hints["security_groups"])
            check_type(argname="argument vpc_subnets", value=vpc_subnets, expected_type=type_hints["vpc_subnets"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "vpc": vpc,
        }
        if allow_major_version_upgrade is not None:
            self._values["allow_major_version_upgrade"] = allow_major_version_upgrade
        if auto_minor_version_upgrade is not None:
            self._values["auto_minor_version_upgrade"] = auto_minor_version_upgrade
        if delete_automated_backups is not None:
            self._values["delete_automated_backups"] = delete_automated_backups
        if enable_performance_insights is not None:
            self._values["enable_performance_insights"] = enable_performance_insights
        if instance_type is not None:
            self._values["instance_type"] = instance_type
        if parameter_group is not None:
            self._values["parameter_group"] = parameter_group
        if parameters is not None:
            self._values["parameters"] = parameters
        if performance_insight_encryption_key is not None:
            self._values["performance_insight_encryption_key"] = performance_insight_encryption_key
        if performance_insight_retention is not None:
            self._values["performance_insight_retention"] = performance_insight_retention
        if publicly_accessible is not None:
            self._values["publicly_accessible"] = publicly_accessible
        if security_groups is not None:
            self._values["security_groups"] = security_groups
        if vpc_subnets is not None:
            self._values["vpc_subnets"] = vpc_subnets

    @builtins.property
    def vpc(self) -> _IVpc_6d1f76c4:
        '''(experimental) What subnets to run the RDS instances in.

        Must be at least 2 subnets in two different AZs.

        :stability: experimental
        '''
        result = self._values.get("vpc")
        assert result is not None, "Required property 'vpc' is missing"
        return typing.cast(_IVpc_6d1f76c4, result)

    @builtins.property
    def allow_major_version_upgrade(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Whether to allow upgrade of major version for the DB instance.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("allow_major_version_upgrade")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def auto_minor_version_upgrade(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Whether to enable automatic upgrade of minor version for the DB instance.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("auto_minor_version_upgrade")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def delete_automated_backups(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Whether to remove automated backups immediately after the DB instance is deleted for the DB instance.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("delete_automated_backups")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_performance_insights(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Whether to enable Performance Insights for the DB instance.

        :default: - false, unless ``performanceInsightRentention`` or ``performanceInsightEncryptionKey`` is set.

        :stability: experimental
        '''
        result = self._values.get("enable_performance_insights")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def instance_type(self) -> typing.Optional[_InstanceType_072ad323]:
        '''(experimental) What type of instance to start for the replicas.

        :default: - t3.medium (or, more precisely, db.t3.medium)

        :stability: experimental
        '''
        result = self._values.get("instance_type")
        return typing.cast(typing.Optional[_InstanceType_072ad323], result)

    @builtins.property
    def parameter_group(self) -> typing.Optional[IParameterGroup]:
        '''(experimental) The DB parameter group to associate with the instance.

        :default: no parameter group

        :stability: experimental
        '''
        result = self._values.get("parameter_group")
        return typing.cast(typing.Optional[IParameterGroup], result)

    @builtins.property
    def parameters(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''(experimental) The parameters in the DBParameterGroup to create automatically.

        You can only specify parameterGroup or parameters but not both.
        You need to use a versioned engine to auto-generate a DBParameterGroup.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("parameters")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def performance_insight_encryption_key(self) -> typing.Optional[_IKey_36930160]:
        '''(experimental) The AWS KMS key for encryption of Performance Insights data.

        :default: - default master key

        :stability: experimental
        '''
        result = self._values.get("performance_insight_encryption_key")
        return typing.cast(typing.Optional[_IKey_36930160], result)

    @builtins.property
    def performance_insight_retention(
        self,
    ) -> typing.Optional["PerformanceInsightRetention"]:
        '''(experimental) The amount of time, in days, to retain Performance Insights data.

        :default: 7

        :stability: experimental
        '''
        result = self._values.get("performance_insight_retention")
        return typing.cast(typing.Optional["PerformanceInsightRetention"], result)

    @builtins.property
    def publicly_accessible(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the DB instance is an internet-facing instance.

        :default: - ``true`` if ``vpcSubnets`` is ``subnetType: SubnetType.PUBLIC``, ``false`` otherwise

        :stability: experimental
        '''
        result = self._values.get("publicly_accessible")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def security_groups(self) -> typing.Optional[typing.List[_ISecurityGroup_cdbba9d3]]:
        '''(experimental) Security group.

        :default: a new security group is created.

        :stability: experimental
        '''
        result = self._values.get("security_groups")
        return typing.cast(typing.Optional[typing.List[_ISecurityGroup_cdbba9d3]], result)

    @builtins.property
    def vpc_subnets(self) -> typing.Optional[_SubnetSelection_1284e62c]:
        '''(experimental) Where to place the instances within the VPC.

        :default: - the Vpc default strategy if not specified.

        :stability: experimental
        '''
        result = self._values.get("vpc_subnets")
        return typing.cast(typing.Optional[_SubnetSelection_1284e62c], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "InstanceProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="monocdk.aws_rds.LicenseModel")
class LicenseModel(enum.Enum):
    '''(experimental) The license model.

    :stability: experimental
    :exampleMetadata: lit=lib/aws-rds/test/integ.instance.lit.ts infused

    Example::

        # Set open cursors with parameter group
        parameter_group = rds.ParameterGroup(self, "ParameterGroup",
            engine=rds.DatabaseInstanceEngine.oracle_se2(version=rds.OracleEngineVersion.VER_19_0_0_0_2020_04_R1),
            parameters={
                "open_cursors": "2500"
            }
        )
        
        option_group = rds.OptionGroup(self, "OptionGroup",
            engine=rds.DatabaseInstanceEngine.oracle_se2(version=rds.OracleEngineVersion.VER_19_0_0_0_2020_04_R1),
            configurations=[cdk.aws_rds.OptionConfiguration(
                name="LOCATOR"
            ), cdk.aws_rds.OptionConfiguration(
                name="OEM",
                port=1158,
                vpc=vpc
            )
            ]
        )
        
        # Allow connections to OEM
        option_group.option_connections.OEM.connections.allow_default_port_from_any_ipv4()
        
        # Database instance with production values
        instance = rds.DatabaseInstance(self, "Instance",
            engine=rds.DatabaseInstanceEngine.oracle_se2(version=rds.OracleEngineVersion.VER_19_0_0_0_2020_04_R1),
            license_model=rds.LicenseModel.BRING_YOUR_OWN_LICENSE,
            instance_type=ec2.InstanceType.of(ec2.InstanceClass.BURSTABLE3, ec2.InstanceSize.MEDIUM),
            multi_az=True,
            storage_type=rds.StorageType.IO1,
            credentials=rds.Credentials.from_username("syscdk"),
            vpc=vpc,
            database_name="ORCL",
            storage_encrypted=True,
            backup_retention=cdk.Duration.days(7),
            monitoring_interval=cdk.Duration.seconds(60),
            enable_performance_insights=True,
            cloudwatch_logs_exports=["trace", "audit", "alert", "listener"
            ],
            cloudwatch_logs_retention=logs.RetentionDays.ONE_MONTH,
            auto_minor_version_upgrade=True,  # required to be true if LOCATOR is used in the option group
            option_group=option_group,
            parameter_group=parameter_group,
            removal_policy=RemovalPolicy.DESTROY
        )
        
        # Allow connections on default port from any IPV4
        instance.connections.allow_default_port_from_any_ipv4()
        
        # Rotate the master user password every 30 days
        instance.add_rotation_single_user()
        
        # Add alarm for high CPU
        cloudwatch.Alarm(self, "HighCPU",
            metric=instance.metric_cPUUtilization(),
            threshold=90,
            evaluation_periods=1
        )
        
        # Trigger Lambda function on instance availability events
        fn = lambda_.Function(self, "Function",
            code=lambda_.Code.from_inline("exports.handler = (event) => console.log(event);"),
            handler="index.handler",
            runtime=lambda_.Runtime.NODEJS_14_X
        )
        
        availability_rule = instance.on_event("Availability", target=targets.LambdaFunction(fn))
        availability_rule.add_event_pattern(
            detail={
                "EventCategories": ["availability"
                ]
            }
        )
    '''

    LICENSE_INCLUDED = "LICENSE_INCLUDED"
    '''(experimental) License included.

    :stability: experimental
    '''
    BRING_YOUR_OWN_LICENSE = "BRING_YOUR_OWN_LICENSE"
    '''(experimental) Bring your own licencse.

    :stability: experimental
    '''
    GENERAL_PUBLIC_LICENSE = "GENERAL_PUBLIC_LICENSE"
    '''(experimental) General public license.

    :stability: experimental
    '''


class MariaDbEngineVersion(
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_rds.MariaDbEngineVersion",
):
    '''(experimental) The versions for the MariaDB instance engines (those returned by {@link DatabaseInstanceEngine.mariaDb}).

    :stability: experimental
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from monocdk import aws_rds as rds
        
        maria_db_engine_version = rds.MariaDbEngineVersion.VER_10_0
    '''

    @jsii.member(jsii_name="of")
    @builtins.classmethod
    def of(
        cls,
        maria_db_full_version: builtins.str,
        maria_db_major_version: builtins.str,
    ) -> "MariaDbEngineVersion":
        '''(experimental) Create a new MariaDbEngineVersion with an arbitrary version.

        :param maria_db_full_version: the full version string, for example "10.5.28".
        :param maria_db_major_version: the major version of the engine, for example "10.5".

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1caff05283e494081bdb00d420a1a2f24c69f56c5b6b635ab40f374049b5d1e8)
            check_type(argname="argument maria_db_full_version", value=maria_db_full_version, expected_type=type_hints["maria_db_full_version"])
            check_type(argname="argument maria_db_major_version", value=maria_db_major_version, expected_type=type_hints["maria_db_major_version"])
        return typing.cast("MariaDbEngineVersion", jsii.sinvoke(cls, "of", [maria_db_full_version, maria_db_major_version]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_0")
    def VER_10_0(cls) -> "MariaDbEngineVersion":
        '''(deprecated) Version "10.0" (only a major version, without a specific minor version).

        :deprecated: MariaDB 10.0 will reach end of life on May 18, 2021

        :stability: deprecated
        '''
        return typing.cast("MariaDbEngineVersion", jsii.sget(cls, "VER_10_0"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_0_17")
    def VER_10_0_17(cls) -> "MariaDbEngineVersion":
        '''(deprecated) Version "10.0.17".

        :deprecated: MariaDB 10.0 will reach end of life on May 18, 2021

        :stability: deprecated
        '''
        return typing.cast("MariaDbEngineVersion", jsii.sget(cls, "VER_10_0_17"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_0_24")
    def VER_10_0_24(cls) -> "MariaDbEngineVersion":
        '''(deprecated) Version "10.0.24".

        :deprecated: MariaDB 10.0 will reach end of life on May 18, 2021

        :stability: deprecated
        '''
        return typing.cast("MariaDbEngineVersion", jsii.sget(cls, "VER_10_0_24"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_0_28")
    def VER_10_0_28(cls) -> "MariaDbEngineVersion":
        '''(deprecated) Version "10.0.28".

        :deprecated: MariaDB 10.0 will reach end of life on May 18, 2021

        :stability: deprecated
        '''
        return typing.cast("MariaDbEngineVersion", jsii.sget(cls, "VER_10_0_28"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_0_31")
    def VER_10_0_31(cls) -> "MariaDbEngineVersion":
        '''(deprecated) Version "10.0.31".

        :deprecated: MariaDB 10.0 will reach end of life on May 18, 2021

        :stability: deprecated
        '''
        return typing.cast("MariaDbEngineVersion", jsii.sget(cls, "VER_10_0_31"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_0_32")
    def VER_10_0_32(cls) -> "MariaDbEngineVersion":
        '''(deprecated) Version "10.0.32".

        :deprecated: MariaDB 10.0 will reach end of life on May 18, 2021

        :stability: deprecated
        '''
        return typing.cast("MariaDbEngineVersion", jsii.sget(cls, "VER_10_0_32"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_0_34")
    def VER_10_0_34(cls) -> "MariaDbEngineVersion":
        '''(deprecated) Version "10.0.34".

        :deprecated: MariaDB 10.0 will reach end of life on May 18, 2021

        :stability: deprecated
        '''
        return typing.cast("MariaDbEngineVersion", jsii.sget(cls, "VER_10_0_34"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_0_35")
    def VER_10_0_35(cls) -> "MariaDbEngineVersion":
        '''(deprecated) Version "10.0.35".

        :deprecated: MariaDB 10.0 will reach end of life on May 18, 2021

        :stability: deprecated
        '''
        return typing.cast("MariaDbEngineVersion", jsii.sget(cls, "VER_10_0_35"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_1")
    def VER_10_1(cls) -> "MariaDbEngineVersion":
        '''(deprecated) Version "10.1" (only a major version, without a specific minor version).

        :deprecated: MariaDB 10.1 will reach end of life on May 18, 2021

        :stability: deprecated
        '''
        return typing.cast("MariaDbEngineVersion", jsii.sget(cls, "VER_10_1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_1_14")
    def VER_10_1_14(cls) -> "MariaDbEngineVersion":
        '''(deprecated) Version "10.1.14".

        :deprecated: MariaDB 10.1 will reach end of life on May 18, 2021

        :stability: deprecated
        '''
        return typing.cast("MariaDbEngineVersion", jsii.sget(cls, "VER_10_1_14"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_1_19")
    def VER_10_1_19(cls) -> "MariaDbEngineVersion":
        '''(deprecated) Version "10.1.19".

        :deprecated: MariaDB 10.1 will reach end of life on May 18, 2021

        :stability: deprecated
        '''
        return typing.cast("MariaDbEngineVersion", jsii.sget(cls, "VER_10_1_19"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_1_23")
    def VER_10_1_23(cls) -> "MariaDbEngineVersion":
        '''(deprecated) Version "10.1.23".

        :deprecated: MariaDB 10.1 will reach end of life on May 18, 2021

        :stability: deprecated
        '''
        return typing.cast("MariaDbEngineVersion", jsii.sget(cls, "VER_10_1_23"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_1_26")
    def VER_10_1_26(cls) -> "MariaDbEngineVersion":
        '''(deprecated) Version "10.1.26".

        :deprecated: MariaDB 10.1 will reach end of life on May 18, 2021

        :stability: deprecated
        '''
        return typing.cast("MariaDbEngineVersion", jsii.sget(cls, "VER_10_1_26"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_1_31")
    def VER_10_1_31(cls) -> "MariaDbEngineVersion":
        '''(deprecated) Version "10.1.31".

        :deprecated: MariaDB 10.1 will reach end of life on May 18, 2021

        :stability: deprecated
        '''
        return typing.cast("MariaDbEngineVersion", jsii.sget(cls, "VER_10_1_31"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_1_34")
    def VER_10_1_34(cls) -> "MariaDbEngineVersion":
        '''(deprecated) Version "10.1.34".

        :deprecated: MariaDB 10.1 will reach end of life on May 18, 2021

        :stability: deprecated
        '''
        return typing.cast("MariaDbEngineVersion", jsii.sget(cls, "VER_10_1_34"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_2")
    def VER_10_2(cls) -> "MariaDbEngineVersion":
        '''(experimental) Version "10.2" (only a major version, without a specific minor version).

        :stability: experimental
        '''
        return typing.cast("MariaDbEngineVersion", jsii.sget(cls, "VER_10_2"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_2_11")
    def VER_10_2_11(cls) -> "MariaDbEngineVersion":
        '''(experimental) Version "10.2.11".

        :stability: experimental
        '''
        return typing.cast("MariaDbEngineVersion", jsii.sget(cls, "VER_10_2_11"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_2_12")
    def VER_10_2_12(cls) -> "MariaDbEngineVersion":
        '''(experimental) Version "10.2.12".

        :stability: experimental
        '''
        return typing.cast("MariaDbEngineVersion", jsii.sget(cls, "VER_10_2_12"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_2_15")
    def VER_10_2_15(cls) -> "MariaDbEngineVersion":
        '''(experimental) Version "10.2.15".

        :stability: experimental
        '''
        return typing.cast("MariaDbEngineVersion", jsii.sget(cls, "VER_10_2_15"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_2_21")
    def VER_10_2_21(cls) -> "MariaDbEngineVersion":
        '''(experimental) Version "10.2.21".

        :stability: experimental
        '''
        return typing.cast("MariaDbEngineVersion", jsii.sget(cls, "VER_10_2_21"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_2_32")
    def VER_10_2_32(cls) -> "MariaDbEngineVersion":
        '''(experimental) Version "10.2.32".

        :stability: experimental
        '''
        return typing.cast("MariaDbEngineVersion", jsii.sget(cls, "VER_10_2_32"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_2_37")
    def VER_10_2_37(cls) -> "MariaDbEngineVersion":
        '''(experimental) Version "10.2.37".

        :stability: experimental
        '''
        return typing.cast("MariaDbEngineVersion", jsii.sget(cls, "VER_10_2_37"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_2_39")
    def VER_10_2_39(cls) -> "MariaDbEngineVersion":
        '''(experimental) Version "10.2.39".

        :stability: experimental
        '''
        return typing.cast("MariaDbEngineVersion", jsii.sget(cls, "VER_10_2_39"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_2_40")
    def VER_10_2_40(cls) -> "MariaDbEngineVersion":
        '''(experimental) Version "10.2.40".

        :stability: experimental
        '''
        return typing.cast("MariaDbEngineVersion", jsii.sget(cls, "VER_10_2_40"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_2_41")
    def VER_10_2_41(cls) -> "MariaDbEngineVersion":
        '''(experimental) Version "10.2.41".

        :stability: experimental
        '''
        return typing.cast("MariaDbEngineVersion", jsii.sget(cls, "VER_10_2_41"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_3")
    def VER_10_3(cls) -> "MariaDbEngineVersion":
        '''(experimental) Version "10.3" (only a major version, without a specific minor version).

        :stability: experimental
        '''
        return typing.cast("MariaDbEngineVersion", jsii.sget(cls, "VER_10_3"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_3_13")
    def VER_10_3_13(cls) -> "MariaDbEngineVersion":
        '''(experimental) Version "10.3.13".

        :stability: experimental
        '''
        return typing.cast("MariaDbEngineVersion", jsii.sget(cls, "VER_10_3_13"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_3_20")
    def VER_10_3_20(cls) -> "MariaDbEngineVersion":
        '''(experimental) Version "10.3.20".

        :stability: experimental
        '''
        return typing.cast("MariaDbEngineVersion", jsii.sget(cls, "VER_10_3_20"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_3_23")
    def VER_10_3_23(cls) -> "MariaDbEngineVersion":
        '''(experimental) Version "10.3.23".

        :stability: experimental
        '''
        return typing.cast("MariaDbEngineVersion", jsii.sget(cls, "VER_10_3_23"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_3_28")
    def VER_10_3_28(cls) -> "MariaDbEngineVersion":
        '''(experimental) Version "10.3.28".

        :stability: experimental
        '''
        return typing.cast("MariaDbEngineVersion", jsii.sget(cls, "VER_10_3_28"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_3_31")
    def VER_10_3_31(cls) -> "MariaDbEngineVersion":
        '''(experimental) Version "10.3.31".

        :stability: experimental
        '''
        return typing.cast("MariaDbEngineVersion", jsii.sget(cls, "VER_10_3_31"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_3_32")
    def VER_10_3_32(cls) -> "MariaDbEngineVersion":
        '''(experimental) Version "10.3.32".

        :stability: experimental
        '''
        return typing.cast("MariaDbEngineVersion", jsii.sget(cls, "VER_10_3_32"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_3_8")
    def VER_10_3_8(cls) -> "MariaDbEngineVersion":
        '''(experimental) Version "10.3.8".

        :stability: experimental
        '''
        return typing.cast("MariaDbEngineVersion", jsii.sget(cls, "VER_10_3_8"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_4")
    def VER_10_4(cls) -> "MariaDbEngineVersion":
        '''(experimental) Version "10.4" (only a major version, without a specific minor version).

        :stability: experimental
        '''
        return typing.cast("MariaDbEngineVersion", jsii.sget(cls, "VER_10_4"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_4_13")
    def VER_10_4_13(cls) -> "MariaDbEngineVersion":
        '''(experimental) Version "10.4.13".

        :stability: experimental
        '''
        return typing.cast("MariaDbEngineVersion", jsii.sget(cls, "VER_10_4_13"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_4_18")
    def VER_10_4_18(cls) -> "MariaDbEngineVersion":
        '''(experimental) Version "10.4.18".

        :stability: experimental
        '''
        return typing.cast("MariaDbEngineVersion", jsii.sget(cls, "VER_10_4_18"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_4_21")
    def VER_10_4_21(cls) -> "MariaDbEngineVersion":
        '''(experimental) Version "10.4.21".

        :stability: experimental
        '''
        return typing.cast("MariaDbEngineVersion", jsii.sget(cls, "VER_10_4_21"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_4_22")
    def VER_10_4_22(cls) -> "MariaDbEngineVersion":
        '''(experimental) Version "10.4.22".

        :stability: experimental
        '''
        return typing.cast("MariaDbEngineVersion", jsii.sget(cls, "VER_10_4_22"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_4_8")
    def VER_10_4_8(cls) -> "MariaDbEngineVersion":
        '''(experimental) Version "10.4.8".

        :stability: experimental
        '''
        return typing.cast("MariaDbEngineVersion", jsii.sget(cls, "VER_10_4_8"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_5")
    def VER_10_5(cls) -> "MariaDbEngineVersion":
        '''(experimental) Version "10.5" (only a major version, without a specific minor version).

        :stability: experimental
        '''
        return typing.cast("MariaDbEngineVersion", jsii.sget(cls, "VER_10_5"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_5_12")
    def VER_10_5_12(cls) -> "MariaDbEngineVersion":
        '''(experimental) Version "10.5.12".

        :stability: experimental
        '''
        return typing.cast("MariaDbEngineVersion", jsii.sget(cls, "VER_10_5_12"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_5_13")
    def VER_10_5_13(cls) -> "MariaDbEngineVersion":
        '''(experimental) Version "10.5.13".

        :stability: experimental
        '''
        return typing.cast("MariaDbEngineVersion", jsii.sget(cls, "VER_10_5_13"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_5_8")
    def VER_10_5_8(cls) -> "MariaDbEngineVersion":
        '''(experimental) Version "10.5.8".

        :stability: experimental
        '''
        return typing.cast("MariaDbEngineVersion", jsii.sget(cls, "VER_10_5_8"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_5_9")
    def VER_10_5_9(cls) -> "MariaDbEngineVersion":
        '''(experimental) Version "10.5.9".

        :stability: experimental
        '''
        return typing.cast("MariaDbEngineVersion", jsii.sget(cls, "VER_10_5_9"))

    @builtins.property
    @jsii.member(jsii_name="mariaDbFullVersion")
    def maria_db_full_version(self) -> builtins.str:
        '''(experimental) The full version string, for example, "10.5.28".

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "mariaDbFullVersion"))

    @builtins.property
    @jsii.member(jsii_name="mariaDbMajorVersion")
    def maria_db_major_version(self) -> builtins.str:
        '''(experimental) The major version of the engine, for example, "10.5".

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "mariaDbMajorVersion"))


@jsii.data_type(
    jsii_type="monocdk.aws_rds.MariaDbInstanceEngineProps",
    jsii_struct_bases=[],
    name_mapping={"version": "version"},
)
class MariaDbInstanceEngineProps:
    def __init__(self, *, version: MariaDbEngineVersion) -> None:
        '''(experimental) Properties for MariaDB instance engines.

        Used in {@link DatabaseInstanceEngine.mariaDb}.

        :param version: (experimental) The exact version of the engine to use.

        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_rds as rds
            
            # maria_db_engine_version: rds.MariaDbEngineVersion
            
            maria_db_instance_engine_props = rds.MariaDbInstanceEngineProps(
                version=maria_db_engine_version
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__588235258c7d49f16ddf977d8a48e44fa15f530cb66f134b36fca574c8a0d7a2)
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "version": version,
        }

    @builtins.property
    def version(self) -> MariaDbEngineVersion:
        '''(experimental) The exact version of the engine to use.

        :stability: experimental
        '''
        result = self._values.get("version")
        assert result is not None, "Required property 'version' is missing"
        return typing.cast(MariaDbEngineVersion, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "MariaDbInstanceEngineProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_rds.MySqlInstanceEngineProps",
    jsii_struct_bases=[],
    name_mapping={"version": "version"},
)
class MySqlInstanceEngineProps:
    def __init__(self, *, version: "MysqlEngineVersion") -> None:
        '''(experimental) Properties for MySQL instance engines.

        Used in {@link DatabaseInstanceEngine.mysql}.

        :param version: (experimental) The exact version of the engine to use.

        :stability: experimental
        :exampleMetadata: infused

        Example::

            # vpc: ec2.Vpc
            
            role = iam.Role(self, "RDSDirectoryServicesRole",
                assumed_by=iam.ServicePrincipal("rds.amazonaws.com"),
                managed_policies=[
                    iam.ManagedPolicy.from_aws_managed_policy_name("service-role/AmazonRDSDirectoryServiceAccess")
                ]
            )
            instance = rds.DatabaseInstance(self, "Instance",
                engine=rds.DatabaseInstanceEngine.mysql(version=rds.MysqlEngineVersion.VER_8_0_19),
                vpc=vpc,
                domain="d-????????",  # The ID of the domain for the instance to join.
                domain_role=role
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3447524277970c83d31a215338805e43dc3f65073e767ef9a00bdc5eefbcd4aa)
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "version": version,
        }

    @builtins.property
    def version(self) -> "MysqlEngineVersion":
        '''(experimental) The exact version of the engine to use.

        :stability: experimental
        '''
        result = self._values.get("version")
        assert result is not None, "Required property 'version' is missing"
        return typing.cast("MysqlEngineVersion", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "MySqlInstanceEngineProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class MysqlEngineVersion(
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_rds.MysqlEngineVersion",
):
    '''(experimental) The versions for the MySQL instance engines (those returned by {@link DatabaseInstanceEngine.mysql}).

    :stability: experimental
    :exampleMetadata: infused

    Example::

        # vpc: ec2.Vpc
        
        role = iam.Role(self, "RDSDirectoryServicesRole",
            assumed_by=iam.ServicePrincipal("rds.amazonaws.com"),
            managed_policies=[
                iam.ManagedPolicy.from_aws_managed_policy_name("service-role/AmazonRDSDirectoryServiceAccess")
            ]
        )
        instance = rds.DatabaseInstance(self, "Instance",
            engine=rds.DatabaseInstanceEngine.mysql(version=rds.MysqlEngineVersion.VER_8_0_19),
            vpc=vpc,
            domain="d-????????",  # The ID of the domain for the instance to join.
            domain_role=role
        )
    '''

    @jsii.member(jsii_name="of")
    @builtins.classmethod
    def of(
        cls,
        mysql_full_version: builtins.str,
        mysql_major_version: builtins.str,
    ) -> "MysqlEngineVersion":
        '''(experimental) Create a new MysqlEngineVersion with an arbitrary version.

        :param mysql_full_version: the full version string, for example "8.1.43".
        :param mysql_major_version: the major version of the engine, for example "8.1".

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__383c79e15ac8e81ec99e177f2a43c80a3ee12edb9ebe25846bad6bde16df4d83)
            check_type(argname="argument mysql_full_version", value=mysql_full_version, expected_type=type_hints["mysql_full_version"])
            check_type(argname="argument mysql_major_version", value=mysql_major_version, expected_type=type_hints["mysql_major_version"])
        return typing.cast("MysqlEngineVersion", jsii.sinvoke(cls, "of", [mysql_full_version, mysql_major_version]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_5_5")
    def VER_5_5(cls) -> "MysqlEngineVersion":
        '''(deprecated) Version "5.5" (only a major version, without a specific minor version).

        :deprecated: MySQL 5.5 will reach end of life on May 25, 2021

        :stability: deprecated
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_5_5"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_5_5_46")
    def VER_5_5_46(cls) -> "MysqlEngineVersion":
        '''(deprecated) Version "5.5.46".

        :deprecated: MySQL 5.5 will reach end of life on May 25, 2021

        :stability: deprecated
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_5_5_46"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_5_5_53")
    def VER_5_5_53(cls) -> "MysqlEngineVersion":
        '''(deprecated) Version "5.5.53".

        :deprecated: MySQL 5.5 will reach end of life on May 25, 2021

        :stability: deprecated
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_5_5_53"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_5_5_57")
    def VER_5_5_57(cls) -> "MysqlEngineVersion":
        '''(deprecated) Version "5.5.57".

        :deprecated: MySQL 5.5 will reach end of life on May 25, 2021

        :stability: deprecated
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_5_5_57"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_5_5_59")
    def VER_5_5_59(cls) -> "MysqlEngineVersion":
        '''(deprecated) Version "5.5.59".

        :deprecated: MySQL 5.5 will reach end of life on May 25, 2021

        :stability: deprecated
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_5_5_59"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_5_5_61")
    def VER_5_5_61(cls) -> "MysqlEngineVersion":
        '''(deprecated) Version "5.5.61".

        :deprecated: MySQL 5.5 will reach end of life on May 25, 2021

        :stability: deprecated
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_5_5_61"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_5_6")
    def VER_5_6(cls) -> "MysqlEngineVersion":
        '''(deprecated) Version "5.6" (only a major version, without a specific minor version).

        :deprecated: MySQL 5.6 will reach end of life on August 3, 2021

        :stability: deprecated
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_5_6"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_5_6_34")
    def VER_5_6_34(cls) -> "MysqlEngineVersion":
        '''(deprecated) Version "5.6.34".

        :deprecated: MySQL 5.6 will reach end of life on August 3, 2021

        :stability: deprecated
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_5_6_34"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_5_6_35")
    def VER_5_6_35(cls) -> "MysqlEngineVersion":
        '''(deprecated) Version "5.6.35".

        :deprecated: MySQL 5.6 will reach end of life on August 3, 2021

        :stability: deprecated
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_5_6_35"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_5_6_37")
    def VER_5_6_37(cls) -> "MysqlEngineVersion":
        '''(deprecated) Version "5.6.37".

        :deprecated: MySQL 5.6 will reach end of life on August 3, 2021

        :stability: deprecated
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_5_6_37"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_5_6_39")
    def VER_5_6_39(cls) -> "MysqlEngineVersion":
        '''(deprecated) Version "5.6.39".

        :deprecated: MySQL 5.6 will reach end of life on August 3, 2021

        :stability: deprecated
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_5_6_39"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_5_6_40")
    def VER_5_6_40(cls) -> "MysqlEngineVersion":
        '''(deprecated) Version "5.6.40".

        :deprecated: MySQL 5.6 will reach end of life on August 3, 2021

        :stability: deprecated
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_5_6_40"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_5_6_41")
    def VER_5_6_41(cls) -> "MysqlEngineVersion":
        '''(deprecated) Version "5.6.41".

        :deprecated: MySQL 5.6 will reach end of life on August 3, 2021

        :stability: deprecated
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_5_6_41"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_5_6_43")
    def VER_5_6_43(cls) -> "MysqlEngineVersion":
        '''(deprecated) Version "5.6.43".

        :deprecated: MySQL 5.6 will reach end of life on August 3, 2021

        :stability: deprecated
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_5_6_43"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_5_6_44")
    def VER_5_6_44(cls) -> "MysqlEngineVersion":
        '''(deprecated) Version "5.6.44".

        :deprecated: MySQL 5.6 will reach end of life on August 3, 2021

        :stability: deprecated
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_5_6_44"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_5_6_46")
    def VER_5_6_46(cls) -> "MysqlEngineVersion":
        '''(deprecated) Version "5.6.46".

        :deprecated: MySQL 5.6 will reach end of life on August 3, 2021

        :stability: deprecated
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_5_6_46"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_5_6_48")
    def VER_5_6_48(cls) -> "MysqlEngineVersion":
        '''(deprecated) Version "5.6.48".

        :deprecated: MySQL 5.6 will reach end of life on August 3, 2021

        :stability: deprecated
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_5_6_48"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_5_6_49")
    def VER_5_6_49(cls) -> "MysqlEngineVersion":
        '''(deprecated) Version "5.6.49".

        :deprecated: MySQL 5.6 will reach end of life on August 3, 2021

        :stability: deprecated
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_5_6_49"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_5_6_51")
    def VER_5_6_51(cls) -> "MysqlEngineVersion":
        '''(deprecated) Version "5.6.51".

        :deprecated: MySQL 5.6 will reach end of life on August 3, 2021

        :stability: deprecated
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_5_6_51"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_5_7")
    def VER_5_7(cls) -> "MysqlEngineVersion":
        '''(experimental) Version "5.7" (only a major version, without a specific minor version).

        :stability: experimental
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_5_7"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_5_7_16")
    def VER_5_7_16(cls) -> "MysqlEngineVersion":
        '''(experimental) Version "5.7.16".

        :stability: experimental
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_5_7_16"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_5_7_17")
    def VER_5_7_17(cls) -> "MysqlEngineVersion":
        '''(experimental) Version "5.7.17".

        :stability: experimental
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_5_7_17"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_5_7_19")
    def VER_5_7_19(cls) -> "MysqlEngineVersion":
        '''(experimental) Version "5.7.19".

        :stability: experimental
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_5_7_19"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_5_7_21")
    def VER_5_7_21(cls) -> "MysqlEngineVersion":
        '''(experimental) Version "5.7.21".

        :stability: experimental
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_5_7_21"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_5_7_22")
    def VER_5_7_22(cls) -> "MysqlEngineVersion":
        '''(experimental) Version "5.7.22".

        :stability: experimental
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_5_7_22"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_5_7_23")
    def VER_5_7_23(cls) -> "MysqlEngineVersion":
        '''(experimental) Version "5.7.23".

        :stability: experimental
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_5_7_23"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_5_7_24")
    def VER_5_7_24(cls) -> "MysqlEngineVersion":
        '''(experimental) Version "5.7.24".

        :stability: experimental
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_5_7_24"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_5_7_25")
    def VER_5_7_25(cls) -> "MysqlEngineVersion":
        '''(experimental) Version "5.7.25".

        :stability: experimental
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_5_7_25"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_5_7_26")
    def VER_5_7_26(cls) -> "MysqlEngineVersion":
        '''(experimental) Version "5.7.26".

        :stability: experimental
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_5_7_26"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_5_7_28")
    def VER_5_7_28(cls) -> "MysqlEngineVersion":
        '''(experimental) Version "5.7.28".

        :stability: experimental
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_5_7_28"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_5_7_30")
    def VER_5_7_30(cls) -> "MysqlEngineVersion":
        '''(experimental) Version "5.7.30".

        :stability: experimental
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_5_7_30"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_5_7_31")
    def VER_5_7_31(cls) -> "MysqlEngineVersion":
        '''(experimental) Version "5.7.31".

        :stability: experimental
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_5_7_31"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_5_7_33")
    def VER_5_7_33(cls) -> "MysqlEngineVersion":
        '''(experimental) Version "5.7.33".

        :stability: experimental
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_5_7_33"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_5_7_34")
    def VER_5_7_34(cls) -> "MysqlEngineVersion":
        '''(experimental) Version "5.7.34".

        :stability: experimental
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_5_7_34"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_5_7_35")
    def VER_5_7_35(cls) -> "MysqlEngineVersion":
        '''(experimental) Version "5.7.35".

        :stability: experimental
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_5_7_35"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_5_7_36")
    def VER_5_7_36(cls) -> "MysqlEngineVersion":
        '''(experimental) Version "5.7.36".

        :stability: experimental
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_5_7_36"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_5_7_37")
    def VER_5_7_37(cls) -> "MysqlEngineVersion":
        '''(experimental) Version "5.7.37".

        :stability: experimental
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_5_7_37"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_8_0")
    def VER_8_0(cls) -> "MysqlEngineVersion":
        '''(experimental) Version "8.0" (only a major version, without a specific minor version).

        :stability: experimental
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_8_0"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_8_0_11")
    def VER_8_0_11(cls) -> "MysqlEngineVersion":
        '''(experimental) Version "8.0.11".

        :stability: experimental
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_8_0_11"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_8_0_13")
    def VER_8_0_13(cls) -> "MysqlEngineVersion":
        '''(experimental) Version "8.0.13".

        :stability: experimental
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_8_0_13"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_8_0_15")
    def VER_8_0_15(cls) -> "MysqlEngineVersion":
        '''(experimental) Version "8.0.15".

        :stability: experimental
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_8_0_15"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_8_0_16")
    def VER_8_0_16(cls) -> "MysqlEngineVersion":
        '''(experimental) Version "8.0.16".

        :stability: experimental
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_8_0_16"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_8_0_17")
    def VER_8_0_17(cls) -> "MysqlEngineVersion":
        '''(experimental) Version "8.0.17".

        :stability: experimental
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_8_0_17"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_8_0_19")
    def VER_8_0_19(cls) -> "MysqlEngineVersion":
        '''(experimental) Version "8.0.19".

        :stability: experimental
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_8_0_19"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_8_0_20")
    def VER_8_0_20(cls) -> "MysqlEngineVersion":
        '''(experimental) Version "8.0.20 ".

        :stability: experimental
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_8_0_20"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_8_0_21")
    def VER_8_0_21(cls) -> "MysqlEngineVersion":
        '''(experimental) Version "8.0.21 ".

        :stability: experimental
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_8_0_21"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_8_0_23")
    def VER_8_0_23(cls) -> "MysqlEngineVersion":
        '''(experimental) Version "8.0.23".

        :stability: experimental
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_8_0_23"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_8_0_25")
    def VER_8_0_25(cls) -> "MysqlEngineVersion":
        '''(experimental) Version "8.0.25".

        :stability: experimental
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_8_0_25"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_8_0_26")
    def VER_8_0_26(cls) -> "MysqlEngineVersion":
        '''(experimental) Version "8.0.26".

        :stability: experimental
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_8_0_26"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_8_0_27")
    def VER_8_0_27(cls) -> "MysqlEngineVersion":
        '''(experimental) Version "8.0.27".

        :stability: experimental
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_8_0_27"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_8_0_28")
    def VER_8_0_28(cls) -> "MysqlEngineVersion":
        '''(experimental) Version "8.0.28".

        :stability: experimental
        '''
        return typing.cast("MysqlEngineVersion", jsii.sget(cls, "VER_8_0_28"))

    @builtins.property
    @jsii.member(jsii_name="mysqlFullVersion")
    def mysql_full_version(self) -> builtins.str:
        '''(experimental) The full version string, for example, "10.5.28".

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "mysqlFullVersion"))

    @builtins.property
    @jsii.member(jsii_name="mysqlMajorVersion")
    def mysql_major_version(self) -> builtins.str:
        '''(experimental) The major version of the engine, for example, "10.5".

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "mysqlMajorVersion"))


@jsii.data_type(
    jsii_type="monocdk.aws_rds.OptionConfiguration",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "port": "port",
        "security_groups": "securityGroups",
        "settings": "settings",
        "version": "version",
        "vpc": "vpc",
    },
)
class OptionConfiguration:
    def __init__(
        self,
        *,
        name: builtins.str,
        port: typing.Optional[jsii.Number] = None,
        security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
        settings: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        version: typing.Optional[builtins.str] = None,
        vpc: typing.Optional[_IVpc_6d1f76c4] = None,
    ) -> None:
        '''(experimental) Configuration properties for an option.

        :param name: (experimental) The name of the option.
        :param port: (experimental) The port number that this option uses. If ``port`` is specified then ``vpc`` must also be specified. Default: - no port
        :param security_groups: (experimental) Optional list of security groups to use for this option, if ``vpc`` is specified. If no groups are provided, a default one will be created. Default: - a default group will be created if ``port`` or ``vpc`` are specified.
        :param settings: (experimental) The settings for the option. Default: - no settings
        :param version: (experimental) The version for the option. Default: - no version
        :param vpc: (experimental) The VPC where a security group should be created for this option. If ``vpc`` is specified then ``port`` must also be specified. Default: - no VPC

        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_ec2 as ec2
            from monocdk import aws_rds as rds
            
            # security_group: ec2.SecurityGroup
            # vpc: ec2.Vpc
            
            option_configuration = rds.OptionConfiguration(
                name="name",
            
                # the properties below are optional
                port=123,
                security_groups=[security_group],
                settings={
                    "settings_key": "settings"
                },
                version="version",
                vpc=vpc
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5af3f73cf0220fd79f44c873ab6287295ab74cbbb264743f2c9fcabbcef53c57)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
            check_type(argname="argument security_groups", value=security_groups, expected_type=type_hints["security_groups"])
            check_type(argname="argument settings", value=settings, expected_type=type_hints["settings"])
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
            check_type(argname="argument vpc", value=vpc, expected_type=type_hints["vpc"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if port is not None:
            self._values["port"] = port
        if security_groups is not None:
            self._values["security_groups"] = security_groups
        if settings is not None:
            self._values["settings"] = settings
        if version is not None:
            self._values["version"] = version
        if vpc is not None:
            self._values["vpc"] = vpc

    @builtins.property
    def name(self) -> builtins.str:
        '''(experimental) The name of the option.

        :stability: experimental
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def port(self) -> typing.Optional[jsii.Number]:
        '''(experimental) The port number that this option uses.

        If ``port`` is specified then ``vpc``
        must also be specified.

        :default: - no port

        :stability: experimental
        '''
        result = self._values.get("port")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def security_groups(self) -> typing.Optional[typing.List[_ISecurityGroup_cdbba9d3]]:
        '''(experimental) Optional list of security groups to use for this option, if ``vpc`` is specified.

        If no groups are provided, a default one will be created.

        :default: - a default group will be created if ``port`` or ``vpc`` are specified.

        :stability: experimental
        '''
        result = self._values.get("security_groups")
        return typing.cast(typing.Optional[typing.List[_ISecurityGroup_cdbba9d3]], result)

    @builtins.property
    def settings(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''(experimental) The settings for the option.

        :default: - no settings

        :stability: experimental
        '''
        result = self._values.get("settings")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def version(self) -> typing.Optional[builtins.str]:
        '''(experimental) The version for the option.

        :default: - no version

        :stability: experimental
        '''
        result = self._values.get("version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vpc(self) -> typing.Optional[_IVpc_6d1f76c4]:
        '''(experimental) The VPC where a security group should be created for this option.

        If ``vpc``
        is specified then ``port`` must also be specified.

        :default: - no VPC

        :stability: experimental
        '''
        result = self._values.get("vpc")
        return typing.cast(typing.Optional[_IVpc_6d1f76c4], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "OptionConfiguration(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(IOptionGroup)
class OptionGroup(
    _Resource_abff4495,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_rds.OptionGroup",
):
    '''(experimental) An option group.

    :stability: experimental
    :exampleMetadata: lit=lib/aws-rds/test/integ.instance.lit.ts infused

    Example::

        # Set open cursors with parameter group
        parameter_group = rds.ParameterGroup(self, "ParameterGroup",
            engine=rds.DatabaseInstanceEngine.oracle_se2(version=rds.OracleEngineVersion.VER_19_0_0_0_2020_04_R1),
            parameters={
                "open_cursors": "2500"
            }
        )
        
        option_group = rds.OptionGroup(self, "OptionGroup",
            engine=rds.DatabaseInstanceEngine.oracle_se2(version=rds.OracleEngineVersion.VER_19_0_0_0_2020_04_R1),
            configurations=[cdk.aws_rds.OptionConfiguration(
                name="LOCATOR"
            ), cdk.aws_rds.OptionConfiguration(
                name="OEM",
                port=1158,
                vpc=vpc
            )
            ]
        )
        
        # Allow connections to OEM
        option_group.option_connections.OEM.connections.allow_default_port_from_any_ipv4()
        
        # Database instance with production values
        instance = rds.DatabaseInstance(self, "Instance",
            engine=rds.DatabaseInstanceEngine.oracle_se2(version=rds.OracleEngineVersion.VER_19_0_0_0_2020_04_R1),
            license_model=rds.LicenseModel.BRING_YOUR_OWN_LICENSE,
            instance_type=ec2.InstanceType.of(ec2.InstanceClass.BURSTABLE3, ec2.InstanceSize.MEDIUM),
            multi_az=True,
            storage_type=rds.StorageType.IO1,
            credentials=rds.Credentials.from_username("syscdk"),
            vpc=vpc,
            database_name="ORCL",
            storage_encrypted=True,
            backup_retention=cdk.Duration.days(7),
            monitoring_interval=cdk.Duration.seconds(60),
            enable_performance_insights=True,
            cloudwatch_logs_exports=["trace", "audit", "alert", "listener"
            ],
            cloudwatch_logs_retention=logs.RetentionDays.ONE_MONTH,
            auto_minor_version_upgrade=True,  # required to be true if LOCATOR is used in the option group
            option_group=option_group,
            parameter_group=parameter_group,
            removal_policy=RemovalPolicy.DESTROY
        )
        
        # Allow connections on default port from any IPV4
        instance.connections.allow_default_port_from_any_ipv4()
        
        # Rotate the master user password every 30 days
        instance.add_rotation_single_user()
        
        # Add alarm for high CPU
        cloudwatch.Alarm(self, "HighCPU",
            metric=instance.metric_cPUUtilization(),
            threshold=90,
            evaluation_periods=1
        )
        
        # Trigger Lambda function on instance availability events
        fn = lambda_.Function(self, "Function",
            code=lambda_.Code.from_inline("exports.handler = (event) => console.log(event);"),
            handler="index.handler",
            runtime=lambda_.Runtime.NODEJS_14_X
        )
        
        availability_rule = instance.on_event("Availability", target=targets.LambdaFunction(fn))
        availability_rule.add_event_pattern(
            detail={
                "EventCategories": ["availability"
                ]
            }
        )
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        configurations: typing.Sequence[typing.Union[OptionConfiguration, typing.Dict[builtins.str, typing.Any]]],
        engine: IInstanceEngine,
        description: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param configurations: (experimental) The configurations for this option group.
        :param engine: (experimental) The database engine that this option group is associated with.
        :param description: (experimental) A description of the option group. Default: a CDK generated description

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__793a9e74affcc700ff112183795a0126ecec1acdb2187df57317558b713acbc4)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = OptionGroupProps(
            configurations=configurations, engine=engine, description=description
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="fromOptionGroupName")
    @builtins.classmethod
    def from_option_group_name(
        cls,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        option_group_name: builtins.str,
    ) -> IOptionGroup:
        '''(experimental) Import an existing option group.

        :param scope: -
        :param id: -
        :param option_group_name: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__934e675aa59866aabf3af48db7738545e6f32ad2396b751a51fde39df526eed1)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument option_group_name", value=option_group_name, expected_type=type_hints["option_group_name"])
        return typing.cast(IOptionGroup, jsii.sinvoke(cls, "fromOptionGroupName", [scope, id, option_group_name]))

    @jsii.member(jsii_name="addConfiguration")
    def add_configuration(
        self,
        *,
        name: builtins.str,
        port: typing.Optional[jsii.Number] = None,
        security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
        settings: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        version: typing.Optional[builtins.str] = None,
        vpc: typing.Optional[_IVpc_6d1f76c4] = None,
    ) -> builtins.bool:
        '''(experimental) Adds a configuration to this OptionGroup.

        This method is a no-op for an imported OptionGroup.

        :param name: (experimental) The name of the option.
        :param port: (experimental) The port number that this option uses. If ``port`` is specified then ``vpc`` must also be specified. Default: - no port
        :param security_groups: (experimental) Optional list of security groups to use for this option, if ``vpc`` is specified. If no groups are provided, a default one will be created. Default: - a default group will be created if ``port`` or ``vpc`` are specified.
        :param settings: (experimental) The settings for the option. Default: - no settings
        :param version: (experimental) The version for the option. Default: - no version
        :param vpc: (experimental) The VPC where a security group should be created for this option. If ``vpc`` is specified then ``port`` must also be specified. Default: - no VPC

        :stability: experimental
        '''
        configuration = OptionConfiguration(
            name=name,
            port=port,
            security_groups=security_groups,
            settings=settings,
            version=version,
            vpc=vpc,
        )

        return typing.cast(builtins.bool, jsii.invoke(self, "addConfiguration", [configuration]))

    @builtins.property
    @jsii.member(jsii_name="optionConnections")
    def option_connections(self) -> typing.Mapping[builtins.str, _Connections_57ccbda9]:
        '''(experimental) The connections object for the options.

        :stability: experimental
        '''
        return typing.cast(typing.Mapping[builtins.str, _Connections_57ccbda9], jsii.get(self, "optionConnections"))

    @builtins.property
    @jsii.member(jsii_name="optionGroupName")
    def option_group_name(self) -> builtins.str:
        '''(experimental) The name of the option group.

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "optionGroupName"))


@jsii.data_type(
    jsii_type="monocdk.aws_rds.OptionGroupProps",
    jsii_struct_bases=[],
    name_mapping={
        "configurations": "configurations",
        "engine": "engine",
        "description": "description",
    },
)
class OptionGroupProps:
    def __init__(
        self,
        *,
        configurations: typing.Sequence[typing.Union[OptionConfiguration, typing.Dict[builtins.str, typing.Any]]],
        engine: IInstanceEngine,
        description: typing.Optional[builtins.str] = None,
    ) -> None:
        '''(experimental) Construction properties for an OptionGroup.

        :param configurations: (experimental) The configurations for this option group.
        :param engine: (experimental) The database engine that this option group is associated with.
        :param description: (experimental) A description of the option group. Default: a CDK generated description

        :stability: experimental
        :exampleMetadata: lit=lib/aws-rds/test/integ.instance.lit.ts infused

        Example::

            # Set open cursors with parameter group
            parameter_group = rds.ParameterGroup(self, "ParameterGroup",
                engine=rds.DatabaseInstanceEngine.oracle_se2(version=rds.OracleEngineVersion.VER_19_0_0_0_2020_04_R1),
                parameters={
                    "open_cursors": "2500"
                }
            )
            
            option_group = rds.OptionGroup(self, "OptionGroup",
                engine=rds.DatabaseInstanceEngine.oracle_se2(version=rds.OracleEngineVersion.VER_19_0_0_0_2020_04_R1),
                configurations=[cdk.aws_rds.OptionConfiguration(
                    name="LOCATOR"
                ), cdk.aws_rds.OptionConfiguration(
                    name="OEM",
                    port=1158,
                    vpc=vpc
                )
                ]
            )
            
            # Allow connections to OEM
            option_group.option_connections.OEM.connections.allow_default_port_from_any_ipv4()
            
            # Database instance with production values
            instance = rds.DatabaseInstance(self, "Instance",
                engine=rds.DatabaseInstanceEngine.oracle_se2(version=rds.OracleEngineVersion.VER_19_0_0_0_2020_04_R1),
                license_model=rds.LicenseModel.BRING_YOUR_OWN_LICENSE,
                instance_type=ec2.InstanceType.of(ec2.InstanceClass.BURSTABLE3, ec2.InstanceSize.MEDIUM),
                multi_az=True,
                storage_type=rds.StorageType.IO1,
                credentials=rds.Credentials.from_username("syscdk"),
                vpc=vpc,
                database_name="ORCL",
                storage_encrypted=True,
                backup_retention=cdk.Duration.days(7),
                monitoring_interval=cdk.Duration.seconds(60),
                enable_performance_insights=True,
                cloudwatch_logs_exports=["trace", "audit", "alert", "listener"
                ],
                cloudwatch_logs_retention=logs.RetentionDays.ONE_MONTH,
                auto_minor_version_upgrade=True,  # required to be true if LOCATOR is used in the option group
                option_group=option_group,
                parameter_group=parameter_group,
                removal_policy=RemovalPolicy.DESTROY
            )
            
            # Allow connections on default port from any IPV4
            instance.connections.allow_default_port_from_any_ipv4()
            
            # Rotate the master user password every 30 days
            instance.add_rotation_single_user()
            
            # Add alarm for high CPU
            cloudwatch.Alarm(self, "HighCPU",
                metric=instance.metric_cPUUtilization(),
                threshold=90,
                evaluation_periods=1
            )
            
            # Trigger Lambda function on instance availability events
            fn = lambda_.Function(self, "Function",
                code=lambda_.Code.from_inline("exports.handler = (event) => console.log(event);"),
                handler="index.handler",
                runtime=lambda_.Runtime.NODEJS_14_X
            )
            
            availability_rule = instance.on_event("Availability", target=targets.LambdaFunction(fn))
            availability_rule.add_event_pattern(
                detail={
                    "EventCategories": ["availability"
                    ]
                }
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__67ea241428936d1a25b7011da11eab02483738a0563b4004bba58044716ba8f7)
            check_type(argname="argument configurations", value=configurations, expected_type=type_hints["configurations"])
            check_type(argname="argument engine", value=engine, expected_type=type_hints["engine"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "configurations": configurations,
            "engine": engine,
        }
        if description is not None:
            self._values["description"] = description

    @builtins.property
    def configurations(self) -> typing.List[OptionConfiguration]:
        '''(experimental) The configurations for this option group.

        :stability: experimental
        '''
        result = self._values.get("configurations")
        assert result is not None, "Required property 'configurations' is missing"
        return typing.cast(typing.List[OptionConfiguration], result)

    @builtins.property
    def engine(self) -> IInstanceEngine:
        '''(experimental) The database engine that this option group is associated with.

        :stability: experimental
        '''
        result = self._values.get("engine")
        assert result is not None, "Required property 'engine' is missing"
        return typing.cast(IInstanceEngine, result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(experimental) A description of the option group.

        :default: a CDK generated description

        :stability: experimental
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "OptionGroupProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_rds.OracleEeInstanceEngineProps",
    jsii_struct_bases=[],
    name_mapping={"version": "version"},
)
class OracleEeInstanceEngineProps:
    def __init__(self, *, version: "OracleEngineVersion") -> None:
        '''(experimental) Properties for Oracle Enterprise Edition instance engines.

        Used in {@link DatabaseInstanceEngine.oracleEe}.

        :param version: (experimental) The exact version of the engine to use.

        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_rds as rds
            
            # oracle_engine_version: rds.OracleEngineVersion
            
            oracle_ee_instance_engine_props = rds.OracleEeInstanceEngineProps(
                version=oracle_engine_version
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0f610fbb6f28018b417f9fd287e226ce49366b96e0b69ef8c03614489fd912de)
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "version": version,
        }

    @builtins.property
    def version(self) -> "OracleEngineVersion":
        '''(experimental) The exact version of the engine to use.

        :stability: experimental
        '''
        result = self._values.get("version")
        assert result is not None, "Required property 'version' is missing"
        return typing.cast("OracleEngineVersion", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "OracleEeInstanceEngineProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class OracleEngineVersion(
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_rds.OracleEngineVersion",
):
    '''(experimental) The versions for the Oracle instance engines (those returned by {@link DatabaseInstanceEngine.oracleSe2} and {@link DatabaseInstanceEngine.oracleEe}).

    :stability: experimental
    :exampleMetadata: infused

    Example::

        # vpc: ec2.Vpc
        
        instance = rds.DatabaseInstance(self, "Instance",
            engine=rds.DatabaseInstanceEngine.oracle_se2(version=rds.OracleEngineVersion.VER_19_0_0_0_2020_04_R1),
            # optional, defaults to m5.large
            instance_type=ec2.InstanceType.of(ec2.InstanceClass.BURSTABLE3, ec2.InstanceSize.SMALL),
            credentials=rds.Credentials.from_generated_secret("syscdk"),  # Optional - will default to 'admin' username and generated password
            vpc=vpc,
            vpc_subnets=ec2.aws_ec2.SubnetSelection(
                subnet_type=ec2.SubnetType.PRIVATE_WITH_NAT
            )
        )
    '''

    @jsii.member(jsii_name="of")
    @builtins.classmethod
    def of(
        cls,
        oracle_full_version: builtins.str,
        oracle_major_version: builtins.str,
    ) -> "OracleEngineVersion":
        '''(experimental) Creates a new OracleEngineVersion with an arbitrary version.

        :param oracle_full_version: the full version string, for example "19.0.0.0.ru-2019-10.rur-2019-10.r1".
        :param oracle_major_version: the major version of the engine, for example "19".

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8d407e1f6ebbe003beffe3846f312bdc64952ba2f774a79118c8fc10988b2507)
            check_type(argname="argument oracle_full_version", value=oracle_full_version, expected_type=type_hints["oracle_full_version"])
            check_type(argname="argument oracle_major_version", value=oracle_major_version, expected_type=type_hints["oracle_major_version"])
        return typing.cast("OracleEngineVersion", jsii.sinvoke(cls, "of", [oracle_full_version, oracle_major_version]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_1")
    def VER_12_1(cls) -> "OracleEngineVersion":
        '''(experimental) Version "12.1" (only a major version, without a specific minor version).

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_12_1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_1_0_2_V1")
    def VER_12_1_0_2_V1(cls) -> "OracleEngineVersion":
        '''(experimental) Version "12.1.0.2.v1".

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_12_1_0_2_V1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_1_0_2_V10")
    def VER_12_1_0_2_V10(cls) -> "OracleEngineVersion":
        '''(experimental) Version "12.1.0.2.v10".

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_12_1_0_2_V10"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_1_0_2_V11")
    def VER_12_1_0_2_V11(cls) -> "OracleEngineVersion":
        '''(experimental) Version "12.1.0.2.v11".

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_12_1_0_2_V11"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_1_0_2_V12")
    def VER_12_1_0_2_V12(cls) -> "OracleEngineVersion":
        '''(experimental) Version "12.1.0.2.v12".

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_12_1_0_2_V12"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_1_0_2_V13")
    def VER_12_1_0_2_V13(cls) -> "OracleEngineVersion":
        '''(experimental) Version "12.1.0.2.v13".

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_12_1_0_2_V13"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_1_0_2_V14")
    def VER_12_1_0_2_V14(cls) -> "OracleEngineVersion":
        '''(experimental) Version "12.1.0.2.v14".

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_12_1_0_2_V14"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_1_0_2_V15")
    def VER_12_1_0_2_V15(cls) -> "OracleEngineVersion":
        '''(experimental) Version "12.1.0.2.v15".

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_12_1_0_2_V15"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_1_0_2_V16")
    def VER_12_1_0_2_V16(cls) -> "OracleEngineVersion":
        '''(experimental) Version "12.1.0.2.v16".

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_12_1_0_2_V16"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_1_0_2_V17")
    def VER_12_1_0_2_V17(cls) -> "OracleEngineVersion":
        '''(experimental) Version "12.1.0.2.v17".

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_12_1_0_2_V17"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_1_0_2_V18")
    def VER_12_1_0_2_V18(cls) -> "OracleEngineVersion":
        '''(experimental) Version "12.1.0.2.v18".

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_12_1_0_2_V18"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_1_0_2_V19")
    def VER_12_1_0_2_V19(cls) -> "OracleEngineVersion":
        '''(experimental) Version "12.1.0.2.v19".

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_12_1_0_2_V19"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_1_0_2_V2")
    def VER_12_1_0_2_V2(cls) -> "OracleEngineVersion":
        '''(experimental) Version "12.1.0.2.v2".

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_12_1_0_2_V2"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_1_0_2_V20")
    def VER_12_1_0_2_V20(cls) -> "OracleEngineVersion":
        '''(experimental) Version "12.1.0.2.v20".

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_12_1_0_2_V20"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_1_0_2_V21")
    def VER_12_1_0_2_V21(cls) -> "OracleEngineVersion":
        '''(experimental) Version "12.1.0.2.v21".

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_12_1_0_2_V21"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_1_0_2_V22")
    def VER_12_1_0_2_V22(cls) -> "OracleEngineVersion":
        '''(experimental) Version "12.1.0.2.v22".

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_12_1_0_2_V22"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_1_0_2_V23")
    def VER_12_1_0_2_V23(cls) -> "OracleEngineVersion":
        '''(experimental) Version "12.1.0.2.v23".

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_12_1_0_2_V23"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_1_0_2_V24")
    def VER_12_1_0_2_V24(cls) -> "OracleEngineVersion":
        '''(experimental) Version "12.1.0.2.v24".

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_12_1_0_2_V24"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_1_0_2_V3")
    def VER_12_1_0_2_V3(cls) -> "OracleEngineVersion":
        '''(experimental) Version "12.1.0.2.v3".

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_12_1_0_2_V3"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_1_0_2_V4")
    def VER_12_1_0_2_V4(cls) -> "OracleEngineVersion":
        '''(experimental) Version "12.1.0.2.v4".

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_12_1_0_2_V4"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_1_0_2_V5")
    def VER_12_1_0_2_V5(cls) -> "OracleEngineVersion":
        '''(experimental) Version "12.1.0.2.v5".

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_12_1_0_2_V5"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_1_0_2_V6")
    def VER_12_1_0_2_V6(cls) -> "OracleEngineVersion":
        '''(experimental) Version "12.1.0.2.v6".

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_12_1_0_2_V6"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_1_0_2_V7")
    def VER_12_1_0_2_V7(cls) -> "OracleEngineVersion":
        '''(experimental) Version "12.1.0.2.v7".

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_12_1_0_2_V7"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_1_0_2_V8")
    def VER_12_1_0_2_V8(cls) -> "OracleEngineVersion":
        '''(experimental) Version "12.1.0.2.v8".

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_12_1_0_2_V8"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_1_0_2_V9")
    def VER_12_1_0_2_V9(cls) -> "OracleEngineVersion":
        '''(experimental) Version "12.1.0.2.v9".

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_12_1_0_2_V9"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_2")
    def VER_12_2(cls) -> "OracleEngineVersion":
        '''(experimental) Version "12.2" (only a major version, without a specific minor version).

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_12_2"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_2_0_1_2018_10_R1")
    def VER_12_2_0_1_2018_10_R1(cls) -> "OracleEngineVersion":
        '''(experimental) Version "12.2.0.1.ru-2018-10.rur-2018-10.r1".

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_12_2_0_1_2018_10_R1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_2_0_1_2019_01_R1")
    def VER_12_2_0_1_2019_01_R1(cls) -> "OracleEngineVersion":
        '''(experimental) Version "12.2.0.1.ru-2019-01.rur-2019-01.r1".

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_12_2_0_1_2019_01_R1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_2_0_1_2019_04_R1")
    def VER_12_2_0_1_2019_04_R1(cls) -> "OracleEngineVersion":
        '''(experimental) Version "12.2.0.1.ru-2019-04.rur-2019-04.r1".

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_12_2_0_1_2019_04_R1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_2_0_1_2019_07_R1")
    def VER_12_2_0_1_2019_07_R1(cls) -> "OracleEngineVersion":
        '''(experimental) Version "12.2.0.1.ru-2019-07.rur-2019-07.r1".

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_12_2_0_1_2019_07_R1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_2_0_1_2019_10_R1")
    def VER_12_2_0_1_2019_10_R1(cls) -> "OracleEngineVersion":
        '''(experimental) Version "12.2.0.1.ru-2019-10.rur-2019-10.r1".

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_12_2_0_1_2019_10_R1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_2_0_1_2020_01_R1")
    def VER_12_2_0_1_2020_01_R1(cls) -> "OracleEngineVersion":
        '''(experimental) Version "12.2.0.1.ru-2020-01.rur-2020-01.r1".

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_12_2_0_1_2020_01_R1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_2_0_1_2020_04_R1")
    def VER_12_2_0_1_2020_04_R1(cls) -> "OracleEngineVersion":
        '''(experimental) Version "12.2.0.1.ru-2020-04.rur-2020-04.r1".

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_12_2_0_1_2020_04_R1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_2_0_1_2020_07_R1")
    def VER_12_2_0_1_2020_07_R1(cls) -> "OracleEngineVersion":
        '''(experimental) Version "12.2.0.1.ru-2020-07.rur-2020-07.r1".

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_12_2_0_1_2020_07_R1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_2_0_1_2020_10_R1")
    def VER_12_2_0_1_2020_10_R1(cls) -> "OracleEngineVersion":
        '''(experimental) Version "12.2.0.1.ru-2021-10.rur-2020-10.r1".

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_12_2_0_1_2020_10_R1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_2_0_1_2021_01_R1")
    def VER_12_2_0_1_2021_01_R1(cls) -> "OracleEngineVersion":
        '''(experimental) Version "12.2.0.1.ru-2021-01.rur-2021-01.r1".

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_12_2_0_1_2021_01_R1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_2_0_1_2021_04_R1")
    def VER_12_2_0_1_2021_04_R1(cls) -> "OracleEngineVersion":
        '''(experimental) Version "12.2.0.1.ru-2021-04.rur-2021-04.r1".

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_12_2_0_1_2021_04_R1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_18")
    def VER_18(cls) -> "OracleEngineVersion":
        '''(experimental) Version "18" (only a major version, without a specific minor version).

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_18"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_18_0_0_0_2019_07_R1")
    def VER_18_0_0_0_2019_07_R1(cls) -> "OracleEngineVersion":
        '''(experimental) Version "18.0.0.0.ru-2019-07.rur-2019-07.r1".

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_18_0_0_0_2019_07_R1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_18_0_0_0_2019_10_R1")
    def VER_18_0_0_0_2019_10_R1(cls) -> "OracleEngineVersion":
        '''(experimental) Version "18.0.0.0.ru-2019-10.rur-2019-10.r1".

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_18_0_0_0_2019_10_R1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_18_0_0_0_2020_01_R1")
    def VER_18_0_0_0_2020_01_R1(cls) -> "OracleEngineVersion":
        '''(experimental) Version "18.0.0.0.ru-2020-01.rur-2020-01.r1".

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_18_0_0_0_2020_01_R1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_18_0_0_0_2020_04_R1")
    def VER_18_0_0_0_2020_04_R1(cls) -> "OracleEngineVersion":
        '''(experimental) Version "18.0.0.0.ru-2020-04.rur-2020-04.r1".

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_18_0_0_0_2020_04_R1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_18_0_0_0_2020_07_R1")
    def VER_18_0_0_0_2020_07_R1(cls) -> "OracleEngineVersion":
        '''(experimental) Version "18.0.0.0.ru-2020-07.rur-2020-07.r1".

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_18_0_0_0_2020_07_R1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_19")
    def VER_19(cls) -> "OracleEngineVersion":
        '''(experimental) Version "19" (only a major version, without a specific minor version).

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_19"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_19_0_0_0_2019_07_R1")
    def VER_19_0_0_0_2019_07_R1(cls) -> "OracleEngineVersion":
        '''(experimental) Version "19.0.0.0.ru-2019-07.rur-2019-07.r1".

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_19_0_0_0_2019_07_R1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_19_0_0_0_2019_10_R1")
    def VER_19_0_0_0_2019_10_R1(cls) -> "OracleEngineVersion":
        '''(experimental) Version "19.0.0.0.ru-2019-10.rur-2019-10.r1".

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_19_0_0_0_2019_10_R1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_19_0_0_0_2020_01_R1")
    def VER_19_0_0_0_2020_01_R1(cls) -> "OracleEngineVersion":
        '''(experimental) Version "19.0.0.0.ru-2020-01.rur-2020-01.r1".

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_19_0_0_0_2020_01_R1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_19_0_0_0_2020_04_R1")
    def VER_19_0_0_0_2020_04_R1(cls) -> "OracleEngineVersion":
        '''(experimental) Version "19.0.0.0.ru-2020-04.rur-2020-04.r1".

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_19_0_0_0_2020_04_R1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_19_0_0_0_2020_07_R1")
    def VER_19_0_0_0_2020_07_R1(cls) -> "OracleEngineVersion":
        '''(experimental) Version "19.0.0.0.ru-2020-07.rur-2020-07.r1".

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_19_0_0_0_2020_07_R1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_19_0_0_0_2020_10_R1")
    def VER_19_0_0_0_2020_10_R1(cls) -> "OracleEngineVersion":
        '''(experimental) Version "19.0.0.0.ru-2020-07.rur-2020-10.r1".

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_19_0_0_0_2020_10_R1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_19_0_0_0_2021_01_R1")
    def VER_19_0_0_0_2021_01_R1(cls) -> "OracleEngineVersion":
        '''(experimental) Version "19.0.0.0.ru-2021-01.rur-2021-01.r1".

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_19_0_0_0_2021_01_R1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_19_0_0_0_2021_01_R2")
    def VER_19_0_0_0_2021_01_R2(cls) -> "OracleEngineVersion":
        '''(experimental) Version "19.0.0.0.ru-2021-01.rur-2021-01.r2".

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_19_0_0_0_2021_01_R2"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_19_0_0_0_2021_04_R1")
    def VER_19_0_0_0_2021_04_R1(cls) -> "OracleEngineVersion":
        '''(experimental) Version "19.0.0.0.ru-2021-01.rur-2021-04.r1".

        :stability: experimental
        '''
        return typing.cast("OracleEngineVersion", jsii.sget(cls, "VER_19_0_0_0_2021_04_R1"))

    @builtins.property
    @jsii.member(jsii_name="oracleFullVersion")
    def oracle_full_version(self) -> builtins.str:
        '''(experimental) The full version string, for example, "19.0.0.0.ru-2019-10.rur-2019-10.r1".

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "oracleFullVersion"))

    @builtins.property
    @jsii.member(jsii_name="oracleMajorVersion")
    def oracle_major_version(self) -> builtins.str:
        '''(experimental) The major version of the engine, for example, "19".

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "oracleMajorVersion"))


class OracleLegacyEngineVersion(
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_rds.OracleLegacyEngineVersion",
):
    '''(deprecated) The versions for the legacy Oracle instance engines (those returned by {@link DatabaseInstanceEngine.oracleSe} and {@link DatabaseInstanceEngine.oracleSe1}). Note: RDS will stop allowing creating new databases with this version in August 2020.

    :deprecated: instances can no longer be created with these engine versions. See https://forums.aws.amazon.com/ann.jspa?annID=7341

    :stability: deprecated
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from monocdk import aws_rds as rds
        
        oracle_legacy_engine_version = rds.OracleLegacyEngineVersion.VER_11_2
    '''

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_2")
    def VER_11_2(cls) -> "OracleLegacyEngineVersion":
        '''(deprecated) Version "11.2" (only a major version, without a specific minor version).

        :stability: deprecated
        '''
        return typing.cast("OracleLegacyEngineVersion", jsii.sget(cls, "VER_11_2"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_2_0_2_V2")
    def VER_11_2_0_2_V2(cls) -> "OracleLegacyEngineVersion":
        '''(deprecated) Version "11.2.0.2.v2".

        :stability: deprecated
        '''
        return typing.cast("OracleLegacyEngineVersion", jsii.sget(cls, "VER_11_2_0_2_V2"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_2_0_4_V1")
    def VER_11_2_0_4_V1(cls) -> "OracleLegacyEngineVersion":
        '''(deprecated) Version "11.2.0.4.v1".

        :stability: deprecated
        '''
        return typing.cast("OracleLegacyEngineVersion", jsii.sget(cls, "VER_11_2_0_4_V1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_2_0_4_V10")
    def VER_11_2_0_4_V10(cls) -> "OracleLegacyEngineVersion":
        '''(deprecated) Version "11.2.0.4.v10".

        :stability: deprecated
        '''
        return typing.cast("OracleLegacyEngineVersion", jsii.sget(cls, "VER_11_2_0_4_V10"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_2_0_4_V11")
    def VER_11_2_0_4_V11(cls) -> "OracleLegacyEngineVersion":
        '''(deprecated) Version "11.2.0.4.v11".

        :stability: deprecated
        '''
        return typing.cast("OracleLegacyEngineVersion", jsii.sget(cls, "VER_11_2_0_4_V11"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_2_0_4_V12")
    def VER_11_2_0_4_V12(cls) -> "OracleLegacyEngineVersion":
        '''(deprecated) Version "11.2.0.4.v12".

        :stability: deprecated
        '''
        return typing.cast("OracleLegacyEngineVersion", jsii.sget(cls, "VER_11_2_0_4_V12"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_2_0_4_V13")
    def VER_11_2_0_4_V13(cls) -> "OracleLegacyEngineVersion":
        '''(deprecated) Version "11.2.0.4.v13".

        :stability: deprecated
        '''
        return typing.cast("OracleLegacyEngineVersion", jsii.sget(cls, "VER_11_2_0_4_V13"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_2_0_4_V14")
    def VER_11_2_0_4_V14(cls) -> "OracleLegacyEngineVersion":
        '''(deprecated) Version "11.2.0.4.v14".

        :stability: deprecated
        '''
        return typing.cast("OracleLegacyEngineVersion", jsii.sget(cls, "VER_11_2_0_4_V14"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_2_0_4_V15")
    def VER_11_2_0_4_V15(cls) -> "OracleLegacyEngineVersion":
        '''(deprecated) Version "11.2.0.4.v15".

        :stability: deprecated
        '''
        return typing.cast("OracleLegacyEngineVersion", jsii.sget(cls, "VER_11_2_0_4_V15"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_2_0_4_V16")
    def VER_11_2_0_4_V16(cls) -> "OracleLegacyEngineVersion":
        '''(deprecated) Version "11.2.0.4.v16".

        :stability: deprecated
        '''
        return typing.cast("OracleLegacyEngineVersion", jsii.sget(cls, "VER_11_2_0_4_V16"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_2_0_4_V17")
    def VER_11_2_0_4_V17(cls) -> "OracleLegacyEngineVersion":
        '''(deprecated) Version "11.2.0.4.v17".

        :stability: deprecated
        '''
        return typing.cast("OracleLegacyEngineVersion", jsii.sget(cls, "VER_11_2_0_4_V17"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_2_0_4_V18")
    def VER_11_2_0_4_V18(cls) -> "OracleLegacyEngineVersion":
        '''(deprecated) Version "11.2.0.4.v18".

        :stability: deprecated
        '''
        return typing.cast("OracleLegacyEngineVersion", jsii.sget(cls, "VER_11_2_0_4_V18"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_2_0_4_V19")
    def VER_11_2_0_4_V19(cls) -> "OracleLegacyEngineVersion":
        '''(deprecated) Version "11.2.0.4.v19".

        :stability: deprecated
        '''
        return typing.cast("OracleLegacyEngineVersion", jsii.sget(cls, "VER_11_2_0_4_V19"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_2_0_4_V20")
    def VER_11_2_0_4_V20(cls) -> "OracleLegacyEngineVersion":
        '''(deprecated) Version "11.2.0.4.v20".

        :stability: deprecated
        '''
        return typing.cast("OracleLegacyEngineVersion", jsii.sget(cls, "VER_11_2_0_4_V20"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_2_0_4_V21")
    def VER_11_2_0_4_V21(cls) -> "OracleLegacyEngineVersion":
        '''(deprecated) Version "11.2.0.4.v21".

        :stability: deprecated
        '''
        return typing.cast("OracleLegacyEngineVersion", jsii.sget(cls, "VER_11_2_0_4_V21"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_2_0_4_V22")
    def VER_11_2_0_4_V22(cls) -> "OracleLegacyEngineVersion":
        '''(deprecated) Version "11.2.0.4.v22".

        :stability: deprecated
        '''
        return typing.cast("OracleLegacyEngineVersion", jsii.sget(cls, "VER_11_2_0_4_V22"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_2_0_4_V23")
    def VER_11_2_0_4_V23(cls) -> "OracleLegacyEngineVersion":
        '''(deprecated) Version "11.2.0.4.v23".

        :stability: deprecated
        '''
        return typing.cast("OracleLegacyEngineVersion", jsii.sget(cls, "VER_11_2_0_4_V23"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_2_0_4_V24")
    def VER_11_2_0_4_V24(cls) -> "OracleLegacyEngineVersion":
        '''(deprecated) Version "11.2.0.4.v24".

        :stability: deprecated
        '''
        return typing.cast("OracleLegacyEngineVersion", jsii.sget(cls, "VER_11_2_0_4_V24"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_2_0_4_V25")
    def VER_11_2_0_4_V25(cls) -> "OracleLegacyEngineVersion":
        '''(deprecated) Version "11.2.0.4.v25".

        :stability: deprecated
        '''
        return typing.cast("OracleLegacyEngineVersion", jsii.sget(cls, "VER_11_2_0_4_V25"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_2_0_4_V3")
    def VER_11_2_0_4_V3(cls) -> "OracleLegacyEngineVersion":
        '''(deprecated) Version "11.2.0.4.v3".

        :stability: deprecated
        '''
        return typing.cast("OracleLegacyEngineVersion", jsii.sget(cls, "VER_11_2_0_4_V3"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_2_0_4_V4")
    def VER_11_2_0_4_V4(cls) -> "OracleLegacyEngineVersion":
        '''(deprecated) Version "11.2.0.4.v4".

        :stability: deprecated
        '''
        return typing.cast("OracleLegacyEngineVersion", jsii.sget(cls, "VER_11_2_0_4_V4"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_2_0_4_V5")
    def VER_11_2_0_4_V5(cls) -> "OracleLegacyEngineVersion":
        '''(deprecated) Version "11.2.0.4.v5".

        :stability: deprecated
        '''
        return typing.cast("OracleLegacyEngineVersion", jsii.sget(cls, "VER_11_2_0_4_V5"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_2_0_4_V6")
    def VER_11_2_0_4_V6(cls) -> "OracleLegacyEngineVersion":
        '''(deprecated) Version "11.2.0.4.v6".

        :stability: deprecated
        '''
        return typing.cast("OracleLegacyEngineVersion", jsii.sget(cls, "VER_11_2_0_4_V6"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_2_0_4_V7")
    def VER_11_2_0_4_V7(cls) -> "OracleLegacyEngineVersion":
        '''(deprecated) Version "11.2.0.4.v7".

        :stability: deprecated
        '''
        return typing.cast("OracleLegacyEngineVersion", jsii.sget(cls, "VER_11_2_0_4_V7"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_2_0_4_V8")
    def VER_11_2_0_4_V8(cls) -> "OracleLegacyEngineVersion":
        '''(deprecated) Version "11.2.0.4.v8".

        :stability: deprecated
        '''
        return typing.cast("OracleLegacyEngineVersion", jsii.sget(cls, "VER_11_2_0_4_V8"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_2_0_4_V9")
    def VER_11_2_0_4_V9(cls) -> "OracleLegacyEngineVersion":
        '''(deprecated) Version "11.2.0.4.v9".

        :stability: deprecated
        '''
        return typing.cast("OracleLegacyEngineVersion", jsii.sget(cls, "VER_11_2_0_4_V9"))

    @builtins.property
    @jsii.member(jsii_name="oracleLegacyFullVersion")
    def oracle_legacy_full_version(self) -> builtins.str:
        '''(deprecated) The full version string, for example, "11.2.0.4.v24".

        :stability: deprecated
        '''
        return typing.cast(builtins.str, jsii.get(self, "oracleLegacyFullVersion"))

    @builtins.property
    @jsii.member(jsii_name="oracleLegacyMajorVersion")
    def oracle_legacy_major_version(self) -> builtins.str:
        '''(deprecated) The major version of the engine, for example, "11.2".

        :stability: deprecated
        '''
        return typing.cast(builtins.str, jsii.get(self, "oracleLegacyMajorVersion"))


@jsii.data_type(
    jsii_type="monocdk.aws_rds.OracleSe1InstanceEngineProps",
    jsii_struct_bases=[],
    name_mapping={"version": "version"},
)
class OracleSe1InstanceEngineProps:
    def __init__(self, *, version: OracleLegacyEngineVersion) -> None:
        '''(deprecated) Properties for Oracle Standard Edition 1 instance engines.

        Used in {@link DatabaseInstanceEngine.oracleSe1}.

        :param version: (deprecated) The exact version of the engine to use.

        :deprecated: instances can no longer be created with this engine. See https://forums.aws.amazon.com/ann.jspa?annID=7341

        :stability: deprecated
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_rds as rds
            
            # oracle_legacy_engine_version: rds.OracleLegacyEngineVersion
            
            oracle_se1_instance_engine_props = rds.OracleSe1InstanceEngineProps(
                version=oracle_legacy_engine_version
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ef52a0a16bc83bb8b2efa91c4e42647f55914596f5b7ad2bcea4c163dca5e9e0)
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "version": version,
        }

    @builtins.property
    def version(self) -> OracleLegacyEngineVersion:
        '''(deprecated) The exact version of the engine to use.

        :stability: deprecated
        '''
        result = self._values.get("version")
        assert result is not None, "Required property 'version' is missing"
        return typing.cast(OracleLegacyEngineVersion, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "OracleSe1InstanceEngineProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_rds.OracleSe2InstanceEngineProps",
    jsii_struct_bases=[],
    name_mapping={"version": "version"},
)
class OracleSe2InstanceEngineProps:
    def __init__(self, *, version: OracleEngineVersion) -> None:
        '''(experimental) Properties for Oracle Standard Edition 2 instance engines.

        Used in {@link DatabaseInstanceEngine.oracleSe2}.

        :param version: (experimental) The exact version of the engine to use.

        :stability: experimental
        :exampleMetadata: infused

        Example::

            # vpc: ec2.Vpc
            
            instance = rds.DatabaseInstance(self, "Instance",
                engine=rds.DatabaseInstanceEngine.oracle_se2(version=rds.OracleEngineVersion.VER_19_0_0_0_2020_04_R1),
                # optional, defaults to m5.large
                instance_type=ec2.InstanceType.of(ec2.InstanceClass.BURSTABLE3, ec2.InstanceSize.SMALL),
                credentials=rds.Credentials.from_generated_secret("syscdk"),  # Optional - will default to 'admin' username and generated password
                vpc=vpc,
                vpc_subnets=ec2.aws_ec2.SubnetSelection(
                    subnet_type=ec2.SubnetType.PRIVATE_WITH_NAT
                )
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3b279b88ffe683316a834ce46911c0991a4ceab3d8a0784051c91c1b1eb47c38)
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "version": version,
        }

    @builtins.property
    def version(self) -> OracleEngineVersion:
        '''(experimental) The exact version of the engine to use.

        :stability: experimental
        '''
        result = self._values.get("version")
        assert result is not None, "Required property 'version' is missing"
        return typing.cast(OracleEngineVersion, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "OracleSe2InstanceEngineProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_rds.OracleSeInstanceEngineProps",
    jsii_struct_bases=[],
    name_mapping={"version": "version"},
)
class OracleSeInstanceEngineProps:
    def __init__(self, *, version: OracleLegacyEngineVersion) -> None:
        '''(deprecated) Properties for Oracle Standard Edition instance engines.

        Used in {@link DatabaseInstanceEngine.oracleSe}.

        :param version: (deprecated) The exact version of the engine to use.

        :deprecated: instances can no longer be created with this engine. See https://forums.aws.amazon.com/ann.jspa?annID=7341

        :stability: deprecated
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_rds as rds
            
            # oracle_legacy_engine_version: rds.OracleLegacyEngineVersion
            
            oracle_se_instance_engine_props = rds.OracleSeInstanceEngineProps(
                version=oracle_legacy_engine_version
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4f7c2569ae685d5347ad9c7ae74abb3a1e37c10bbb4bc1f2f6afd52f33ea038a)
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "version": version,
        }

    @builtins.property
    def version(self) -> OracleLegacyEngineVersion:
        '''(deprecated) The exact version of the engine to use.

        :stability: deprecated
        '''
        result = self._values.get("version")
        assert result is not None, "Required property 'version' is missing"
        return typing.cast(OracleLegacyEngineVersion, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "OracleSeInstanceEngineProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(IParameterGroup)
class ParameterGroup(
    _Resource_abff4495,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_rds.ParameterGroup",
):
    '''(experimental) A parameter group.

    Represents both a cluster parameter group,
    and an instance parameter group.

    :stability: experimental
    :resource: AWS::RDS::DBParameterGroup
    :exampleMetadata: infused

    Example::

        # vpc: ec2.Vpc
        
        
        cluster = rds.ServerlessCluster(self, "AnotherCluster",
            engine=rds.DatabaseClusterEngine.AURORA_POSTGRESQL,
            parameter_group=rds.ParameterGroup.from_parameter_group_name(self, "ParameterGroup", "default.aurora-postgresql10"),
            vpc=vpc,
            scaling=ec2.aws_rds.ServerlessScalingOptions(
                auto_pause=Duration.minutes(10),  # default is to pause after 5 minutes of idle time
                min_capacity=rds.AuroraCapacityUnit.ACU_8,  # default is 2 Aurora capacity units (ACUs)
                max_capacity=rds.AuroraCapacityUnit.ACU_32
            )
        )
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        engine: IEngine,
        description: typing.Optional[builtins.str] = None,
        parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param engine: (experimental) The database engine for this parameter group.
        :param description: (experimental) Description for this parameter group. Default: a CDK generated description
        :param parameters: (experimental) The parameters in this parameter group. Default: - None

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__90c01ed05e68e04d55d397f6e8bb36549c2b91733d5fae769136f660b8ae3678)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = ParameterGroupProps(
            engine=engine, description=description, parameters=parameters
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="fromParameterGroupName")
    @builtins.classmethod
    def from_parameter_group_name(
        cls,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        parameter_group_name: builtins.str,
    ) -> IParameterGroup:
        '''(experimental) Imports a parameter group.

        :param scope: -
        :param id: -
        :param parameter_group_name: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6fda544cc1f62b6e28c1c8a4bcf01a21333070e4f1356ee4cd5a56f3f116dc16)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument parameter_group_name", value=parameter_group_name, expected_type=type_hints["parameter_group_name"])
        return typing.cast(IParameterGroup, jsii.sinvoke(cls, "fromParameterGroupName", [scope, id, parameter_group_name]))

    @jsii.member(jsii_name="addParameter")
    def add_parameter(self, key: builtins.str, value: builtins.str) -> builtins.bool:
        '''(experimental) Add a parameter to this parameter group.

        :param key: The key of the parameter to be added.
        :param value: The value of the parameter to be added.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b239d5a2a3d7f34833af46729dfb481d8940df5fd6fcae183077be987a3057b4)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(builtins.bool, jsii.invoke(self, "addParameter", [key, value]))

    @jsii.member(jsii_name="bindToCluster")
    def bind_to_cluster(self) -> "ParameterGroupClusterConfig":
        '''(experimental) Method called when this Parameter Group is used when defining a database cluster.

        :stability: experimental
        '''
        _options = ParameterGroupClusterBindOptions()

        return typing.cast("ParameterGroupClusterConfig", jsii.invoke(self, "bindToCluster", [_options]))

    @jsii.member(jsii_name="bindToInstance")
    def bind_to_instance(self) -> "ParameterGroupInstanceConfig":
        '''(experimental) Method called when this Parameter Group is used when defining a database instance.

        :stability: experimental
        '''
        _options = ParameterGroupInstanceBindOptions()

        return typing.cast("ParameterGroupInstanceConfig", jsii.invoke(self, "bindToInstance", [_options]))


@jsii.data_type(
    jsii_type="monocdk.aws_rds.ParameterGroupClusterBindOptions",
    jsii_struct_bases=[],
    name_mapping={},
)
class ParameterGroupClusterBindOptions:
    def __init__(self) -> None:
        '''(experimental) Options for {@link IParameterGroup.bindToCluster}. Empty for now, but can be extended later.

        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_rds as rds
            
            parameter_group_cluster_bind_options = rds.ParameterGroupClusterBindOptions()
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {}

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ParameterGroupClusterBindOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_rds.ParameterGroupClusterConfig",
    jsii_struct_bases=[],
    name_mapping={"parameter_group_name": "parameterGroupName"},
)
class ParameterGroupClusterConfig:
    def __init__(self, *, parameter_group_name: builtins.str) -> None:
        '''(experimental) The type returned from {@link IParameterGroup.bindToCluster}.

        :param parameter_group_name: (experimental) The name of this parameter group.

        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_rds as rds
            
            parameter_group_cluster_config = rds.ParameterGroupClusterConfig(
                parameter_group_name="parameterGroupName"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b3856afadbeacddd94f57f6b344677b9b284923622062b4299752b840befc9b0)
            check_type(argname="argument parameter_group_name", value=parameter_group_name, expected_type=type_hints["parameter_group_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "parameter_group_name": parameter_group_name,
        }

    @builtins.property
    def parameter_group_name(self) -> builtins.str:
        '''(experimental) The name of this parameter group.

        :stability: experimental
        '''
        result = self._values.get("parameter_group_name")
        assert result is not None, "Required property 'parameter_group_name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ParameterGroupClusterConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_rds.ParameterGroupInstanceBindOptions",
    jsii_struct_bases=[],
    name_mapping={},
)
class ParameterGroupInstanceBindOptions:
    def __init__(self) -> None:
        '''(experimental) Options for {@link IParameterGroup.bindToInstance}. Empty for now, but can be extended later.

        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_rds as rds
            
            parameter_group_instance_bind_options = rds.ParameterGroupInstanceBindOptions()
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {}

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ParameterGroupInstanceBindOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_rds.ParameterGroupInstanceConfig",
    jsii_struct_bases=[],
    name_mapping={"parameter_group_name": "parameterGroupName"},
)
class ParameterGroupInstanceConfig:
    def __init__(self, *, parameter_group_name: builtins.str) -> None:
        '''(experimental) The type returned from {@link IParameterGroup.bindToInstance}.

        :param parameter_group_name: (experimental) The name of this parameter group.

        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_rds as rds
            
            parameter_group_instance_config = rds.ParameterGroupInstanceConfig(
                parameter_group_name="parameterGroupName"
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8a2bcd211a18f14cc2ad9eb202e62ed95cbd5190450681961248905ae9aba0f5)
            check_type(argname="argument parameter_group_name", value=parameter_group_name, expected_type=type_hints["parameter_group_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "parameter_group_name": parameter_group_name,
        }

    @builtins.property
    def parameter_group_name(self) -> builtins.str:
        '''(experimental) The name of this parameter group.

        :stability: experimental
        '''
        result = self._values.get("parameter_group_name")
        assert result is not None, "Required property 'parameter_group_name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ParameterGroupInstanceConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_rds.ParameterGroupProps",
    jsii_struct_bases=[],
    name_mapping={
        "engine": "engine",
        "description": "description",
        "parameters": "parameters",
    },
)
class ParameterGroupProps:
    def __init__(
        self,
        *,
        engine: IEngine,
        description: typing.Optional[builtins.str] = None,
        parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''(experimental) Properties for a parameter group.

        :param engine: (experimental) The database engine for this parameter group.
        :param description: (experimental) Description for this parameter group. Default: a CDK generated description
        :param parameters: (experimental) The parameters in this parameter group. Default: - None

        :stability: experimental
        :exampleMetadata: lit=lib/aws-rds/test/integ.instance.lit.ts infused

        Example::

            # Set open cursors with parameter group
            parameter_group = rds.ParameterGroup(self, "ParameterGroup",
                engine=rds.DatabaseInstanceEngine.oracle_se2(version=rds.OracleEngineVersion.VER_19_0_0_0_2020_04_R1),
                parameters={
                    "open_cursors": "2500"
                }
            )
            
            option_group = rds.OptionGroup(self, "OptionGroup",
                engine=rds.DatabaseInstanceEngine.oracle_se2(version=rds.OracleEngineVersion.VER_19_0_0_0_2020_04_R1),
                configurations=[cdk.aws_rds.OptionConfiguration(
                    name="LOCATOR"
                ), cdk.aws_rds.OptionConfiguration(
                    name="OEM",
                    port=1158,
                    vpc=vpc
                )
                ]
            )
            
            # Allow connections to OEM
            option_group.option_connections.OEM.connections.allow_default_port_from_any_ipv4()
            
            # Database instance with production values
            instance = rds.DatabaseInstance(self, "Instance",
                engine=rds.DatabaseInstanceEngine.oracle_se2(version=rds.OracleEngineVersion.VER_19_0_0_0_2020_04_R1),
                license_model=rds.LicenseModel.BRING_YOUR_OWN_LICENSE,
                instance_type=ec2.InstanceType.of(ec2.InstanceClass.BURSTABLE3, ec2.InstanceSize.MEDIUM),
                multi_az=True,
                storage_type=rds.StorageType.IO1,
                credentials=rds.Credentials.from_username("syscdk"),
                vpc=vpc,
                database_name="ORCL",
                storage_encrypted=True,
                backup_retention=cdk.Duration.days(7),
                monitoring_interval=cdk.Duration.seconds(60),
                enable_performance_insights=True,
                cloudwatch_logs_exports=["trace", "audit", "alert", "listener"
                ],
                cloudwatch_logs_retention=logs.RetentionDays.ONE_MONTH,
                auto_minor_version_upgrade=True,  # required to be true if LOCATOR is used in the option group
                option_group=option_group,
                parameter_group=parameter_group,
                removal_policy=RemovalPolicy.DESTROY
            )
            
            # Allow connections on default port from any IPV4
            instance.connections.allow_default_port_from_any_ipv4()
            
            # Rotate the master user password every 30 days
            instance.add_rotation_single_user()
            
            # Add alarm for high CPU
            cloudwatch.Alarm(self, "HighCPU",
                metric=instance.metric_cPUUtilization(),
                threshold=90,
                evaluation_periods=1
            )
            
            # Trigger Lambda function on instance availability events
            fn = lambda_.Function(self, "Function",
                code=lambda_.Code.from_inline("exports.handler = (event) => console.log(event);"),
                handler="index.handler",
                runtime=lambda_.Runtime.NODEJS_14_X
            )
            
            availability_rule = instance.on_event("Availability", target=targets.LambdaFunction(fn))
            availability_rule.add_event_pattern(
                detail={
                    "EventCategories": ["availability"
                    ]
                }
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cfc15b0cca60651e959371413a17d7021075a5fcfb6e863405746569bd9be72b)
            check_type(argname="argument engine", value=engine, expected_type=type_hints["engine"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument parameters", value=parameters, expected_type=type_hints["parameters"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "engine": engine,
        }
        if description is not None:
            self._values["description"] = description
        if parameters is not None:
            self._values["parameters"] = parameters

    @builtins.property
    def engine(self) -> IEngine:
        '''(experimental) The database engine for this parameter group.

        :stability: experimental
        '''
        result = self._values.get("engine")
        assert result is not None, "Required property 'engine' is missing"
        return typing.cast(IEngine, result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(experimental) Description for this parameter group.

        :default: a CDK generated description

        :stability: experimental
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def parameters(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''(experimental) The parameters in this parameter group.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("parameters")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ParameterGroupProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="monocdk.aws_rds.PerformanceInsightRetention")
class PerformanceInsightRetention(enum.Enum):
    '''(experimental) The retention period for Performance Insight.

    :stability: experimental
    '''

    DEFAULT = "DEFAULT"
    '''(experimental) Default retention period of 7 days.

    :stability: experimental
    '''
    LONG_TERM = "LONG_TERM"
    '''(experimental) Long term retention period of 2 years.

    :stability: experimental
    '''


@jsii.data_type(
    jsii_type="monocdk.aws_rds.PostgresEngineFeatures",
    jsii_struct_bases=[],
    name_mapping={"s3_export": "s3Export", "s3_import": "s3Import"},
)
class PostgresEngineFeatures:
    def __init__(
        self,
        *,
        s3_export: typing.Optional[builtins.bool] = None,
        s3_import: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''(experimental) Features supported by the Postgres database engine.

        :param s3_export: (experimental) Whether this version of the Postgres engine supports the S3 data export feature. Default: false
        :param s3_import: (experimental) Whether this version of the Postgres engine supports the S3 data import feature. Default: false

        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_rds as rds
            
            postgres_engine_features = rds.PostgresEngineFeatures(
                s3_export=False,
                s3_import=False
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__74319f9390a1fb9bf6edb0516d8b0ed2c8b80b284e60d924d08721fa035e8dae)
            check_type(argname="argument s3_export", value=s3_export, expected_type=type_hints["s3_export"])
            check_type(argname="argument s3_import", value=s3_import, expected_type=type_hints["s3_import"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if s3_export is not None:
            self._values["s3_export"] = s3_export
        if s3_import is not None:
            self._values["s3_import"] = s3_import

    @builtins.property
    def s3_export(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Whether this version of the Postgres engine supports the S3 data export feature.

        :default: false

        :stability: experimental
        '''
        result = self._values.get("s3_export")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def s3_import(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Whether this version of the Postgres engine supports the S3 data import feature.

        :default: false

        :stability: experimental
        '''
        result = self._values.get("s3_import")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PostgresEngineFeatures(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class PostgresEngineVersion(
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_rds.PostgresEngineVersion",
):
    '''(experimental) The versions for the PostgreSQL instance engines (those returned by {@link DatabaseInstanceEngine.postgres}).

    :stability: experimental
    :exampleMetadata: infused

    Example::

        # vpc: ec2.Vpc
        
        engine = rds.DatabaseInstanceEngine.postgres(version=rds.PostgresEngineVersion.VER_12_3)
        my_key = kms.Key(self, "MyKey")
        
        rds.DatabaseInstance(self, "InstanceWithCustomizedSecret",
            engine=engine,
            vpc=vpc,
            credentials=rds.Credentials.from_generated_secret("postgres",
                secret_name="my-cool-name",
                encryption_key=my_key,
                exclude_characters="!&*^#@()",
                replica_regions=[ec2.aws_secretsmanager.ReplicaRegion(region="eu-west-1"), ec2.aws_secretsmanager.ReplicaRegion(region="eu-west-2")]
            )
        )
    '''

    @jsii.member(jsii_name="of")
    @builtins.classmethod
    def of(
        cls,
        postgres_full_version: builtins.str,
        postgres_major_version: builtins.str,
        *,
        s3_export: typing.Optional[builtins.bool] = None,
        s3_import: typing.Optional[builtins.bool] = None,
    ) -> "PostgresEngineVersion":
        '''(experimental) Create a new PostgresEngineVersion with an arbitrary version.

        :param postgres_full_version: the full version string, for example "13.11".
        :param postgres_major_version: the major version of the engine, for example "13".
        :param s3_export: (experimental) Whether this version of the Postgres engine supports the S3 data export feature. Default: false
        :param s3_import: (experimental) Whether this version of the Postgres engine supports the S3 data import feature. Default: false

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__85d98fcae85beb46d59234eb91fbdd38c155f8103b0ec0a082bf71feb615aa53)
            check_type(argname="argument postgres_full_version", value=postgres_full_version, expected_type=type_hints["postgres_full_version"])
            check_type(argname="argument postgres_major_version", value=postgres_major_version, expected_type=type_hints["postgres_major_version"])
        postgres_features = PostgresEngineFeatures(
            s3_export=s3_export, s3_import=s3_import
        )

        return typing.cast("PostgresEngineVersion", jsii.sinvoke(cls, "of", [postgres_full_version, postgres_major_version, postgres_features]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10")
    def VER_10(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "10" (only a major version, without a specific minor version).

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_10"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_1")
    def VER_10_1(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "10.1".

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_10_1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_10")
    def VER_10_10(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "10.10".

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_10_10"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_11")
    def VER_10_11(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "10.11".

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_10_11"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_12")
    def VER_10_12(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "10.12".

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_10_12"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_13")
    def VER_10_13(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "10.13".

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_10_13"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_14")
    def VER_10_14(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "10.14".

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_10_14"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_15")
    def VER_10_15(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "10.15".

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_10_15"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_16")
    def VER_10_16(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "10.16".

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_10_16"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_17")
    def VER_10_17(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "10.17".

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_10_17"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_18")
    def VER_10_18(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "10.18".

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_10_18"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_19")
    def VER_10_19(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "10.19".

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_10_19"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_20")
    def VER_10_20(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "10.20".

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_10_20"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_3")
    def VER_10_3(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "10.3".

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_10_3"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_4")
    def VER_10_4(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "10.4".

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_10_4"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_5")
    def VER_10_5(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "10.5".

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_10_5"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_6")
    def VER_10_6(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "10.6".

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_10_6"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_7")
    def VER_10_7(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "10.7".

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_10_7"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_10_9")
    def VER_10_9(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "10.9".

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_10_9"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11")
    def VER_11(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "11" (only a major version, without a specific minor version).

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_11"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_1")
    def VER_11_1(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "11.1".

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_11_1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_10")
    def VER_11_10(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "11.10".

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_11_10"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_11")
    def VER_11_11(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "11.11".

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_11_11"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_12")
    def VER_11_12(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "11.12".

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_11_12"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_13")
    def VER_11_13(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "11.13".

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_11_13"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_14")
    def VER_11_14(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "11.14".

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_11_14"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_15")
    def VER_11_15(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "11.15".

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_11_15"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_2")
    def VER_11_2(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "11.2".

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_11_2"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_4")
    def VER_11_4(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "11.4".

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_11_4"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_5")
    def VER_11_5(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "11.5".

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_11_5"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_6")
    def VER_11_6(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "11.6".

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_11_6"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_7")
    def VER_11_7(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "11.7".

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_11_7"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_8")
    def VER_11_8(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "11.8".

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_11_8"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_9")
    def VER_11_9(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "11.9".

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_11_9"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12")
    def VER_12(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "12" (only a major version, without a specific minor version).

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_12"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_10")
    def VER_12_10(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "12.10".

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_12_10"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_2")
    def VER_12_2(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "12.2".

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_12_2"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_3")
    def VER_12_3(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "12.3".

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_12_3"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_4")
    def VER_12_4(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "12.4".

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_12_4"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_5")
    def VER_12_5(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "12.5".

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_12_5"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_6")
    def VER_12_6(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "12.6".

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_12_6"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_7")
    def VER_12_7(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "12.7".

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_12_7"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_8")
    def VER_12_8(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "12.8".

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_12_8"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_9")
    def VER_12_9(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "12.9".

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_12_9"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_13")
    def VER_13(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "13" (only a major version, without a specific minor version).

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_13"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_13_1")
    def VER_13_1(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "13.1".

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_13_1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_13_2")
    def VER_13_2(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "13.2".

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_13_2"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_13_3")
    def VER_13_3(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "13.3".

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_13_3"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_13_4")
    def VER_13_4(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "13.4".

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_13_4"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_13_5")
    def VER_13_5(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "13.5".

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_13_5"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_13_6")
    def VER_13_6(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "13.6".

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_13_6"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_14")
    def VER_14(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "14" (only a major version, without a specific minor version).

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_14"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_14_1")
    def VER_14_1(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "14.1".

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_14_1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_14_2")
    def VER_14_2(cls) -> "PostgresEngineVersion":
        '''(experimental) Version "14.2".

        :stability: experimental
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_14_2"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_9_5")
    def VER_9_5(cls) -> "PostgresEngineVersion":
        '''(deprecated) Version "9.5" (only a major version, without a specific minor version).

        :deprecated: PostgreSQL 9.5 will reach end of life on February 16, 2021

        :stability: deprecated
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_9_5"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_9_5_10")
    def VER_9_5_10(cls) -> "PostgresEngineVersion":
        '''(deprecated) Version "9.5.10".

        :deprecated: PostgreSQL 9.5 will reach end of life on February 16, 2021

        :stability: deprecated
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_9_5_10"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_9_5_12")
    def VER_9_5_12(cls) -> "PostgresEngineVersion":
        '''(deprecated) Version "9.5.12".

        :deprecated: PostgreSQL 9.5 will reach end of life on February 16, 2021

        :stability: deprecated
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_9_5_12"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_9_5_13")
    def VER_9_5_13(cls) -> "PostgresEngineVersion":
        '''(deprecated) Version "9.5.13".

        :deprecated: PostgreSQL 9.5 will reach end of life on February 16, 2021

        :stability: deprecated
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_9_5_13"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_9_5_14")
    def VER_9_5_14(cls) -> "PostgresEngineVersion":
        '''(deprecated) Version "9.5.14".

        :deprecated: PostgreSQL 9.5 will reach end of life on February 16, 2021

        :stability: deprecated
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_9_5_14"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_9_5_15")
    def VER_9_5_15(cls) -> "PostgresEngineVersion":
        '''(deprecated) Version "9.5.15".

        :deprecated: PostgreSQL 9.5 will reach end of life on February 16, 2021

        :stability: deprecated
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_9_5_15"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_9_5_16")
    def VER_9_5_16(cls) -> "PostgresEngineVersion":
        '''(deprecated) Version "9.5.16".

        :deprecated: PostgreSQL 9.5 will reach end of life on February 16, 2021

        :stability: deprecated
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_9_5_16"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_9_5_18")
    def VER_9_5_18(cls) -> "PostgresEngineVersion":
        '''(deprecated) Version "9.5.18".

        :deprecated: PostgreSQL 9.5 will reach end of life on February 16, 2021

        :stability: deprecated
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_9_5_18"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_9_5_19")
    def VER_9_5_19(cls) -> "PostgresEngineVersion":
        '''(deprecated) Version "9.5.19".

        :deprecated: PostgreSQL 9.5 will reach end of life on February 16, 2021

        :stability: deprecated
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_9_5_19"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_9_5_2")
    def VER_9_5_2(cls) -> "PostgresEngineVersion":
        '''(deprecated) Version "9.5.2".

        :deprecated: PostgreSQL 9.5 will reach end of life on February 16, 2021

        :stability: deprecated
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_9_5_2"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_9_5_20")
    def VER_9_5_20(cls) -> "PostgresEngineVersion":
        '''(deprecated) Version "9.5.20".

        :deprecated: PostgreSQL 9.5 will reach end of life on February 16, 2021

        :stability: deprecated
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_9_5_20"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_9_5_21")
    def VER_9_5_21(cls) -> "PostgresEngineVersion":
        '''(deprecated) Version "9.5.21".

        :deprecated: PostgreSQL 9.5 will reach end of life on February 16, 2021

        :stability: deprecated
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_9_5_21"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_9_5_22")
    def VER_9_5_22(cls) -> "PostgresEngineVersion":
        '''(deprecated) Version "9.5.22".

        :deprecated: PostgreSQL 9.5 will reach end of life on February 16, 2021

        :stability: deprecated
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_9_5_22"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_9_5_23")
    def VER_9_5_23(cls) -> "PostgresEngineVersion":
        '''(deprecated) Version "9.5.23".

        :deprecated: PostgreSQL 9.5 will reach end of life on February 16, 2021

        :stability: deprecated
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_9_5_23"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_9_5_24")
    def VER_9_5_24(cls) -> "PostgresEngineVersion":
        '''(deprecated) Version "9.5.24".

        :deprecated: PostgreSQL 9.5 will reach end of life on February 16, 2021

        :stability: deprecated
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_9_5_24"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_9_5_25")
    def VER_9_5_25(cls) -> "PostgresEngineVersion":
        '''(deprecated) Version "9.5.25".

        :deprecated: PostgreSQL 9.5 will reach end of life on February 16, 2021

        :stability: deprecated
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_9_5_25"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_9_5_4")
    def VER_9_5_4(cls) -> "PostgresEngineVersion":
        '''(deprecated) Version "9.5.4".

        :deprecated: PostgreSQL 9.5 will reach end of life on February 16, 2021

        :stability: deprecated
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_9_5_4"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_9_5_6")
    def VER_9_5_6(cls) -> "PostgresEngineVersion":
        '''(deprecated) Version "9.5.6".

        :deprecated: PostgreSQL 9.5 will reach end of life on February 16, 2021

        :stability: deprecated
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_9_5_6"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_9_5_7")
    def VER_9_5_7(cls) -> "PostgresEngineVersion":
        '''(deprecated) Version "9.5.7".

        :deprecated: PostgreSQL 9.5 will reach end of life on February 16, 2021

        :stability: deprecated
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_9_5_7"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_9_5_9")
    def VER_9_5_9(cls) -> "PostgresEngineVersion":
        '''(deprecated) Version "9.5.9".

        :deprecated: PostgreSQL 9.5 will reach end of life on February 16, 2021

        :stability: deprecated
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_9_5_9"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_9_6")
    def VER_9_6(cls) -> "PostgresEngineVersion":
        '''(deprecated) Version "9.6" (only a major version, without a specific minor version).

        :deprecated: PostgreSQL 9.6 will reach end of life in November 2021

        :stability: deprecated
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_9_6"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_9_6_1")
    def VER_9_6_1(cls) -> "PostgresEngineVersion":
        '''(deprecated) Version "9.6.1".

        :deprecated: PostgreSQL 9.6 will reach end of life in November 2021

        :stability: deprecated
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_9_6_1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_9_6_10")
    def VER_9_6_10(cls) -> "PostgresEngineVersion":
        '''(deprecated) Version "9.6.10".

        :deprecated: PostgreSQL 9.6 will reach end of life in November 2021

        :stability: deprecated
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_9_6_10"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_9_6_11")
    def VER_9_6_11(cls) -> "PostgresEngineVersion":
        '''(deprecated) Version "9.6.11".

        :deprecated: PostgreSQL 9.6 will reach end of life in November 2021

        :stability: deprecated
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_9_6_11"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_9_6_12")
    def VER_9_6_12(cls) -> "PostgresEngineVersion":
        '''(deprecated) Version "9.6.12".

        :deprecated: PostgreSQL 9.6 will reach end of life in November 2021

        :stability: deprecated
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_9_6_12"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_9_6_14")
    def VER_9_6_14(cls) -> "PostgresEngineVersion":
        '''(deprecated) Version "9.6.14".

        :deprecated: PostgreSQL 9.6 will reach end of life in November 2021

        :stability: deprecated
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_9_6_14"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_9_6_15")
    def VER_9_6_15(cls) -> "PostgresEngineVersion":
        '''(deprecated) Version "9.6.15".

        :deprecated: PostgreSQL 9.6 will reach end of life in November 2021

        :stability: deprecated
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_9_6_15"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_9_6_16")
    def VER_9_6_16(cls) -> "PostgresEngineVersion":
        '''(deprecated) Version "9.6.16".

        :deprecated: PostgreSQL 9.6 will reach end of life in November 2021

        :stability: deprecated
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_9_6_16"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_9_6_17")
    def VER_9_6_17(cls) -> "PostgresEngineVersion":
        '''(deprecated) Version "9.6.17".

        :deprecated: PostgreSQL 9.6 will reach end of life in November 2021

        :stability: deprecated
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_9_6_17"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_9_6_18")
    def VER_9_6_18(cls) -> "PostgresEngineVersion":
        '''(deprecated) Version "9.6.18".

        :deprecated: PostgreSQL 9.6 will reach end of life in November 2021

        :stability: deprecated
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_9_6_18"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_9_6_19")
    def VER_9_6_19(cls) -> "PostgresEngineVersion":
        '''(deprecated) Version "9.6.19".

        :deprecated: PostgreSQL 9.6 will reach end of life in November 2021

        :stability: deprecated
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_9_6_19"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_9_6_2")
    def VER_9_6_2(cls) -> "PostgresEngineVersion":
        '''(deprecated) Version "9.6.2".

        :deprecated: PostgreSQL 9.6 will reach end of life in November 2021

        :stability: deprecated
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_9_6_2"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_9_6_20")
    def VER_9_6_20(cls) -> "PostgresEngineVersion":
        '''(deprecated) Version "9.6.20".

        :deprecated: PostgreSQL 9.6 will reach end of life in November 2021

        :stability: deprecated
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_9_6_20"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_9_6_21")
    def VER_9_6_21(cls) -> "PostgresEngineVersion":
        '''(deprecated) Version "9.6.21".

        :deprecated: PostgreSQL 9.6 will reach end of life in November 2021

        :stability: deprecated
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_9_6_21"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_9_6_22")
    def VER_9_6_22(cls) -> "PostgresEngineVersion":
        '''(deprecated) Version "9.6.22".

        :deprecated: PostgreSQL 9.6 will reach end of life in November 2021

        :stability: deprecated
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_9_6_22"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_9_6_23")
    def VER_9_6_23(cls) -> "PostgresEngineVersion":
        '''(deprecated) Version "9.6.23".

        :deprecated: PostgreSQL 9.6 will reach end of life in November 2021

        :stability: deprecated
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_9_6_23"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_9_6_24")
    def VER_9_6_24(cls) -> "PostgresEngineVersion":
        '''(deprecated) Version "9.6.24".

        :deprecated: PostgreSQL 9.6 will reach end of life in November 2021

        :stability: deprecated
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_9_6_24"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_9_6_3")
    def VER_9_6_3(cls) -> "PostgresEngineVersion":
        '''(deprecated) Version "9.6.3".

        :deprecated: PostgreSQL 9.6 will reach end of life in November 2021

        :stability: deprecated
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_9_6_3"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_9_6_5")
    def VER_9_6_5(cls) -> "PostgresEngineVersion":
        '''(deprecated) Version "9.6.5".

        :deprecated: PostgreSQL 9.6 will reach end of life in November 2021

        :stability: deprecated
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_9_6_5"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_9_6_6")
    def VER_9_6_6(cls) -> "PostgresEngineVersion":
        '''(deprecated) Version "9.6.6".

        :deprecated: PostgreSQL 9.6 will reach end of life in November 2021

        :stability: deprecated
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_9_6_6"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_9_6_8")
    def VER_9_6_8(cls) -> "PostgresEngineVersion":
        '''(deprecated) Version "9.6.8".

        :deprecated: PostgreSQL 9.6 will reach end of life in November 2021

        :stability: deprecated
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_9_6_8"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_9_6_9")
    def VER_9_6_9(cls) -> "PostgresEngineVersion":
        '''(deprecated) Version "9.6.9".

        :deprecated: PostgreSQL 9.6 will reach end of life in November 2021

        :stability: deprecated
        '''
        return typing.cast("PostgresEngineVersion", jsii.sget(cls, "VER_9_6_9"))

    @builtins.property
    @jsii.member(jsii_name="postgresFullVersion")
    def postgres_full_version(self) -> builtins.str:
        '''(experimental) The full version string, for example, "13.11".

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "postgresFullVersion"))

    @builtins.property
    @jsii.member(jsii_name="postgresMajorVersion")
    def postgres_major_version(self) -> builtins.str:
        '''(experimental) The major version of the engine, for example, "13".

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "postgresMajorVersion"))


@jsii.data_type(
    jsii_type="monocdk.aws_rds.PostgresInstanceEngineProps",
    jsii_struct_bases=[],
    name_mapping={"version": "version"},
)
class PostgresInstanceEngineProps:
    def __init__(self, *, version: PostgresEngineVersion) -> None:
        '''(experimental) Properties for PostgreSQL instance engines.

        Used in {@link DatabaseInstanceEngine.postgres}.

        :param version: (experimental) The exact version of the engine to use.

        :stability: experimental
        :exampleMetadata: infused

        Example::

            # vpc: ec2.Vpc
            
            engine = rds.DatabaseInstanceEngine.postgres(version=rds.PostgresEngineVersion.VER_12_3)
            my_key = kms.Key(self, "MyKey")
            
            rds.DatabaseInstance(self, "InstanceWithCustomizedSecret",
                engine=engine,
                vpc=vpc,
                credentials=rds.Credentials.from_generated_secret("postgres",
                    secret_name="my-cool-name",
                    encryption_key=my_key,
                    exclude_characters="!&*^#@()",
                    replica_regions=[ec2.aws_secretsmanager.ReplicaRegion(region="eu-west-1"), ec2.aws_secretsmanager.ReplicaRegion(region="eu-west-2")]
                )
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c92574a4ef80b2701826c7adc992b4fb02b48c041c62648bd156c2e65dadeafb)
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "version": version,
        }

    @builtins.property
    def version(self) -> PostgresEngineVersion:
        '''(experimental) The exact version of the engine to use.

        :stability: experimental
        '''
        result = self._values.get("version")
        assert result is not None, "Required property 'version' is missing"
        return typing.cast(PostgresEngineVersion, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PostgresInstanceEngineProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_rds.ProcessorFeatures",
    jsii_struct_bases=[],
    name_mapping={"core_count": "coreCount", "threads_per_core": "threadsPerCore"},
)
class ProcessorFeatures:
    def __init__(
        self,
        *,
        core_count: typing.Optional[jsii.Number] = None,
        threads_per_core: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''(experimental) The processor features.

        :param core_count: (experimental) The number of CPU core. Default: - the default number of CPU cores for the chosen instance class.
        :param threads_per_core: (experimental) The number of threads per core. Default: - the default number of threads per core for the chosen instance class.

        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_rds as rds
            
            processor_features = rds.ProcessorFeatures(
                core_count=123,
                threads_per_core=123
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__78ba48d18d789b94abe5cf92c49294fd5b445bbb8ae725723673f169835175c1)
            check_type(argname="argument core_count", value=core_count, expected_type=type_hints["core_count"])
            check_type(argname="argument threads_per_core", value=threads_per_core, expected_type=type_hints["threads_per_core"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if core_count is not None:
            self._values["core_count"] = core_count
        if threads_per_core is not None:
            self._values["threads_per_core"] = threads_per_core

    @builtins.property
    def core_count(self) -> typing.Optional[jsii.Number]:
        '''(experimental) The number of CPU core.

        :default: - the default number of CPU cores for the chosen instance class.

        :stability: experimental
        '''
        result = self._values.get("core_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threads_per_core(self) -> typing.Optional[jsii.Number]:
        '''(experimental) The number of threads per core.

        :default: - the default number of threads per core for the chosen instance class.

        :stability: experimental
        '''
        result = self._values.get("threads_per_core")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ProcessorFeatures(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ProxyTarget(metaclass=jsii.JSIIMeta, jsii_type="monocdk.aws_rds.ProxyTarget"):
    '''(experimental) Proxy target: Instance or Cluster.

    A target group is a collection of databases that the proxy can connect to.
    Currently, you can specify only one RDS DB instance or Aurora DB cluster.

    :stability: experimental
    :exampleMetadata: infused

    Example::

        # vpc: ec2.Vpc
        
        cluster = rds.DatabaseCluster(self, "Database",
            engine=rds.DatabaseClusterEngine.AURORA,
            instance_props=ec2.aws_rds.InstanceProps(vpc=vpc)
        )
        
        proxy = rds.DatabaseProxy(self, "Proxy",
            proxy_target=rds.ProxyTarget.from_cluster(cluster),
            secrets=[cluster.secret],
            vpc=vpc
        )
        
        role = iam.Role(self, "DBProxyRole", assumed_by=iam.AccountPrincipal(self.account))
        proxy.grant_connect(role, "admin")
    '''

    @jsii.member(jsii_name="fromCluster")
    @builtins.classmethod
    def from_cluster(cls, cluster: IDatabaseCluster) -> "ProxyTarget":
        '''(experimental) From cluster.

        :param cluster: RDS database cluster.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f24797854e76ef5fe4233507517b5c21d4b86db91926c88a0743c95138f5b2f8)
            check_type(argname="argument cluster", value=cluster, expected_type=type_hints["cluster"])
        return typing.cast("ProxyTarget", jsii.sinvoke(cls, "fromCluster", [cluster]))

    @jsii.member(jsii_name="fromInstance")
    @builtins.classmethod
    def from_instance(cls, instance: IDatabaseInstance) -> "ProxyTarget":
        '''(experimental) From instance.

        :param instance: RDS database instance.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9d0b4b2f9dc7bbd60360dacdc50d5851e7666c32227b3b00ec304d3145d8817f)
            check_type(argname="argument instance", value=instance, expected_type=type_hints["instance"])
        return typing.cast("ProxyTarget", jsii.sinvoke(cls, "fromInstance", [instance]))

    @jsii.member(jsii_name="bind")
    def bind(self, proxy: "DatabaseProxy") -> "ProxyTargetConfig":
        '''(experimental) Bind this target to the specified database proxy.

        :param proxy: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5bb49356d51cceef0c5e66f1131f55593c941cbfe311d0ccfdd4c7cdbe7ffba5)
            check_type(argname="argument proxy", value=proxy, expected_type=type_hints["proxy"])
        return typing.cast("ProxyTargetConfig", jsii.invoke(self, "bind", [proxy]))


@jsii.data_type(
    jsii_type="monocdk.aws_rds.ProxyTargetConfig",
    jsii_struct_bases=[],
    name_mapping={
        "engine_family": "engineFamily",
        "db_clusters": "dbClusters",
        "db_instances": "dbInstances",
    },
)
class ProxyTargetConfig:
    def __init__(
        self,
        *,
        engine_family: builtins.str,
        db_clusters: typing.Optional[typing.Sequence[IDatabaseCluster]] = None,
        db_instances: typing.Optional[typing.Sequence[IDatabaseInstance]] = None,
    ) -> None:
        '''(experimental) The result of binding a ``ProxyTarget`` to a ``DatabaseProxy``.

        :param engine_family: (experimental) The engine family of the database instance or cluster this proxy connects with.
        :param db_clusters: (experimental) The database clusters to which this proxy connects. Either this or ``dbInstances`` will be set and the other ``undefined``. Default: - ``undefined`` if ``dbInstances`` is set.
        :param db_instances: (experimental) The database instances to which this proxy connects. Either this or ``dbClusters`` will be set and the other ``undefined``. Default: - ``undefined`` if ``dbClusters`` is set.

        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_rds as rds
            
            # database_cluster: rds.DatabaseCluster
            # database_instance: rds.DatabaseInstance
            
            proxy_target_config = rds.ProxyTargetConfig(
                engine_family="engineFamily",
            
                # the properties below are optional
                db_clusters=[database_cluster],
                db_instances=[database_instance]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__869414a8a0959f8f2fa42ea9743c131364ff2ce8501b50066b84e8163815922b)
            check_type(argname="argument engine_family", value=engine_family, expected_type=type_hints["engine_family"])
            check_type(argname="argument db_clusters", value=db_clusters, expected_type=type_hints["db_clusters"])
            check_type(argname="argument db_instances", value=db_instances, expected_type=type_hints["db_instances"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "engine_family": engine_family,
        }
        if db_clusters is not None:
            self._values["db_clusters"] = db_clusters
        if db_instances is not None:
            self._values["db_instances"] = db_instances

    @builtins.property
    def engine_family(self) -> builtins.str:
        '''(experimental) The engine family of the database instance or cluster this proxy connects with.

        :stability: experimental
        '''
        result = self._values.get("engine_family")
        assert result is not None, "Required property 'engine_family' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def db_clusters(self) -> typing.Optional[typing.List[IDatabaseCluster]]:
        '''(experimental) The database clusters to which this proxy connects.

        Either this or ``dbInstances`` will be set and the other ``undefined``.

        :default: - ``undefined`` if ``dbInstances`` is set.

        :stability: experimental
        '''
        result = self._values.get("db_clusters")
        return typing.cast(typing.Optional[typing.List[IDatabaseCluster]], result)

    @builtins.property
    def db_instances(self) -> typing.Optional[typing.List[IDatabaseInstance]]:
        '''(experimental) The database instances to which this proxy connects.

        Either this or ``dbClusters`` will be set and the other ``undefined``.

        :default: - ``undefined`` if ``dbClusters`` is set.

        :stability: experimental
        '''
        result = self._values.get("db_instances")
        return typing.cast(typing.Optional[typing.List[IDatabaseInstance]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ProxyTargetConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_rds.RotationMultiUserOptions",
    jsii_struct_bases=[CommonRotationUserOptions],
    name_mapping={
        "automatically_after": "automaticallyAfter",
        "endpoint": "endpoint",
        "exclude_characters": "excludeCharacters",
        "vpc_subnets": "vpcSubnets",
        "secret": "secret",
    },
)
class RotationMultiUserOptions(CommonRotationUserOptions):
    def __init__(
        self,
        *,
        automatically_after: typing.Optional[_Duration_070aa057] = None,
        endpoint: typing.Optional[_IInterfaceVpcEndpoint_6081623d] = None,
        exclude_characters: typing.Optional[builtins.str] = None,
        vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
        secret: _ISecret_22fb8757,
    ) -> None:
        '''(experimental) Options to add the multi user rotation.

        :param automatically_after: (experimental) Specifies the number of days after the previous rotation before Secrets Manager triggers the next automatic rotation. Default: - 30 days
        :param endpoint: (experimental) The VPC interface endpoint to use for the Secrets Manager API. If you enable private DNS hostnames for your VPC private endpoint (the default), you don't need to specify an endpoint. The standard Secrets Manager DNS hostname the Secrets Manager CLI and SDKs use by default (https://secretsmanager..amazonaws.com) automatically resolves to your VPC endpoint. Default: https://secretsmanager..amazonaws.com
        :param exclude_characters: (experimental) Specifies characters to not include in generated passwords. Default: " %+~`#$&*()|[]{}:;<>?!'/
        :param vpc_subnets: (experimental) Where to place the rotation Lambda function. Default: - same placement as instance or cluster
        :param secret: (experimental) The secret to rotate. It must be a JSON string with the following format:: { "engine": <required: database engine>, "host": <required: instance host name>, "username": <required: username>, "password": <required: password>, "dbname": <optional: database name>, "port": <optional: if not specified, default port will be used>, "masterarn": <required: the arn of the master secret which will be used to create users/change passwords> }

        :stability: experimental
        :exampleMetadata: infused

        Example::

            # instance: rds.DatabaseInstance
            # my_imported_secret: rds.DatabaseSecret
            
            instance.add_rotation_multi_user("MyUser",
                secret=my_imported_secret
            )
        '''
        if isinstance(vpc_subnets, dict):
            vpc_subnets = _SubnetSelection_1284e62c(**vpc_subnets)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cf9bb5f36a0d33fc4df64b28384588fa77fbae6ae43809c6ac04aea972a18af5)
            check_type(argname="argument automatically_after", value=automatically_after, expected_type=type_hints["automatically_after"])
            check_type(argname="argument endpoint", value=endpoint, expected_type=type_hints["endpoint"])
            check_type(argname="argument exclude_characters", value=exclude_characters, expected_type=type_hints["exclude_characters"])
            check_type(argname="argument vpc_subnets", value=vpc_subnets, expected_type=type_hints["vpc_subnets"])
            check_type(argname="argument secret", value=secret, expected_type=type_hints["secret"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "secret": secret,
        }
        if automatically_after is not None:
            self._values["automatically_after"] = automatically_after
        if endpoint is not None:
            self._values["endpoint"] = endpoint
        if exclude_characters is not None:
            self._values["exclude_characters"] = exclude_characters
        if vpc_subnets is not None:
            self._values["vpc_subnets"] = vpc_subnets

    @builtins.property
    def automatically_after(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Specifies the number of days after the previous rotation before Secrets Manager triggers the next automatic rotation.

        :default: - 30 days

        :stability: experimental
        '''
        result = self._values.get("automatically_after")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def endpoint(self) -> typing.Optional[_IInterfaceVpcEndpoint_6081623d]:
        '''(experimental) The VPC interface endpoint to use for the Secrets Manager API.

        If you enable private DNS hostnames for your VPC private endpoint (the default), you don't
        need to specify an endpoint. The standard Secrets Manager DNS hostname the Secrets Manager
        CLI and SDKs use by default (https://secretsmanager..amazonaws.com) automatically
        resolves to your VPC endpoint.

        :default: https://secretsmanager..amazonaws.com

        :stability: experimental
        '''
        result = self._values.get("endpoint")
        return typing.cast(typing.Optional[_IInterfaceVpcEndpoint_6081623d], result)

    @builtins.property
    def exclude_characters(self) -> typing.Optional[builtins.str]:
        '''(experimental) Specifies characters to not include in generated passwords.

        :default: " %+~`#$&*()|[]{}:;<>?!'/

        :stability: experimental
        :: "\\"
        '''
        result = self._values.get("exclude_characters")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vpc_subnets(self) -> typing.Optional[_SubnetSelection_1284e62c]:
        '''(experimental) Where to place the rotation Lambda function.

        :default: - same placement as instance or cluster

        :stability: experimental
        '''
        result = self._values.get("vpc_subnets")
        return typing.cast(typing.Optional[_SubnetSelection_1284e62c], result)

    @builtins.property
    def secret(self) -> _ISecret_22fb8757:
        '''(experimental) The secret to rotate.

        It must be a JSON string with the following format::

           {
              "engine": <required: database engine>,
              "host": <required: instance host name>,
              "username": <required: username>,
              "password": <required: password>,
              "dbname": <optional: database name>,
              "port": <optional: if not specified, default port will be used>,
              "masterarn": <required: the arn of the master secret which will be used to create users/change passwords>
           }

        :stability: experimental
        '''
        result = self._values.get("secret")
        assert result is not None, "Required property 'secret' is missing"
        return typing.cast(_ISecret_22fb8757, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RotationMultiUserOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_rds.RotationSingleUserOptions",
    jsii_struct_bases=[CommonRotationUserOptions],
    name_mapping={
        "automatically_after": "automaticallyAfter",
        "endpoint": "endpoint",
        "exclude_characters": "excludeCharacters",
        "vpc_subnets": "vpcSubnets",
    },
)
class RotationSingleUserOptions(CommonRotationUserOptions):
    def __init__(
        self,
        *,
        automatically_after: typing.Optional[_Duration_070aa057] = None,
        endpoint: typing.Optional[_IInterfaceVpcEndpoint_6081623d] = None,
        exclude_characters: typing.Optional[builtins.str] = None,
        vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''(experimental) Options to add the multi user rotation.

        :param automatically_after: (experimental) Specifies the number of days after the previous rotation before Secrets Manager triggers the next automatic rotation. Default: - 30 days
        :param endpoint: (experimental) The VPC interface endpoint to use for the Secrets Manager API. If you enable private DNS hostnames for your VPC private endpoint (the default), you don't need to specify an endpoint. The standard Secrets Manager DNS hostname the Secrets Manager CLI and SDKs use by default (https://secretsmanager..amazonaws.com) automatically resolves to your VPC endpoint. Default: https://secretsmanager..amazonaws.com
        :param exclude_characters: (experimental) Specifies characters to not include in generated passwords. Default: " %+~`#$&*()|[]{}:;<>?!'/
        :param vpc_subnets: (experimental) Where to place the rotation Lambda function. Default: - same placement as instance or cluster

        :stability: experimental
        :exampleMetadata: infused

        Example::

            import monocdk as cdk
            
            # instance: rds.DatabaseInstance
            
            instance.add_rotation_single_user(
                automatically_after=cdk.Duration.days(7),  # defaults to 30 days
                exclude_characters="!@#$%^&*"
            )
        '''
        if isinstance(vpc_subnets, dict):
            vpc_subnets = _SubnetSelection_1284e62c(**vpc_subnets)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__18c6926712e62b3ea8e6707529765906d55166e52e3678b6225439b0ff7157ba)
            check_type(argname="argument automatically_after", value=automatically_after, expected_type=type_hints["automatically_after"])
            check_type(argname="argument endpoint", value=endpoint, expected_type=type_hints["endpoint"])
            check_type(argname="argument exclude_characters", value=exclude_characters, expected_type=type_hints["exclude_characters"])
            check_type(argname="argument vpc_subnets", value=vpc_subnets, expected_type=type_hints["vpc_subnets"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if automatically_after is not None:
            self._values["automatically_after"] = automatically_after
        if endpoint is not None:
            self._values["endpoint"] = endpoint
        if exclude_characters is not None:
            self._values["exclude_characters"] = exclude_characters
        if vpc_subnets is not None:
            self._values["vpc_subnets"] = vpc_subnets

    @builtins.property
    def automatically_after(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) Specifies the number of days after the previous rotation before Secrets Manager triggers the next automatic rotation.

        :default: - 30 days

        :stability: experimental
        '''
        result = self._values.get("automatically_after")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def endpoint(self) -> typing.Optional[_IInterfaceVpcEndpoint_6081623d]:
        '''(experimental) The VPC interface endpoint to use for the Secrets Manager API.

        If you enable private DNS hostnames for your VPC private endpoint (the default), you don't
        need to specify an endpoint. The standard Secrets Manager DNS hostname the Secrets Manager
        CLI and SDKs use by default (https://secretsmanager..amazonaws.com) automatically
        resolves to your VPC endpoint.

        :default: https://secretsmanager..amazonaws.com

        :stability: experimental
        '''
        result = self._values.get("endpoint")
        return typing.cast(typing.Optional[_IInterfaceVpcEndpoint_6081623d], result)

    @builtins.property
    def exclude_characters(self) -> typing.Optional[builtins.str]:
        '''(experimental) Specifies characters to not include in generated passwords.

        :default: " %+~`#$&*()|[]{}:;<>?!'/

        :stability: experimental
        :: "\\"
        '''
        result = self._values.get("exclude_characters")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vpc_subnets(self) -> typing.Optional[_SubnetSelection_1284e62c]:
        '''(experimental) Where to place the rotation Lambda function.

        :default: - same placement as instance or cluster

        :stability: experimental
        '''
        result = self._values.get("vpc_subnets")
        return typing.cast(typing.Optional[_SubnetSelection_1284e62c], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RotationSingleUserOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(IServerlessCluster)
class ServerlessCluster(
    _Resource_abff4495,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_rds.ServerlessCluster",
):
    '''(experimental) Create an Aurora Serverless Cluster.

    :stability: experimental
    :resource: AWS::RDS::DBCluster
    :exampleMetadata: infused

    Example::

        # vpc: ec2.Vpc
        
        # code: lambda.Code
        
        
        cluster = rds.ServerlessCluster(self, "AnotherCluster",
            engine=rds.DatabaseClusterEngine.AURORA_MYSQL,
            vpc=vpc,  # this parameter is optional for serverless Clusters
            enable_data_api=True
        )
        fn = lambda_.Function(self, "MyFunction",
            runtime=lambda_.Runtime.NODEJS_14_X,
            handler="index.handler",
            code=code,
            environment={
                "CLUSTER_ARN": cluster.cluster_arn,
                "SECRET_ARN": cluster.secret.secret_arn
            }
        )
        cluster.grant_data_api_access(fn)
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        engine: "IClusterEngine",
        backup_retention: typing.Optional[_Duration_070aa057] = None,
        cluster_identifier: typing.Optional[builtins.str] = None,
        credentials: typing.Optional[Credentials] = None,
        default_database_name: typing.Optional[builtins.str] = None,
        deletion_protection: typing.Optional[builtins.bool] = None,
        enable_data_api: typing.Optional[builtins.bool] = None,
        parameter_group: typing.Optional[IParameterGroup] = None,
        removal_policy: typing.Optional[_RemovalPolicy_c97e7a20] = None,
        scaling: typing.Optional[typing.Union["ServerlessScalingOptions", typing.Dict[builtins.str, typing.Any]]] = None,
        security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
        storage_encryption_key: typing.Optional[_IKey_36930160] = None,
        subnet_group: typing.Optional[ISubnetGroup] = None,
        vpc: typing.Optional[_IVpc_6d1f76c4] = None,
        vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param engine: (experimental) What kind of database to start.
        :param backup_retention: (experimental) The number of days during which automatic DB snapshots are retained. Automatic backup retention cannot be disabled on serverless clusters. Must be a value from 1 day to 35 days. Default: Duration.days(1)
        :param cluster_identifier: (experimental) An optional identifier for the cluster. Default: - A name is automatically generated.
        :param credentials: (experimental) Credentials for the administrative user. Default: - A username of 'admin' and SecretsManager-generated password
        :param default_database_name: (experimental) Name of a database which is automatically created inside the cluster. Default: - Database is not created in cluster.
        :param deletion_protection: (experimental) Indicates whether the DB cluster should have deletion protection enabled. Default: - true if removalPolicy is RETAIN, false otherwise
        :param enable_data_api: (experimental) Whether to enable the Data API. Default: false
        :param parameter_group: (experimental) Additional parameters to pass to the database engine. Default: - no parameter group.
        :param removal_policy: (experimental) The removal policy to apply when the cluster and its instances are removed from the stack or replaced during an update. Default: - RemovalPolicy.SNAPSHOT (remove the cluster and instances, but retain a snapshot of the data)
        :param scaling: (experimental) Scaling configuration of an Aurora Serverless database cluster. Default: - Serverless cluster is automatically paused after 5 minutes of being idle. minimum capacity: 2 ACU maximum capacity: 16 ACU
        :param security_groups: (experimental) Security group. Default: - a new security group is created if ``vpc`` was provided. If the ``vpc`` property was not provided, no VPC security groups will be associated with the DB cluster.
        :param storage_encryption_key: (experimental) The KMS key for storage encryption. Default: - the default master key will be used for storage encryption
        :param subnet_group: (experimental) Existing subnet group for the cluster. Default: - a new subnet group is created if ``vpc`` was provided. If the ``vpc`` property was not provided, no subnet group will be associated with the DB cluster
        :param vpc: (experimental) The VPC that this Aurora Serverless cluster has been created in. Default: - the default VPC in the account and region will be used
        :param vpc_subnets: (experimental) Where to place the instances within the VPC. If provided, the ``vpc`` property must also be specified. Default: - the VPC default strategy if not specified.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3f4fce36b4f6fc1edc581c019e8f50b95258548065ba4fd02bf095b81316fed9)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = ServerlessClusterProps(
            engine=engine,
            backup_retention=backup_retention,
            cluster_identifier=cluster_identifier,
            credentials=credentials,
            default_database_name=default_database_name,
            deletion_protection=deletion_protection,
            enable_data_api=enable_data_api,
            parameter_group=parameter_group,
            removal_policy=removal_policy,
            scaling=scaling,
            security_groups=security_groups,
            storage_encryption_key=storage_encryption_key,
            subnet_group=subnet_group,
            vpc=vpc,
            vpc_subnets=vpc_subnets,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="fromServerlessClusterAttributes")
    @builtins.classmethod
    def from_serverless_cluster_attributes(
        cls,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        cluster_identifier: builtins.str,
        cluster_endpoint_address: typing.Optional[builtins.str] = None,
        port: typing.Optional[jsii.Number] = None,
        reader_endpoint_address: typing.Optional[builtins.str] = None,
        secret: typing.Optional[_ISecret_22fb8757] = None,
        security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
    ) -> IServerlessCluster:
        '''(experimental) Import an existing DatabaseCluster from properties.

        :param scope: -
        :param id: -
        :param cluster_identifier: (experimental) Identifier for the cluster.
        :param cluster_endpoint_address: (experimental) Cluster endpoint address. Default: - no endpoint address
        :param port: (experimental) The database port. Default: - none
        :param reader_endpoint_address: (experimental) Reader endpoint address. Default: - no reader address
        :param secret: (experimental) The secret attached to the database cluster. Default: - no secret
        :param security_groups: (experimental) The security groups of the database cluster. Default: - no security groups

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0decd73735e8da13cb5c9d6431a80aface326941b2f021885f51ebe89f3e61c7)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        attrs = ServerlessClusterAttributes(
            cluster_identifier=cluster_identifier,
            cluster_endpoint_address=cluster_endpoint_address,
            port=port,
            reader_endpoint_address=reader_endpoint_address,
            secret=secret,
            security_groups=security_groups,
        )

        return typing.cast(IServerlessCluster, jsii.sinvoke(cls, "fromServerlessClusterAttributes", [scope, id, attrs]))

    @jsii.member(jsii_name="addRotationMultiUser")
    def add_rotation_multi_user(
        self,
        id: builtins.str,
        *,
        secret: _ISecret_22fb8757,
        automatically_after: typing.Optional[_Duration_070aa057] = None,
        endpoint: typing.Optional[_IInterfaceVpcEndpoint_6081623d] = None,
        exclude_characters: typing.Optional[builtins.str] = None,
        vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> _SecretRotation_e64158ad:
        '''(experimental) Adds the multi user rotation to this cluster.

        :param id: -
        :param secret: (experimental) The secret to rotate. It must be a JSON string with the following format:: { "engine": <required: database engine>, "host": <required: instance host name>, "username": <required: username>, "password": <required: password>, "dbname": <optional: database name>, "port": <optional: if not specified, default port will be used>, "masterarn": <required: the arn of the master secret which will be used to create users/change passwords> }
        :param automatically_after: (experimental) Specifies the number of days after the previous rotation before Secrets Manager triggers the next automatic rotation. Default: - 30 days
        :param endpoint: (experimental) The VPC interface endpoint to use for the Secrets Manager API. If you enable private DNS hostnames for your VPC private endpoint (the default), you don't need to specify an endpoint. The standard Secrets Manager DNS hostname the Secrets Manager CLI and SDKs use by default (https://secretsmanager..amazonaws.com) automatically resolves to your VPC endpoint. Default: https://secretsmanager..amazonaws.com
        :param exclude_characters: (experimental) Specifies characters to not include in generated passwords. Default: " %+~`#$&*()|[]{}:;<>?!'/
        :param vpc_subnets: (experimental) Where to place the rotation Lambda function. Default: - same placement as instance or cluster

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0f6cab592c9a10b7728365d1d46309aaf0a931e91942b6d4866bbef6629bc4a4)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        options = RotationMultiUserOptions(
            secret=secret,
            automatically_after=automatically_after,
            endpoint=endpoint,
            exclude_characters=exclude_characters,
            vpc_subnets=vpc_subnets,
        )

        return typing.cast(_SecretRotation_e64158ad, jsii.invoke(self, "addRotationMultiUser", [id, options]))

    @jsii.member(jsii_name="addRotationSingleUser")
    def add_rotation_single_user(
        self,
        *,
        automatically_after: typing.Optional[_Duration_070aa057] = None,
        endpoint: typing.Optional[_IInterfaceVpcEndpoint_6081623d] = None,
        exclude_characters: typing.Optional[builtins.str] = None,
        vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> _SecretRotation_e64158ad:
        '''(experimental) Adds the single user rotation of the master password to this cluster.

        :param automatically_after: (experimental) Specifies the number of days after the previous rotation before Secrets Manager triggers the next automatic rotation. Default: - 30 days
        :param endpoint: (experimental) The VPC interface endpoint to use for the Secrets Manager API. If you enable private DNS hostnames for your VPC private endpoint (the default), you don't need to specify an endpoint. The standard Secrets Manager DNS hostname the Secrets Manager CLI and SDKs use by default (https://secretsmanager..amazonaws.com) automatically resolves to your VPC endpoint. Default: https://secretsmanager..amazonaws.com
        :param exclude_characters: (experimental) Specifies characters to not include in generated passwords. Default: " %+~`#$&*()|[]{}:;<>?!'/
        :param vpc_subnets: (experimental) Where to place the rotation Lambda function. Default: - same placement as instance or cluster

        :stability: experimental
        '''
        options = RotationSingleUserOptions(
            automatically_after=automatically_after,
            endpoint=endpoint,
            exclude_characters=exclude_characters,
            vpc_subnets=vpc_subnets,
        )

        return typing.cast(_SecretRotation_e64158ad, jsii.invoke(self, "addRotationSingleUser", [options]))

    @jsii.member(jsii_name="asSecretAttachmentTarget")
    def as_secret_attachment_target(self) -> _SecretAttachmentTargetProps_ab8522eb:
        '''(experimental) Renders the secret attachment target specifications.

        :stability: experimental
        '''
        return typing.cast(_SecretAttachmentTargetProps_ab8522eb, jsii.invoke(self, "asSecretAttachmentTarget", []))

    @jsii.member(jsii_name="grantDataApiAccess")
    def grant_data_api_access(self, grantee: _IGrantable_4c5a91d1) -> _Grant_bcb5eae7:
        '''(experimental) Grant the given identity to access to the Data API, including read access to the secret attached to the cluster if present.

        :param grantee: The principal to grant access to.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9ea739497412a26bde3e636d0ec798b87c51670de46e2e00e7de359fa3899b80)
            check_type(argname="argument grantee", value=grantee, expected_type=type_hints["grantee"])
        return typing.cast(_Grant_bcb5eae7, jsii.invoke(self, "grantDataApiAccess", [grantee]))

    @builtins.property
    @jsii.member(jsii_name="clusterArn")
    def cluster_arn(self) -> builtins.str:
        '''(experimental) The ARN of the cluster.

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "clusterArn"))

    @builtins.property
    @jsii.member(jsii_name="clusterEndpoint")
    def cluster_endpoint(self) -> Endpoint:
        '''(experimental) The endpoint to use for read/write operations.

        :stability: experimental
        '''
        return typing.cast(Endpoint, jsii.get(self, "clusterEndpoint"))

    @builtins.property
    @jsii.member(jsii_name="clusterIdentifier")
    def cluster_identifier(self) -> builtins.str:
        '''(experimental) Identifier of the cluster.

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "clusterIdentifier"))

    @builtins.property
    @jsii.member(jsii_name="clusterReadEndpoint")
    def cluster_read_endpoint(self) -> Endpoint:
        '''(experimental) The endpoint to use for read/write operations.

        :stability: experimental
        '''
        return typing.cast(Endpoint, jsii.get(self, "clusterReadEndpoint"))

    @builtins.property
    @jsii.member(jsii_name="connections")
    def connections(self) -> _Connections_57ccbda9:
        '''(experimental) Access to the network connections.

        :stability: experimental
        '''
        return typing.cast(_Connections_57ccbda9, jsii.get(self, "connections"))

    @builtins.property
    @jsii.member(jsii_name="newCfnProps")
    def _new_cfn_props(self) -> CfnDBClusterProps:
        '''
        :stability: experimental
        '''
        return typing.cast(CfnDBClusterProps, jsii.get(self, "newCfnProps"))

    @builtins.property
    @jsii.member(jsii_name="securityGroups")
    def _security_groups(self) -> typing.List[_ISecurityGroup_cdbba9d3]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[_ISecurityGroup_cdbba9d3], jsii.get(self, "securityGroups"))

    @builtins.property
    @jsii.member(jsii_name="secret")
    def secret(self) -> typing.Optional[_ISecret_22fb8757]:
        '''(experimental) The secret attached to this cluster.

        :stability: experimental
        '''
        return typing.cast(typing.Optional[_ISecret_22fb8757], jsii.get(self, "secret"))

    @builtins.property
    @jsii.member(jsii_name="enableDataApi")
    def _enable_data_api(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "enableDataApi"))

    @_enable_data_api.setter
    def _enable_data_api(self, value: typing.Optional[builtins.bool]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b8239386d5e925694ab8e342dabde05b663192970c05bf5a01b50695e298a31f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableDataApi", value)


@jsii.data_type(
    jsii_type="monocdk.aws_rds.ServerlessClusterAttributes",
    jsii_struct_bases=[],
    name_mapping={
        "cluster_identifier": "clusterIdentifier",
        "cluster_endpoint_address": "clusterEndpointAddress",
        "port": "port",
        "reader_endpoint_address": "readerEndpointAddress",
        "secret": "secret",
        "security_groups": "securityGroups",
    },
)
class ServerlessClusterAttributes:
    def __init__(
        self,
        *,
        cluster_identifier: builtins.str,
        cluster_endpoint_address: typing.Optional[builtins.str] = None,
        port: typing.Optional[jsii.Number] = None,
        reader_endpoint_address: typing.Optional[builtins.str] = None,
        secret: typing.Optional[_ISecret_22fb8757] = None,
        security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
    ) -> None:
        '''(experimental) Properties that describe an existing cluster instance.

        :param cluster_identifier: (experimental) Identifier for the cluster.
        :param cluster_endpoint_address: (experimental) Cluster endpoint address. Default: - no endpoint address
        :param port: (experimental) The database port. Default: - none
        :param reader_endpoint_address: (experimental) Reader endpoint address. Default: - no reader address
        :param secret: (experimental) The secret attached to the database cluster. Default: - no secret
        :param security_groups: (experimental) The security groups of the database cluster. Default: - no security groups

        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_ec2 as ec2
            from monocdk import aws_rds as rds
            from monocdk import aws_secretsmanager as secretsmanager
            
            # secret: secretsmanager.Secret
            # security_group: ec2.SecurityGroup
            
            serverless_cluster_attributes = rds.ServerlessClusterAttributes(
                cluster_identifier="clusterIdentifier",
            
                # the properties below are optional
                cluster_endpoint_address="clusterEndpointAddress",
                port=123,
                reader_endpoint_address="readerEndpointAddress",
                secret=secret,
                security_groups=[security_group]
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__100e843e41111b2230661fc3d965672dce41eae90c755f074c806f70198af10f)
            check_type(argname="argument cluster_identifier", value=cluster_identifier, expected_type=type_hints["cluster_identifier"])
            check_type(argname="argument cluster_endpoint_address", value=cluster_endpoint_address, expected_type=type_hints["cluster_endpoint_address"])
            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
            check_type(argname="argument reader_endpoint_address", value=reader_endpoint_address, expected_type=type_hints["reader_endpoint_address"])
            check_type(argname="argument secret", value=secret, expected_type=type_hints["secret"])
            check_type(argname="argument security_groups", value=security_groups, expected_type=type_hints["security_groups"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "cluster_identifier": cluster_identifier,
        }
        if cluster_endpoint_address is not None:
            self._values["cluster_endpoint_address"] = cluster_endpoint_address
        if port is not None:
            self._values["port"] = port
        if reader_endpoint_address is not None:
            self._values["reader_endpoint_address"] = reader_endpoint_address
        if secret is not None:
            self._values["secret"] = secret
        if security_groups is not None:
            self._values["security_groups"] = security_groups

    @builtins.property
    def cluster_identifier(self) -> builtins.str:
        '''(experimental) Identifier for the cluster.

        :stability: experimental
        '''
        result = self._values.get("cluster_identifier")
        assert result is not None, "Required property 'cluster_identifier' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def cluster_endpoint_address(self) -> typing.Optional[builtins.str]:
        '''(experimental) Cluster endpoint address.

        :default: - no endpoint address

        :stability: experimental
        '''
        result = self._values.get("cluster_endpoint_address")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def port(self) -> typing.Optional[jsii.Number]:
        '''(experimental) The database port.

        :default: - none

        :stability: experimental
        '''
        result = self._values.get("port")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def reader_endpoint_address(self) -> typing.Optional[builtins.str]:
        '''(experimental) Reader endpoint address.

        :default: - no reader address

        :stability: experimental
        '''
        result = self._values.get("reader_endpoint_address")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def secret(self) -> typing.Optional[_ISecret_22fb8757]:
        '''(experimental) The secret attached to the database cluster.

        :default: - no secret

        :stability: experimental
        '''
        result = self._values.get("secret")
        return typing.cast(typing.Optional[_ISecret_22fb8757], result)

    @builtins.property
    def security_groups(self) -> typing.Optional[typing.List[_ISecurityGroup_cdbba9d3]]:
        '''(experimental) The security groups of the database cluster.

        :default: - no security groups

        :stability: experimental
        '''
        result = self._values.get("security_groups")
        return typing.cast(typing.Optional[typing.List[_ISecurityGroup_cdbba9d3]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ServerlessClusterAttributes(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(IServerlessCluster)
class ServerlessClusterFromSnapshot(
    _Resource_abff4495,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_rds.ServerlessClusterFromSnapshot",
):
    '''(experimental) A Aurora Serverless Cluster restored from a snapshot.

    :stability: experimental
    :resource: AWS::RDS::DBCluster
    :exampleMetadata: infused

    Example::

        # vpc: ec2.Vpc
        
        rds.ServerlessClusterFromSnapshot(self, "Cluster",
            engine=rds.DatabaseClusterEngine.AURORA_MYSQL,
            vpc=vpc,
            snapshot_identifier="mySnapshot"
        )
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        engine: "IClusterEngine",
        snapshot_identifier: builtins.str,
        backup_retention: typing.Optional[_Duration_070aa057] = None,
        cluster_identifier: typing.Optional[builtins.str] = None,
        credentials: typing.Optional["SnapshotCredentials"] = None,
        default_database_name: typing.Optional[builtins.str] = None,
        deletion_protection: typing.Optional[builtins.bool] = None,
        enable_data_api: typing.Optional[builtins.bool] = None,
        parameter_group: typing.Optional[IParameterGroup] = None,
        removal_policy: typing.Optional[_RemovalPolicy_c97e7a20] = None,
        scaling: typing.Optional[typing.Union["ServerlessScalingOptions", typing.Dict[builtins.str, typing.Any]]] = None,
        security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
        subnet_group: typing.Optional[ISubnetGroup] = None,
        vpc: typing.Optional[_IVpc_6d1f76c4] = None,
        vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param engine: (experimental) What kind of database to start.
        :param snapshot_identifier: (experimental) The identifier for the DB instance snapshot or DB cluster snapshot to restore from. You can use either the name or the Amazon Resource Name (ARN) to specify a DB cluster snapshot. However, you can use only the ARN to specify a DB instance snapshot.
        :param backup_retention: (experimental) The number of days during which automatic DB snapshots are retained. Automatic backup retention cannot be disabled on serverless clusters. Must be a value from 1 day to 35 days. Default: Duration.days(1)
        :param cluster_identifier: (experimental) An optional identifier for the cluster. Default: - A name is automatically generated.
        :param credentials: (experimental) Master user credentials. Note - It is not possible to change the master username for a snapshot; however, it is possible to provide (or generate) a new password. Default: - The existing username and password from the snapshot will be used.
        :param default_database_name: (experimental) Name of a database which is automatically created inside the cluster. Default: - Database is not created in cluster.
        :param deletion_protection: (experimental) Indicates whether the DB cluster should have deletion protection enabled. Default: - true if removalPolicy is RETAIN, false otherwise
        :param enable_data_api: (experimental) Whether to enable the Data API. Default: false
        :param parameter_group: (experimental) Additional parameters to pass to the database engine. Default: - no parameter group.
        :param removal_policy: (experimental) The removal policy to apply when the cluster and its instances are removed from the stack or replaced during an update. Default: - RemovalPolicy.SNAPSHOT (remove the cluster and instances, but retain a snapshot of the data)
        :param scaling: (experimental) Scaling configuration of an Aurora Serverless database cluster. Default: - Serverless cluster is automatically paused after 5 minutes of being idle. minimum capacity: 2 ACU maximum capacity: 16 ACU
        :param security_groups: (experimental) Security group. Default: - a new security group is created if ``vpc`` was provided. If the ``vpc`` property was not provided, no VPC security groups will be associated with the DB cluster.
        :param subnet_group: (experimental) Existing subnet group for the cluster. Default: - a new subnet group is created if ``vpc`` was provided. If the ``vpc`` property was not provided, no subnet group will be associated with the DB cluster
        :param vpc: (experimental) The VPC that this Aurora Serverless cluster has been created in. Default: - the default VPC in the account and region will be used
        :param vpc_subnets: (experimental) Where to place the instances within the VPC. If provided, the ``vpc`` property must also be specified. Default: - the VPC default strategy if not specified.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__df256bf1309523cdac6667b4390d29bedb2764fe28cad8d2618c5b660f1cb96e)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = ServerlessClusterFromSnapshotProps(
            engine=engine,
            snapshot_identifier=snapshot_identifier,
            backup_retention=backup_retention,
            cluster_identifier=cluster_identifier,
            credentials=credentials,
            default_database_name=default_database_name,
            deletion_protection=deletion_protection,
            enable_data_api=enable_data_api,
            parameter_group=parameter_group,
            removal_policy=removal_policy,
            scaling=scaling,
            security_groups=security_groups,
            subnet_group=subnet_group,
            vpc=vpc,
            vpc_subnets=vpc_subnets,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="asSecretAttachmentTarget")
    def as_secret_attachment_target(self) -> _SecretAttachmentTargetProps_ab8522eb:
        '''(experimental) Renders the secret attachment target specifications.

        :stability: experimental
        '''
        return typing.cast(_SecretAttachmentTargetProps_ab8522eb, jsii.invoke(self, "asSecretAttachmentTarget", []))

    @jsii.member(jsii_name="grantDataApiAccess")
    def grant_data_api_access(self, grantee: _IGrantable_4c5a91d1) -> _Grant_bcb5eae7:
        '''(experimental) Grant the given identity to access to the Data API, including read access to the secret attached to the cluster if present.

        :param grantee: The principal to grant access to.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fc541f3d3cbe5927a7d6f9e6b8215fd14a7ed4487ec91821171ef2d811e50843)
            check_type(argname="argument grantee", value=grantee, expected_type=type_hints["grantee"])
        return typing.cast(_Grant_bcb5eae7, jsii.invoke(self, "grantDataApiAccess", [grantee]))

    @builtins.property
    @jsii.member(jsii_name="clusterArn")
    def cluster_arn(self) -> builtins.str:
        '''(experimental) The ARN of the cluster.

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "clusterArn"))

    @builtins.property
    @jsii.member(jsii_name="clusterEndpoint")
    def cluster_endpoint(self) -> Endpoint:
        '''(experimental) The endpoint to use for read/write operations.

        :stability: experimental
        '''
        return typing.cast(Endpoint, jsii.get(self, "clusterEndpoint"))

    @builtins.property
    @jsii.member(jsii_name="clusterIdentifier")
    def cluster_identifier(self) -> builtins.str:
        '''(experimental) Identifier of the cluster.

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "clusterIdentifier"))

    @builtins.property
    @jsii.member(jsii_name="clusterReadEndpoint")
    def cluster_read_endpoint(self) -> Endpoint:
        '''(experimental) The endpoint to use for read/write operations.

        :stability: experimental
        '''
        return typing.cast(Endpoint, jsii.get(self, "clusterReadEndpoint"))

    @builtins.property
    @jsii.member(jsii_name="connections")
    def connections(self) -> _Connections_57ccbda9:
        '''(experimental) Access to the network connections.

        :stability: experimental
        '''
        return typing.cast(_Connections_57ccbda9, jsii.get(self, "connections"))

    @builtins.property
    @jsii.member(jsii_name="newCfnProps")
    def _new_cfn_props(self) -> CfnDBClusterProps:
        '''
        :stability: experimental
        '''
        return typing.cast(CfnDBClusterProps, jsii.get(self, "newCfnProps"))

    @builtins.property
    @jsii.member(jsii_name="securityGroups")
    def _security_groups(self) -> typing.List[_ISecurityGroup_cdbba9d3]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[_ISecurityGroup_cdbba9d3], jsii.get(self, "securityGroups"))

    @builtins.property
    @jsii.member(jsii_name="secret")
    def secret(self) -> typing.Optional[_ISecret_22fb8757]:
        '''(experimental) The secret attached to this cluster.

        :stability: experimental
        '''
        return typing.cast(typing.Optional[_ISecret_22fb8757], jsii.get(self, "secret"))

    @builtins.property
    @jsii.member(jsii_name="enableDataApi")
    def _enable_data_api(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "enableDataApi"))

    @_enable_data_api.setter
    def _enable_data_api(self, value: typing.Optional[builtins.bool]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__75063d9057fdf010bc0800cb67560572592b93e9c7a1a3942f93bbb97f209f85)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableDataApi", value)


@jsii.data_type(
    jsii_type="monocdk.aws_rds.ServerlessClusterFromSnapshotProps",
    jsii_struct_bases=[],
    name_mapping={
        "engine": "engine",
        "snapshot_identifier": "snapshotIdentifier",
        "backup_retention": "backupRetention",
        "cluster_identifier": "clusterIdentifier",
        "credentials": "credentials",
        "default_database_name": "defaultDatabaseName",
        "deletion_protection": "deletionProtection",
        "enable_data_api": "enableDataApi",
        "parameter_group": "parameterGroup",
        "removal_policy": "removalPolicy",
        "scaling": "scaling",
        "security_groups": "securityGroups",
        "subnet_group": "subnetGroup",
        "vpc": "vpc",
        "vpc_subnets": "vpcSubnets",
    },
)
class ServerlessClusterFromSnapshotProps:
    def __init__(
        self,
        *,
        engine: "IClusterEngine",
        snapshot_identifier: builtins.str,
        backup_retention: typing.Optional[_Duration_070aa057] = None,
        cluster_identifier: typing.Optional[builtins.str] = None,
        credentials: typing.Optional["SnapshotCredentials"] = None,
        default_database_name: typing.Optional[builtins.str] = None,
        deletion_protection: typing.Optional[builtins.bool] = None,
        enable_data_api: typing.Optional[builtins.bool] = None,
        parameter_group: typing.Optional[IParameterGroup] = None,
        removal_policy: typing.Optional[_RemovalPolicy_c97e7a20] = None,
        scaling: typing.Optional[typing.Union["ServerlessScalingOptions", typing.Dict[builtins.str, typing.Any]]] = None,
        security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
        subnet_group: typing.Optional[ISubnetGroup] = None,
        vpc: typing.Optional[_IVpc_6d1f76c4] = None,
        vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''(experimental) Properties for ``ServerlessClusterFromSnapshot``.

        :param engine: (experimental) What kind of database to start.
        :param snapshot_identifier: (experimental) The identifier for the DB instance snapshot or DB cluster snapshot to restore from. You can use either the name or the Amazon Resource Name (ARN) to specify a DB cluster snapshot. However, you can use only the ARN to specify a DB instance snapshot.
        :param backup_retention: (experimental) The number of days during which automatic DB snapshots are retained. Automatic backup retention cannot be disabled on serverless clusters. Must be a value from 1 day to 35 days. Default: Duration.days(1)
        :param cluster_identifier: (experimental) An optional identifier for the cluster. Default: - A name is automatically generated.
        :param credentials: (experimental) Master user credentials. Note - It is not possible to change the master username for a snapshot; however, it is possible to provide (or generate) a new password. Default: - The existing username and password from the snapshot will be used.
        :param default_database_name: (experimental) Name of a database which is automatically created inside the cluster. Default: - Database is not created in cluster.
        :param deletion_protection: (experimental) Indicates whether the DB cluster should have deletion protection enabled. Default: - true if removalPolicy is RETAIN, false otherwise
        :param enable_data_api: (experimental) Whether to enable the Data API. Default: false
        :param parameter_group: (experimental) Additional parameters to pass to the database engine. Default: - no parameter group.
        :param removal_policy: (experimental) The removal policy to apply when the cluster and its instances are removed from the stack or replaced during an update. Default: - RemovalPolicy.SNAPSHOT (remove the cluster and instances, but retain a snapshot of the data)
        :param scaling: (experimental) Scaling configuration of an Aurora Serverless database cluster. Default: - Serverless cluster is automatically paused after 5 minutes of being idle. minimum capacity: 2 ACU maximum capacity: 16 ACU
        :param security_groups: (experimental) Security group. Default: - a new security group is created if ``vpc`` was provided. If the ``vpc`` property was not provided, no VPC security groups will be associated with the DB cluster.
        :param subnet_group: (experimental) Existing subnet group for the cluster. Default: - a new subnet group is created if ``vpc`` was provided. If the ``vpc`` property was not provided, no subnet group will be associated with the DB cluster
        :param vpc: (experimental) The VPC that this Aurora Serverless cluster has been created in. Default: - the default VPC in the account and region will be used
        :param vpc_subnets: (experimental) Where to place the instances within the VPC. If provided, the ``vpc`` property must also be specified. Default: - the VPC default strategy if not specified.

        :stability: experimental
        :exampleMetadata: infused

        Example::

            # vpc: ec2.Vpc
            
            rds.ServerlessClusterFromSnapshot(self, "Cluster",
                engine=rds.DatabaseClusterEngine.AURORA_MYSQL,
                vpc=vpc,
                snapshot_identifier="mySnapshot"
            )
        '''
        if isinstance(scaling, dict):
            scaling = ServerlessScalingOptions(**scaling)
        if isinstance(vpc_subnets, dict):
            vpc_subnets = _SubnetSelection_1284e62c(**vpc_subnets)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ae09b1a081dc5c4d4a0f74848ba7c6013aa92ca431e41e503309eefa2f4cff57)
            check_type(argname="argument engine", value=engine, expected_type=type_hints["engine"])
            check_type(argname="argument snapshot_identifier", value=snapshot_identifier, expected_type=type_hints["snapshot_identifier"])
            check_type(argname="argument backup_retention", value=backup_retention, expected_type=type_hints["backup_retention"])
            check_type(argname="argument cluster_identifier", value=cluster_identifier, expected_type=type_hints["cluster_identifier"])
            check_type(argname="argument credentials", value=credentials, expected_type=type_hints["credentials"])
            check_type(argname="argument default_database_name", value=default_database_name, expected_type=type_hints["default_database_name"])
            check_type(argname="argument deletion_protection", value=deletion_protection, expected_type=type_hints["deletion_protection"])
            check_type(argname="argument enable_data_api", value=enable_data_api, expected_type=type_hints["enable_data_api"])
            check_type(argname="argument parameter_group", value=parameter_group, expected_type=type_hints["parameter_group"])
            check_type(argname="argument removal_policy", value=removal_policy, expected_type=type_hints["removal_policy"])
            check_type(argname="argument scaling", value=scaling, expected_type=type_hints["scaling"])
            check_type(argname="argument security_groups", value=security_groups, expected_type=type_hints["security_groups"])
            check_type(argname="argument subnet_group", value=subnet_group, expected_type=type_hints["subnet_group"])
            check_type(argname="argument vpc", value=vpc, expected_type=type_hints["vpc"])
            check_type(argname="argument vpc_subnets", value=vpc_subnets, expected_type=type_hints["vpc_subnets"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "engine": engine,
            "snapshot_identifier": snapshot_identifier,
        }
        if backup_retention is not None:
            self._values["backup_retention"] = backup_retention
        if cluster_identifier is not None:
            self._values["cluster_identifier"] = cluster_identifier
        if credentials is not None:
            self._values["credentials"] = credentials
        if default_database_name is not None:
            self._values["default_database_name"] = default_database_name
        if deletion_protection is not None:
            self._values["deletion_protection"] = deletion_protection
        if enable_data_api is not None:
            self._values["enable_data_api"] = enable_data_api
        if parameter_group is not None:
            self._values["parameter_group"] = parameter_group
        if removal_policy is not None:
            self._values["removal_policy"] = removal_policy
        if scaling is not None:
            self._values["scaling"] = scaling
        if security_groups is not None:
            self._values["security_groups"] = security_groups
        if subnet_group is not None:
            self._values["subnet_group"] = subnet_group
        if vpc is not None:
            self._values["vpc"] = vpc
        if vpc_subnets is not None:
            self._values["vpc_subnets"] = vpc_subnets

    @builtins.property
    def engine(self) -> "IClusterEngine":
        '''(experimental) What kind of database to start.

        :stability: experimental
        '''
        result = self._values.get("engine")
        assert result is not None, "Required property 'engine' is missing"
        return typing.cast("IClusterEngine", result)

    @builtins.property
    def snapshot_identifier(self) -> builtins.str:
        '''(experimental) The identifier for the DB instance snapshot or DB cluster snapshot to restore from.

        You can use either the name or the Amazon Resource Name (ARN) to specify a DB cluster snapshot.
        However, you can use only the ARN to specify a DB instance snapshot.

        :stability: experimental
        '''
        result = self._values.get("snapshot_identifier")
        assert result is not None, "Required property 'snapshot_identifier' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def backup_retention(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) The number of days during which automatic DB snapshots are retained.

        Automatic backup retention cannot be disabled on serverless clusters.
        Must be a value from 1 day to 35 days.

        :default: Duration.days(1)

        :stability: experimental
        '''
        result = self._values.get("backup_retention")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def cluster_identifier(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional identifier for the cluster.

        :default: - A name is automatically generated.

        :stability: experimental
        '''
        result = self._values.get("cluster_identifier")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def credentials(self) -> typing.Optional["SnapshotCredentials"]:
        '''(experimental) Master user credentials.

        Note - It is not possible to change the master username for a snapshot;
        however, it is possible to provide (or generate) a new password.

        :default: - The existing username and password from the snapshot will be used.

        :stability: experimental
        '''
        result = self._values.get("credentials")
        return typing.cast(typing.Optional["SnapshotCredentials"], result)

    @builtins.property
    def default_database_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Name of a database which is automatically created inside the cluster.

        :default: - Database is not created in cluster.

        :stability: experimental
        '''
        result = self._values.get("default_database_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def deletion_protection(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the DB cluster should have deletion protection enabled.

        :default: - true if removalPolicy is RETAIN, false otherwise

        :stability: experimental
        '''
        result = self._values.get("deletion_protection")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_data_api(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Whether to enable the Data API.

        :default: false

        :see: https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/data-api.html
        :stability: experimental
        '''
        result = self._values.get("enable_data_api")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def parameter_group(self) -> typing.Optional[IParameterGroup]:
        '''(experimental) Additional parameters to pass to the database engine.

        :default: - no parameter group.

        :stability: experimental
        '''
        result = self._values.get("parameter_group")
        return typing.cast(typing.Optional[IParameterGroup], result)

    @builtins.property
    def removal_policy(self) -> typing.Optional[_RemovalPolicy_c97e7a20]:
        '''(experimental) The removal policy to apply when the cluster and its instances are removed from the stack or replaced during an update.

        :default: - RemovalPolicy.SNAPSHOT (remove the cluster and instances, but retain a snapshot of the data)

        :stability: experimental
        '''
        result = self._values.get("removal_policy")
        return typing.cast(typing.Optional[_RemovalPolicy_c97e7a20], result)

    @builtins.property
    def scaling(self) -> typing.Optional["ServerlessScalingOptions"]:
        '''(experimental) Scaling configuration of an Aurora Serverless database cluster.

        :default:

        - Serverless cluster is automatically paused after 5 minutes of being idle.
        minimum capacity: 2 ACU
        maximum capacity: 16 ACU

        :stability: experimental
        '''
        result = self._values.get("scaling")
        return typing.cast(typing.Optional["ServerlessScalingOptions"], result)

    @builtins.property
    def security_groups(self) -> typing.Optional[typing.List[_ISecurityGroup_cdbba9d3]]:
        '''(experimental) Security group.

        :default:

        - a new security group is created if ``vpc`` was provided.
        If the ``vpc`` property was not provided, no VPC security groups will be associated with the DB cluster.

        :stability: experimental
        '''
        result = self._values.get("security_groups")
        return typing.cast(typing.Optional[typing.List[_ISecurityGroup_cdbba9d3]], result)

    @builtins.property
    def subnet_group(self) -> typing.Optional[ISubnetGroup]:
        '''(experimental) Existing subnet group for the cluster.

        :default:

        - a new subnet group is created if ``vpc`` was provided.
        If the ``vpc`` property was not provided, no subnet group will be associated with the DB cluster

        :stability: experimental
        '''
        result = self._values.get("subnet_group")
        return typing.cast(typing.Optional[ISubnetGroup], result)

    @builtins.property
    def vpc(self) -> typing.Optional[_IVpc_6d1f76c4]:
        '''(experimental) The VPC that this Aurora Serverless cluster has been created in.

        :default: - the default VPC in the account and region will be used

        :stability: experimental
        '''
        result = self._values.get("vpc")
        return typing.cast(typing.Optional[_IVpc_6d1f76c4], result)

    @builtins.property
    def vpc_subnets(self) -> typing.Optional[_SubnetSelection_1284e62c]:
        '''(experimental) Where to place the instances within the VPC.

        If provided, the ``vpc`` property must also be specified.

        :default: - the VPC default strategy if not specified.

        :stability: experimental
        '''
        result = self._values.get("vpc_subnets")
        return typing.cast(typing.Optional[_SubnetSelection_1284e62c], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ServerlessClusterFromSnapshotProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_rds.ServerlessClusterProps",
    jsii_struct_bases=[],
    name_mapping={
        "engine": "engine",
        "backup_retention": "backupRetention",
        "cluster_identifier": "clusterIdentifier",
        "credentials": "credentials",
        "default_database_name": "defaultDatabaseName",
        "deletion_protection": "deletionProtection",
        "enable_data_api": "enableDataApi",
        "parameter_group": "parameterGroup",
        "removal_policy": "removalPolicy",
        "scaling": "scaling",
        "security_groups": "securityGroups",
        "storage_encryption_key": "storageEncryptionKey",
        "subnet_group": "subnetGroup",
        "vpc": "vpc",
        "vpc_subnets": "vpcSubnets",
    },
)
class ServerlessClusterProps:
    def __init__(
        self,
        *,
        engine: "IClusterEngine",
        backup_retention: typing.Optional[_Duration_070aa057] = None,
        cluster_identifier: typing.Optional[builtins.str] = None,
        credentials: typing.Optional[Credentials] = None,
        default_database_name: typing.Optional[builtins.str] = None,
        deletion_protection: typing.Optional[builtins.bool] = None,
        enable_data_api: typing.Optional[builtins.bool] = None,
        parameter_group: typing.Optional[IParameterGroup] = None,
        removal_policy: typing.Optional[_RemovalPolicy_c97e7a20] = None,
        scaling: typing.Optional[typing.Union["ServerlessScalingOptions", typing.Dict[builtins.str, typing.Any]]] = None,
        security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
        storage_encryption_key: typing.Optional[_IKey_36930160] = None,
        subnet_group: typing.Optional[ISubnetGroup] = None,
        vpc: typing.Optional[_IVpc_6d1f76c4] = None,
        vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''(experimental) Properties for a new Aurora Serverless Cluster.

        :param engine: (experimental) What kind of database to start.
        :param backup_retention: (experimental) The number of days during which automatic DB snapshots are retained. Automatic backup retention cannot be disabled on serverless clusters. Must be a value from 1 day to 35 days. Default: Duration.days(1)
        :param cluster_identifier: (experimental) An optional identifier for the cluster. Default: - A name is automatically generated.
        :param credentials: (experimental) Credentials for the administrative user. Default: - A username of 'admin' and SecretsManager-generated password
        :param default_database_name: (experimental) Name of a database which is automatically created inside the cluster. Default: - Database is not created in cluster.
        :param deletion_protection: (experimental) Indicates whether the DB cluster should have deletion protection enabled. Default: - true if removalPolicy is RETAIN, false otherwise
        :param enable_data_api: (experimental) Whether to enable the Data API. Default: false
        :param parameter_group: (experimental) Additional parameters to pass to the database engine. Default: - no parameter group.
        :param removal_policy: (experimental) The removal policy to apply when the cluster and its instances are removed from the stack or replaced during an update. Default: - RemovalPolicy.SNAPSHOT (remove the cluster and instances, but retain a snapshot of the data)
        :param scaling: (experimental) Scaling configuration of an Aurora Serverless database cluster. Default: - Serverless cluster is automatically paused after 5 minutes of being idle. minimum capacity: 2 ACU maximum capacity: 16 ACU
        :param security_groups: (experimental) Security group. Default: - a new security group is created if ``vpc`` was provided. If the ``vpc`` property was not provided, no VPC security groups will be associated with the DB cluster.
        :param storage_encryption_key: (experimental) The KMS key for storage encryption. Default: - the default master key will be used for storage encryption
        :param subnet_group: (experimental) Existing subnet group for the cluster. Default: - a new subnet group is created if ``vpc`` was provided. If the ``vpc`` property was not provided, no subnet group will be associated with the DB cluster
        :param vpc: (experimental) The VPC that this Aurora Serverless cluster has been created in. Default: - the default VPC in the account and region will be used
        :param vpc_subnets: (experimental) Where to place the instances within the VPC. If provided, the ``vpc`` property must also be specified. Default: - the VPC default strategy if not specified.

        :stability: experimental
        :exampleMetadata: infused

        Example::

            # vpc: ec2.Vpc
            
            # code: lambda.Code
            
            
            cluster = rds.ServerlessCluster(self, "AnotherCluster",
                engine=rds.DatabaseClusterEngine.AURORA_MYSQL,
                vpc=vpc,  # this parameter is optional for serverless Clusters
                enable_data_api=True
            )
            fn = lambda_.Function(self, "MyFunction",
                runtime=lambda_.Runtime.NODEJS_14_X,
                handler="index.handler",
                code=code,
                environment={
                    "CLUSTER_ARN": cluster.cluster_arn,
                    "SECRET_ARN": cluster.secret.secret_arn
                }
            )
            cluster.grant_data_api_access(fn)
        '''
        if isinstance(scaling, dict):
            scaling = ServerlessScalingOptions(**scaling)
        if isinstance(vpc_subnets, dict):
            vpc_subnets = _SubnetSelection_1284e62c(**vpc_subnets)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2d0a4715cdde0ac9feac72f55495577f3f41f4d550e7739595836f80e150e1f0)
            check_type(argname="argument engine", value=engine, expected_type=type_hints["engine"])
            check_type(argname="argument backup_retention", value=backup_retention, expected_type=type_hints["backup_retention"])
            check_type(argname="argument cluster_identifier", value=cluster_identifier, expected_type=type_hints["cluster_identifier"])
            check_type(argname="argument credentials", value=credentials, expected_type=type_hints["credentials"])
            check_type(argname="argument default_database_name", value=default_database_name, expected_type=type_hints["default_database_name"])
            check_type(argname="argument deletion_protection", value=deletion_protection, expected_type=type_hints["deletion_protection"])
            check_type(argname="argument enable_data_api", value=enable_data_api, expected_type=type_hints["enable_data_api"])
            check_type(argname="argument parameter_group", value=parameter_group, expected_type=type_hints["parameter_group"])
            check_type(argname="argument removal_policy", value=removal_policy, expected_type=type_hints["removal_policy"])
            check_type(argname="argument scaling", value=scaling, expected_type=type_hints["scaling"])
            check_type(argname="argument security_groups", value=security_groups, expected_type=type_hints["security_groups"])
            check_type(argname="argument storage_encryption_key", value=storage_encryption_key, expected_type=type_hints["storage_encryption_key"])
            check_type(argname="argument subnet_group", value=subnet_group, expected_type=type_hints["subnet_group"])
            check_type(argname="argument vpc", value=vpc, expected_type=type_hints["vpc"])
            check_type(argname="argument vpc_subnets", value=vpc_subnets, expected_type=type_hints["vpc_subnets"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "engine": engine,
        }
        if backup_retention is not None:
            self._values["backup_retention"] = backup_retention
        if cluster_identifier is not None:
            self._values["cluster_identifier"] = cluster_identifier
        if credentials is not None:
            self._values["credentials"] = credentials
        if default_database_name is not None:
            self._values["default_database_name"] = default_database_name
        if deletion_protection is not None:
            self._values["deletion_protection"] = deletion_protection
        if enable_data_api is not None:
            self._values["enable_data_api"] = enable_data_api
        if parameter_group is not None:
            self._values["parameter_group"] = parameter_group
        if removal_policy is not None:
            self._values["removal_policy"] = removal_policy
        if scaling is not None:
            self._values["scaling"] = scaling
        if security_groups is not None:
            self._values["security_groups"] = security_groups
        if storage_encryption_key is not None:
            self._values["storage_encryption_key"] = storage_encryption_key
        if subnet_group is not None:
            self._values["subnet_group"] = subnet_group
        if vpc is not None:
            self._values["vpc"] = vpc
        if vpc_subnets is not None:
            self._values["vpc_subnets"] = vpc_subnets

    @builtins.property
    def engine(self) -> "IClusterEngine":
        '''(experimental) What kind of database to start.

        :stability: experimental
        '''
        result = self._values.get("engine")
        assert result is not None, "Required property 'engine' is missing"
        return typing.cast("IClusterEngine", result)

    @builtins.property
    def backup_retention(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) The number of days during which automatic DB snapshots are retained.

        Automatic backup retention cannot be disabled on serverless clusters.
        Must be a value from 1 day to 35 days.

        :default: Duration.days(1)

        :stability: experimental
        '''
        result = self._values.get("backup_retention")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def cluster_identifier(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional identifier for the cluster.

        :default: - A name is automatically generated.

        :stability: experimental
        '''
        result = self._values.get("cluster_identifier")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def credentials(self) -> typing.Optional[Credentials]:
        '''(experimental) Credentials for the administrative user.

        :default: - A username of 'admin' and SecretsManager-generated password

        :stability: experimental
        '''
        result = self._values.get("credentials")
        return typing.cast(typing.Optional[Credentials], result)

    @builtins.property
    def default_database_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Name of a database which is automatically created inside the cluster.

        :default: - Database is not created in cluster.

        :stability: experimental
        '''
        result = self._values.get("default_database_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def deletion_protection(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the DB cluster should have deletion protection enabled.

        :default: - true if removalPolicy is RETAIN, false otherwise

        :stability: experimental
        '''
        result = self._values.get("deletion_protection")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_data_api(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Whether to enable the Data API.

        :default: false

        :see: https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/data-api.html
        :stability: experimental
        '''
        result = self._values.get("enable_data_api")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def parameter_group(self) -> typing.Optional[IParameterGroup]:
        '''(experimental) Additional parameters to pass to the database engine.

        :default: - no parameter group.

        :stability: experimental
        '''
        result = self._values.get("parameter_group")
        return typing.cast(typing.Optional[IParameterGroup], result)

    @builtins.property
    def removal_policy(self) -> typing.Optional[_RemovalPolicy_c97e7a20]:
        '''(experimental) The removal policy to apply when the cluster and its instances are removed from the stack or replaced during an update.

        :default: - RemovalPolicy.SNAPSHOT (remove the cluster and instances, but retain a snapshot of the data)

        :stability: experimental
        '''
        result = self._values.get("removal_policy")
        return typing.cast(typing.Optional[_RemovalPolicy_c97e7a20], result)

    @builtins.property
    def scaling(self) -> typing.Optional["ServerlessScalingOptions"]:
        '''(experimental) Scaling configuration of an Aurora Serverless database cluster.

        :default:

        - Serverless cluster is automatically paused after 5 minutes of being idle.
        minimum capacity: 2 ACU
        maximum capacity: 16 ACU

        :stability: experimental
        '''
        result = self._values.get("scaling")
        return typing.cast(typing.Optional["ServerlessScalingOptions"], result)

    @builtins.property
    def security_groups(self) -> typing.Optional[typing.List[_ISecurityGroup_cdbba9d3]]:
        '''(experimental) Security group.

        :default:

        - a new security group is created if ``vpc`` was provided.
        If the ``vpc`` property was not provided, no VPC security groups will be associated with the DB cluster.

        :stability: experimental
        '''
        result = self._values.get("security_groups")
        return typing.cast(typing.Optional[typing.List[_ISecurityGroup_cdbba9d3]], result)

    @builtins.property
    def storage_encryption_key(self) -> typing.Optional[_IKey_36930160]:
        '''(experimental) The KMS key for storage encryption.

        :default: - the default master key will be used for storage encryption

        :stability: experimental
        '''
        result = self._values.get("storage_encryption_key")
        return typing.cast(typing.Optional[_IKey_36930160], result)

    @builtins.property
    def subnet_group(self) -> typing.Optional[ISubnetGroup]:
        '''(experimental) Existing subnet group for the cluster.

        :default:

        - a new subnet group is created if ``vpc`` was provided.
        If the ``vpc`` property was not provided, no subnet group will be associated with the DB cluster

        :stability: experimental
        '''
        result = self._values.get("subnet_group")
        return typing.cast(typing.Optional[ISubnetGroup], result)

    @builtins.property
    def vpc(self) -> typing.Optional[_IVpc_6d1f76c4]:
        '''(experimental) The VPC that this Aurora Serverless cluster has been created in.

        :default: - the default VPC in the account and region will be used

        :stability: experimental
        '''
        result = self._values.get("vpc")
        return typing.cast(typing.Optional[_IVpc_6d1f76c4], result)

    @builtins.property
    def vpc_subnets(self) -> typing.Optional[_SubnetSelection_1284e62c]:
        '''(experimental) Where to place the instances within the VPC.

        If provided, the ``vpc`` property must also be specified.

        :default: - the VPC default strategy if not specified.

        :stability: experimental
        '''
        result = self._values.get("vpc_subnets")
        return typing.cast(typing.Optional[_SubnetSelection_1284e62c], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ServerlessClusterProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_rds.ServerlessScalingOptions",
    jsii_struct_bases=[],
    name_mapping={
        "auto_pause": "autoPause",
        "max_capacity": "maxCapacity",
        "min_capacity": "minCapacity",
    },
)
class ServerlessScalingOptions:
    def __init__(
        self,
        *,
        auto_pause: typing.Optional[_Duration_070aa057] = None,
        max_capacity: typing.Optional[AuroraCapacityUnit] = None,
        min_capacity: typing.Optional[AuroraCapacityUnit] = None,
    ) -> None:
        '''(experimental) Options for configuring scaling on an Aurora Serverless cluster.

        :param auto_pause: (experimental) The time before an Aurora Serverless database cluster is paused. A database cluster can be paused only when it is idle (it has no connections). Auto pause time must be between 5 minutes and 1 day. If a DB cluster is paused for more than seven days, the DB cluster might be backed up with a snapshot. In this case, the DB cluster is restored when there is a request to connect to it. Set to 0 to disable Default: - automatic pause enabled after 5 minutes
        :param max_capacity: (experimental) The maximum capacity for an Aurora Serverless database cluster. Default: - determined by Aurora based on database engine
        :param min_capacity: (experimental) The minimum capacity for an Aurora Serverless database cluster. Default: - determined by Aurora based on database engine

        :stability: experimental
        :exampleMetadata: infused

        Example::

            # vpc: ec2.Vpc
            
            
            cluster = rds.ServerlessCluster(self, "AnotherCluster",
                engine=rds.DatabaseClusterEngine.AURORA_POSTGRESQL,
                parameter_group=rds.ParameterGroup.from_parameter_group_name(self, "ParameterGroup", "default.aurora-postgresql10"),
                vpc=vpc,
                scaling=ec2.aws_rds.ServerlessScalingOptions(
                    auto_pause=Duration.minutes(10),  # default is to pause after 5 minutes of idle time
                    min_capacity=rds.AuroraCapacityUnit.ACU_8,  # default is 2 Aurora capacity units (ACUs)
                    max_capacity=rds.AuroraCapacityUnit.ACU_32
                )
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6f3daa768677410b74d362a928ed30907050bd9490b5d2e4c2c15b00b64c80c9)
            check_type(argname="argument auto_pause", value=auto_pause, expected_type=type_hints["auto_pause"])
            check_type(argname="argument max_capacity", value=max_capacity, expected_type=type_hints["max_capacity"])
            check_type(argname="argument min_capacity", value=min_capacity, expected_type=type_hints["min_capacity"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if auto_pause is not None:
            self._values["auto_pause"] = auto_pause
        if max_capacity is not None:
            self._values["max_capacity"] = max_capacity
        if min_capacity is not None:
            self._values["min_capacity"] = min_capacity

    @builtins.property
    def auto_pause(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) The time before an Aurora Serverless database cluster is paused.

        A database cluster can be paused only when it is idle (it has no connections).
        Auto pause time must be between 5 minutes and 1 day.

        If a DB cluster is paused for more than seven days, the DB cluster might be
        backed up with a snapshot. In this case, the DB cluster is restored when there
        is a request to connect to it.

        Set to 0 to disable

        :default: - automatic pause enabled after 5 minutes

        :stability: experimental
        '''
        result = self._values.get("auto_pause")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def max_capacity(self) -> typing.Optional[AuroraCapacityUnit]:
        '''(experimental) The maximum capacity for an Aurora Serverless database cluster.

        :default: - determined by Aurora based on database engine

        :stability: experimental
        '''
        result = self._values.get("max_capacity")
        return typing.cast(typing.Optional[AuroraCapacityUnit], result)

    @builtins.property
    def min_capacity(self) -> typing.Optional[AuroraCapacityUnit]:
        '''(experimental) The minimum capacity for an Aurora Serverless database cluster.

        :default: - determined by Aurora based on database engine

        :stability: experimental
        '''
        result = self._values.get("min_capacity")
        return typing.cast(typing.Optional[AuroraCapacityUnit], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ServerlessScalingOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SessionPinningFilter(
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_rds.SessionPinningFilter",
):
    '''(experimental) SessionPinningFilter.

    :see: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-proxy.html#rds-proxy-pinning
    :stability: experimental
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from monocdk import aws_rds as rds
        
        session_pinning_filter = rds.SessionPinningFilter.of("filterName")
    '''

    @jsii.member(jsii_name="of")
    @builtins.classmethod
    def of(cls, filter_name: builtins.str) -> "SessionPinningFilter":
        '''(experimental) custom filter.

        :param filter_name: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3afa4807de84f81c5119248d0b9831a5785b0d1644564c043b1a10b30638e935)
            check_type(argname="argument filter_name", value=filter_name, expected_type=type_hints["filter_name"])
        return typing.cast("SessionPinningFilter", jsii.sinvoke(cls, "of", [filter_name]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="EXCLUDE_VARIABLE_SETS")
    def EXCLUDE_VARIABLE_SETS(cls) -> "SessionPinningFilter":
        '''(experimental) You can opt out of session pinning for the following kinds of application statements:.

        - Setting session variables and configuration settings.

        :stability: experimental
        '''
        return typing.cast("SessionPinningFilter", jsii.sget(cls, "EXCLUDE_VARIABLE_SETS"))

    @builtins.property
    @jsii.member(jsii_name="filterName")
    def filter_name(self) -> builtins.str:
        '''(experimental) Filter name.

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "filterName"))


class SnapshotCredentials(
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="monocdk.aws_rds.SnapshotCredentials",
):
    '''(experimental) Credentials to update the password for a ``DatabaseInstanceFromSnapshot``.

    :stability: experimental
    :exampleMetadata: infused

    Example::

        # vpc: ec2.Vpc
        
        engine = rds.DatabaseInstanceEngine.postgres(version=rds.PostgresEngineVersion.VER_12_3)
        my_key = kms.Key(self, "MyKey")
        
        rds.DatabaseInstanceFromSnapshot(self, "InstanceFromSnapshotWithCustomizedSecret",
            engine=engine,
            vpc=vpc,
            snapshot_identifier="mySnapshot",
            credentials=rds.SnapshotCredentials.from_generated_secret("username",
                encryption_key=my_key,
                exclude_characters="!&*^#@()",
                replica_regions=[ec2.aws_secretsmanager.ReplicaRegion(region="eu-west-1"), ec2.aws_secretsmanager.ReplicaRegion(region="eu-west-2")]
            )
        )
    '''

    def __init__(self) -> None:
        '''
        :stability: experimental
        '''
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="fromGeneratedPassword")
    @builtins.classmethod
    def from_generated_password(
        cls,
        username: builtins.str,
        *,
        encryption_key: typing.Optional[_IKey_36930160] = None,
        exclude_characters: typing.Optional[builtins.str] = None,
        replica_regions: typing.Optional[typing.Sequence[typing.Union[_ReplicaRegion_ad1a6d2e, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> "SnapshotCredentials":
        '''(experimental) Generate a new password for the snapshot, using the existing username and an optional encryption key.

        Note - The username must match the existing master username of the snapshot.

        NOTE: use ``fromGeneratedSecret()`` for new Clusters and Instances. Switching from
        ``fromGeneratedPassword()`` to ``fromGeneratedSecret()`` for already deployed Clusters
        or Instances will update their master password.

        :param username: -
        :param encryption_key: (experimental) KMS encryption key to encrypt the generated secret. Default: - default master key
        :param exclude_characters: (experimental) The characters to exclude from the generated password. Default: - the DatabaseSecret default exclude character set (" %+~`#$&*()|[]{}:;<>?!'/
        :param replica_regions: (experimental) A list of regions where to replicate this secret. Default: - Secret is not replicated

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__49be72e8b5ba999d7f8dab4c158ed5aa0009ba4f6ad064c115b5a6dcede198e5)
            check_type(argname="argument username", value=username, expected_type=type_hints["username"])
        options = SnapshotCredentialsFromGeneratedPasswordOptions(
            encryption_key=encryption_key,
            exclude_characters=exclude_characters,
            replica_regions=replica_regions,
        )

        return typing.cast("SnapshotCredentials", jsii.sinvoke(cls, "fromGeneratedPassword", [username, options]))

    @jsii.member(jsii_name="fromGeneratedSecret")
    @builtins.classmethod
    def from_generated_secret(
        cls,
        username: builtins.str,
        *,
        encryption_key: typing.Optional[_IKey_36930160] = None,
        exclude_characters: typing.Optional[builtins.str] = None,
        replica_regions: typing.Optional[typing.Sequence[typing.Union[_ReplicaRegion_ad1a6d2e, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> "SnapshotCredentials":
        '''(experimental) Generate a new password for the snapshot, using the existing username and an optional encryption key.

        The new credentials are stored in Secrets Manager.

        Note - The username must match the existing master username of the snapshot.

        :param username: -
        :param encryption_key: (experimental) KMS encryption key to encrypt the generated secret. Default: - default master key
        :param exclude_characters: (experimental) The characters to exclude from the generated password. Default: - the DatabaseSecret default exclude character set (" %+~`#$&*()|[]{}:;<>?!'/
        :param replica_regions: (experimental) A list of regions where to replicate this secret. Default: - Secret is not replicated

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fcafbe3ed0f0a7c4ce170baba5462b0cb8b0976e4a85c9ffa3699686243ceebf)
            check_type(argname="argument username", value=username, expected_type=type_hints["username"])
        options = SnapshotCredentialsFromGeneratedPasswordOptions(
            encryption_key=encryption_key,
            exclude_characters=exclude_characters,
            replica_regions=replica_regions,
        )

        return typing.cast("SnapshotCredentials", jsii.sinvoke(cls, "fromGeneratedSecret", [username, options]))

    @jsii.member(jsii_name="fromPassword")
    @builtins.classmethod
    def from_password(cls, password: _SecretValue_c18506ef) -> "SnapshotCredentials":
        '''(experimental) Update the snapshot login with an existing password.

        :param password: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f8b24e4f72bb8381cb20927e9fc1cfe481bcfcadabc8136bf30a0b75e9ebb5b0)
            check_type(argname="argument password", value=password, expected_type=type_hints["password"])
        return typing.cast("SnapshotCredentials", jsii.sinvoke(cls, "fromPassword", [password]))

    @jsii.member(jsii_name="fromSecret")
    @builtins.classmethod
    def from_secret(cls, secret: _ISecret_22fb8757) -> "SnapshotCredentials":
        '''(experimental) Update the snapshot login with an existing password from a Secret.

        The Secret must be a JSON string with a ``password`` field::

           {
              ...
              "password": <required: password>,
           }

        :param secret: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__846c761862615dad710463a35dc1a03f4cc0ff2864fb51cad84202106963b86c)
            check_type(argname="argument secret", value=secret, expected_type=type_hints["secret"])
        return typing.cast("SnapshotCredentials", jsii.sinvoke(cls, "fromSecret", [secret]))

    @builtins.property
    @jsii.member(jsii_name="generatePassword")
    @abc.abstractmethod
    def generate_password(self) -> builtins.bool:
        '''(experimental) Whether a new password should be generated.

        :stability: experimental
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="encryptionKey")
    @abc.abstractmethod
    def encryption_key(self) -> typing.Optional[_IKey_36930160]:
        '''(experimental) KMS encryption key to encrypt the generated secret.

        :default: - default master key

        :stability: experimental
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="excludeCharacters")
    @abc.abstractmethod
    def exclude_characters(self) -> typing.Optional[builtins.str]:
        '''(experimental) The characters to exclude from the generated password.

        Only used if {@link generatePassword} if true.

        :default: - the DatabaseSecret default exclude character set (" %+~`#$&*()|[]{}:;<>?!'/

        :stability: experimental
        :: "\\")
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="password")
    @abc.abstractmethod
    def password(self) -> typing.Optional[_SecretValue_c18506ef]:
        '''(experimental) The master user password.

        Do not put passwords in your CDK code directly.

        :default: - the existing password from the snapshot

        :stability: experimental
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="replaceOnPasswordCriteriaChanges")
    @abc.abstractmethod
    def replace_on_password_criteria_changes(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Whether to replace the generated secret when the criteria for the password change.

        :default: false

        :stability: experimental
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="replicaRegions")
    @abc.abstractmethod
    def replica_regions(self) -> typing.Optional[typing.List[_ReplicaRegion_ad1a6d2e]]:
        '''(experimental) A list of regions where to replicate the generated secret.

        :default: - Secret is not replicated

        :stability: experimental
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="secret")
    @abc.abstractmethod
    def secret(self) -> typing.Optional[_ISecret_22fb8757]:
        '''(experimental) Secret used to instantiate this Login.

        :default: - none

        :stability: experimental
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="username")
    @abc.abstractmethod
    def username(self) -> typing.Optional[builtins.str]:
        '''(experimental) The master user name.

        Must be the **current** master user name of the snapshot.
        It is not possible to change the master user name of a RDS instance.

        :default: - the existing username from the snapshot

        :stability: experimental
        '''
        ...


class _SnapshotCredentialsProxy(SnapshotCredentials):
    @builtins.property
    @jsii.member(jsii_name="generatePassword")
    def generate_password(self) -> builtins.bool:
        '''(experimental) Whether a new password should be generated.

        :stability: experimental
        '''
        return typing.cast(builtins.bool, jsii.get(self, "generatePassword"))

    @builtins.property
    @jsii.member(jsii_name="encryptionKey")
    def encryption_key(self) -> typing.Optional[_IKey_36930160]:
        '''(experimental) KMS encryption key to encrypt the generated secret.

        :default: - default master key

        :stability: experimental
        '''
        return typing.cast(typing.Optional[_IKey_36930160], jsii.get(self, "encryptionKey"))

    @builtins.property
    @jsii.member(jsii_name="excludeCharacters")
    def exclude_characters(self) -> typing.Optional[builtins.str]:
        '''(experimental) The characters to exclude from the generated password.

        Only used if {@link generatePassword} if true.

        :default: - the DatabaseSecret default exclude character set (" %+~`#$&*()|[]{}:;<>?!'/

        :stability: experimental
        :: "\\")
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "excludeCharacters"))

    @builtins.property
    @jsii.member(jsii_name="password")
    def password(self) -> typing.Optional[_SecretValue_c18506ef]:
        '''(experimental) The master user password.

        Do not put passwords in your CDK code directly.

        :default: - the existing password from the snapshot

        :stability: experimental
        '''
        return typing.cast(typing.Optional[_SecretValue_c18506ef], jsii.get(self, "password"))

    @builtins.property
    @jsii.member(jsii_name="replaceOnPasswordCriteriaChanges")
    def replace_on_password_criteria_changes(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Whether to replace the generated secret when the criteria for the password change.

        :default: false

        :stability: experimental
        '''
        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "replaceOnPasswordCriteriaChanges"))

    @builtins.property
    @jsii.member(jsii_name="replicaRegions")
    def replica_regions(self) -> typing.Optional[typing.List[_ReplicaRegion_ad1a6d2e]]:
        '''(experimental) A list of regions where to replicate the generated secret.

        :default: - Secret is not replicated

        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.List[_ReplicaRegion_ad1a6d2e]], jsii.get(self, "replicaRegions"))

    @builtins.property
    @jsii.member(jsii_name="secret")
    def secret(self) -> typing.Optional[_ISecret_22fb8757]:
        '''(experimental) Secret used to instantiate this Login.

        :default: - none

        :stability: experimental
        '''
        return typing.cast(typing.Optional[_ISecret_22fb8757], jsii.get(self, "secret"))

    @builtins.property
    @jsii.member(jsii_name="username")
    def username(self) -> typing.Optional[builtins.str]:
        '''(experimental) The master user name.

        Must be the **current** master user name of the snapshot.
        It is not possible to change the master user name of a RDS instance.

        :default: - the existing username from the snapshot

        :stability: experimental
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "username"))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, SnapshotCredentials).__jsii_proxy_class__ = lambda : _SnapshotCredentialsProxy


@jsii.data_type(
    jsii_type="monocdk.aws_rds.SnapshotCredentialsFromGeneratedPasswordOptions",
    jsii_struct_bases=[],
    name_mapping={
        "encryption_key": "encryptionKey",
        "exclude_characters": "excludeCharacters",
        "replica_regions": "replicaRegions",
    },
)
class SnapshotCredentialsFromGeneratedPasswordOptions:
    def __init__(
        self,
        *,
        encryption_key: typing.Optional[_IKey_36930160] = None,
        exclude_characters: typing.Optional[builtins.str] = None,
        replica_regions: typing.Optional[typing.Sequence[typing.Union[_ReplicaRegion_ad1a6d2e, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''(experimental) Options used in the {@link SnapshotCredentials.fromGeneratedPassword} method.

        :param encryption_key: (experimental) KMS encryption key to encrypt the generated secret. Default: - default master key
        :param exclude_characters: (experimental) The characters to exclude from the generated password. Default: - the DatabaseSecret default exclude character set (" %+~`#$&*()|[]{}:;<>?!'/
        :param replica_regions: (experimental) A list of regions where to replicate this secret. Default: - Secret is not replicated

        :stability: experimental
        :exampleMetadata: infused

        Example::

            # vpc: ec2.Vpc
            
            engine = rds.DatabaseInstanceEngine.postgres(version=rds.PostgresEngineVersion.VER_12_3)
            my_key = kms.Key(self, "MyKey")
            
            rds.DatabaseInstanceFromSnapshot(self, "InstanceFromSnapshotWithCustomizedSecret",
                engine=engine,
                vpc=vpc,
                snapshot_identifier="mySnapshot",
                credentials=rds.SnapshotCredentials.from_generated_secret("username",
                    encryption_key=my_key,
                    exclude_characters="!&*^#@()",
                    replica_regions=[ec2.aws_secretsmanager.ReplicaRegion(region="eu-west-1"), ec2.aws_secretsmanager.ReplicaRegion(region="eu-west-2")]
                )
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__beba8649819d0ec03054437e063c9b64f9509d3b314f0c0b03266fc1be49407a)
            check_type(argname="argument encryption_key", value=encryption_key, expected_type=type_hints["encryption_key"])
            check_type(argname="argument exclude_characters", value=exclude_characters, expected_type=type_hints["exclude_characters"])
            check_type(argname="argument replica_regions", value=replica_regions, expected_type=type_hints["replica_regions"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if encryption_key is not None:
            self._values["encryption_key"] = encryption_key
        if exclude_characters is not None:
            self._values["exclude_characters"] = exclude_characters
        if replica_regions is not None:
            self._values["replica_regions"] = replica_regions

    @builtins.property
    def encryption_key(self) -> typing.Optional[_IKey_36930160]:
        '''(experimental) KMS encryption key to encrypt the generated secret.

        :default: - default master key

        :stability: experimental
        '''
        result = self._values.get("encryption_key")
        return typing.cast(typing.Optional[_IKey_36930160], result)

    @builtins.property
    def exclude_characters(self) -> typing.Optional[builtins.str]:
        '''(experimental) The characters to exclude from the generated password.

        :default: - the DatabaseSecret default exclude character set (" %+~`#$&*()|[]{}:;<>?!'/

        :stability: experimental
        :: "\\")
        '''
        result = self._values.get("exclude_characters")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def replica_regions(self) -> typing.Optional[typing.List[_ReplicaRegion_ad1a6d2e]]:
        '''(experimental) A list of regions where to replicate this secret.

        :default: - Secret is not replicated

        :stability: experimental
        '''
        result = self._values.get("replica_regions")
        return typing.cast(typing.Optional[typing.List[_ReplicaRegion_ad1a6d2e]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SnapshotCredentialsFromGeneratedPasswordOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_rds.SqlServerEeInstanceEngineProps",
    jsii_struct_bases=[],
    name_mapping={"version": "version"},
)
class SqlServerEeInstanceEngineProps:
    def __init__(self, *, version: "SqlServerEngineVersion") -> None:
        '''(experimental) Properties for SQL Server Enterprise Edition instance engines.

        Used in {@link DatabaseInstanceEngine.sqlServerEe}.

        :param version: (experimental) The exact version of the engine to use.

        :stability: experimental
        :exampleMetadata: infused

        Example::

            # vpc: ec2.Vpc
            
            
            parameter_group = rds.ParameterGroup(self, "ParameterGroup",
                engine=rds.DatabaseInstanceEngine.sql_server_ee(
                    version=rds.SqlServerEngineVersion.VER_11
                ),
                parameters={
                    "locks": "100"
                }
            )
            
            rds.DatabaseInstance(self, "Database",
                engine=rds.DatabaseInstanceEngine.SQL_SERVER_EE,
                vpc=vpc,
                parameter_group=parameter_group
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__db3bff83440d505f4cfc9c643c7e013fe5bd881feb39617be3ae3630a43af4bb)
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "version": version,
        }

    @builtins.property
    def version(self) -> "SqlServerEngineVersion":
        '''(experimental) The exact version of the engine to use.

        :stability: experimental
        '''
        result = self._values.get("version")
        assert result is not None, "Required property 'version' is missing"
        return typing.cast("SqlServerEngineVersion", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SqlServerEeInstanceEngineProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SqlServerEngineVersion(
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_rds.SqlServerEngineVersion",
):
    '''(experimental) The versions for the SQL Server instance engines (those returned by {@link DatabaseInstanceEngine.sqlServerSe}, {@link DatabaseInstanceEngine.sqlServerEx}, {@link DatabaseInstanceEngine.sqlServerWeb} and {@link DatabaseInstanceEngine.sqlServerEe}).

    :stability: experimental
    :exampleMetadata: infused

    Example::

        # vpc: ec2.Vpc
        
        
        parameter_group = rds.ParameterGroup(self, "ParameterGroup",
            engine=rds.DatabaseInstanceEngine.sql_server_ee(
                version=rds.SqlServerEngineVersion.VER_11
            ),
            parameters={
                "locks": "100"
            }
        )
        
        rds.DatabaseInstance(self, "Database",
            engine=rds.DatabaseInstanceEngine.SQL_SERVER_EE,
            vpc=vpc,
            parameter_group=parameter_group
        )
    '''

    @jsii.member(jsii_name="of")
    @builtins.classmethod
    def of(
        cls,
        sql_server_full_version: builtins.str,
        sql_server_major_version: builtins.str,
    ) -> "SqlServerEngineVersion":
        '''(experimental) Create a new SqlServerEngineVersion with an arbitrary version.

        :param sql_server_full_version: the full version string, for example "15.00.3049.1.v1".
        :param sql_server_major_version: the major version of the engine, for example "15.00".

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0b2584b7e834ed144406454f1f8fc75a4f1fb9473181e079bcc166b109e46e32)
            check_type(argname="argument sql_server_full_version", value=sql_server_full_version, expected_type=type_hints["sql_server_full_version"])
            check_type(argname="argument sql_server_major_version", value=sql_server_major_version, expected_type=type_hints["sql_server_major_version"])
        return typing.cast("SqlServerEngineVersion", jsii.sinvoke(cls, "of", [sql_server_full_version, sql_server_major_version]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11")
    def VER_11(cls) -> "SqlServerEngineVersion":
        '''(experimental) Version "11.00" (only a major version, without a specific minor version).

        :stability: experimental
        '''
        return typing.cast("SqlServerEngineVersion", jsii.sget(cls, "VER_11"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_00_5058_0_V1")
    def VER_11_00_5058_0_V1(cls) -> "SqlServerEngineVersion":
        '''(experimental) Version "11.00.5058.0.v1".

        :stability: experimental
        '''
        return typing.cast("SqlServerEngineVersion", jsii.sget(cls, "VER_11_00_5058_0_V1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_00_6020_0_V1")
    def VER_11_00_6020_0_V1(cls) -> "SqlServerEngineVersion":
        '''(experimental) Version "11.00.6020.0.v1".

        :stability: experimental
        '''
        return typing.cast("SqlServerEngineVersion", jsii.sget(cls, "VER_11_00_6020_0_V1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_00_6594_0_V1")
    def VER_11_00_6594_0_V1(cls) -> "SqlServerEngineVersion":
        '''(experimental) Version "11.00.6594.0.v1".

        :stability: experimental
        '''
        return typing.cast("SqlServerEngineVersion", jsii.sget(cls, "VER_11_00_6594_0_V1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_00_7462_6_V1")
    def VER_11_00_7462_6_V1(cls) -> "SqlServerEngineVersion":
        '''(experimental) Version "11.00.7462.6.v1".

        :stability: experimental
        '''
        return typing.cast("SqlServerEngineVersion", jsii.sget(cls, "VER_11_00_7462_6_V1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_11_00_7493_4_V1")
    def VER_11_00_7493_4_V1(cls) -> "SqlServerEngineVersion":
        '''(experimental) Version "11.00.7493.4.v1".

        :stability: experimental
        '''
        return typing.cast("SqlServerEngineVersion", jsii.sget(cls, "VER_11_00_7493_4_V1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12")
    def VER_12(cls) -> "SqlServerEngineVersion":
        '''(experimental) Version "12.00" (only a major version, without a specific minor version).

        :stability: experimental
        '''
        return typing.cast("SqlServerEngineVersion", jsii.sget(cls, "VER_12"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_00_5000_0_V1")
    def VER_12_00_5000_0_V1(cls) -> "SqlServerEngineVersion":
        '''(experimental) Version "12.00.5000.0.v1".

        :stability: experimental
        '''
        return typing.cast("SqlServerEngineVersion", jsii.sget(cls, "VER_12_00_5000_0_V1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_00_5546_0_V1")
    def VER_12_00_5546_0_V1(cls) -> "SqlServerEngineVersion":
        '''(experimental) Version "12.00.5546.0.v1".

        :stability: experimental
        '''
        return typing.cast("SqlServerEngineVersion", jsii.sget(cls, "VER_12_00_5546_0_V1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_00_5571_0_V1")
    def VER_12_00_5571_0_V1(cls) -> "SqlServerEngineVersion":
        '''(experimental) Version "12.00.5571.0.v1".

        :stability: experimental
        '''
        return typing.cast("SqlServerEngineVersion", jsii.sget(cls, "VER_12_00_5571_0_V1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_00_6293_0_V1")
    def VER_12_00_6293_0_V1(cls) -> "SqlServerEngineVersion":
        '''(experimental) Version "12.00.6293.0.v1".

        :stability: experimental
        '''
        return typing.cast("SqlServerEngineVersion", jsii.sget(cls, "VER_12_00_6293_0_V1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_12_00_6329_1_V1")
    def VER_12_00_6329_1_V1(cls) -> "SqlServerEngineVersion":
        '''(experimental) Version "12.00.6329.1.v1".

        :stability: experimental
        '''
        return typing.cast("SqlServerEngineVersion", jsii.sget(cls, "VER_12_00_6329_1_V1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_13")
    def VER_13(cls) -> "SqlServerEngineVersion":
        '''(experimental) Version "13.00" (only a major version, without a specific minor version).

        :stability: experimental
        '''
        return typing.cast("SqlServerEngineVersion", jsii.sget(cls, "VER_13"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_13_00_2164_0_V1")
    def VER_13_00_2164_0_V1(cls) -> "SqlServerEngineVersion":
        '''(experimental) Version "13.00.2164.0.v1".

        :stability: experimental
        '''
        return typing.cast("SqlServerEngineVersion", jsii.sget(cls, "VER_13_00_2164_0_V1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_13_00_4422_0_V1")
    def VER_13_00_4422_0_V1(cls) -> "SqlServerEngineVersion":
        '''(experimental) Version "13.00.4422.0.v1".

        :stability: experimental
        '''
        return typing.cast("SqlServerEngineVersion", jsii.sget(cls, "VER_13_00_4422_0_V1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_13_00_4451_0_V1")
    def VER_13_00_4451_0_V1(cls) -> "SqlServerEngineVersion":
        '''(experimental) Version "13.00.4451.0.v1".

        :stability: experimental
        '''
        return typing.cast("SqlServerEngineVersion", jsii.sget(cls, "VER_13_00_4451_0_V1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_13_00_4466_4_V1")
    def VER_13_00_4466_4_V1(cls) -> "SqlServerEngineVersion":
        '''(experimental) Version "13.00.4466.4.v1".

        :stability: experimental
        '''
        return typing.cast("SqlServerEngineVersion", jsii.sget(cls, "VER_13_00_4466_4_V1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_13_00_4522_0_V1")
    def VER_13_00_4522_0_V1(cls) -> "SqlServerEngineVersion":
        '''(experimental) Version "13.00.4522.0.v1".

        :stability: experimental
        '''
        return typing.cast("SqlServerEngineVersion", jsii.sget(cls, "VER_13_00_4522_0_V1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_13_00_5216_0_V1")
    def VER_13_00_5216_0_V1(cls) -> "SqlServerEngineVersion":
        '''(experimental) Version "13.00.5216.0.v1".

        :stability: experimental
        '''
        return typing.cast("SqlServerEngineVersion", jsii.sget(cls, "VER_13_00_5216_0_V1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_13_00_5292_0_V1")
    def VER_13_00_5292_0_V1(cls) -> "SqlServerEngineVersion":
        '''(experimental) Version "13.00.5292.0.v1".

        :stability: experimental
        '''
        return typing.cast("SqlServerEngineVersion", jsii.sget(cls, "VER_13_00_5292_0_V1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_13_00_5366_0_V1")
    def VER_13_00_5366_0_V1(cls) -> "SqlServerEngineVersion":
        '''(experimental) Version "13.00.5366.0.v1".

        :stability: experimental
        '''
        return typing.cast("SqlServerEngineVersion", jsii.sget(cls, "VER_13_00_5366_0_V1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_13_00_5426_0_V1")
    def VER_13_00_5426_0_V1(cls) -> "SqlServerEngineVersion":
        '''(experimental) Version "13.00.5426.0.v1".

        :stability: experimental
        '''
        return typing.cast("SqlServerEngineVersion", jsii.sget(cls, "VER_13_00_5426_0_V1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_13_00_5598_27_V1")
    def VER_13_00_5598_27_V1(cls) -> "SqlServerEngineVersion":
        '''(experimental) Version "13.00.5598.27.v1".

        :stability: experimental
        '''
        return typing.cast("SqlServerEngineVersion", jsii.sget(cls, "VER_13_00_5598_27_V1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_13_00_5820_21_V1")
    def VER_13_00_5820_21_V1(cls) -> "SqlServerEngineVersion":
        '''(experimental) Version "13.00.5820.21.v1".

        :stability: experimental
        '''
        return typing.cast("SqlServerEngineVersion", jsii.sget(cls, "VER_13_00_5820_21_V1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_13_00_5850_14_V1")
    def VER_13_00_5850_14_V1(cls) -> "SqlServerEngineVersion":
        '''(experimental) Version "13.00.5850.14.v1".

        :stability: experimental
        '''
        return typing.cast("SqlServerEngineVersion", jsii.sget(cls, "VER_13_00_5850_14_V1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_13_00_5882_1_V1")
    def VER_13_00_5882_1_V1(cls) -> "SqlServerEngineVersion":
        '''(experimental) Version "13.00.5882.1.v1".

        :stability: experimental
        '''
        return typing.cast("SqlServerEngineVersion", jsii.sget(cls, "VER_13_00_5882_1_V1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_14")
    def VER_14(cls) -> "SqlServerEngineVersion":
        '''(experimental) Version "14.00" (only a major version, without a specific minor version).

        :stability: experimental
        '''
        return typing.cast("SqlServerEngineVersion", jsii.sget(cls, "VER_14"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_14_00_1000_169_V1")
    def VER_14_00_1000_169_V1(cls) -> "SqlServerEngineVersion":
        '''(experimental) Version "14.00.1000.169.v1".

        :stability: experimental
        '''
        return typing.cast("SqlServerEngineVersion", jsii.sget(cls, "VER_14_00_1000_169_V1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_14_00_3015_40_V1")
    def VER_14_00_3015_40_V1(cls) -> "SqlServerEngineVersion":
        '''(experimental) Version "14.00.3015.40.v1".

        :stability: experimental
        '''
        return typing.cast("SqlServerEngineVersion", jsii.sget(cls, "VER_14_00_3015_40_V1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_14_00_3035_2_V1")
    def VER_14_00_3035_2_V1(cls) -> "SqlServerEngineVersion":
        '''(experimental) Version "14.00.3035.2.v1".

        :stability: experimental
        '''
        return typing.cast("SqlServerEngineVersion", jsii.sget(cls, "VER_14_00_3035_2_V1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_14_00_3049_1_V1")
    def VER_14_00_3049_1_V1(cls) -> "SqlServerEngineVersion":
        '''(experimental) Version "14.00.3049.1.v1".

        :stability: experimental
        '''
        return typing.cast("SqlServerEngineVersion", jsii.sget(cls, "VER_14_00_3049_1_V1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_14_00_3192_2_V1")
    def VER_14_00_3192_2_V1(cls) -> "SqlServerEngineVersion":
        '''(deprecated) Version "14.00.3192.2.v1".

        :deprecated: SQL Server version 14.00.3192.2.v1 reached end of life

        :stability: deprecated
        '''
        return typing.cast("SqlServerEngineVersion", jsii.sget(cls, "VER_14_00_3192_2_V1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_14_00_3223_3_V1")
    def VER_14_00_3223_3_V1(cls) -> "SqlServerEngineVersion":
        '''(experimental) Version "14.00.3223.3.v1".

        :stability: experimental
        '''
        return typing.cast("SqlServerEngineVersion", jsii.sget(cls, "VER_14_00_3223_3_V1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_14_00_3281_6_V1")
    def VER_14_00_3281_6_V1(cls) -> "SqlServerEngineVersion":
        '''(experimental) Version "14.00.3281.6.v1".

        :stability: experimental
        '''
        return typing.cast("SqlServerEngineVersion", jsii.sget(cls, "VER_14_00_3281_6_V1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_14_00_3294_2_V1")
    def VER_14_00_3294_2_V1(cls) -> "SqlServerEngineVersion":
        '''(experimental) Version "14.00.3294.2.v1".

        :stability: experimental
        '''
        return typing.cast("SqlServerEngineVersion", jsii.sget(cls, "VER_14_00_3294_2_V1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_14_00_3356_20_V1")
    def VER_14_00_3356_20_V1(cls) -> "SqlServerEngineVersion":
        '''(experimental) Version "14.00.3356.20.v1".

        :stability: experimental
        '''
        return typing.cast("SqlServerEngineVersion", jsii.sget(cls, "VER_14_00_3356_20_V1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_14_00_3381_3_V1")
    def VER_14_00_3381_3_V1(cls) -> "SqlServerEngineVersion":
        '''(experimental) Version "14.00.3381.3.v1".

        :stability: experimental
        '''
        return typing.cast("SqlServerEngineVersion", jsii.sget(cls, "VER_14_00_3381_3_V1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_15")
    def VER_15(cls) -> "SqlServerEngineVersion":
        '''(experimental) Version "15.00" (only a major version, without a specific minor version).

        :stability: experimental
        '''
        return typing.cast("SqlServerEngineVersion", jsii.sget(cls, "VER_15"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_15_00_4043_16_V1")
    def VER_15_00_4043_16_V1(cls) -> "SqlServerEngineVersion":
        '''(experimental) Version "15.00.4043.16.v1".

        :stability: experimental
        '''
        return typing.cast("SqlServerEngineVersion", jsii.sget(cls, "VER_15_00_4043_16_V1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_15_00_4043_23_V1")
    def VER_15_00_4043_23_V1(cls) -> "SqlServerEngineVersion":
        '''(deprecated) Version "15.00.4043.23.v1".

        :deprecated: This version is erroneous. You might be looking for {@link SqlServerEngineVersion.VER_15_00_4073_23_V1}, instead.

        :stability: deprecated
        '''
        return typing.cast("SqlServerEngineVersion", jsii.sget(cls, "VER_15_00_4043_23_V1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VER_15_00_4073_23_V1")
    def VER_15_00_4073_23_V1(cls) -> "SqlServerEngineVersion":
        '''(experimental) Version "15.00.4073.23.v1".

        :stability: experimental
        '''
        return typing.cast("SqlServerEngineVersion", jsii.sget(cls, "VER_15_00_4073_23_V1"))

    @builtins.property
    @jsii.member(jsii_name="sqlServerFullVersion")
    def sql_server_full_version(self) -> builtins.str:
        '''(experimental) The full version string, for example, "15.00.3049.1.v1".

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "sqlServerFullVersion"))

    @builtins.property
    @jsii.member(jsii_name="sqlServerMajorVersion")
    def sql_server_major_version(self) -> builtins.str:
        '''(experimental) The major version of the engine, for example, "15.00".

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "sqlServerMajorVersion"))


@jsii.data_type(
    jsii_type="monocdk.aws_rds.SqlServerExInstanceEngineProps",
    jsii_struct_bases=[],
    name_mapping={"version": "version"},
)
class SqlServerExInstanceEngineProps:
    def __init__(self, *, version: SqlServerEngineVersion) -> None:
        '''(experimental) Properties for SQL Server Express Edition instance engines.

        Used in {@link DatabaseInstanceEngine.sqlServerEx}.

        :param version: (experimental) The exact version of the engine to use.

        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_rds as rds
            
            # sql_server_engine_version: rds.SqlServerEngineVersion
            
            sql_server_ex_instance_engine_props = rds.SqlServerExInstanceEngineProps(
                version=sql_server_engine_version
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__39fe10285f46f8aab0cac1d253ab30bf947add3b58aedb00f1568bacdb4ef459)
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "version": version,
        }

    @builtins.property
    def version(self) -> SqlServerEngineVersion:
        '''(experimental) The exact version of the engine to use.

        :stability: experimental
        '''
        result = self._values.get("version")
        assert result is not None, "Required property 'version' is missing"
        return typing.cast(SqlServerEngineVersion, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SqlServerExInstanceEngineProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_rds.SqlServerSeInstanceEngineProps",
    jsii_struct_bases=[],
    name_mapping={"version": "version"},
)
class SqlServerSeInstanceEngineProps:
    def __init__(self, *, version: SqlServerEngineVersion) -> None:
        '''(experimental) Properties for SQL Server Standard Edition instance engines.

        Used in {@link DatabaseInstanceEngine.sqlServerSe}.

        :param version: (experimental) The exact version of the engine to use.

        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_rds as rds
            
            # sql_server_engine_version: rds.SqlServerEngineVersion
            
            sql_server_se_instance_engine_props = rds.SqlServerSeInstanceEngineProps(
                version=sql_server_engine_version
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1f51c736910b187178ab834b3beb9489bfa8a2fbf0f8aaa4d38aefa09edf3295)
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "version": version,
        }

    @builtins.property
    def version(self) -> SqlServerEngineVersion:
        '''(experimental) The exact version of the engine to use.

        :stability: experimental
        '''
        result = self._values.get("version")
        assert result is not None, "Required property 'version' is missing"
        return typing.cast(SqlServerEngineVersion, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SqlServerSeInstanceEngineProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_rds.SqlServerWebInstanceEngineProps",
    jsii_struct_bases=[],
    name_mapping={"version": "version"},
)
class SqlServerWebInstanceEngineProps:
    def __init__(self, *, version: SqlServerEngineVersion) -> None:
        '''(experimental) Properties for SQL Server Web Edition instance engines.

        Used in {@link DatabaseInstanceEngine.sqlServerWeb}.

        :param version: (experimental) The exact version of the engine to use.

        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from monocdk import aws_rds as rds
            
            # sql_server_engine_version: rds.SqlServerEngineVersion
            
            sql_server_web_instance_engine_props = rds.SqlServerWebInstanceEngineProps(
                version=sql_server_engine_version
            )
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__05de9a07f18e6177c022990bb7d718b43a26c4347ee88a923409163485e10d8a)
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "version": version,
        }

    @builtins.property
    def version(self) -> SqlServerEngineVersion:
        '''(experimental) The exact version of the engine to use.

        :stability: experimental
        '''
        result = self._values.get("version")
        assert result is not None, "Required property 'version' is missing"
        return typing.cast(SqlServerEngineVersion, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SqlServerWebInstanceEngineProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="monocdk.aws_rds.StorageType")
class StorageType(enum.Enum):
    '''(experimental) The type of storage.

    :stability: experimental
    :exampleMetadata: lit=lib/aws-rds/test/integ.instance.lit.ts infused

    Example::

        # Set open cursors with parameter group
        parameter_group = rds.ParameterGroup(self, "ParameterGroup",
            engine=rds.DatabaseInstanceEngine.oracle_se2(version=rds.OracleEngineVersion.VER_19_0_0_0_2020_04_R1),
            parameters={
                "open_cursors": "2500"
            }
        )
        
        option_group = rds.OptionGroup(self, "OptionGroup",
            engine=rds.DatabaseInstanceEngine.oracle_se2(version=rds.OracleEngineVersion.VER_19_0_0_0_2020_04_R1),
            configurations=[cdk.aws_rds.OptionConfiguration(
                name="LOCATOR"
            ), cdk.aws_rds.OptionConfiguration(
                name="OEM",
                port=1158,
                vpc=vpc
            )
            ]
        )
        
        # Allow connections to OEM
        option_group.option_connections.OEM.connections.allow_default_port_from_any_ipv4()
        
        # Database instance with production values
        instance = rds.DatabaseInstance(self, "Instance",
            engine=rds.DatabaseInstanceEngine.oracle_se2(version=rds.OracleEngineVersion.VER_19_0_0_0_2020_04_R1),
            license_model=rds.LicenseModel.BRING_YOUR_OWN_LICENSE,
            instance_type=ec2.InstanceType.of(ec2.InstanceClass.BURSTABLE3, ec2.InstanceSize.MEDIUM),
            multi_az=True,
            storage_type=rds.StorageType.IO1,
            credentials=rds.Credentials.from_username("syscdk"),
            vpc=vpc,
            database_name="ORCL",
            storage_encrypted=True,
            backup_retention=cdk.Duration.days(7),
            monitoring_interval=cdk.Duration.seconds(60),
            enable_performance_insights=True,
            cloudwatch_logs_exports=["trace", "audit", "alert", "listener"
            ],
            cloudwatch_logs_retention=logs.RetentionDays.ONE_MONTH,
            auto_minor_version_upgrade=True,  # required to be true if LOCATOR is used in the option group
            option_group=option_group,
            parameter_group=parameter_group,
            removal_policy=RemovalPolicy.DESTROY
        )
        
        # Allow connections on default port from any IPV4
        instance.connections.allow_default_port_from_any_ipv4()
        
        # Rotate the master user password every 30 days
        instance.add_rotation_single_user()
        
        # Add alarm for high CPU
        cloudwatch.Alarm(self, "HighCPU",
            metric=instance.metric_cPUUtilization(),
            threshold=90,
            evaluation_periods=1
        )
        
        # Trigger Lambda function on instance availability events
        fn = lambda_.Function(self, "Function",
            code=lambda_.Code.from_inline("exports.handler = (event) => console.log(event);"),
            handler="index.handler",
            runtime=lambda_.Runtime.NODEJS_14_X
        )
        
        availability_rule = instance.on_event("Availability", target=targets.LambdaFunction(fn))
        availability_rule.add_event_pattern(
            detail={
                "EventCategories": ["availability"
                ]
            }
        )
    '''

    STANDARD = "STANDARD"
    '''(experimental) Standard.

    :stability: experimental
    '''
    GP2 = "GP2"
    '''(experimental) General purpose (SSD).

    :stability: experimental
    '''
    IO1 = "IO1"
    '''(experimental) Provisioned IOPS (SSD).

    :stability: experimental
    '''


@jsii.implements(ISubnetGroup)
class SubnetGroup(
    _Resource_abff4495,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_rds.SubnetGroup",
):
    '''(experimental) Class for creating a RDS DB subnet group.

    :stability: experimental
    :resource: AWS::RDS::DBSubnetGroup
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        import monocdk as monocdk
        from monocdk import aws_ec2 as ec2
        from monocdk import aws_rds as rds
        
        # subnet: ec2.Subnet
        # subnet_filter: ec2.SubnetFilter
        # vpc: ec2.Vpc
        
        subnet_group = rds.SubnetGroup(self, "MySubnetGroup",
            description="description",
            vpc=vpc,
        
            # the properties below are optional
            removal_policy=monocdk.RemovalPolicy.DESTROY,
            subnet_group_name="subnetGroupName",
            vpc_subnets=ec2.SubnetSelection(
                availability_zones=["availabilityZones"],
                one_per_az=False,
                subnet_filters=[subnet_filter],
                subnet_group_name="subnetGroupName",
                subnet_name="subnetName",
                subnets=[subnet],
                subnet_type=ec2.SubnetType.ISOLATED
            )
        )
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        description: builtins.str,
        vpc: _IVpc_6d1f76c4,
        removal_policy: typing.Optional[_RemovalPolicy_c97e7a20] = None,
        subnet_group_name: typing.Optional[builtins.str] = None,
        vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param description: (experimental) Description of the subnet group.
        :param vpc: (experimental) The VPC to place the subnet group in.
        :param removal_policy: (experimental) The removal policy to apply when the subnet group are removed from the stack or replaced during an update. Default: RemovalPolicy.DESTROY
        :param subnet_group_name: (experimental) The name of the subnet group. Default: - a name is generated
        :param vpc_subnets: (experimental) Which subnets within the VPC to associate with this group. Default: - private subnets

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e83f7e9099f30b4f649568b531a0da0c60e5b09a4f44bebc9ac5b685bb0882d7)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = SubnetGroupProps(
            description=description,
            vpc=vpc,
            removal_policy=removal_policy,
            subnet_group_name=subnet_group_name,
            vpc_subnets=vpc_subnets,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="fromSubnetGroupName")
    @builtins.classmethod
    def from_subnet_group_name(
        cls,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        subnet_group_name: builtins.str,
    ) -> ISubnetGroup:
        '''(experimental) Imports an existing subnet group by name.

        :param scope: -
        :param id: -
        :param subnet_group_name: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__aca450bf2613635119900dfa4842ae53e63015c4409b4a63ef1ee757e1b7d16f)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument subnet_group_name", value=subnet_group_name, expected_type=type_hints["subnet_group_name"])
        return typing.cast(ISubnetGroup, jsii.sinvoke(cls, "fromSubnetGroupName", [scope, id, subnet_group_name]))

    @builtins.property
    @jsii.member(jsii_name="subnetGroupName")
    def subnet_group_name(self) -> builtins.str:
        '''(experimental) The name of the subnet group.

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "subnetGroupName"))


@jsii.data_type(
    jsii_type="monocdk.aws_rds.SubnetGroupProps",
    jsii_struct_bases=[],
    name_mapping={
        "description": "description",
        "vpc": "vpc",
        "removal_policy": "removalPolicy",
        "subnet_group_name": "subnetGroupName",
        "vpc_subnets": "vpcSubnets",
    },
)
class SubnetGroupProps:
    def __init__(
        self,
        *,
        description: builtins.str,
        vpc: _IVpc_6d1f76c4,
        removal_policy: typing.Optional[_RemovalPolicy_c97e7a20] = None,
        subnet_group_name: typing.Optional[builtins.str] = None,
        vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''(experimental) Properties for creating a SubnetGroup.

        :param description: (experimental) Description of the subnet group.
        :param vpc: (experimental) The VPC to place the subnet group in.
        :param removal_policy: (experimental) The removal policy to apply when the subnet group are removed from the stack or replaced during an update. Default: RemovalPolicy.DESTROY
        :param subnet_group_name: (experimental) The name of the subnet group. Default: - a name is generated
        :param vpc_subnets: (experimental) Which subnets within the VPC to associate with this group. Default: - private subnets

        :stability: experimental
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            import monocdk as monocdk
            from monocdk import aws_ec2 as ec2
            from monocdk import aws_rds as rds
            
            # subnet: ec2.Subnet
            # subnet_filter: ec2.SubnetFilter
            # vpc: ec2.Vpc
            
            subnet_group_props = rds.SubnetGroupProps(
                description="description",
                vpc=vpc,
            
                # the properties below are optional
                removal_policy=monocdk.RemovalPolicy.DESTROY,
                subnet_group_name="subnetGroupName",
                vpc_subnets=ec2.SubnetSelection(
                    availability_zones=["availabilityZones"],
                    one_per_az=False,
                    subnet_filters=[subnet_filter],
                    subnet_group_name="subnetGroupName",
                    subnet_name="subnetName",
                    subnets=[subnet],
                    subnet_type=ec2.SubnetType.ISOLATED
                )
            )
        '''
        if isinstance(vpc_subnets, dict):
            vpc_subnets = _SubnetSelection_1284e62c(**vpc_subnets)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__90c82cb877541d63ee328c2cf95a734a158a60e1242a0b6c1c9d02e140209c2a)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument vpc", value=vpc, expected_type=type_hints["vpc"])
            check_type(argname="argument removal_policy", value=removal_policy, expected_type=type_hints["removal_policy"])
            check_type(argname="argument subnet_group_name", value=subnet_group_name, expected_type=type_hints["subnet_group_name"])
            check_type(argname="argument vpc_subnets", value=vpc_subnets, expected_type=type_hints["vpc_subnets"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "description": description,
            "vpc": vpc,
        }
        if removal_policy is not None:
            self._values["removal_policy"] = removal_policy
        if subnet_group_name is not None:
            self._values["subnet_group_name"] = subnet_group_name
        if vpc_subnets is not None:
            self._values["vpc_subnets"] = vpc_subnets

    @builtins.property
    def description(self) -> builtins.str:
        '''(experimental) Description of the subnet group.

        :stability: experimental
        '''
        result = self._values.get("description")
        assert result is not None, "Required property 'description' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def vpc(self) -> _IVpc_6d1f76c4:
        '''(experimental) The VPC to place the subnet group in.

        :stability: experimental
        '''
        result = self._values.get("vpc")
        assert result is not None, "Required property 'vpc' is missing"
        return typing.cast(_IVpc_6d1f76c4, result)

    @builtins.property
    def removal_policy(self) -> typing.Optional[_RemovalPolicy_c97e7a20]:
        '''(experimental) The removal policy to apply when the subnet group are removed from the stack or replaced during an update.

        :default: RemovalPolicy.DESTROY

        :stability: experimental
        '''
        result = self._values.get("removal_policy")
        return typing.cast(typing.Optional[_RemovalPolicy_c97e7a20], result)

    @builtins.property
    def subnet_group_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) The name of the subnet group.

        :default: - a name is generated

        :stability: experimental
        '''
        result = self._values.get("subnet_group_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vpc_subnets(self) -> typing.Optional[_SubnetSelection_1284e62c]:
        '''(experimental) Which subnets within the VPC to associate with this group.

        :default: - private subnets

        :stability: experimental
        '''
        result = self._values.get("vpc_subnets")
        return typing.cast(typing.Optional[_SubnetSelection_1284e62c], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SubnetGroupProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(IDatabaseCluster)
class DatabaseClusterBase(
    _Resource_abff4495,
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="monocdk.aws_rds.DatabaseClusterBase",
):
    '''(experimental) A new or imported clustered database.

    :stability: experimental
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        account: typing.Optional[builtins.str] = None,
        environment_from_arn: typing.Optional[builtins.str] = None,
        physical_name: typing.Optional[builtins.str] = None,
        region: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param account: (experimental) The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
        :param environment_from_arn: (experimental) ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
        :param physical_name: (experimental) The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
        :param region: (experimental) The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8c84a493c30065af253aa2a20c74b4adf09f6fa7f5a4235cb017a2023528fc46)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _ResourceProps_9b554c0f(
            account=account,
            environment_from_arn=environment_from_arn,
            physical_name=physical_name,
            region=region,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="addProxy")
    def add_proxy(
        self,
        id: builtins.str,
        *,
        secrets: typing.Sequence[_ISecret_22fb8757],
        vpc: _IVpc_6d1f76c4,
        borrow_timeout: typing.Optional[_Duration_070aa057] = None,
        db_proxy_name: typing.Optional[builtins.str] = None,
        debug_logging: typing.Optional[builtins.bool] = None,
        iam_auth: typing.Optional[builtins.bool] = None,
        idle_client_timeout: typing.Optional[_Duration_070aa057] = None,
        init_query: typing.Optional[builtins.str] = None,
        max_connections_percent: typing.Optional[jsii.Number] = None,
        max_idle_connections_percent: typing.Optional[jsii.Number] = None,
        require_tls: typing.Optional[builtins.bool] = None,
        role: typing.Optional[_IRole_59af6f50] = None,
        security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
        session_pinning_filters: typing.Optional[typing.Sequence[SessionPinningFilter]] = None,
        vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> "DatabaseProxy":
        '''(experimental) Add a new db proxy to this cluster.

        :param id: -
        :param secrets: (experimental) The secret that the proxy uses to authenticate to the RDS DB instance or Aurora DB cluster. These secrets are stored within Amazon Secrets Manager. One or more secrets are required.
        :param vpc: (experimental) The VPC to associate with the new proxy.
        :param borrow_timeout: (experimental) The duration for a proxy to wait for a connection to become available in the connection pool. Only applies when the proxy has opened its maximum number of connections and all connections are busy with client sessions. Value must be between 1 second and 1 hour, or ``Duration.seconds(0)`` to represent unlimited. Default: cdk.Duration.seconds(120)
        :param db_proxy_name: (experimental) The identifier for the proxy. This name must be unique for all proxies owned by your AWS account in the specified AWS Region. An identifier must begin with a letter and must contain only ASCII letters, digits, and hyphens; it can't end with a hyphen or contain two consecutive hyphens. Default: - Generated by CloudFormation (recommended)
        :param debug_logging: (experimental) Whether the proxy includes detailed information about SQL statements in its logs. This information helps you to debug issues involving SQL behavior or the performance and scalability of the proxy connections. The debug information includes the text of SQL statements that you submit through the proxy. Thus, only enable this setting when needed for debugging, and only when you have security measures in place to safeguard any sensitive information that appears in the logs. Default: false
        :param iam_auth: (experimental) Whether to require or disallow AWS Identity and Access Management (IAM) authentication for connections to the proxy. Default: false
        :param idle_client_timeout: (experimental) The number of seconds that a connection to the proxy can be inactive before the proxy disconnects it. You can set this value higher or lower than the connection timeout limit for the associated database. Default: cdk.Duration.minutes(30)
        :param init_query: (experimental) One or more SQL statements for the proxy to run when opening each new database connection. Typically used with SET statements to make sure that each connection has identical settings such as time zone and character set. For multiple statements, use semicolons as the separator. You can also include multiple variables in a single SET statement, such as SET x=1, y=2. not currently supported for PostgreSQL. Default: - no initialization query
        :param max_connections_percent: (experimental) The maximum size of the connection pool for each target in a target group. For Aurora MySQL, it is expressed as a percentage of the max_connections setting for the RDS DB instance or Aurora DB cluster used by the target group. 1-100 Default: 100
        :param max_idle_connections_percent: (experimental) Controls how actively the proxy closes idle database connections in the connection pool. A high value enables the proxy to leave a high percentage of idle connections open. A low value causes the proxy to close idle client connections and return the underlying database connections to the connection pool. For Aurora MySQL, it is expressed as a percentage of the max_connections setting for the RDS DB instance or Aurora DB cluster used by the target group. between 0 and MaxConnectionsPercent Default: 50
        :param require_tls: (experimental) A Boolean parameter that specifies whether Transport Layer Security (TLS) encryption is required for connections to the proxy. By enabling this setting, you can enforce encrypted TLS connections to the proxy. Default: true
        :param role: (experimental) IAM role that the proxy uses to access secrets in AWS Secrets Manager. Default: - A role will automatically be created
        :param security_groups: (experimental) One or more VPC security groups to associate with the new proxy. Default: - No security groups
        :param session_pinning_filters: (experimental) Each item in the list represents a class of SQL operations that normally cause all later statements in a session using a proxy to be pinned to the same underlying database connection. Including an item in the list exempts that class of SQL operations from the pinning behavior. Default: - no session pinning filters
        :param vpc_subnets: (experimental) The subnets used by the proxy. Default: - the VPC default strategy if not specified.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__75766e271c3f5c091bf6ce657282c17c6307b632b99c2523b9d7880b081c0d01)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        options = DatabaseProxyOptions(
            secrets=secrets,
            vpc=vpc,
            borrow_timeout=borrow_timeout,
            db_proxy_name=db_proxy_name,
            debug_logging=debug_logging,
            iam_auth=iam_auth,
            idle_client_timeout=idle_client_timeout,
            init_query=init_query,
            max_connections_percent=max_connections_percent,
            max_idle_connections_percent=max_idle_connections_percent,
            require_tls=require_tls,
            role=role,
            security_groups=security_groups,
            session_pinning_filters=session_pinning_filters,
            vpc_subnets=vpc_subnets,
        )

        return typing.cast("DatabaseProxy", jsii.invoke(self, "addProxy", [id, options]))

    @jsii.member(jsii_name="asSecretAttachmentTarget")
    def as_secret_attachment_target(self) -> _SecretAttachmentTargetProps_ab8522eb:
        '''(experimental) Renders the secret attachment target specifications.

        :stability: experimental
        '''
        return typing.cast(_SecretAttachmentTargetProps_ab8522eb, jsii.invoke(self, "asSecretAttachmentTarget", []))

    @jsii.member(jsii_name="metric")
    def metric(
        self,
        metric_name: builtins.str,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) Return the given named metric for this DBCluster.

        :param metric_name: -
        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dd44afa3757812a08c93c3a61edfa0c9c0279e08758f3139db41c2ed6c7ef3b6)
            check_type(argname="argument metric_name", value=metric_name, expected_type=type_hints["metric_name"])
        props = _MetricOptions_1c185ae8(
            account=account,
            color=color,
            dimensions=dimensions,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_5b2b8e58, jsii.invoke(self, "metric", [metric_name, props]))

    @jsii.member(jsii_name="metricCPUUtilization")
    def metric_cpu_utilization(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The percentage of CPU utilization.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        props = _MetricOptions_1c185ae8(
            account=account,
            color=color,
            dimensions=dimensions,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_5b2b8e58, jsii.invoke(self, "metricCPUUtilization", [props]))

    @jsii.member(jsii_name="metricDatabaseConnections")
    def metric_database_connections(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The number of database connections in use.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        props = _MetricOptions_1c185ae8(
            account=account,
            color=color,
            dimensions=dimensions,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_5b2b8e58, jsii.invoke(self, "metricDatabaseConnections", [props]))

    @jsii.member(jsii_name="metricDeadlocks")
    def metric_deadlocks(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The average number of deadlocks in the database per second.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        props = _MetricOptions_1c185ae8(
            account=account,
            color=color,
            dimensions=dimensions,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_5b2b8e58, jsii.invoke(self, "metricDeadlocks", [props]))

    @jsii.member(jsii_name="metricEngineUptime")
    def metric_engine_uptime(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The amount of time that the instance has been running, in seconds.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        props = _MetricOptions_1c185ae8(
            account=account,
            color=color,
            dimensions=dimensions,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_5b2b8e58, jsii.invoke(self, "metricEngineUptime", [props]))

    @jsii.member(jsii_name="metricFreeableMemory")
    def metric_freeable_memory(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The amount of available random access memory, in bytes.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        props = _MetricOptions_1c185ae8(
            account=account,
            color=color,
            dimensions=dimensions,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_5b2b8e58, jsii.invoke(self, "metricFreeableMemory", [props]))

    @jsii.member(jsii_name="metricFreeLocalStorage")
    def metric_free_local_storage(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The amount of local storage available, in bytes.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        props = _MetricOptions_1c185ae8(
            account=account,
            color=color,
            dimensions=dimensions,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_5b2b8e58, jsii.invoke(self, "metricFreeLocalStorage", [props]))

    @jsii.member(jsii_name="metricNetworkReceiveThroughput")
    def metric_network_receive_throughput(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The amount of network throughput received from clients by each instance, in bytes per second.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        props = _MetricOptions_1c185ae8(
            account=account,
            color=color,
            dimensions=dimensions,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_5b2b8e58, jsii.invoke(self, "metricNetworkReceiveThroughput", [props]))

    @jsii.member(jsii_name="metricNetworkThroughput")
    def metric_network_throughput(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The amount of network throughput both received from and transmitted to clients by each instance, in bytes per second.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        props = _MetricOptions_1c185ae8(
            account=account,
            color=color,
            dimensions=dimensions,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_5b2b8e58, jsii.invoke(self, "metricNetworkThroughput", [props]))

    @jsii.member(jsii_name="metricNetworkTransmitThroughput")
    def metric_network_transmit_throughput(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The amount of network throughput sent to clients by each instance, in bytes per second.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        props = _MetricOptions_1c185ae8(
            account=account,
            color=color,
            dimensions=dimensions,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_5b2b8e58, jsii.invoke(self, "metricNetworkTransmitThroughput", [props]))

    @jsii.member(jsii_name="metricSnapshotStorageUsed")
    def metric_snapshot_storage_used(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The total amount of backup storage in bytes consumed by all Aurora snapshots outside its backup retention window.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        props = _MetricOptions_1c185ae8(
            account=account,
            color=color,
            dimensions=dimensions,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_5b2b8e58, jsii.invoke(self, "metricSnapshotStorageUsed", [props]))

    @jsii.member(jsii_name="metricTotalBackupStorageBilled")
    def metric_total_backup_storage_billed(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The total amount of backup storage in bytes for which you are billed.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        props = _MetricOptions_1c185ae8(
            account=account,
            color=color,
            dimensions=dimensions,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_5b2b8e58, jsii.invoke(self, "metricTotalBackupStorageBilled", [props]))

    @jsii.member(jsii_name="metricVolumeBytesUsed")
    def metric_volume_bytes_used(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The amount of storage used by your Aurora DB instance, in bytes.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        props = _MetricOptions_1c185ae8(
            account=account,
            color=color,
            dimensions=dimensions,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_5b2b8e58, jsii.invoke(self, "metricVolumeBytesUsed", [props]))

    @jsii.member(jsii_name="metricVolumeReadIOPs")
    def metric_volume_read_io_ps(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The number of billed read I/O operations from a cluster volume, reported at 5-minute intervals.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        props = _MetricOptions_1c185ae8(
            account=account,
            color=color,
            dimensions=dimensions,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_5b2b8e58, jsii.invoke(self, "metricVolumeReadIOPs", [props]))

    @jsii.member(jsii_name="metricVolumeWriteIOPs")
    def metric_volume_write_io_ps(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The number of write disk I/O operations to the cluster volume, reported at 5-minute intervals.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        props = _MetricOptions_1c185ae8(
            account=account,
            color=color,
            dimensions=dimensions,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_5b2b8e58, jsii.invoke(self, "metricVolumeWriteIOPs", [props]))

    @builtins.property
    @jsii.member(jsii_name="clusterEndpoint")
    @abc.abstractmethod
    def cluster_endpoint(self) -> Endpoint:
        '''(experimental) The endpoint to use for read/write operations.

        :stability: experimental
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="clusterIdentifier")
    @abc.abstractmethod
    def cluster_identifier(self) -> builtins.str:
        '''(experimental) Identifier of the cluster.

        :stability: experimental
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="clusterReadEndpoint")
    @abc.abstractmethod
    def cluster_read_endpoint(self) -> Endpoint:
        '''(experimental) Endpoint to use for load-balanced read-only operations.

        :stability: experimental
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="connections")
    @abc.abstractmethod
    def connections(self) -> _Connections_57ccbda9:
        '''(experimental) Access to the network connections.

        :stability: experimental
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="instanceEndpoints")
    @abc.abstractmethod
    def instance_endpoints(self) -> typing.List[Endpoint]:
        '''(experimental) Endpoints which address each individual replica.

        :stability: experimental
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="instanceIdentifiers")
    @abc.abstractmethod
    def instance_identifiers(self) -> typing.List[builtins.str]:
        '''(experimental) Identifiers of the replicas.

        :stability: experimental
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="engine")
    @abc.abstractmethod
    def engine(self) -> typing.Optional["IClusterEngine"]:
        '''(experimental) The engine of this Cluster.

        May be not known for imported Clusters if it wasn't provided explicitly.

        :stability: experimental
        '''
        ...


class _DatabaseClusterBaseProxy(
    DatabaseClusterBase,
    jsii.proxy_for(_Resource_abff4495), # type: ignore[misc]
):
    @builtins.property
    @jsii.member(jsii_name="clusterEndpoint")
    def cluster_endpoint(self) -> Endpoint:
        '''(experimental) The endpoint to use for read/write operations.

        :stability: experimental
        '''
        return typing.cast(Endpoint, jsii.get(self, "clusterEndpoint"))

    @builtins.property
    @jsii.member(jsii_name="clusterIdentifier")
    def cluster_identifier(self) -> builtins.str:
        '''(experimental) Identifier of the cluster.

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "clusterIdentifier"))

    @builtins.property
    @jsii.member(jsii_name="clusterReadEndpoint")
    def cluster_read_endpoint(self) -> Endpoint:
        '''(experimental) Endpoint to use for load-balanced read-only operations.

        :stability: experimental
        '''
        return typing.cast(Endpoint, jsii.get(self, "clusterReadEndpoint"))

    @builtins.property
    @jsii.member(jsii_name="connections")
    def connections(self) -> _Connections_57ccbda9:
        '''(experimental) Access to the network connections.

        :stability: experimental
        '''
        return typing.cast(_Connections_57ccbda9, jsii.get(self, "connections"))

    @builtins.property
    @jsii.member(jsii_name="instanceEndpoints")
    def instance_endpoints(self) -> typing.List[Endpoint]:
        '''(experimental) Endpoints which address each individual replica.

        :stability: experimental
        '''
        return typing.cast(typing.List[Endpoint], jsii.get(self, "instanceEndpoints"))

    @builtins.property
    @jsii.member(jsii_name="instanceIdentifiers")
    def instance_identifiers(self) -> typing.List[builtins.str]:
        '''(experimental) Identifiers of the replicas.

        :stability: experimental
        '''
        return typing.cast(typing.List[builtins.str], jsii.get(self, "instanceIdentifiers"))

    @builtins.property
    @jsii.member(jsii_name="engine")
    def engine(self) -> typing.Optional["IClusterEngine"]:
        '''(experimental) The engine of this Cluster.

        May be not known for imported Clusters if it wasn't provided explicitly.

        :stability: experimental
        '''
        return typing.cast(typing.Optional["IClusterEngine"], jsii.get(self, "engine"))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, DatabaseClusterBase).__jsii_proxy_class__ = lambda : _DatabaseClusterBaseProxy


class DatabaseClusterFromSnapshot(
    DatabaseClusterBase,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_rds.DatabaseClusterFromSnapshot",
):
    '''(experimental) A database cluster restored from a snapshot.

    :stability: experimental
    :resource: AWS::RDS::DBInstance
    :exampleMetadata: infused

    Example::

        # vpc: ec2.Vpc
        
        rds.DatabaseClusterFromSnapshot(self, "Database",
            engine=rds.DatabaseClusterEngine.aurora(version=rds.AuroraEngineVersion.VER_1_22_2),
            instance_props=ec2.aws_rds.InstanceProps(
                vpc=vpc
            ),
            snapshot_identifier="mySnapshot"
        )
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        engine: "IClusterEngine",
        instance_props: typing.Union[InstanceProps, typing.Dict[builtins.str, typing.Any]],
        snapshot_identifier: builtins.str,
        backtrack_window: typing.Optional[_Duration_070aa057] = None,
        backup: typing.Optional[typing.Union[BackupProps, typing.Dict[builtins.str, typing.Any]]] = None,
        cloudwatch_logs_exports: typing.Optional[typing.Sequence[builtins.str]] = None,
        cloudwatch_logs_retention: typing.Optional[_RetentionDays_6c560d31] = None,
        cloudwatch_logs_retention_role: typing.Optional[_IRole_59af6f50] = None,
        cluster_identifier: typing.Optional[builtins.str] = None,
        copy_tags_to_snapshot: typing.Optional[builtins.bool] = None,
        credentials: typing.Optional[Credentials] = None,
        default_database_name: typing.Optional[builtins.str] = None,
        deletion_protection: typing.Optional[builtins.bool] = None,
        iam_authentication: typing.Optional[builtins.bool] = None,
        instance_identifier_base: typing.Optional[builtins.str] = None,
        instances: typing.Optional[jsii.Number] = None,
        monitoring_interval: typing.Optional[_Duration_070aa057] = None,
        monitoring_role: typing.Optional[_IRole_59af6f50] = None,
        parameter_group: typing.Optional[IParameterGroup] = None,
        parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        port: typing.Optional[jsii.Number] = None,
        preferred_maintenance_window: typing.Optional[builtins.str] = None,
        removal_policy: typing.Optional[_RemovalPolicy_c97e7a20] = None,
        s3_export_buckets: typing.Optional[typing.Sequence[_IBucket_73486e29]] = None,
        s3_export_role: typing.Optional[_IRole_59af6f50] = None,
        s3_import_buckets: typing.Optional[typing.Sequence[_IBucket_73486e29]] = None,
        s3_import_role: typing.Optional[_IRole_59af6f50] = None,
        storage_encrypted: typing.Optional[builtins.bool] = None,
        storage_encryption_key: typing.Optional[_IKey_36930160] = None,
        subnet_group: typing.Optional[ISubnetGroup] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param engine: (experimental) What kind of database to start.
        :param instance_props: (experimental) Settings for the individual instances that are launched.
        :param snapshot_identifier: (experimental) The identifier for the DB instance snapshot or DB cluster snapshot to restore from. You can use either the name or the Amazon Resource Name (ARN) to specify a DB cluster snapshot. However, you can use only the ARN to specify a DB instance snapshot.
        :param backtrack_window: (experimental) The number of seconds to set a cluster's target backtrack window to. This feature is only supported by the Aurora MySQL database engine and cannot be enabled on existing clusters. Default: 0 seconds (no backtrack)
        :param backup: (experimental) Backup settings. Default: - Backup retention period for automated backups is 1 day. Backup preferred window is set to a 30-minute window selected at random from an 8-hour block of time for each AWS Region, occurring on a random day of the week.
        :param cloudwatch_logs_exports: (experimental) The list of log types that need to be enabled for exporting to CloudWatch Logs. Default: - no log exports
        :param cloudwatch_logs_retention: (experimental) The number of days log events are kept in CloudWatch Logs. When updating this property, unsetting it doesn't remove the log retention policy. To remove the retention policy, set the value to ``Infinity``. Default: - logs never expire
        :param cloudwatch_logs_retention_role: (experimental) The IAM role for the Lambda function associated with the custom resource that sets the retention policy. Default: - a new role is created.
        :param cluster_identifier: (experimental) An optional identifier for the cluster. Default: - A name is automatically generated.
        :param copy_tags_to_snapshot: (experimental) Whether to copy tags to the snapshot when a snapshot is created. Default: - true
        :param credentials: (experimental) Credentials for the administrative user. Default: - A username of 'admin' (or 'postgres' for PostgreSQL) and SecretsManager-generated password
        :param default_database_name: (experimental) Name of a database which is automatically created inside the cluster. Default: - Database is not created in cluster.
        :param deletion_protection: (experimental) Indicates whether the DB cluster should have deletion protection enabled. Default: - true if ``removalPolicy`` is RETAIN, false otherwise
        :param iam_authentication: (experimental) Whether to enable mapping of AWS Identity and Access Management (IAM) accounts to database accounts. Default: false
        :param instance_identifier_base: (experimental) Base identifier for instances. Every replica is named by appending the replica number to this string, 1-based. Default: - clusterIdentifier is used with the word "Instance" appended. If clusterIdentifier is not provided, the identifier is automatically generated.
        :param instances: (experimental) How many replicas/instances to create. Has to be at least 1. Default: 2
        :param monitoring_interval: (experimental) The interval, in seconds, between points when Amazon RDS collects enhanced monitoring metrics for the DB instances. Default: no enhanced monitoring
        :param monitoring_role: (experimental) Role that will be used to manage DB instances monitoring. Default: - A role is automatically created for you
        :param parameter_group: (experimental) Additional parameters to pass to the database engine. Default: - No parameter group.
        :param parameters: (experimental) The parameters in the DBClusterParameterGroup to create automatically. You can only specify parameterGroup or parameters but not both. You need to use a versioned engine to auto-generate a DBClusterParameterGroup. Default: - None
        :param port: (experimental) What port to listen on. Default: - The default for the engine is used.
        :param preferred_maintenance_window: (experimental) A preferred maintenance window day/time range. Should be specified as a range ddd:hh24:mi-ddd:hh24:mi (24H Clock UTC). Example: 'Sun:23:45-Mon:00:15' Default: - 30-minute window selected at random from an 8-hour block of time for each AWS Region, occurring on a random day of the week.
        :param removal_policy: (experimental) The removal policy to apply when the cluster and its instances are removed from the stack or replaced during an update. Default: - RemovalPolicy.SNAPSHOT (remove the cluster and instances, but retain a snapshot of the data)
        :param s3_export_buckets: (experimental) S3 buckets that you want to load data into. This feature is only supported by the Aurora database engine. This property must not be used if ``s3ExportRole`` is used. For MySQL: Default: - None
        :param s3_export_role: (experimental) Role that will be associated with this DB cluster to enable S3 export. This feature is only supported by the Aurora database engine. This property must not be used if ``s3ExportBuckets`` is used. For MySQL: Default: - New role is created if ``s3ExportBuckets`` is set, no role is defined otherwise
        :param s3_import_buckets: (experimental) S3 buckets that you want to load data from. This feature is only supported by the Aurora database engine. This property must not be used if ``s3ImportRole`` is used. For MySQL: Default: - None
        :param s3_import_role: (experimental) Role that will be associated with this DB cluster to enable S3 import. This feature is only supported by the Aurora database engine. This property must not be used if ``s3ImportBuckets`` is used. For MySQL: Default: - New role is created if ``s3ImportBuckets`` is set, no role is defined otherwise
        :param storage_encrypted: (experimental) Whether to enable storage encryption. Default: - true if storageEncryptionKey is provided, false otherwise
        :param storage_encryption_key: (experimental) The KMS key for storage encryption. If specified, {@link storageEncrypted} will be set to ``true``. Default: - if storageEncrypted is true then the default master key, no key otherwise
        :param subnet_group: (experimental) Existing subnet group for the cluster. Default: - a new subnet group will be created.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4a1fb5e2feb43f6d5ecb5aa4ff4c30bd8606c8066dceda258312f08f023e731e)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = DatabaseClusterFromSnapshotProps(
            engine=engine,
            instance_props=instance_props,
            snapshot_identifier=snapshot_identifier,
            backtrack_window=backtrack_window,
            backup=backup,
            cloudwatch_logs_exports=cloudwatch_logs_exports,
            cloudwatch_logs_retention=cloudwatch_logs_retention,
            cloudwatch_logs_retention_role=cloudwatch_logs_retention_role,
            cluster_identifier=cluster_identifier,
            copy_tags_to_snapshot=copy_tags_to_snapshot,
            credentials=credentials,
            default_database_name=default_database_name,
            deletion_protection=deletion_protection,
            iam_authentication=iam_authentication,
            instance_identifier_base=instance_identifier_base,
            instances=instances,
            monitoring_interval=monitoring_interval,
            monitoring_role=monitoring_role,
            parameter_group=parameter_group,
            parameters=parameters,
            port=port,
            preferred_maintenance_window=preferred_maintenance_window,
            removal_policy=removal_policy,
            s3_export_buckets=s3_export_buckets,
            s3_export_role=s3_export_role,
            s3_import_buckets=s3_import_buckets,
            s3_import_role=s3_import_role,
            storage_encrypted=storage_encrypted,
            storage_encryption_key=storage_encryption_key,
            subnet_group=subnet_group,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="addRotationMultiUser")
    def add_rotation_multi_user(
        self,
        id: builtins.str,
        *,
        secret: _ISecret_22fb8757,
        automatically_after: typing.Optional[_Duration_070aa057] = None,
        endpoint: typing.Optional[_IInterfaceVpcEndpoint_6081623d] = None,
        exclude_characters: typing.Optional[builtins.str] = None,
        vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> _SecretRotation_e64158ad:
        '''(experimental) Adds the multi user rotation to this cluster.

        :param id: -
        :param secret: (experimental) The secret to rotate. It must be a JSON string with the following format:: { "engine": <required: database engine>, "host": <required: instance host name>, "username": <required: username>, "password": <required: password>, "dbname": <optional: database name>, "port": <optional: if not specified, default port will be used>, "masterarn": <required: the arn of the master secret which will be used to create users/change passwords> }
        :param automatically_after: (experimental) Specifies the number of days after the previous rotation before Secrets Manager triggers the next automatic rotation. Default: - 30 days
        :param endpoint: (experimental) The VPC interface endpoint to use for the Secrets Manager API. If you enable private DNS hostnames for your VPC private endpoint (the default), you don't need to specify an endpoint. The standard Secrets Manager DNS hostname the Secrets Manager CLI and SDKs use by default (https://secretsmanager..amazonaws.com) automatically resolves to your VPC endpoint. Default: https://secretsmanager..amazonaws.com
        :param exclude_characters: (experimental) Specifies characters to not include in generated passwords. Default: " %+~`#$&*()|[]{}:;<>?!'/
        :param vpc_subnets: (experimental) Where to place the rotation Lambda function. Default: - same placement as instance or cluster

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cc10a92d598a414e11858ab08ef64463c3866beee755f08c5bc6a4a5916a9765)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        options = RotationMultiUserOptions(
            secret=secret,
            automatically_after=automatically_after,
            endpoint=endpoint,
            exclude_characters=exclude_characters,
            vpc_subnets=vpc_subnets,
        )

        return typing.cast(_SecretRotation_e64158ad, jsii.invoke(self, "addRotationMultiUser", [id, options]))

    @jsii.member(jsii_name="addRotationSingleUser")
    def add_rotation_single_user(
        self,
        *,
        automatically_after: typing.Optional[_Duration_070aa057] = None,
        endpoint: typing.Optional[_IInterfaceVpcEndpoint_6081623d] = None,
        exclude_characters: typing.Optional[builtins.str] = None,
        vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> _SecretRotation_e64158ad:
        '''(experimental) Adds the single user rotation of the master password to this cluster.

        :param automatically_after: (experimental) Specifies the number of days after the previous rotation before Secrets Manager triggers the next automatic rotation. Default: - 30 days
        :param endpoint: (experimental) The VPC interface endpoint to use for the Secrets Manager API. If you enable private DNS hostnames for your VPC private endpoint (the default), you don't need to specify an endpoint. The standard Secrets Manager DNS hostname the Secrets Manager CLI and SDKs use by default (https://secretsmanager..amazonaws.com) automatically resolves to your VPC endpoint. Default: https://secretsmanager..amazonaws.com
        :param exclude_characters: (experimental) Specifies characters to not include in generated passwords. Default: " %+~`#$&*()|[]{}:;<>?!'/
        :param vpc_subnets: (experimental) Where to place the rotation Lambda function. Default: - same placement as instance or cluster

        :stability: experimental
        '''
        options = RotationSingleUserOptions(
            automatically_after=automatically_after,
            endpoint=endpoint,
            exclude_characters=exclude_characters,
            vpc_subnets=vpc_subnets,
        )

        return typing.cast(_SecretRotation_e64158ad, jsii.invoke(self, "addRotationSingleUser", [options]))

    @builtins.property
    @jsii.member(jsii_name="clusterEndpoint")
    def cluster_endpoint(self) -> Endpoint:
        '''(experimental) The endpoint to use for read/write operations.

        :stability: experimental
        '''
        return typing.cast(Endpoint, jsii.get(self, "clusterEndpoint"))

    @builtins.property
    @jsii.member(jsii_name="clusterIdentifier")
    def cluster_identifier(self) -> builtins.str:
        '''(experimental) Identifier of the cluster.

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "clusterIdentifier"))

    @builtins.property
    @jsii.member(jsii_name="clusterReadEndpoint")
    def cluster_read_endpoint(self) -> Endpoint:
        '''(experimental) Endpoint to use for load-balanced read-only operations.

        :stability: experimental
        '''
        return typing.cast(Endpoint, jsii.get(self, "clusterReadEndpoint"))

    @builtins.property
    @jsii.member(jsii_name="connections")
    def connections(self) -> _Connections_57ccbda9:
        '''(experimental) Access to the network connections.

        :stability: experimental
        '''
        return typing.cast(_Connections_57ccbda9, jsii.get(self, "connections"))

    @builtins.property
    @jsii.member(jsii_name="instanceEndpoints")
    def instance_endpoints(self) -> typing.List[Endpoint]:
        '''(experimental) Endpoints which address each individual replica.

        :stability: experimental
        '''
        return typing.cast(typing.List[Endpoint], jsii.get(self, "instanceEndpoints"))

    @builtins.property
    @jsii.member(jsii_name="instanceIdentifiers")
    def instance_identifiers(self) -> typing.List[builtins.str]:
        '''(experimental) Identifiers of the replicas.

        :stability: experimental
        '''
        return typing.cast(typing.List[builtins.str], jsii.get(self, "instanceIdentifiers"))

    @builtins.property
    @jsii.member(jsii_name="multiUserRotationApplication")
    def multi_user_rotation_application(self) -> _SecretRotationApplication_0ac7c5d5:
        '''(experimental) Application for multi user rotation to this cluster.

        :stability: experimental
        '''
        return typing.cast(_SecretRotationApplication_0ac7c5d5, jsii.get(self, "multiUserRotationApplication"))

    @builtins.property
    @jsii.member(jsii_name="newCfnProps")
    def _new_cfn_props(self) -> CfnDBClusterProps:
        '''
        :stability: experimental
        '''
        return typing.cast(CfnDBClusterProps, jsii.get(self, "newCfnProps"))

    @builtins.property
    @jsii.member(jsii_name="securityGroups")
    def _security_groups(self) -> typing.List[_ISecurityGroup_cdbba9d3]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[_ISecurityGroup_cdbba9d3], jsii.get(self, "securityGroups"))

    @builtins.property
    @jsii.member(jsii_name="singleUserRotationApplication")
    def single_user_rotation_application(self) -> _SecretRotationApplication_0ac7c5d5:
        '''(experimental) Application for single user rotation of the master password to this cluster.

        :stability: experimental
        '''
        return typing.cast(_SecretRotationApplication_0ac7c5d5, jsii.get(self, "singleUserRotationApplication"))

    @builtins.property
    @jsii.member(jsii_name="subnetGroup")
    def _subnet_group(self) -> ISubnetGroup:
        '''
        :stability: experimental
        '''
        return typing.cast(ISubnetGroup, jsii.get(self, "subnetGroup"))

    @builtins.property
    @jsii.member(jsii_name="vpc")
    def vpc(self) -> _IVpc_6d1f76c4:
        '''(experimental) The VPC network to place the cluster in.

        :stability: experimental
        '''
        return typing.cast(_IVpc_6d1f76c4, jsii.get(self, "vpc"))

    @builtins.property
    @jsii.member(jsii_name="engine")
    def engine(self) -> typing.Optional["IClusterEngine"]:
        '''(experimental) The engine for this Cluster.

        Never undefined.

        :stability: experimental
        '''
        return typing.cast(typing.Optional["IClusterEngine"], jsii.get(self, "engine"))

    @builtins.property
    @jsii.member(jsii_name="secret")
    def secret(self) -> typing.Optional[_ISecret_22fb8757]:
        '''(experimental) The secret attached to this cluster.

        :stability: experimental
        '''
        return typing.cast(typing.Optional[_ISecret_22fb8757], jsii.get(self, "secret"))

    @builtins.property
    @jsii.member(jsii_name="vpcSubnets")
    def vpc_subnets(self) -> typing.Optional[_SubnetSelection_1284e62c]:
        '''(experimental) The cluster's subnets.

        :stability: experimental
        '''
        return typing.cast(typing.Optional[_SubnetSelection_1284e62c], jsii.get(self, "vpcSubnets"))


@jsii.implements(IDatabaseInstance)
class DatabaseInstanceBase(
    _Resource_abff4495,
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="monocdk.aws_rds.DatabaseInstanceBase",
):
    '''(experimental) A new or imported database instance.

    :stability: experimental
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from monocdk import aws_ec2 as ec2
        from monocdk import aws_rds as rds
        
        # instance_engine: rds.IInstanceEngine
        # security_group: ec2.SecurityGroup
        
        database_instance_base = rds.DatabaseInstanceBase.from_database_instance_attributes(self, "MyDatabaseInstanceBase",
            instance_endpoint_address="instanceEndpointAddress",
            instance_identifier="instanceIdentifier",
            port=123,
            security_groups=[security_group],
        
            # the properties below are optional
            engine=instance_engine
        )
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        account: typing.Optional[builtins.str] = None,
        environment_from_arn: typing.Optional[builtins.str] = None,
        physical_name: typing.Optional[builtins.str] = None,
        region: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param account: (experimental) The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
        :param environment_from_arn: (experimental) ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
        :param physical_name: (experimental) The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
        :param region: (experimental) The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4ab24e4025a70ea135fbc9a5e34af9947cd775417747d8037f4ddce95d0dc4ad)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _ResourceProps_9b554c0f(
            account=account,
            environment_from_arn=environment_from_arn,
            physical_name=physical_name,
            region=region,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="fromDatabaseInstanceAttributes")
    @builtins.classmethod
    def from_database_instance_attributes(
        cls,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        instance_endpoint_address: builtins.str,
        instance_identifier: builtins.str,
        port: jsii.Number,
        security_groups: typing.Sequence[_ISecurityGroup_cdbba9d3],
        engine: typing.Optional[IInstanceEngine] = None,
    ) -> IDatabaseInstance:
        '''(experimental) Import an existing database instance.

        :param scope: -
        :param id: -
        :param instance_endpoint_address: (experimental) The endpoint address.
        :param instance_identifier: (experimental) The instance identifier.
        :param port: (experimental) The database port.
        :param security_groups: (experimental) The security groups of the instance.
        :param engine: (experimental) The engine of the existing database Instance. Default: - the imported Instance's engine is unknown

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ee1427d6f2e8781e9c421ec58b331d3ff172574263d962e8207f47d772838ad7)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        attrs = DatabaseInstanceAttributes(
            instance_endpoint_address=instance_endpoint_address,
            instance_identifier=instance_identifier,
            port=port,
            security_groups=security_groups,
            engine=engine,
        )

        return typing.cast(IDatabaseInstance, jsii.sinvoke(cls, "fromDatabaseInstanceAttributes", [scope, id, attrs]))

    @jsii.member(jsii_name="addProxy")
    def add_proxy(
        self,
        id: builtins.str,
        *,
        secrets: typing.Sequence[_ISecret_22fb8757],
        vpc: _IVpc_6d1f76c4,
        borrow_timeout: typing.Optional[_Duration_070aa057] = None,
        db_proxy_name: typing.Optional[builtins.str] = None,
        debug_logging: typing.Optional[builtins.bool] = None,
        iam_auth: typing.Optional[builtins.bool] = None,
        idle_client_timeout: typing.Optional[_Duration_070aa057] = None,
        init_query: typing.Optional[builtins.str] = None,
        max_connections_percent: typing.Optional[jsii.Number] = None,
        max_idle_connections_percent: typing.Optional[jsii.Number] = None,
        require_tls: typing.Optional[builtins.bool] = None,
        role: typing.Optional[_IRole_59af6f50] = None,
        security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
        session_pinning_filters: typing.Optional[typing.Sequence[SessionPinningFilter]] = None,
        vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> "DatabaseProxy":
        '''(experimental) Add a new db proxy to this instance.

        :param id: -
        :param secrets: (experimental) The secret that the proxy uses to authenticate to the RDS DB instance or Aurora DB cluster. These secrets are stored within Amazon Secrets Manager. One or more secrets are required.
        :param vpc: (experimental) The VPC to associate with the new proxy.
        :param borrow_timeout: (experimental) The duration for a proxy to wait for a connection to become available in the connection pool. Only applies when the proxy has opened its maximum number of connections and all connections are busy with client sessions. Value must be between 1 second and 1 hour, or ``Duration.seconds(0)`` to represent unlimited. Default: cdk.Duration.seconds(120)
        :param db_proxy_name: (experimental) The identifier for the proxy. This name must be unique for all proxies owned by your AWS account in the specified AWS Region. An identifier must begin with a letter and must contain only ASCII letters, digits, and hyphens; it can't end with a hyphen or contain two consecutive hyphens. Default: - Generated by CloudFormation (recommended)
        :param debug_logging: (experimental) Whether the proxy includes detailed information about SQL statements in its logs. This information helps you to debug issues involving SQL behavior or the performance and scalability of the proxy connections. The debug information includes the text of SQL statements that you submit through the proxy. Thus, only enable this setting when needed for debugging, and only when you have security measures in place to safeguard any sensitive information that appears in the logs. Default: false
        :param iam_auth: (experimental) Whether to require or disallow AWS Identity and Access Management (IAM) authentication for connections to the proxy. Default: false
        :param idle_client_timeout: (experimental) The number of seconds that a connection to the proxy can be inactive before the proxy disconnects it. You can set this value higher or lower than the connection timeout limit for the associated database. Default: cdk.Duration.minutes(30)
        :param init_query: (experimental) One or more SQL statements for the proxy to run when opening each new database connection. Typically used with SET statements to make sure that each connection has identical settings such as time zone and character set. For multiple statements, use semicolons as the separator. You can also include multiple variables in a single SET statement, such as SET x=1, y=2. not currently supported for PostgreSQL. Default: - no initialization query
        :param max_connections_percent: (experimental) The maximum size of the connection pool for each target in a target group. For Aurora MySQL, it is expressed as a percentage of the max_connections setting for the RDS DB instance or Aurora DB cluster used by the target group. 1-100 Default: 100
        :param max_idle_connections_percent: (experimental) Controls how actively the proxy closes idle database connections in the connection pool. A high value enables the proxy to leave a high percentage of idle connections open. A low value causes the proxy to close idle client connections and return the underlying database connections to the connection pool. For Aurora MySQL, it is expressed as a percentage of the max_connections setting for the RDS DB instance or Aurora DB cluster used by the target group. between 0 and MaxConnectionsPercent Default: 50
        :param require_tls: (experimental) A Boolean parameter that specifies whether Transport Layer Security (TLS) encryption is required for connections to the proxy. By enabling this setting, you can enforce encrypted TLS connections to the proxy. Default: true
        :param role: (experimental) IAM role that the proxy uses to access secrets in AWS Secrets Manager. Default: - A role will automatically be created
        :param security_groups: (experimental) One or more VPC security groups to associate with the new proxy. Default: - No security groups
        :param session_pinning_filters: (experimental) Each item in the list represents a class of SQL operations that normally cause all later statements in a session using a proxy to be pinned to the same underlying database connection. Including an item in the list exempts that class of SQL operations from the pinning behavior. Default: - no session pinning filters
        :param vpc_subnets: (experimental) The subnets used by the proxy. Default: - the VPC default strategy if not specified.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e36deb15b067ffab9bfc343baf4c382594e4573778c86ae209e6e8190d9aea5a)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        options = DatabaseProxyOptions(
            secrets=secrets,
            vpc=vpc,
            borrow_timeout=borrow_timeout,
            db_proxy_name=db_proxy_name,
            debug_logging=debug_logging,
            iam_auth=iam_auth,
            idle_client_timeout=idle_client_timeout,
            init_query=init_query,
            max_connections_percent=max_connections_percent,
            max_idle_connections_percent=max_idle_connections_percent,
            require_tls=require_tls,
            role=role,
            security_groups=security_groups,
            session_pinning_filters=session_pinning_filters,
            vpc_subnets=vpc_subnets,
        )

        return typing.cast("DatabaseProxy", jsii.invoke(self, "addProxy", [id, options]))

    @jsii.member(jsii_name="asSecretAttachmentTarget")
    def as_secret_attachment_target(self) -> _SecretAttachmentTargetProps_ab8522eb:
        '''(experimental) Renders the secret attachment target specifications.

        :stability: experimental
        '''
        return typing.cast(_SecretAttachmentTargetProps_ab8522eb, jsii.invoke(self, "asSecretAttachmentTarget", []))

    @jsii.member(jsii_name="grantConnect")
    def grant_connect(self, grantee: _IGrantable_4c5a91d1) -> _Grant_bcb5eae7:
        '''(experimental) Grant the given identity connection access to the database.

        **Note**: this method does not currently work, see https://github.com/aws/aws-cdk/issues/11851 for details.

        :param grantee: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a6bdf2abeb04fa1086542575d5e77e395c2ab5427948b0e8936489aa5634e2a2)
            check_type(argname="argument grantee", value=grantee, expected_type=type_hints["grantee"])
        return typing.cast(_Grant_bcb5eae7, jsii.invoke(self, "grantConnect", [grantee]))

    @jsii.member(jsii_name="metric")
    def metric(
        self,
        metric_name: builtins.str,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) Return the given named metric for this DBInstance.

        :param metric_name: -
        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cb214af6808d327243fed9a086e2708146880ce10bb7cd717b694908080fdfbb)
            check_type(argname="argument metric_name", value=metric_name, expected_type=type_hints["metric_name"])
        props = _MetricOptions_1c185ae8(
            account=account,
            color=color,
            dimensions=dimensions,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_5b2b8e58, jsii.invoke(self, "metric", [metric_name, props]))

    @jsii.member(jsii_name="metricCPUUtilization")
    def metric_cpu_utilization(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The percentage of CPU utilization.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        props = _MetricOptions_1c185ae8(
            account=account,
            color=color,
            dimensions=dimensions,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_5b2b8e58, jsii.invoke(self, "metricCPUUtilization", [props]))

    @jsii.member(jsii_name="metricDatabaseConnections")
    def metric_database_connections(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The number of database connections in use.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        props = _MetricOptions_1c185ae8(
            account=account,
            color=color,
            dimensions=dimensions,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_5b2b8e58, jsii.invoke(self, "metricDatabaseConnections", [props]))

    @jsii.member(jsii_name="metricFreeableMemory")
    def metric_freeable_memory(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The amount of available random access memory.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        props = _MetricOptions_1c185ae8(
            account=account,
            color=color,
            dimensions=dimensions,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_5b2b8e58, jsii.invoke(self, "metricFreeableMemory", [props]))

    @jsii.member(jsii_name="metricFreeStorageSpace")
    def metric_free_storage_space(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The amount of available storage space.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        props = _MetricOptions_1c185ae8(
            account=account,
            color=color,
            dimensions=dimensions,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_5b2b8e58, jsii.invoke(self, "metricFreeStorageSpace", [props]))

    @jsii.member(jsii_name="metricReadIOPS")
    def metric_read_iops(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The average number of disk write I/O operations per second.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        props = _MetricOptions_1c185ae8(
            account=account,
            color=color,
            dimensions=dimensions,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_5b2b8e58, jsii.invoke(self, "metricReadIOPS", [props]))

    @jsii.member(jsii_name="metricWriteIOPS")
    def metric_write_iops(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_070aa057] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_113c79f9] = None,
    ) -> _Metric_5b2b8e58:
        '''(experimental) The average number of disk read I/O operations per second.

        Average over 5 minutes

        :param account: (experimental) Account which this metric comes from. Default: - Deployment account.
        :param color: (experimental) The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions: (deprecated) Dimensions of the metric. Default: - No dimensions.
        :param dimensions_map: (experimental) Dimensions of the metric. Default: - No dimensions.
        :param label: (experimental) Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
        :param period: (experimental) The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: (experimental) Region which this metric comes from. Default: - Deployment region.
        :param statistic: (experimental) What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: (experimental) Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        props = _MetricOptions_1c185ae8(
            account=account,
            color=color,
            dimensions=dimensions,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_5b2b8e58, jsii.invoke(self, "metricWriteIOPS", [props]))

    @jsii.member(jsii_name="onEvent")
    def on_event(
        self,
        id: builtins.str,
        *,
        description: typing.Optional[builtins.str] = None,
        event_pattern: typing.Optional[typing.Union[_EventPattern_a23fbf37, typing.Dict[builtins.str, typing.Any]]] = None,
        rule_name: typing.Optional[builtins.str] = None,
        target: typing.Optional[_IRuleTarget_d45ec729] = None,
    ) -> _Rule_6cfff189:
        '''(experimental) Defines a CloudWatch event rule which triggers for instance events.

        Use
        ``rule.addEventPattern(pattern)`` to specify a filter.

        :param id: -
        :param description: (experimental) A description of the rule's purpose. Default: - No description
        :param event_pattern: (experimental) Additional restrictions for the event to route to the specified target. The method that generates the rule probably imposes some type of event filtering. The filtering implied by what you pass here is added on top of that filtering. Default: - No additional filtering based on an event pattern.
        :param rule_name: (experimental) A name for the rule. Default: AWS CloudFormation generates a unique physical ID.
        :param target: (experimental) The target to register for the event. Default: - No target is added to the rule. Use ``addTarget()`` to add a target.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8df77bf6703f53ef99be278b35aa0c1f0b2dbdd60c88c4ca14f38d17d9ec4457)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        options = _OnEventOptions_d5081088(
            description=description,
            event_pattern=event_pattern,
            rule_name=rule_name,
            target=target,
        )

        return typing.cast(_Rule_6cfff189, jsii.invoke(self, "onEvent", [id, options]))

    @builtins.property
    @jsii.member(jsii_name="connections")
    @abc.abstractmethod
    def connections(self) -> _Connections_57ccbda9:
        '''(experimental) Access to network connections.

        :stability: experimental
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="dbInstanceEndpointAddress")
    @abc.abstractmethod
    def db_instance_endpoint_address(self) -> builtins.str:
        '''(experimental) The instance endpoint address.

        :stability: experimental
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="dbInstanceEndpointPort")
    @abc.abstractmethod
    def db_instance_endpoint_port(self) -> builtins.str:
        '''(experimental) The instance endpoint port.

        :stability: experimental
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="instanceArn")
    def instance_arn(self) -> builtins.str:
        '''(experimental) The instance arn.

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "instanceArn"))

    @builtins.property
    @jsii.member(jsii_name="instanceEndpoint")
    @abc.abstractmethod
    def instance_endpoint(self) -> Endpoint:
        '''(experimental) The instance endpoint.

        :stability: experimental
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="instanceIdentifier")
    @abc.abstractmethod
    def instance_identifier(self) -> builtins.str:
        '''(experimental) The instance identifier.

        :stability: experimental
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="engine")
    @abc.abstractmethod
    def engine(self) -> typing.Optional[IInstanceEngine]:
        '''(experimental) The engine of this database Instance.

        May be not known for imported Instances if it wasn't provided explicitly,
        or for read replicas.

        :stability: experimental
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="enableIamAuthentication")
    @abc.abstractmethod
    def _enable_iam_authentication(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        '''
        ...

    @_enable_iam_authentication.setter
    @abc.abstractmethod
    def _enable_iam_authentication(self, value: typing.Optional[builtins.bool]) -> None:
        ...


class _DatabaseInstanceBaseProxy(
    DatabaseInstanceBase,
    jsii.proxy_for(_Resource_abff4495), # type: ignore[misc]
):
    @builtins.property
    @jsii.member(jsii_name="connections")
    def connections(self) -> _Connections_57ccbda9:
        '''(experimental) Access to network connections.

        :stability: experimental
        '''
        return typing.cast(_Connections_57ccbda9, jsii.get(self, "connections"))

    @builtins.property
    @jsii.member(jsii_name="dbInstanceEndpointAddress")
    def db_instance_endpoint_address(self) -> builtins.str:
        '''(experimental) The instance endpoint address.

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "dbInstanceEndpointAddress"))

    @builtins.property
    @jsii.member(jsii_name="dbInstanceEndpointPort")
    def db_instance_endpoint_port(self) -> builtins.str:
        '''(experimental) The instance endpoint port.

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "dbInstanceEndpointPort"))

    @builtins.property
    @jsii.member(jsii_name="instanceEndpoint")
    def instance_endpoint(self) -> Endpoint:
        '''(experimental) The instance endpoint.

        :stability: experimental
        '''
        return typing.cast(Endpoint, jsii.get(self, "instanceEndpoint"))

    @builtins.property
    @jsii.member(jsii_name="instanceIdentifier")
    def instance_identifier(self) -> builtins.str:
        '''(experimental) The instance identifier.

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "instanceIdentifier"))

    @builtins.property
    @jsii.member(jsii_name="engine")
    def engine(self) -> typing.Optional[IInstanceEngine]:
        '''(experimental) The engine of this database Instance.

        May be not known for imported Instances if it wasn't provided explicitly,
        or for read replicas.

        :stability: experimental
        '''
        return typing.cast(typing.Optional[IInstanceEngine], jsii.get(self, "engine"))

    @builtins.property
    @jsii.member(jsii_name="enableIamAuthentication")
    def _enable_iam_authentication(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "enableIamAuthentication"))

    @_enable_iam_authentication.setter
    def _enable_iam_authentication(self, value: typing.Optional[builtins.bool]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cfe3ca15d94a6f7229e28ac5c56a67f5b1849e5c380fe10b0fa6c2ec51ee42b5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableIamAuthentication", value)

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, DatabaseInstanceBase).__jsii_proxy_class__ = lambda : _DatabaseInstanceBaseProxy


@jsii.implements(IDatabaseInstance)
class DatabaseInstanceFromSnapshot(
    DatabaseInstanceBase,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_rds.DatabaseInstanceFromSnapshot",
):
    '''(experimental) A database instance restored from a snapshot.

    :stability: experimental
    :resource: AWS::RDS::DBInstance
    :exampleMetadata: infused

    Example::

        # vpc: ec2.Vpc
        
        # source_instance: rds.DatabaseInstance
        
        rds.DatabaseInstanceFromSnapshot(self, "Instance",
            snapshot_identifier="my-snapshot",
            engine=rds.DatabaseInstanceEngine.postgres(version=rds.PostgresEngineVersion.VER_12_3),
            # optional, defaults to m5.large
            instance_type=ec2.InstanceType.of(ec2.InstanceClass.BURSTABLE2, ec2.InstanceSize.LARGE),
            vpc=vpc
        )
        rds.DatabaseInstanceReadReplica(self, "ReadReplica",
            source_database_instance=source_instance,
            instance_type=ec2.InstanceType.of(ec2.InstanceClass.BURSTABLE2, ec2.InstanceSize.LARGE),
            vpc=vpc
        )
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        snapshot_identifier: builtins.str,
        credentials: typing.Optional[SnapshotCredentials] = None,
        engine: IInstanceEngine,
        allocated_storage: typing.Optional[jsii.Number] = None,
        allow_major_version_upgrade: typing.Optional[builtins.bool] = None,
        database_name: typing.Optional[builtins.str] = None,
        instance_type: typing.Optional[_InstanceType_072ad323] = None,
        license_model: typing.Optional[LicenseModel] = None,
        parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        timezone: typing.Optional[builtins.str] = None,
        vpc: _IVpc_6d1f76c4,
        auto_minor_version_upgrade: typing.Optional[builtins.bool] = None,
        availability_zone: typing.Optional[builtins.str] = None,
        backup_retention: typing.Optional[_Duration_070aa057] = None,
        cloudwatch_logs_exports: typing.Optional[typing.Sequence[builtins.str]] = None,
        cloudwatch_logs_retention: typing.Optional[_RetentionDays_6c560d31] = None,
        cloudwatch_logs_retention_role: typing.Optional[_IRole_59af6f50] = None,
        copy_tags_to_snapshot: typing.Optional[builtins.bool] = None,
        delete_automated_backups: typing.Optional[builtins.bool] = None,
        deletion_protection: typing.Optional[builtins.bool] = None,
        domain: typing.Optional[builtins.str] = None,
        domain_role: typing.Optional[_IRole_59af6f50] = None,
        enable_performance_insights: typing.Optional[builtins.bool] = None,
        iam_authentication: typing.Optional[builtins.bool] = None,
        instance_identifier: typing.Optional[builtins.str] = None,
        iops: typing.Optional[jsii.Number] = None,
        max_allocated_storage: typing.Optional[jsii.Number] = None,
        monitoring_interval: typing.Optional[_Duration_070aa057] = None,
        monitoring_role: typing.Optional[_IRole_59af6f50] = None,
        multi_az: typing.Optional[builtins.bool] = None,
        option_group: typing.Optional[IOptionGroup] = None,
        parameter_group: typing.Optional[IParameterGroup] = None,
        performance_insight_encryption_key: typing.Optional[_IKey_36930160] = None,
        performance_insight_retention: typing.Optional[PerformanceInsightRetention] = None,
        port: typing.Optional[jsii.Number] = None,
        preferred_backup_window: typing.Optional[builtins.str] = None,
        preferred_maintenance_window: typing.Optional[builtins.str] = None,
        processor_features: typing.Optional[typing.Union[ProcessorFeatures, typing.Dict[builtins.str, typing.Any]]] = None,
        publicly_accessible: typing.Optional[builtins.bool] = None,
        removal_policy: typing.Optional[_RemovalPolicy_c97e7a20] = None,
        s3_export_buckets: typing.Optional[typing.Sequence[_IBucket_73486e29]] = None,
        s3_export_role: typing.Optional[_IRole_59af6f50] = None,
        s3_import_buckets: typing.Optional[typing.Sequence[_IBucket_73486e29]] = None,
        s3_import_role: typing.Optional[_IRole_59af6f50] = None,
        security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
        storage_type: typing.Optional[StorageType] = None,
        subnet_group: typing.Optional[ISubnetGroup] = None,
        vpc_placement: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
        vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param snapshot_identifier: (experimental) The name or Amazon Resource Name (ARN) of the DB snapshot that's used to restore the DB instance. If you're restoring from a shared manual DB snapshot, you must specify the ARN of the snapshot.
        :param credentials: (experimental) Master user credentials. Note - It is not possible to change the master username for a snapshot; however, it is possible to provide (or generate) a new password. Default: - The existing username and password from the snapshot will be used.
        :param engine: (experimental) The database engine.
        :param allocated_storage: (experimental) The allocated storage size, specified in gigabytes (GB). Default: 100
        :param allow_major_version_upgrade: (experimental) Whether to allow major version upgrades. Default: false
        :param database_name: (experimental) The name of the database. Default: - no name
        :param instance_type: (experimental) The name of the compute and memory capacity for the instance. Default: - m5.large (or, more specifically, db.m5.large)
        :param license_model: (experimental) The license model. Default: - RDS default license model
        :param parameters: (experimental) The parameters in the DBParameterGroup to create automatically. You can only specify parameterGroup or parameters but not both. You need to use a versioned engine to auto-generate a DBParameterGroup. Default: - None
        :param timezone: (experimental) The time zone of the instance. This is currently supported only by Microsoft Sql Server. Default: - RDS default timezone
        :param vpc: (experimental) The VPC network where the DB subnet group should be created.
        :param auto_minor_version_upgrade: (experimental) Indicates that minor engine upgrades are applied automatically to the DB instance during the maintenance window. Default: true
        :param availability_zone: (experimental) The name of the Availability Zone where the DB instance will be located. Default: - no preference
        :param backup_retention: (experimental) The number of days during which automatic DB snapshots are retained. Set to zero to disable backups. When creating a read replica, you must enable automatic backups on the source database instance by setting the backup retention to a value other than zero. Default: - Duration.days(1) for source instances, disabled for read replicas
        :param cloudwatch_logs_exports: (experimental) The list of log types that need to be enabled for exporting to CloudWatch Logs. Default: - no log exports
        :param cloudwatch_logs_retention: (experimental) The number of days log events are kept in CloudWatch Logs. When updating this property, unsetting it doesn't remove the log retention policy. To remove the retention policy, set the value to ``Infinity``. Default: - logs never expire
        :param cloudwatch_logs_retention_role: (experimental) The IAM role for the Lambda function associated with the custom resource that sets the retention policy. Default: - a new role is created.
        :param copy_tags_to_snapshot: (experimental) Indicates whether to copy all of the user-defined tags from the DB instance to snapshots of the DB instance. Default: true
        :param delete_automated_backups: (experimental) Indicates whether automated backups should be deleted or retained when you delete a DB instance. Default: false
        :param deletion_protection: (experimental) Indicates whether the DB instance should have deletion protection enabled. Default: - true if ``removalPolicy`` is RETAIN, false otherwise
        :param domain: (experimental) The Active Directory directory ID to create the DB instance in. Default: - Do not join domain
        :param domain_role: (experimental) The IAM role to be used when making API calls to the Directory Service. The role needs the AWS-managed policy AmazonRDSDirectoryServiceAccess or equivalent. Default: - The role will be created for you if {@link DatabaseInstanceNewProps#domain} is specified
        :param enable_performance_insights: (experimental) Whether to enable Performance Insights for the DB instance. Default: - false, unless ``performanceInsightRentention`` or ``performanceInsightEncryptionKey`` is set.
        :param iam_authentication: (experimental) Whether to enable mapping of AWS Identity and Access Management (IAM) accounts to database accounts. Default: false
        :param instance_identifier: (experimental) A name for the DB instance. If you specify a name, AWS CloudFormation converts it to lowercase. Default: - a CloudFormation generated name
        :param iops: (experimental) The number of I/O operations per second (IOPS) that the database provisions. The value must be equal to or greater than 1000. Default: - no provisioned iops
        :param max_allocated_storage: (experimental) Upper limit to which RDS can scale the storage in GiB(Gibibyte). Default: - No autoscaling of RDS instance
        :param monitoring_interval: (experimental) The interval, in seconds, between points when Amazon RDS collects enhanced monitoring metrics for the DB instance. Default: - no enhanced monitoring
        :param monitoring_role: (experimental) Role that will be used to manage DB instance monitoring. Default: - A role is automatically created for you
        :param multi_az: (experimental) Specifies if the database instance is a multiple Availability Zone deployment. Default: false
        :param option_group: (experimental) The option group to associate with the instance. Default: - no option group
        :param parameter_group: (experimental) The DB parameter group to associate with the instance. Default: - no parameter group
        :param performance_insight_encryption_key: (experimental) The AWS KMS key for encryption of Performance Insights data. Default: - default master key
        :param performance_insight_retention: (experimental) The amount of time, in days, to retain Performance Insights data. Default: 7
        :param port: (experimental) The port for the instance. Default: - the default port for the chosen engine.
        :param preferred_backup_window: (experimental) The daily time range during which automated backups are performed. Constraints: - Must be in the format ``hh24:mi-hh24:mi``. - Must be in Universal Coordinated Time (UTC). - Must not conflict with the preferred maintenance window. - Must be at least 30 minutes. Default: - a 30-minute window selected at random from an 8-hour block of time for each AWS Region. To see the time blocks available, see https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithAutomatedBackups.html#USER_WorkingWithAutomatedBackups.BackupWindow
        :param preferred_maintenance_window: (experimental) The weekly time range (in UTC) during which system maintenance can occur. Format: ``ddd:hh24:mi-ddd:hh24:mi`` Constraint: Minimum 30-minute window Default: - a 30-minute window selected at random from an 8-hour block of time for each AWS Region, occurring on a random day of the week. To see the time blocks available, see https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_UpgradeDBInstance.Maintenance.html#Concepts.DBMaintenance
        :param processor_features: (experimental) The number of CPU cores and the number of threads per core. Default: - the default number of CPU cores and threads per core for the chosen instance class. See https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html#USER_ConfigureProcessor
        :param publicly_accessible: (experimental) Indicates whether the DB instance is an internet-facing instance. Default: - ``true`` if ``vpcSubnets`` is ``subnetType: SubnetType.PUBLIC``, ``false`` otherwise
        :param removal_policy: (experimental) The CloudFormation policy to apply when the instance is removed from the stack or replaced during an update. Default: - RemovalPolicy.SNAPSHOT (remove the resource, but retain a snapshot of the data)
        :param s3_export_buckets: (experimental) S3 buckets that you want to load data into. This property must not be used if ``s3ExportRole`` is used. For Microsoft SQL Server: Default: - None
        :param s3_export_role: (experimental) Role that will be associated with this DB instance to enable S3 export. This property must not be used if ``s3ExportBuckets`` is used. For Microsoft SQL Server: Default: - New role is created if ``s3ExportBuckets`` is set, no role is defined otherwise
        :param s3_import_buckets: (experimental) S3 buckets that you want to load data from. This feature is only supported by the Microsoft SQL Server, Oracle, and PostgreSQL engines. This property must not be used if ``s3ImportRole`` is used. For Microsoft SQL Server: Default: - None
        :param s3_import_role: (experimental) Role that will be associated with this DB instance to enable S3 import. This feature is only supported by the Microsoft SQL Server, Oracle, and PostgreSQL engines. This property must not be used if ``s3ImportBuckets`` is used. For Microsoft SQL Server: Default: - New role is created if ``s3ImportBuckets`` is set, no role is defined otherwise
        :param security_groups: (experimental) The security groups to assign to the DB instance. Default: - a new security group is created
        :param storage_type: (experimental) The storage type. Storage types supported are gp2, io1, standard. Default: GP2
        :param subnet_group: (experimental) Existing subnet group for the instance. Default: - a new subnet group will be created.
        :param vpc_placement: (deprecated) The type of subnets to add to the created DB subnet group. Default: - private subnets
        :param vpc_subnets: (experimental) The type of subnets to add to the created DB subnet group. Default: - private subnets

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__108d23c4f82e82c8b6b27c51d73170e3cbcdf0b7381208e5c2eb3c713d5ca703)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = DatabaseInstanceFromSnapshotProps(
            snapshot_identifier=snapshot_identifier,
            credentials=credentials,
            engine=engine,
            allocated_storage=allocated_storage,
            allow_major_version_upgrade=allow_major_version_upgrade,
            database_name=database_name,
            instance_type=instance_type,
            license_model=license_model,
            parameters=parameters,
            timezone=timezone,
            vpc=vpc,
            auto_minor_version_upgrade=auto_minor_version_upgrade,
            availability_zone=availability_zone,
            backup_retention=backup_retention,
            cloudwatch_logs_exports=cloudwatch_logs_exports,
            cloudwatch_logs_retention=cloudwatch_logs_retention,
            cloudwatch_logs_retention_role=cloudwatch_logs_retention_role,
            copy_tags_to_snapshot=copy_tags_to_snapshot,
            delete_automated_backups=delete_automated_backups,
            deletion_protection=deletion_protection,
            domain=domain,
            domain_role=domain_role,
            enable_performance_insights=enable_performance_insights,
            iam_authentication=iam_authentication,
            instance_identifier=instance_identifier,
            iops=iops,
            max_allocated_storage=max_allocated_storage,
            monitoring_interval=monitoring_interval,
            monitoring_role=monitoring_role,
            multi_az=multi_az,
            option_group=option_group,
            parameter_group=parameter_group,
            performance_insight_encryption_key=performance_insight_encryption_key,
            performance_insight_retention=performance_insight_retention,
            port=port,
            preferred_backup_window=preferred_backup_window,
            preferred_maintenance_window=preferred_maintenance_window,
            processor_features=processor_features,
            publicly_accessible=publicly_accessible,
            removal_policy=removal_policy,
            s3_export_buckets=s3_export_buckets,
            s3_export_role=s3_export_role,
            s3_import_buckets=s3_import_buckets,
            s3_import_role=s3_import_role,
            security_groups=security_groups,
            storage_type=storage_type,
            subnet_group=subnet_group,
            vpc_placement=vpc_placement,
            vpc_subnets=vpc_subnets,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="addRotationMultiUser")
    def add_rotation_multi_user(
        self,
        id: builtins.str,
        *,
        secret: _ISecret_22fb8757,
        automatically_after: typing.Optional[_Duration_070aa057] = None,
        endpoint: typing.Optional[_IInterfaceVpcEndpoint_6081623d] = None,
        exclude_characters: typing.Optional[builtins.str] = None,
        vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> _SecretRotation_e64158ad:
        '''(experimental) Adds the multi user rotation to this instance.

        :param id: -
        :param secret: (experimental) The secret to rotate. It must be a JSON string with the following format:: { "engine": <required: database engine>, "host": <required: instance host name>, "username": <required: username>, "password": <required: password>, "dbname": <optional: database name>, "port": <optional: if not specified, default port will be used>, "masterarn": <required: the arn of the master secret which will be used to create users/change passwords> }
        :param automatically_after: (experimental) Specifies the number of days after the previous rotation before Secrets Manager triggers the next automatic rotation. Default: - 30 days
        :param endpoint: (experimental) The VPC interface endpoint to use for the Secrets Manager API. If you enable private DNS hostnames for your VPC private endpoint (the default), you don't need to specify an endpoint. The standard Secrets Manager DNS hostname the Secrets Manager CLI and SDKs use by default (https://secretsmanager..amazonaws.com) automatically resolves to your VPC endpoint. Default: https://secretsmanager..amazonaws.com
        :param exclude_characters: (experimental) Specifies characters to not include in generated passwords. Default: " %+~`#$&*()|[]{}:;<>?!'/
        :param vpc_subnets: (experimental) Where to place the rotation Lambda function. Default: - same placement as instance or cluster

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__198c8b3488658ccb011ae6959bc91cf28add379ee73c78a0033e5826ffa08d02)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        options = RotationMultiUserOptions(
            secret=secret,
            automatically_after=automatically_after,
            endpoint=endpoint,
            exclude_characters=exclude_characters,
            vpc_subnets=vpc_subnets,
        )

        return typing.cast(_SecretRotation_e64158ad, jsii.invoke(self, "addRotationMultiUser", [id, options]))

    @jsii.member(jsii_name="addRotationSingleUser")
    def add_rotation_single_user(
        self,
        *,
        automatically_after: typing.Optional[_Duration_070aa057] = None,
        endpoint: typing.Optional[_IInterfaceVpcEndpoint_6081623d] = None,
        exclude_characters: typing.Optional[builtins.str] = None,
        vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> _SecretRotation_e64158ad:
        '''(experimental) Adds the single user rotation of the master password to this instance.

        :param automatically_after: (experimental) Specifies the number of days after the previous rotation before Secrets Manager triggers the next automatic rotation. Default: - 30 days
        :param endpoint: (experimental) The VPC interface endpoint to use for the Secrets Manager API. If you enable private DNS hostnames for your VPC private endpoint (the default), you don't need to specify an endpoint. The standard Secrets Manager DNS hostname the Secrets Manager CLI and SDKs use by default (https://secretsmanager..amazonaws.com) automatically resolves to your VPC endpoint. Default: https://secretsmanager..amazonaws.com
        :param exclude_characters: (experimental) Specifies characters to not include in generated passwords. Default: " %+~`#$&*()|[]{}:;<>?!'/
        :param vpc_subnets: (experimental) Where to place the rotation Lambda function. Default: - same placement as instance or cluster

        :stability: experimental
        '''
        options = RotationSingleUserOptions(
            automatically_after=automatically_after,
            endpoint=endpoint,
            exclude_characters=exclude_characters,
            vpc_subnets=vpc_subnets,
        )

        return typing.cast(_SecretRotation_e64158ad, jsii.invoke(self, "addRotationSingleUser", [options]))

    @jsii.member(jsii_name="setLogRetention")
    def _set_log_retention(self) -> None:
        '''
        :stability: experimental
        '''
        return typing.cast(None, jsii.invoke(self, "setLogRetention", []))

    @builtins.property
    @jsii.member(jsii_name="connections")
    def connections(self) -> _Connections_57ccbda9:
        '''(experimental) Access to network connections.

        :stability: experimental
        '''
        return typing.cast(_Connections_57ccbda9, jsii.get(self, "connections"))

    @builtins.property
    @jsii.member(jsii_name="dbInstanceEndpointAddress")
    def db_instance_endpoint_address(self) -> builtins.str:
        '''(experimental) The instance endpoint address.

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "dbInstanceEndpointAddress"))

    @builtins.property
    @jsii.member(jsii_name="dbInstanceEndpointPort")
    def db_instance_endpoint_port(self) -> builtins.str:
        '''(experimental) The instance endpoint port.

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "dbInstanceEndpointPort"))

    @builtins.property
    @jsii.member(jsii_name="instanceEndpoint")
    def instance_endpoint(self) -> Endpoint:
        '''(experimental) The instance endpoint.

        :stability: experimental
        '''
        return typing.cast(Endpoint, jsii.get(self, "instanceEndpoint"))

    @builtins.property
    @jsii.member(jsii_name="instanceIdentifier")
    def instance_identifier(self) -> builtins.str:
        '''(experimental) The instance identifier.

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "instanceIdentifier"))

    @builtins.property
    @jsii.member(jsii_name="instanceType")
    def _instance_type(self) -> _InstanceType_072ad323:
        '''
        :stability: experimental
        '''
        return typing.cast(_InstanceType_072ad323, jsii.get(self, "instanceType"))

    @builtins.property
    @jsii.member(jsii_name="newCfnProps")
    def _new_cfn_props(self) -> CfnDBInstanceProps:
        '''
        :stability: experimental
        '''
        return typing.cast(CfnDBInstanceProps, jsii.get(self, "newCfnProps"))

    @builtins.property
    @jsii.member(jsii_name="sourceCfnProps")
    def _source_cfn_props(self) -> CfnDBInstanceProps:
        '''
        :stability: experimental
        '''
        return typing.cast(CfnDBInstanceProps, jsii.get(self, "sourceCfnProps"))

    @builtins.property
    @jsii.member(jsii_name="vpc")
    def vpc(self) -> _IVpc_6d1f76c4:
        '''(experimental) The VPC where this database instance is deployed.

        :stability: experimental
        '''
        return typing.cast(_IVpc_6d1f76c4, jsii.get(self, "vpc"))

    @builtins.property
    @jsii.member(jsii_name="engine")
    def engine(self) -> typing.Optional[IInstanceEngine]:
        '''(experimental) The engine of this database Instance.

        May be not known for imported Instances if it wasn't provided explicitly,
        or for read replicas.

        :stability: experimental
        '''
        return typing.cast(typing.Optional[IInstanceEngine], jsii.get(self, "engine"))

    @builtins.property
    @jsii.member(jsii_name="secret")
    def secret(self) -> typing.Optional[_ISecret_22fb8757]:
        '''(experimental) The AWS Secrets Manager secret attached to the instance.

        :stability: experimental
        '''
        return typing.cast(typing.Optional[_ISecret_22fb8757], jsii.get(self, "secret"))

    @builtins.property
    @jsii.member(jsii_name="vpcPlacement")
    def _vpc_placement(self) -> typing.Optional[_SubnetSelection_1284e62c]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[_SubnetSelection_1284e62c], jsii.get(self, "vpcPlacement"))

    @builtins.property
    @jsii.member(jsii_name="enableIamAuthentication")
    def _enable_iam_authentication(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "enableIamAuthentication"))

    @_enable_iam_authentication.setter
    def _enable_iam_authentication(self, value: typing.Optional[builtins.bool]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__509e48ffdeac25dcc54a555a17ad3d1a377fb948128543d28d8b44c7fa3a39cb)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableIamAuthentication", value)


@jsii.data_type(
    jsii_type="monocdk.aws_rds.DatabaseInstanceFromSnapshotProps",
    jsii_struct_bases=[DatabaseInstanceSourceProps],
    name_mapping={
        "vpc": "vpc",
        "auto_minor_version_upgrade": "autoMinorVersionUpgrade",
        "availability_zone": "availabilityZone",
        "backup_retention": "backupRetention",
        "cloudwatch_logs_exports": "cloudwatchLogsExports",
        "cloudwatch_logs_retention": "cloudwatchLogsRetention",
        "cloudwatch_logs_retention_role": "cloudwatchLogsRetentionRole",
        "copy_tags_to_snapshot": "copyTagsToSnapshot",
        "delete_automated_backups": "deleteAutomatedBackups",
        "deletion_protection": "deletionProtection",
        "domain": "domain",
        "domain_role": "domainRole",
        "enable_performance_insights": "enablePerformanceInsights",
        "iam_authentication": "iamAuthentication",
        "instance_identifier": "instanceIdentifier",
        "iops": "iops",
        "max_allocated_storage": "maxAllocatedStorage",
        "monitoring_interval": "monitoringInterval",
        "monitoring_role": "monitoringRole",
        "multi_az": "multiAz",
        "option_group": "optionGroup",
        "parameter_group": "parameterGroup",
        "performance_insight_encryption_key": "performanceInsightEncryptionKey",
        "performance_insight_retention": "performanceInsightRetention",
        "port": "port",
        "preferred_backup_window": "preferredBackupWindow",
        "preferred_maintenance_window": "preferredMaintenanceWindow",
        "processor_features": "processorFeatures",
        "publicly_accessible": "publiclyAccessible",
        "removal_policy": "removalPolicy",
        "s3_export_buckets": "s3ExportBuckets",
        "s3_export_role": "s3ExportRole",
        "s3_import_buckets": "s3ImportBuckets",
        "s3_import_role": "s3ImportRole",
        "security_groups": "securityGroups",
        "storage_type": "storageType",
        "subnet_group": "subnetGroup",
        "vpc_placement": "vpcPlacement",
        "vpc_subnets": "vpcSubnets",
        "engine": "engine",
        "allocated_storage": "allocatedStorage",
        "allow_major_version_upgrade": "allowMajorVersionUpgrade",
        "database_name": "databaseName",
        "instance_type": "instanceType",
        "license_model": "licenseModel",
        "parameters": "parameters",
        "timezone": "timezone",
        "snapshot_identifier": "snapshotIdentifier",
        "credentials": "credentials",
    },
)
class DatabaseInstanceFromSnapshotProps(DatabaseInstanceSourceProps):
    def __init__(
        self,
        *,
        vpc: _IVpc_6d1f76c4,
        auto_minor_version_upgrade: typing.Optional[builtins.bool] = None,
        availability_zone: typing.Optional[builtins.str] = None,
        backup_retention: typing.Optional[_Duration_070aa057] = None,
        cloudwatch_logs_exports: typing.Optional[typing.Sequence[builtins.str]] = None,
        cloudwatch_logs_retention: typing.Optional[_RetentionDays_6c560d31] = None,
        cloudwatch_logs_retention_role: typing.Optional[_IRole_59af6f50] = None,
        copy_tags_to_snapshot: typing.Optional[builtins.bool] = None,
        delete_automated_backups: typing.Optional[builtins.bool] = None,
        deletion_protection: typing.Optional[builtins.bool] = None,
        domain: typing.Optional[builtins.str] = None,
        domain_role: typing.Optional[_IRole_59af6f50] = None,
        enable_performance_insights: typing.Optional[builtins.bool] = None,
        iam_authentication: typing.Optional[builtins.bool] = None,
        instance_identifier: typing.Optional[builtins.str] = None,
        iops: typing.Optional[jsii.Number] = None,
        max_allocated_storage: typing.Optional[jsii.Number] = None,
        monitoring_interval: typing.Optional[_Duration_070aa057] = None,
        monitoring_role: typing.Optional[_IRole_59af6f50] = None,
        multi_az: typing.Optional[builtins.bool] = None,
        option_group: typing.Optional[IOptionGroup] = None,
        parameter_group: typing.Optional[IParameterGroup] = None,
        performance_insight_encryption_key: typing.Optional[_IKey_36930160] = None,
        performance_insight_retention: typing.Optional[PerformanceInsightRetention] = None,
        port: typing.Optional[jsii.Number] = None,
        preferred_backup_window: typing.Optional[builtins.str] = None,
        preferred_maintenance_window: typing.Optional[builtins.str] = None,
        processor_features: typing.Optional[typing.Union[ProcessorFeatures, typing.Dict[builtins.str, typing.Any]]] = None,
        publicly_accessible: typing.Optional[builtins.bool] = None,
        removal_policy: typing.Optional[_RemovalPolicy_c97e7a20] = None,
        s3_export_buckets: typing.Optional[typing.Sequence[_IBucket_73486e29]] = None,
        s3_export_role: typing.Optional[_IRole_59af6f50] = None,
        s3_import_buckets: typing.Optional[typing.Sequence[_IBucket_73486e29]] = None,
        s3_import_role: typing.Optional[_IRole_59af6f50] = None,
        security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
        storage_type: typing.Optional[StorageType] = None,
        subnet_group: typing.Optional[ISubnetGroup] = None,
        vpc_placement: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
        vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
        engine: IInstanceEngine,
        allocated_storage: typing.Optional[jsii.Number] = None,
        allow_major_version_upgrade: typing.Optional[builtins.bool] = None,
        database_name: typing.Optional[builtins.str] = None,
        instance_type: typing.Optional[_InstanceType_072ad323] = None,
        license_model: typing.Optional[LicenseModel] = None,
        parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        timezone: typing.Optional[builtins.str] = None,
        snapshot_identifier: builtins.str,
        credentials: typing.Optional[SnapshotCredentials] = None,
    ) -> None:
        '''(experimental) Construction properties for a DatabaseInstanceFromSnapshot.

        :param vpc: (experimental) The VPC network where the DB subnet group should be created.
        :param auto_minor_version_upgrade: (experimental) Indicates that minor engine upgrades are applied automatically to the DB instance during the maintenance window. Default: true
        :param availability_zone: (experimental) The name of the Availability Zone where the DB instance will be located. Default: - no preference
        :param backup_retention: (experimental) The number of days during which automatic DB snapshots are retained. Set to zero to disable backups. When creating a read replica, you must enable automatic backups on the source database instance by setting the backup retention to a value other than zero. Default: - Duration.days(1) for source instances, disabled for read replicas
        :param cloudwatch_logs_exports: (experimental) The list of log types that need to be enabled for exporting to CloudWatch Logs. Default: - no log exports
        :param cloudwatch_logs_retention: (experimental) The number of days log events are kept in CloudWatch Logs. When updating this property, unsetting it doesn't remove the log retention policy. To remove the retention policy, set the value to ``Infinity``. Default: - logs never expire
        :param cloudwatch_logs_retention_role: (experimental) The IAM role for the Lambda function associated with the custom resource that sets the retention policy. Default: - a new role is created.
        :param copy_tags_to_snapshot: (experimental) Indicates whether to copy all of the user-defined tags from the DB instance to snapshots of the DB instance. Default: true
        :param delete_automated_backups: (experimental) Indicates whether automated backups should be deleted or retained when you delete a DB instance. Default: false
        :param deletion_protection: (experimental) Indicates whether the DB instance should have deletion protection enabled. Default: - true if ``removalPolicy`` is RETAIN, false otherwise
        :param domain: (experimental) The Active Directory directory ID to create the DB instance in. Default: - Do not join domain
        :param domain_role: (experimental) The IAM role to be used when making API calls to the Directory Service. The role needs the AWS-managed policy AmazonRDSDirectoryServiceAccess or equivalent. Default: - The role will be created for you if {@link DatabaseInstanceNewProps#domain} is specified
        :param enable_performance_insights: (experimental) Whether to enable Performance Insights for the DB instance. Default: - false, unless ``performanceInsightRentention`` or ``performanceInsightEncryptionKey`` is set.
        :param iam_authentication: (experimental) Whether to enable mapping of AWS Identity and Access Management (IAM) accounts to database accounts. Default: false
        :param instance_identifier: (experimental) A name for the DB instance. If you specify a name, AWS CloudFormation converts it to lowercase. Default: - a CloudFormation generated name
        :param iops: (experimental) The number of I/O operations per second (IOPS) that the database provisions. The value must be equal to or greater than 1000. Default: - no provisioned iops
        :param max_allocated_storage: (experimental) Upper limit to which RDS can scale the storage in GiB(Gibibyte). Default: - No autoscaling of RDS instance
        :param monitoring_interval: (experimental) The interval, in seconds, between points when Amazon RDS collects enhanced monitoring metrics for the DB instance. Default: - no enhanced monitoring
        :param monitoring_role: (experimental) Role that will be used to manage DB instance monitoring. Default: - A role is automatically created for you
        :param multi_az: (experimental) Specifies if the database instance is a multiple Availability Zone deployment. Default: false
        :param option_group: (experimental) The option group to associate with the instance. Default: - no option group
        :param parameter_group: (experimental) The DB parameter group to associate with the instance. Default: - no parameter group
        :param performance_insight_encryption_key: (experimental) The AWS KMS key for encryption of Performance Insights data. Default: - default master key
        :param performance_insight_retention: (experimental) The amount of time, in days, to retain Performance Insights data. Default: 7
        :param port: (experimental) The port for the instance. Default: - the default port for the chosen engine.
        :param preferred_backup_window: (experimental) The daily time range during which automated backups are performed. Constraints: - Must be in the format ``hh24:mi-hh24:mi``. - Must be in Universal Coordinated Time (UTC). - Must not conflict with the preferred maintenance window. - Must be at least 30 minutes. Default: - a 30-minute window selected at random from an 8-hour block of time for each AWS Region. To see the time blocks available, see https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithAutomatedBackups.html#USER_WorkingWithAutomatedBackups.BackupWindow
        :param preferred_maintenance_window: (experimental) The weekly time range (in UTC) during which system maintenance can occur. Format: ``ddd:hh24:mi-ddd:hh24:mi`` Constraint: Minimum 30-minute window Default: - a 30-minute window selected at random from an 8-hour block of time for each AWS Region, occurring on a random day of the week. To see the time blocks available, see https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_UpgradeDBInstance.Maintenance.html#Concepts.DBMaintenance
        :param processor_features: (experimental) The number of CPU cores and the number of threads per core. Default: - the default number of CPU cores and threads per core for the chosen instance class. See https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html#USER_ConfigureProcessor
        :param publicly_accessible: (experimental) Indicates whether the DB instance is an internet-facing instance. Default: - ``true`` if ``vpcSubnets`` is ``subnetType: SubnetType.PUBLIC``, ``false`` otherwise
        :param removal_policy: (experimental) The CloudFormation policy to apply when the instance is removed from the stack or replaced during an update. Default: - RemovalPolicy.SNAPSHOT (remove the resource, but retain a snapshot of the data)
        :param s3_export_buckets: (experimental) S3 buckets that you want to load data into. This property must not be used if ``s3ExportRole`` is used. For Microsoft SQL Server: Default: - None
        :param s3_export_role: (experimental) Role that will be associated with this DB instance to enable S3 export. This property must not be used if ``s3ExportBuckets`` is used. For Microsoft SQL Server: Default: - New role is created if ``s3ExportBuckets`` is set, no role is defined otherwise
        :param s3_import_buckets: (experimental) S3 buckets that you want to load data from. This feature is only supported by the Microsoft SQL Server, Oracle, and PostgreSQL engines. This property must not be used if ``s3ImportRole`` is used. For Microsoft SQL Server: Default: - None
        :param s3_import_role: (experimental) Role that will be associated with this DB instance to enable S3 import. This feature is only supported by the Microsoft SQL Server, Oracle, and PostgreSQL engines. This property must not be used if ``s3ImportBuckets`` is used. For Microsoft SQL Server: Default: - New role is created if ``s3ImportBuckets`` is set, no role is defined otherwise
        :param security_groups: (experimental) The security groups to assign to the DB instance. Default: - a new security group is created
        :param storage_type: (experimental) The storage type. Storage types supported are gp2, io1, standard. Default: GP2
        :param subnet_group: (experimental) Existing subnet group for the instance. Default: - a new subnet group will be created.
        :param vpc_placement: (deprecated) The type of subnets to add to the created DB subnet group. Default: - private subnets
        :param vpc_subnets: (experimental) The type of subnets to add to the created DB subnet group. Default: - private subnets
        :param engine: (experimental) The database engine.
        :param allocated_storage: (experimental) The allocated storage size, specified in gigabytes (GB). Default: 100
        :param allow_major_version_upgrade: (experimental) Whether to allow major version upgrades. Default: false
        :param database_name: (experimental) The name of the database. Default: - no name
        :param instance_type: (experimental) The name of the compute and memory capacity for the instance. Default: - m5.large (or, more specifically, db.m5.large)
        :param license_model: (experimental) The license model. Default: - RDS default license model
        :param parameters: (experimental) The parameters in the DBParameterGroup to create automatically. You can only specify parameterGroup or parameters but not both. You need to use a versioned engine to auto-generate a DBParameterGroup. Default: - None
        :param timezone: (experimental) The time zone of the instance. This is currently supported only by Microsoft Sql Server. Default: - RDS default timezone
        :param snapshot_identifier: (experimental) The name or Amazon Resource Name (ARN) of the DB snapshot that's used to restore the DB instance. If you're restoring from a shared manual DB snapshot, you must specify the ARN of the snapshot.
        :param credentials: (experimental) Master user credentials. Note - It is not possible to change the master username for a snapshot; however, it is possible to provide (or generate) a new password. Default: - The existing username and password from the snapshot will be used.

        :stability: experimental
        :exampleMetadata: infused

        Example::

            # vpc: ec2.Vpc
            
            # source_instance: rds.DatabaseInstance
            
            rds.DatabaseInstanceFromSnapshot(self, "Instance",
                snapshot_identifier="my-snapshot",
                engine=rds.DatabaseInstanceEngine.postgres(version=rds.PostgresEngineVersion.VER_12_3),
                # optional, defaults to m5.large
                instance_type=ec2.InstanceType.of(ec2.InstanceClass.BURSTABLE2, ec2.InstanceSize.LARGE),
                vpc=vpc
            )
            rds.DatabaseInstanceReadReplica(self, "ReadReplica",
                source_database_instance=source_instance,
                instance_type=ec2.InstanceType.of(ec2.InstanceClass.BURSTABLE2, ec2.InstanceSize.LARGE),
                vpc=vpc
            )
        '''
        if isinstance(processor_features, dict):
            processor_features = ProcessorFeatures(**processor_features)
        if isinstance(vpc_placement, dict):
            vpc_placement = _SubnetSelection_1284e62c(**vpc_placement)
        if isinstance(vpc_subnets, dict):
            vpc_subnets = _SubnetSelection_1284e62c(**vpc_subnets)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__245ec839472d26b125b71df469fef0472070f4bbc6eb321718bc7a0c92d03c3f)
            check_type(argname="argument vpc", value=vpc, expected_type=type_hints["vpc"])
            check_type(argname="argument auto_minor_version_upgrade", value=auto_minor_version_upgrade, expected_type=type_hints["auto_minor_version_upgrade"])
            check_type(argname="argument availability_zone", value=availability_zone, expected_type=type_hints["availability_zone"])
            check_type(argname="argument backup_retention", value=backup_retention, expected_type=type_hints["backup_retention"])
            check_type(argname="argument cloudwatch_logs_exports", value=cloudwatch_logs_exports, expected_type=type_hints["cloudwatch_logs_exports"])
            check_type(argname="argument cloudwatch_logs_retention", value=cloudwatch_logs_retention, expected_type=type_hints["cloudwatch_logs_retention"])
            check_type(argname="argument cloudwatch_logs_retention_role", value=cloudwatch_logs_retention_role, expected_type=type_hints["cloudwatch_logs_retention_role"])
            check_type(argname="argument copy_tags_to_snapshot", value=copy_tags_to_snapshot, expected_type=type_hints["copy_tags_to_snapshot"])
            check_type(argname="argument delete_automated_backups", value=delete_automated_backups, expected_type=type_hints["delete_automated_backups"])
            check_type(argname="argument deletion_protection", value=deletion_protection, expected_type=type_hints["deletion_protection"])
            check_type(argname="argument domain", value=domain, expected_type=type_hints["domain"])
            check_type(argname="argument domain_role", value=domain_role, expected_type=type_hints["domain_role"])
            check_type(argname="argument enable_performance_insights", value=enable_performance_insights, expected_type=type_hints["enable_performance_insights"])
            check_type(argname="argument iam_authentication", value=iam_authentication, expected_type=type_hints["iam_authentication"])
            check_type(argname="argument instance_identifier", value=instance_identifier, expected_type=type_hints["instance_identifier"])
            check_type(argname="argument iops", value=iops, expected_type=type_hints["iops"])
            check_type(argname="argument max_allocated_storage", value=max_allocated_storage, expected_type=type_hints["max_allocated_storage"])
            check_type(argname="argument monitoring_interval", value=monitoring_interval, expected_type=type_hints["monitoring_interval"])
            check_type(argname="argument monitoring_role", value=monitoring_role, expected_type=type_hints["monitoring_role"])
            check_type(argname="argument multi_az", value=multi_az, expected_type=type_hints["multi_az"])
            check_type(argname="argument option_group", value=option_group, expected_type=type_hints["option_group"])
            check_type(argname="argument parameter_group", value=parameter_group, expected_type=type_hints["parameter_group"])
            check_type(argname="argument performance_insight_encryption_key", value=performance_insight_encryption_key, expected_type=type_hints["performance_insight_encryption_key"])
            check_type(argname="argument performance_insight_retention", value=performance_insight_retention, expected_type=type_hints["performance_insight_retention"])
            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
            check_type(argname="argument preferred_backup_window", value=preferred_backup_window, expected_type=type_hints["preferred_backup_window"])
            check_type(argname="argument preferred_maintenance_window", value=preferred_maintenance_window, expected_type=type_hints["preferred_maintenance_window"])
            check_type(argname="argument processor_features", value=processor_features, expected_type=type_hints["processor_features"])
            check_type(argname="argument publicly_accessible", value=publicly_accessible, expected_type=type_hints["publicly_accessible"])
            check_type(argname="argument removal_policy", value=removal_policy, expected_type=type_hints["removal_policy"])
            check_type(argname="argument s3_export_buckets", value=s3_export_buckets, expected_type=type_hints["s3_export_buckets"])
            check_type(argname="argument s3_export_role", value=s3_export_role, expected_type=type_hints["s3_export_role"])
            check_type(argname="argument s3_import_buckets", value=s3_import_buckets, expected_type=type_hints["s3_import_buckets"])
            check_type(argname="argument s3_import_role", value=s3_import_role, expected_type=type_hints["s3_import_role"])
            check_type(argname="argument security_groups", value=security_groups, expected_type=type_hints["security_groups"])
            check_type(argname="argument storage_type", value=storage_type, expected_type=type_hints["storage_type"])
            check_type(argname="argument subnet_group", value=subnet_group, expected_type=type_hints["subnet_group"])
            check_type(argname="argument vpc_placement", value=vpc_placement, expected_type=type_hints["vpc_placement"])
            check_type(argname="argument vpc_subnets", value=vpc_subnets, expected_type=type_hints["vpc_subnets"])
            check_type(argname="argument engine", value=engine, expected_type=type_hints["engine"])
            check_type(argname="argument allocated_storage", value=allocated_storage, expected_type=type_hints["allocated_storage"])
            check_type(argname="argument allow_major_version_upgrade", value=allow_major_version_upgrade, expected_type=type_hints["allow_major_version_upgrade"])
            check_type(argname="argument database_name", value=database_name, expected_type=type_hints["database_name"])
            check_type(argname="argument instance_type", value=instance_type, expected_type=type_hints["instance_type"])
            check_type(argname="argument license_model", value=license_model, expected_type=type_hints["license_model"])
            check_type(argname="argument parameters", value=parameters, expected_type=type_hints["parameters"])
            check_type(argname="argument timezone", value=timezone, expected_type=type_hints["timezone"])
            check_type(argname="argument snapshot_identifier", value=snapshot_identifier, expected_type=type_hints["snapshot_identifier"])
            check_type(argname="argument credentials", value=credentials, expected_type=type_hints["credentials"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "vpc": vpc,
            "engine": engine,
            "snapshot_identifier": snapshot_identifier,
        }
        if auto_minor_version_upgrade is not None:
            self._values["auto_minor_version_upgrade"] = auto_minor_version_upgrade
        if availability_zone is not None:
            self._values["availability_zone"] = availability_zone
        if backup_retention is not None:
            self._values["backup_retention"] = backup_retention
        if cloudwatch_logs_exports is not None:
            self._values["cloudwatch_logs_exports"] = cloudwatch_logs_exports
        if cloudwatch_logs_retention is not None:
            self._values["cloudwatch_logs_retention"] = cloudwatch_logs_retention
        if cloudwatch_logs_retention_role is not None:
            self._values["cloudwatch_logs_retention_role"] = cloudwatch_logs_retention_role
        if copy_tags_to_snapshot is not None:
            self._values["copy_tags_to_snapshot"] = copy_tags_to_snapshot
        if delete_automated_backups is not None:
            self._values["delete_automated_backups"] = delete_automated_backups
        if deletion_protection is not None:
            self._values["deletion_protection"] = deletion_protection
        if domain is not None:
            self._values["domain"] = domain
        if domain_role is not None:
            self._values["domain_role"] = domain_role
        if enable_performance_insights is not None:
            self._values["enable_performance_insights"] = enable_performance_insights
        if iam_authentication is not None:
            self._values["iam_authentication"] = iam_authentication
        if instance_identifier is not None:
            self._values["instance_identifier"] = instance_identifier
        if iops is not None:
            self._values["iops"] = iops
        if max_allocated_storage is not None:
            self._values["max_allocated_storage"] = max_allocated_storage
        if monitoring_interval is not None:
            self._values["monitoring_interval"] = monitoring_interval
        if monitoring_role is not None:
            self._values["monitoring_role"] = monitoring_role
        if multi_az is not None:
            self._values["multi_az"] = multi_az
        if option_group is not None:
            self._values["option_group"] = option_group
        if parameter_group is not None:
            self._values["parameter_group"] = parameter_group
        if performance_insight_encryption_key is not None:
            self._values["performance_insight_encryption_key"] = performance_insight_encryption_key
        if performance_insight_retention is not None:
            self._values["performance_insight_retention"] = performance_insight_retention
        if port is not None:
            self._values["port"] = port
        if preferred_backup_window is not None:
            self._values["preferred_backup_window"] = preferred_backup_window
        if preferred_maintenance_window is not None:
            self._values["preferred_maintenance_window"] = preferred_maintenance_window
        if processor_features is not None:
            self._values["processor_features"] = processor_features
        if publicly_accessible is not None:
            self._values["publicly_accessible"] = publicly_accessible
        if removal_policy is not None:
            self._values["removal_policy"] = removal_policy
        if s3_export_buckets is not None:
            self._values["s3_export_buckets"] = s3_export_buckets
        if s3_export_role is not None:
            self._values["s3_export_role"] = s3_export_role
        if s3_import_buckets is not None:
            self._values["s3_import_buckets"] = s3_import_buckets
        if s3_import_role is not None:
            self._values["s3_import_role"] = s3_import_role
        if security_groups is not None:
            self._values["security_groups"] = security_groups
        if storage_type is not None:
            self._values["storage_type"] = storage_type
        if subnet_group is not None:
            self._values["subnet_group"] = subnet_group
        if vpc_placement is not None:
            self._values["vpc_placement"] = vpc_placement
        if vpc_subnets is not None:
            self._values["vpc_subnets"] = vpc_subnets
        if allocated_storage is not None:
            self._values["allocated_storage"] = allocated_storage
        if allow_major_version_upgrade is not None:
            self._values["allow_major_version_upgrade"] = allow_major_version_upgrade
        if database_name is not None:
            self._values["database_name"] = database_name
        if instance_type is not None:
            self._values["instance_type"] = instance_type
        if license_model is not None:
            self._values["license_model"] = license_model
        if parameters is not None:
            self._values["parameters"] = parameters
        if timezone is not None:
            self._values["timezone"] = timezone
        if credentials is not None:
            self._values["credentials"] = credentials

    @builtins.property
    def vpc(self) -> _IVpc_6d1f76c4:
        '''(experimental) The VPC network where the DB subnet group should be created.

        :stability: experimental
        '''
        result = self._values.get("vpc")
        assert result is not None, "Required property 'vpc' is missing"
        return typing.cast(_IVpc_6d1f76c4, result)

    @builtins.property
    def auto_minor_version_upgrade(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates that minor engine upgrades are applied automatically to the DB instance during the maintenance window.

        :default: true

        :stability: experimental
        '''
        result = self._values.get("auto_minor_version_upgrade")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def availability_zone(self) -> typing.Optional[builtins.str]:
        '''(experimental) The name of the Availability Zone where the DB instance will be located.

        :default: - no preference

        :stability: experimental
        '''
        result = self._values.get("availability_zone")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def backup_retention(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) The number of days during which automatic DB snapshots are retained.

        Set to zero to disable backups.
        When creating a read replica, you must enable automatic backups on the source
        database instance by setting the backup retention to a value other than zero.

        :default: - Duration.days(1) for source instances, disabled for read replicas

        :stability: experimental
        '''
        result = self._values.get("backup_retention")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def cloudwatch_logs_exports(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) The list of log types that need to be enabled for exporting to CloudWatch Logs.

        :default: - no log exports

        :stability: experimental
        '''
        result = self._values.get("cloudwatch_logs_exports")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def cloudwatch_logs_retention(self) -> typing.Optional[_RetentionDays_6c560d31]:
        '''(experimental) The number of days log events are kept in CloudWatch Logs.

        When updating
        this property, unsetting it doesn't remove the log retention policy. To
        remove the retention policy, set the value to ``Infinity``.

        :default: - logs never expire

        :stability: experimental
        '''
        result = self._values.get("cloudwatch_logs_retention")
        return typing.cast(typing.Optional[_RetentionDays_6c560d31], result)

    @builtins.property
    def cloudwatch_logs_retention_role(self) -> typing.Optional[_IRole_59af6f50]:
        '''(experimental) The IAM role for the Lambda function associated with the custom resource that sets the retention policy.

        :default: - a new role is created.

        :stability: experimental
        '''
        result = self._values.get("cloudwatch_logs_retention_role")
        return typing.cast(typing.Optional[_IRole_59af6f50], result)

    @builtins.property
    def copy_tags_to_snapshot(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether to copy all of the user-defined tags from the DB instance to snapshots of the DB instance.

        :default: true

        :stability: experimental
        '''
        result = self._values.get("copy_tags_to_snapshot")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def delete_automated_backups(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether automated backups should be deleted or retained when you delete a DB instance.

        :default: false

        :stability: experimental
        '''
        result = self._values.get("delete_automated_backups")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def deletion_protection(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the DB instance should have deletion protection enabled.

        :default: - true if ``removalPolicy`` is RETAIN, false otherwise

        :stability: experimental
        '''
        result = self._values.get("deletion_protection")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def domain(self) -> typing.Optional[builtins.str]:
        '''(experimental) The Active Directory directory ID to create the DB instance in.

        :default: - Do not join domain

        :stability: experimental
        '''
        result = self._values.get("domain")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def domain_role(self) -> typing.Optional[_IRole_59af6f50]:
        '''(experimental) The IAM role to be used when making API calls to the Directory Service.

        The role needs the AWS-managed policy
        AmazonRDSDirectoryServiceAccess or equivalent.

        :default: - The role will be created for you if {@link DatabaseInstanceNewProps#domain} is specified

        :stability: experimental
        '''
        result = self._values.get("domain_role")
        return typing.cast(typing.Optional[_IRole_59af6f50], result)

    @builtins.property
    def enable_performance_insights(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Whether to enable Performance Insights for the DB instance.

        :default: - false, unless ``performanceInsightRentention`` or ``performanceInsightEncryptionKey`` is set.

        :stability: experimental
        '''
        result = self._values.get("enable_performance_insights")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def iam_authentication(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Whether to enable mapping of AWS Identity and Access Management (IAM) accounts to database accounts.

        :default: false

        :stability: experimental
        '''
        result = self._values.get("iam_authentication")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def instance_identifier(self) -> typing.Optional[builtins.str]:
        '''(experimental) A name for the DB instance.

        If you specify a name, AWS CloudFormation
        converts it to lowercase.

        :default: - a CloudFormation generated name

        :stability: experimental
        '''
        result = self._values.get("instance_identifier")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def iops(self) -> typing.Optional[jsii.Number]:
        '''(experimental) The number of I/O operations per second (IOPS) that the database provisions.

        The value must be equal to or greater than 1000.

        :default: - no provisioned iops

        :stability: experimental
        '''
        result = self._values.get("iops")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def max_allocated_storage(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Upper limit to which RDS can scale the storage in GiB(Gibibyte).

        :default: - No autoscaling of RDS instance

        :see: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PIOPS.StorageTypes.html#USER_PIOPS.Autoscaling
        :stability: experimental
        '''
        result = self._values.get("max_allocated_storage")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def monitoring_interval(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) The interval, in seconds, between points when Amazon RDS collects enhanced monitoring metrics for the DB instance.

        :default: - no enhanced monitoring

        :stability: experimental
        '''
        result = self._values.get("monitoring_interval")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def monitoring_role(self) -> typing.Optional[_IRole_59af6f50]:
        '''(experimental) Role that will be used to manage DB instance monitoring.

        :default: - A role is automatically created for you

        :stability: experimental
        '''
        result = self._values.get("monitoring_role")
        return typing.cast(typing.Optional[_IRole_59af6f50], result)

    @builtins.property
    def multi_az(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Specifies if the database instance is a multiple Availability Zone deployment.

        :default: false

        :stability: experimental
        '''
        result = self._values.get("multi_az")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def option_group(self) -> typing.Optional[IOptionGroup]:
        '''(experimental) The option group to associate with the instance.

        :default: - no option group

        :stability: experimental
        '''
        result = self._values.get("option_group")
        return typing.cast(typing.Optional[IOptionGroup], result)

    @builtins.property
    def parameter_group(self) -> typing.Optional[IParameterGroup]:
        '''(experimental) The DB parameter group to associate with the instance.

        :default: - no parameter group

        :stability: experimental
        '''
        result = self._values.get("parameter_group")
        return typing.cast(typing.Optional[IParameterGroup], result)

    @builtins.property
    def performance_insight_encryption_key(self) -> typing.Optional[_IKey_36930160]:
        '''(experimental) The AWS KMS key for encryption of Performance Insights data.

        :default: - default master key

        :stability: experimental
        '''
        result = self._values.get("performance_insight_encryption_key")
        return typing.cast(typing.Optional[_IKey_36930160], result)

    @builtins.property
    def performance_insight_retention(
        self,
    ) -> typing.Optional[PerformanceInsightRetention]:
        '''(experimental) The amount of time, in days, to retain Performance Insights data.

        :default: 7

        :stability: experimental
        '''
        result = self._values.get("performance_insight_retention")
        return typing.cast(typing.Optional[PerformanceInsightRetention], result)

    @builtins.property
    def port(self) -> typing.Optional[jsii.Number]:
        '''(experimental) The port for the instance.

        :default: - the default port for the chosen engine.

        :stability: experimental
        '''
        result = self._values.get("port")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def preferred_backup_window(self) -> typing.Optional[builtins.str]:
        '''(experimental) The daily time range during which automated backups are performed.

        Constraints:

        - Must be in the format ``hh24:mi-hh24:mi``.
        - Must be in Universal Coordinated Time (UTC).
        - Must not conflict with the preferred maintenance window.
        - Must be at least 30 minutes.

        :default:

        - a 30-minute window selected at random from an 8-hour block of
        time for each AWS Region. To see the time blocks available, see
        https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithAutomatedBackups.html#USER_WorkingWithAutomatedBackups.BackupWindow

        :stability: experimental
        '''
        result = self._values.get("preferred_backup_window")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def preferred_maintenance_window(self) -> typing.Optional[builtins.str]:
        '''(experimental) The weekly time range (in UTC) during which system maintenance can occur.

        Format: ``ddd:hh24:mi-ddd:hh24:mi``
        Constraint: Minimum 30-minute window

        :default:

        - a 30-minute window selected at random from an 8-hour block of
        time for each AWS Region, occurring on a random day of the week. To see
        the time blocks available, see https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_UpgradeDBInstance.Maintenance.html#Concepts.DBMaintenance

        :stability: experimental
        '''
        result = self._values.get("preferred_maintenance_window")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def processor_features(self) -> typing.Optional[ProcessorFeatures]:
        '''(experimental) The number of CPU cores and the number of threads per core.

        :default:

        - the default number of CPU cores and threads per core for the
        chosen instance class.

        See https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html#USER_ConfigureProcessor

        :stability: experimental
        '''
        result = self._values.get("processor_features")
        return typing.cast(typing.Optional[ProcessorFeatures], result)

    @builtins.property
    def publicly_accessible(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the DB instance is an internet-facing instance.

        :default: - ``true`` if ``vpcSubnets`` is ``subnetType: SubnetType.PUBLIC``, ``false`` otherwise

        :stability: experimental
        '''
        result = self._values.get("publicly_accessible")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def removal_policy(self) -> typing.Optional[_RemovalPolicy_c97e7a20]:
        '''(experimental) The CloudFormation policy to apply when the instance is removed from the stack or replaced during an update.

        :default: - RemovalPolicy.SNAPSHOT (remove the resource, but retain a snapshot of the data)

        :stability: experimental
        '''
        result = self._values.get("removal_policy")
        return typing.cast(typing.Optional[_RemovalPolicy_c97e7a20], result)

    @builtins.property
    def s3_export_buckets(self) -> typing.Optional[typing.List[_IBucket_73486e29]]:
        '''(experimental) S3 buckets that you want to load data into.

        This property must not be used if ``s3ExportRole`` is used.

        For Microsoft SQL Server:

        :default: - None

        :see: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/oracle-s3-integration.html
        :stability: experimental
        '''
        result = self._values.get("s3_export_buckets")
        return typing.cast(typing.Optional[typing.List[_IBucket_73486e29]], result)

    @builtins.property
    def s3_export_role(self) -> typing.Optional[_IRole_59af6f50]:
        '''(experimental) Role that will be associated with this DB instance to enable S3 export.

        This property must not be used if ``s3ExportBuckets`` is used.

        For Microsoft SQL Server:

        :default: - New role is created if ``s3ExportBuckets`` is set, no role is defined otherwise

        :see: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/oracle-s3-integration.html
        :stability: experimental
        '''
        result = self._values.get("s3_export_role")
        return typing.cast(typing.Optional[_IRole_59af6f50], result)

    @builtins.property
    def s3_import_buckets(self) -> typing.Optional[typing.List[_IBucket_73486e29]]:
        '''(experimental) S3 buckets that you want to load data from.

        This feature is only supported by the Microsoft SQL Server, Oracle, and PostgreSQL engines.

        This property must not be used if ``s3ImportRole`` is used.

        For Microsoft SQL Server:

        :default: - None

        :see: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/PostgreSQL.Procedural.Importing.html
        :stability: experimental
        '''
        result = self._values.get("s3_import_buckets")
        return typing.cast(typing.Optional[typing.List[_IBucket_73486e29]], result)

    @builtins.property
    def s3_import_role(self) -> typing.Optional[_IRole_59af6f50]:
        '''(experimental) Role that will be associated with this DB instance to enable S3 import.

        This feature is only supported by the Microsoft SQL Server, Oracle, and PostgreSQL engines.

        This property must not be used if ``s3ImportBuckets`` is used.

        For Microsoft SQL Server:

        :default: - New role is created if ``s3ImportBuckets`` is set, no role is defined otherwise

        :see: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/PostgreSQL.Procedural.Importing.html
        :stability: experimental
        '''
        result = self._values.get("s3_import_role")
        return typing.cast(typing.Optional[_IRole_59af6f50], result)

    @builtins.property
    def security_groups(self) -> typing.Optional[typing.List[_ISecurityGroup_cdbba9d3]]:
        '''(experimental) The security groups to assign to the DB instance.

        :default: - a new security group is created

        :stability: experimental
        '''
        result = self._values.get("security_groups")
        return typing.cast(typing.Optional[typing.List[_ISecurityGroup_cdbba9d3]], result)

    @builtins.property
    def storage_type(self) -> typing.Optional[StorageType]:
        '''(experimental) The storage type.

        Storage types supported are gp2, io1, standard.

        :default: GP2

        :see: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Storage.html#Concepts.Storage.GeneralSSD
        :stability: experimental
        '''
        result = self._values.get("storage_type")
        return typing.cast(typing.Optional[StorageType], result)

    @builtins.property
    def subnet_group(self) -> typing.Optional[ISubnetGroup]:
        '''(experimental) Existing subnet group for the instance.

        :default: - a new subnet group will be created.

        :stability: experimental
        '''
        result = self._values.get("subnet_group")
        return typing.cast(typing.Optional[ISubnetGroup], result)

    @builtins.property
    def vpc_placement(self) -> typing.Optional[_SubnetSelection_1284e62c]:
        '''(deprecated) The type of subnets to add to the created DB subnet group.

        :default: - private subnets

        :deprecated: use ``vpcSubnets``

        :stability: deprecated
        '''
        result = self._values.get("vpc_placement")
        return typing.cast(typing.Optional[_SubnetSelection_1284e62c], result)

    @builtins.property
    def vpc_subnets(self) -> typing.Optional[_SubnetSelection_1284e62c]:
        '''(experimental) The type of subnets to add to the created DB subnet group.

        :default: - private subnets

        :stability: experimental
        '''
        result = self._values.get("vpc_subnets")
        return typing.cast(typing.Optional[_SubnetSelection_1284e62c], result)

    @builtins.property
    def engine(self) -> IInstanceEngine:
        '''(experimental) The database engine.

        :stability: experimental
        '''
        result = self._values.get("engine")
        assert result is not None, "Required property 'engine' is missing"
        return typing.cast(IInstanceEngine, result)

    @builtins.property
    def allocated_storage(self) -> typing.Optional[jsii.Number]:
        '''(experimental) The allocated storage size, specified in gigabytes (GB).

        :default: 100

        :stability: experimental
        '''
        result = self._values.get("allocated_storage")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def allow_major_version_upgrade(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Whether to allow major version upgrades.

        :default: false

        :stability: experimental
        '''
        result = self._values.get("allow_major_version_upgrade")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def database_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) The name of the database.

        :default: - no name

        :stability: experimental
        '''
        result = self._values.get("database_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def instance_type(self) -> typing.Optional[_InstanceType_072ad323]:
        '''(experimental) The name of the compute and memory capacity for the instance.

        :default: - m5.large (or, more specifically, db.m5.large)

        :stability: experimental
        '''
        result = self._values.get("instance_type")
        return typing.cast(typing.Optional[_InstanceType_072ad323], result)

    @builtins.property
    def license_model(self) -> typing.Optional[LicenseModel]:
        '''(experimental) The license model.

        :default: - RDS default license model

        :stability: experimental
        '''
        result = self._values.get("license_model")
        return typing.cast(typing.Optional[LicenseModel], result)

    @builtins.property
    def parameters(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''(experimental) The parameters in the DBParameterGroup to create automatically.

        You can only specify parameterGroup or parameters but not both.
        You need to use a versioned engine to auto-generate a DBParameterGroup.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("parameters")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def timezone(self) -> typing.Optional[builtins.str]:
        '''(experimental) The time zone of the instance.

        This is currently supported only by Microsoft Sql Server.

        :default: - RDS default timezone

        :stability: experimental
        '''
        result = self._values.get("timezone")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def snapshot_identifier(self) -> builtins.str:
        '''(experimental) The name or Amazon Resource Name (ARN) of the DB snapshot that's used to restore the DB instance.

        If you're restoring from a shared manual DB
        snapshot, you must specify the ARN of the snapshot.

        :stability: experimental
        '''
        result = self._values.get("snapshot_identifier")
        assert result is not None, "Required property 'snapshot_identifier' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def credentials(self) -> typing.Optional[SnapshotCredentials]:
        '''(experimental) Master user credentials.

        Note - It is not possible to change the master username for a snapshot;
        however, it is possible to provide (or generate) a new password.

        :default: - The existing username and password from the snapshot will be used.

        :stability: experimental
        '''
        result = self._values.get("credentials")
        return typing.cast(typing.Optional[SnapshotCredentials], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DatabaseInstanceFromSnapshotProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="monocdk.aws_rds.DatabaseInstanceProps",
    jsii_struct_bases=[DatabaseInstanceSourceProps],
    name_mapping={
        "vpc": "vpc",
        "auto_minor_version_upgrade": "autoMinorVersionUpgrade",
        "availability_zone": "availabilityZone",
        "backup_retention": "backupRetention",
        "cloudwatch_logs_exports": "cloudwatchLogsExports",
        "cloudwatch_logs_retention": "cloudwatchLogsRetention",
        "cloudwatch_logs_retention_role": "cloudwatchLogsRetentionRole",
        "copy_tags_to_snapshot": "copyTagsToSnapshot",
        "delete_automated_backups": "deleteAutomatedBackups",
        "deletion_protection": "deletionProtection",
        "domain": "domain",
        "domain_role": "domainRole",
        "enable_performance_insights": "enablePerformanceInsights",
        "iam_authentication": "iamAuthentication",
        "instance_identifier": "instanceIdentifier",
        "iops": "iops",
        "max_allocated_storage": "maxAllocatedStorage",
        "monitoring_interval": "monitoringInterval",
        "monitoring_role": "monitoringRole",
        "multi_az": "multiAz",
        "option_group": "optionGroup",
        "parameter_group": "parameterGroup",
        "performance_insight_encryption_key": "performanceInsightEncryptionKey",
        "performance_insight_retention": "performanceInsightRetention",
        "port": "port",
        "preferred_backup_window": "preferredBackupWindow",
        "preferred_maintenance_window": "preferredMaintenanceWindow",
        "processor_features": "processorFeatures",
        "publicly_accessible": "publiclyAccessible",
        "removal_policy": "removalPolicy",
        "s3_export_buckets": "s3ExportBuckets",
        "s3_export_role": "s3ExportRole",
        "s3_import_buckets": "s3ImportBuckets",
        "s3_import_role": "s3ImportRole",
        "security_groups": "securityGroups",
        "storage_type": "storageType",
        "subnet_group": "subnetGroup",
        "vpc_placement": "vpcPlacement",
        "vpc_subnets": "vpcSubnets",
        "engine": "engine",
        "allocated_storage": "allocatedStorage",
        "allow_major_version_upgrade": "allowMajorVersionUpgrade",
        "database_name": "databaseName",
        "instance_type": "instanceType",
        "license_model": "licenseModel",
        "parameters": "parameters",
        "timezone": "timezone",
        "character_set_name": "characterSetName",
        "credentials": "credentials",
        "storage_encrypted": "storageEncrypted",
        "storage_encryption_key": "storageEncryptionKey",
    },
)
class DatabaseInstanceProps(DatabaseInstanceSourceProps):
    def __init__(
        self,
        *,
        vpc: _IVpc_6d1f76c4,
        auto_minor_version_upgrade: typing.Optional[builtins.bool] = None,
        availability_zone: typing.Optional[builtins.str] = None,
        backup_retention: typing.Optional[_Duration_070aa057] = None,
        cloudwatch_logs_exports: typing.Optional[typing.Sequence[builtins.str]] = None,
        cloudwatch_logs_retention: typing.Optional[_RetentionDays_6c560d31] = None,
        cloudwatch_logs_retention_role: typing.Optional[_IRole_59af6f50] = None,
        copy_tags_to_snapshot: typing.Optional[builtins.bool] = None,
        delete_automated_backups: typing.Optional[builtins.bool] = None,
        deletion_protection: typing.Optional[builtins.bool] = None,
        domain: typing.Optional[builtins.str] = None,
        domain_role: typing.Optional[_IRole_59af6f50] = None,
        enable_performance_insights: typing.Optional[builtins.bool] = None,
        iam_authentication: typing.Optional[builtins.bool] = None,
        instance_identifier: typing.Optional[builtins.str] = None,
        iops: typing.Optional[jsii.Number] = None,
        max_allocated_storage: typing.Optional[jsii.Number] = None,
        monitoring_interval: typing.Optional[_Duration_070aa057] = None,
        monitoring_role: typing.Optional[_IRole_59af6f50] = None,
        multi_az: typing.Optional[builtins.bool] = None,
        option_group: typing.Optional[IOptionGroup] = None,
        parameter_group: typing.Optional[IParameterGroup] = None,
        performance_insight_encryption_key: typing.Optional[_IKey_36930160] = None,
        performance_insight_retention: typing.Optional[PerformanceInsightRetention] = None,
        port: typing.Optional[jsii.Number] = None,
        preferred_backup_window: typing.Optional[builtins.str] = None,
        preferred_maintenance_window: typing.Optional[builtins.str] = None,
        processor_features: typing.Optional[typing.Union[ProcessorFeatures, typing.Dict[builtins.str, typing.Any]]] = None,
        publicly_accessible: typing.Optional[builtins.bool] = None,
        removal_policy: typing.Optional[_RemovalPolicy_c97e7a20] = None,
        s3_export_buckets: typing.Optional[typing.Sequence[_IBucket_73486e29]] = None,
        s3_export_role: typing.Optional[_IRole_59af6f50] = None,
        s3_import_buckets: typing.Optional[typing.Sequence[_IBucket_73486e29]] = None,
        s3_import_role: typing.Optional[_IRole_59af6f50] = None,
        security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
        storage_type: typing.Optional[StorageType] = None,
        subnet_group: typing.Optional[ISubnetGroup] = None,
        vpc_placement: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
        vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
        engine: IInstanceEngine,
        allocated_storage: typing.Optional[jsii.Number] = None,
        allow_major_version_upgrade: typing.Optional[builtins.bool] = None,
        database_name: typing.Optional[builtins.str] = None,
        instance_type: typing.Optional[_InstanceType_072ad323] = None,
        license_model: typing.Optional[LicenseModel] = None,
        parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        timezone: typing.Optional[builtins.str] = None,
        character_set_name: typing.Optional[builtins.str] = None,
        credentials: typing.Optional[Credentials] = None,
        storage_encrypted: typing.Optional[builtins.bool] = None,
        storage_encryption_key: typing.Optional[_IKey_36930160] = None,
    ) -> None:
        '''(experimental) Construction properties for a DatabaseInstance.

        :param vpc: (experimental) The VPC network where the DB subnet group should be created.
        :param auto_minor_version_upgrade: (experimental) Indicates that minor engine upgrades are applied automatically to the DB instance during the maintenance window. Default: true
        :param availability_zone: (experimental) The name of the Availability Zone where the DB instance will be located. Default: - no preference
        :param backup_retention: (experimental) The number of days during which automatic DB snapshots are retained. Set to zero to disable backups. When creating a read replica, you must enable automatic backups on the source database instance by setting the backup retention to a value other than zero. Default: - Duration.days(1) for source instances, disabled for read replicas
        :param cloudwatch_logs_exports: (experimental) The list of log types that need to be enabled for exporting to CloudWatch Logs. Default: - no log exports
        :param cloudwatch_logs_retention: (experimental) The number of days log events are kept in CloudWatch Logs. When updating this property, unsetting it doesn't remove the log retention policy. To remove the retention policy, set the value to ``Infinity``. Default: - logs never expire
        :param cloudwatch_logs_retention_role: (experimental) The IAM role for the Lambda function associated with the custom resource that sets the retention policy. Default: - a new role is created.
        :param copy_tags_to_snapshot: (experimental) Indicates whether to copy all of the user-defined tags from the DB instance to snapshots of the DB instance. Default: true
        :param delete_automated_backups: (experimental) Indicates whether automated backups should be deleted or retained when you delete a DB instance. Default: false
        :param deletion_protection: (experimental) Indicates whether the DB instance should have deletion protection enabled. Default: - true if ``removalPolicy`` is RETAIN, false otherwise
        :param domain: (experimental) The Active Directory directory ID to create the DB instance in. Default: - Do not join domain
        :param domain_role: (experimental) The IAM role to be used when making API calls to the Directory Service. The role needs the AWS-managed policy AmazonRDSDirectoryServiceAccess or equivalent. Default: - The role will be created for you if {@link DatabaseInstanceNewProps#domain} is specified
        :param enable_performance_insights: (experimental) Whether to enable Performance Insights for the DB instance. Default: - false, unless ``performanceInsightRentention`` or ``performanceInsightEncryptionKey`` is set.
        :param iam_authentication: (experimental) Whether to enable mapping of AWS Identity and Access Management (IAM) accounts to database accounts. Default: false
        :param instance_identifier: (experimental) A name for the DB instance. If you specify a name, AWS CloudFormation converts it to lowercase. Default: - a CloudFormation generated name
        :param iops: (experimental) The number of I/O operations per second (IOPS) that the database provisions. The value must be equal to or greater than 1000. Default: - no provisioned iops
        :param max_allocated_storage: (experimental) Upper limit to which RDS can scale the storage in GiB(Gibibyte). Default: - No autoscaling of RDS instance
        :param monitoring_interval: (experimental) The interval, in seconds, between points when Amazon RDS collects enhanced monitoring metrics for the DB instance. Default: - no enhanced monitoring
        :param monitoring_role: (experimental) Role that will be used to manage DB instance monitoring. Default: - A role is automatically created for you
        :param multi_az: (experimental) Specifies if the database instance is a multiple Availability Zone deployment. Default: false
        :param option_group: (experimental) The option group to associate with the instance. Default: - no option group
        :param parameter_group: (experimental) The DB parameter group to associate with the instance. Default: - no parameter group
        :param performance_insight_encryption_key: (experimental) The AWS KMS key for encryption of Performance Insights data. Default: - default master key
        :param performance_insight_retention: (experimental) The amount of time, in days, to retain Performance Insights data. Default: 7
        :param port: (experimental) The port for the instance. Default: - the default port for the chosen engine.
        :param preferred_backup_window: (experimental) The daily time range during which automated backups are performed. Constraints: - Must be in the format ``hh24:mi-hh24:mi``. - Must be in Universal Coordinated Time (UTC). - Must not conflict with the preferred maintenance window. - Must be at least 30 minutes. Default: - a 30-minute window selected at random from an 8-hour block of time for each AWS Region. To see the time blocks available, see https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithAutomatedBackups.html#USER_WorkingWithAutomatedBackups.BackupWindow
        :param preferred_maintenance_window: (experimental) The weekly time range (in UTC) during which system maintenance can occur. Format: ``ddd:hh24:mi-ddd:hh24:mi`` Constraint: Minimum 30-minute window Default: - a 30-minute window selected at random from an 8-hour block of time for each AWS Region, occurring on a random day of the week. To see the time blocks available, see https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_UpgradeDBInstance.Maintenance.html#Concepts.DBMaintenance
        :param processor_features: (experimental) The number of CPU cores and the number of threads per core. Default: - the default number of CPU cores and threads per core for the chosen instance class. See https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html#USER_ConfigureProcessor
        :param publicly_accessible: (experimental) Indicates whether the DB instance is an internet-facing instance. Default: - ``true`` if ``vpcSubnets`` is ``subnetType: SubnetType.PUBLIC``, ``false`` otherwise
        :param removal_policy: (experimental) The CloudFormation policy to apply when the instance is removed from the stack or replaced during an update. Default: - RemovalPolicy.SNAPSHOT (remove the resource, but retain a snapshot of the data)
        :param s3_export_buckets: (experimental) S3 buckets that you want to load data into. This property must not be used if ``s3ExportRole`` is used. For Microsoft SQL Server: Default: - None
        :param s3_export_role: (experimental) Role that will be associated with this DB instance to enable S3 export. This property must not be used if ``s3ExportBuckets`` is used. For Microsoft SQL Server: Default: - New role is created if ``s3ExportBuckets`` is set, no role is defined otherwise
        :param s3_import_buckets: (experimental) S3 buckets that you want to load data from. This feature is only supported by the Microsoft SQL Server, Oracle, and PostgreSQL engines. This property must not be used if ``s3ImportRole`` is used. For Microsoft SQL Server: Default: - None
        :param s3_import_role: (experimental) Role that will be associated with this DB instance to enable S3 import. This feature is only supported by the Microsoft SQL Server, Oracle, and PostgreSQL engines. This property must not be used if ``s3ImportBuckets`` is used. For Microsoft SQL Server: Default: - New role is created if ``s3ImportBuckets`` is set, no role is defined otherwise
        :param security_groups: (experimental) The security groups to assign to the DB instance. Default: - a new security group is created
        :param storage_type: (experimental) The storage type. Storage types supported are gp2, io1, standard. Default: GP2
        :param subnet_group: (experimental) Existing subnet group for the instance. Default: - a new subnet group will be created.
        :param vpc_placement: (deprecated) The type of subnets to add to the created DB subnet group. Default: - private subnets
        :param vpc_subnets: (experimental) The type of subnets to add to the created DB subnet group. Default: - private subnets
        :param engine: (experimental) The database engine.
        :param allocated_storage: (experimental) The allocated storage size, specified in gigabytes (GB). Default: 100
        :param allow_major_version_upgrade: (experimental) Whether to allow major version upgrades. Default: false
        :param database_name: (experimental) The name of the database. Default: - no name
        :param instance_type: (experimental) The name of the compute and memory capacity for the instance. Default: - m5.large (or, more specifically, db.m5.large)
        :param license_model: (experimental) The license model. Default: - RDS default license model
        :param parameters: (experimental) The parameters in the DBParameterGroup to create automatically. You can only specify parameterGroup or parameters but not both. You need to use a versioned engine to auto-generate a DBParameterGroup. Default: - None
        :param timezone: (experimental) The time zone of the instance. This is currently supported only by Microsoft Sql Server. Default: - RDS default timezone
        :param character_set_name: (experimental) For supported engines, specifies the character set to associate with the DB instance. Default: - RDS default character set name
        :param credentials: (experimental) Credentials for the administrative user. Default: - A username of 'admin' (or 'postgres' for PostgreSQL) and SecretsManager-generated password
        :param storage_encrypted: (experimental) Indicates whether the DB instance is encrypted. Default: - true if storageEncryptionKey has been provided, false otherwise
        :param storage_encryption_key: (experimental) The KMS key that's used to encrypt the DB instance. Default: - default master key if storageEncrypted is true, no key otherwise

        :stability: experimental
        :exampleMetadata: infused

        Example::

            # vpc: ec2.Vpc
            
            engine = rds.DatabaseInstanceEngine.postgres(version=rds.PostgresEngineVersion.VER_12_3)
            rds.DatabaseInstance(self, "InstanceWithUsername",
                engine=engine,
                vpc=vpc,
                credentials=rds.Credentials.from_generated_secret("postgres")
            )
            
            rds.DatabaseInstance(self, "InstanceWithUsernameAndPassword",
                engine=engine,
                vpc=vpc,
                credentials=rds.Credentials.from_password("postgres", SecretValue.ssm_secure("/dbPassword", "1"))
            )
            
            my_secret = secretsmanager.Secret.from_secret_name(self, "DBSecret", "myDBLoginInfo")
            rds.DatabaseInstance(self, "InstanceWithSecretLogin",
                engine=engine,
                vpc=vpc,
                credentials=rds.Credentials.from_secret(my_secret)
            )
        '''
        if isinstance(processor_features, dict):
            processor_features = ProcessorFeatures(**processor_features)
        if isinstance(vpc_placement, dict):
            vpc_placement = _SubnetSelection_1284e62c(**vpc_placement)
        if isinstance(vpc_subnets, dict):
            vpc_subnets = _SubnetSelection_1284e62c(**vpc_subnets)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ae2e23512db40ff95a1157e35b72a05ed3c84b26f517ca4cfa98e752225fae7c)
            check_type(argname="argument vpc", value=vpc, expected_type=type_hints["vpc"])
            check_type(argname="argument auto_minor_version_upgrade", value=auto_minor_version_upgrade, expected_type=type_hints["auto_minor_version_upgrade"])
            check_type(argname="argument availability_zone", value=availability_zone, expected_type=type_hints["availability_zone"])
            check_type(argname="argument backup_retention", value=backup_retention, expected_type=type_hints["backup_retention"])
            check_type(argname="argument cloudwatch_logs_exports", value=cloudwatch_logs_exports, expected_type=type_hints["cloudwatch_logs_exports"])
            check_type(argname="argument cloudwatch_logs_retention", value=cloudwatch_logs_retention, expected_type=type_hints["cloudwatch_logs_retention"])
            check_type(argname="argument cloudwatch_logs_retention_role", value=cloudwatch_logs_retention_role, expected_type=type_hints["cloudwatch_logs_retention_role"])
            check_type(argname="argument copy_tags_to_snapshot", value=copy_tags_to_snapshot, expected_type=type_hints["copy_tags_to_snapshot"])
            check_type(argname="argument delete_automated_backups", value=delete_automated_backups, expected_type=type_hints["delete_automated_backups"])
            check_type(argname="argument deletion_protection", value=deletion_protection, expected_type=type_hints["deletion_protection"])
            check_type(argname="argument domain", value=domain, expected_type=type_hints["domain"])
            check_type(argname="argument domain_role", value=domain_role, expected_type=type_hints["domain_role"])
            check_type(argname="argument enable_performance_insights", value=enable_performance_insights, expected_type=type_hints["enable_performance_insights"])
            check_type(argname="argument iam_authentication", value=iam_authentication, expected_type=type_hints["iam_authentication"])
            check_type(argname="argument instance_identifier", value=instance_identifier, expected_type=type_hints["instance_identifier"])
            check_type(argname="argument iops", value=iops, expected_type=type_hints["iops"])
            check_type(argname="argument max_allocated_storage", value=max_allocated_storage, expected_type=type_hints["max_allocated_storage"])
            check_type(argname="argument monitoring_interval", value=monitoring_interval, expected_type=type_hints["monitoring_interval"])
            check_type(argname="argument monitoring_role", value=monitoring_role, expected_type=type_hints["monitoring_role"])
            check_type(argname="argument multi_az", value=multi_az, expected_type=type_hints["multi_az"])
            check_type(argname="argument option_group", value=option_group, expected_type=type_hints["option_group"])
            check_type(argname="argument parameter_group", value=parameter_group, expected_type=type_hints["parameter_group"])
            check_type(argname="argument performance_insight_encryption_key", value=performance_insight_encryption_key, expected_type=type_hints["performance_insight_encryption_key"])
            check_type(argname="argument performance_insight_retention", value=performance_insight_retention, expected_type=type_hints["performance_insight_retention"])
            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
            check_type(argname="argument preferred_backup_window", value=preferred_backup_window, expected_type=type_hints["preferred_backup_window"])
            check_type(argname="argument preferred_maintenance_window", value=preferred_maintenance_window, expected_type=type_hints["preferred_maintenance_window"])
            check_type(argname="argument processor_features", value=processor_features, expected_type=type_hints["processor_features"])
            check_type(argname="argument publicly_accessible", value=publicly_accessible, expected_type=type_hints["publicly_accessible"])
            check_type(argname="argument removal_policy", value=removal_policy, expected_type=type_hints["removal_policy"])
            check_type(argname="argument s3_export_buckets", value=s3_export_buckets, expected_type=type_hints["s3_export_buckets"])
            check_type(argname="argument s3_export_role", value=s3_export_role, expected_type=type_hints["s3_export_role"])
            check_type(argname="argument s3_import_buckets", value=s3_import_buckets, expected_type=type_hints["s3_import_buckets"])
            check_type(argname="argument s3_import_role", value=s3_import_role, expected_type=type_hints["s3_import_role"])
            check_type(argname="argument security_groups", value=security_groups, expected_type=type_hints["security_groups"])
            check_type(argname="argument storage_type", value=storage_type, expected_type=type_hints["storage_type"])
            check_type(argname="argument subnet_group", value=subnet_group, expected_type=type_hints["subnet_group"])
            check_type(argname="argument vpc_placement", value=vpc_placement, expected_type=type_hints["vpc_placement"])
            check_type(argname="argument vpc_subnets", value=vpc_subnets, expected_type=type_hints["vpc_subnets"])
            check_type(argname="argument engine", value=engine, expected_type=type_hints["engine"])
            check_type(argname="argument allocated_storage", value=allocated_storage, expected_type=type_hints["allocated_storage"])
            check_type(argname="argument allow_major_version_upgrade", value=allow_major_version_upgrade, expected_type=type_hints["allow_major_version_upgrade"])
            check_type(argname="argument database_name", value=database_name, expected_type=type_hints["database_name"])
            check_type(argname="argument instance_type", value=instance_type, expected_type=type_hints["instance_type"])
            check_type(argname="argument license_model", value=license_model, expected_type=type_hints["license_model"])
            check_type(argname="argument parameters", value=parameters, expected_type=type_hints["parameters"])
            check_type(argname="argument timezone", value=timezone, expected_type=type_hints["timezone"])
            check_type(argname="argument character_set_name", value=character_set_name, expected_type=type_hints["character_set_name"])
            check_type(argname="argument credentials", value=credentials, expected_type=type_hints["credentials"])
            check_type(argname="argument storage_encrypted", value=storage_encrypted, expected_type=type_hints["storage_encrypted"])
            check_type(argname="argument storage_encryption_key", value=storage_encryption_key, expected_type=type_hints["storage_encryption_key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "vpc": vpc,
            "engine": engine,
        }
        if auto_minor_version_upgrade is not None:
            self._values["auto_minor_version_upgrade"] = auto_minor_version_upgrade
        if availability_zone is not None:
            self._values["availability_zone"] = availability_zone
        if backup_retention is not None:
            self._values["backup_retention"] = backup_retention
        if cloudwatch_logs_exports is not None:
            self._values["cloudwatch_logs_exports"] = cloudwatch_logs_exports
        if cloudwatch_logs_retention is not None:
            self._values["cloudwatch_logs_retention"] = cloudwatch_logs_retention
        if cloudwatch_logs_retention_role is not None:
            self._values["cloudwatch_logs_retention_role"] = cloudwatch_logs_retention_role
        if copy_tags_to_snapshot is not None:
            self._values["copy_tags_to_snapshot"] = copy_tags_to_snapshot
        if delete_automated_backups is not None:
            self._values["delete_automated_backups"] = delete_automated_backups
        if deletion_protection is not None:
            self._values["deletion_protection"] = deletion_protection
        if domain is not None:
            self._values["domain"] = domain
        if domain_role is not None:
            self._values["domain_role"] = domain_role
        if enable_performance_insights is not None:
            self._values["enable_performance_insights"] = enable_performance_insights
        if iam_authentication is not None:
            self._values["iam_authentication"] = iam_authentication
        if instance_identifier is not None:
            self._values["instance_identifier"] = instance_identifier
        if iops is not None:
            self._values["iops"] = iops
        if max_allocated_storage is not None:
            self._values["max_allocated_storage"] = max_allocated_storage
        if monitoring_interval is not None:
            self._values["monitoring_interval"] = monitoring_interval
        if monitoring_role is not None:
            self._values["monitoring_role"] = monitoring_role
        if multi_az is not None:
            self._values["multi_az"] = multi_az
        if option_group is not None:
            self._values["option_group"] = option_group
        if parameter_group is not None:
            self._values["parameter_group"] = parameter_group
        if performance_insight_encryption_key is not None:
            self._values["performance_insight_encryption_key"] = performance_insight_encryption_key
        if performance_insight_retention is not None:
            self._values["performance_insight_retention"] = performance_insight_retention
        if port is not None:
            self._values["port"] = port
        if preferred_backup_window is not None:
            self._values["preferred_backup_window"] = preferred_backup_window
        if preferred_maintenance_window is not None:
            self._values["preferred_maintenance_window"] = preferred_maintenance_window
        if processor_features is not None:
            self._values["processor_features"] = processor_features
        if publicly_accessible is not None:
            self._values["publicly_accessible"] = publicly_accessible
        if removal_policy is not None:
            self._values["removal_policy"] = removal_policy
        if s3_export_buckets is not None:
            self._values["s3_export_buckets"] = s3_export_buckets
        if s3_export_role is not None:
            self._values["s3_export_role"] = s3_export_role
        if s3_import_buckets is not None:
            self._values["s3_import_buckets"] = s3_import_buckets
        if s3_import_role is not None:
            self._values["s3_import_role"] = s3_import_role
        if security_groups is not None:
            self._values["security_groups"] = security_groups
        if storage_type is not None:
            self._values["storage_type"] = storage_type
        if subnet_group is not None:
            self._values["subnet_group"] = subnet_group
        if vpc_placement is not None:
            self._values["vpc_placement"] = vpc_placement
        if vpc_subnets is not None:
            self._values["vpc_subnets"] = vpc_subnets
        if allocated_storage is not None:
            self._values["allocated_storage"] = allocated_storage
        if allow_major_version_upgrade is not None:
            self._values["allow_major_version_upgrade"] = allow_major_version_upgrade
        if database_name is not None:
            self._values["database_name"] = database_name
        if instance_type is not None:
            self._values["instance_type"] = instance_type
        if license_model is not None:
            self._values["license_model"] = license_model
        if parameters is not None:
            self._values["parameters"] = parameters
        if timezone is not None:
            self._values["timezone"] = timezone
        if character_set_name is not None:
            self._values["character_set_name"] = character_set_name
        if credentials is not None:
            self._values["credentials"] = credentials
        if storage_encrypted is not None:
            self._values["storage_encrypted"] = storage_encrypted
        if storage_encryption_key is not None:
            self._values["storage_encryption_key"] = storage_encryption_key

    @builtins.property
    def vpc(self) -> _IVpc_6d1f76c4:
        '''(experimental) The VPC network where the DB subnet group should be created.

        :stability: experimental
        '''
        result = self._values.get("vpc")
        assert result is not None, "Required property 'vpc' is missing"
        return typing.cast(_IVpc_6d1f76c4, result)

    @builtins.property
    def auto_minor_version_upgrade(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates that minor engine upgrades are applied automatically to the DB instance during the maintenance window.

        :default: true

        :stability: experimental
        '''
        result = self._values.get("auto_minor_version_upgrade")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def availability_zone(self) -> typing.Optional[builtins.str]:
        '''(experimental) The name of the Availability Zone where the DB instance will be located.

        :default: - no preference

        :stability: experimental
        '''
        result = self._values.get("availability_zone")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def backup_retention(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) The number of days during which automatic DB snapshots are retained.

        Set to zero to disable backups.
        When creating a read replica, you must enable automatic backups on the source
        database instance by setting the backup retention to a value other than zero.

        :default: - Duration.days(1) for source instances, disabled for read replicas

        :stability: experimental
        '''
        result = self._values.get("backup_retention")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def cloudwatch_logs_exports(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) The list of log types that need to be enabled for exporting to CloudWatch Logs.

        :default: - no log exports

        :stability: experimental
        '''
        result = self._values.get("cloudwatch_logs_exports")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def cloudwatch_logs_retention(self) -> typing.Optional[_RetentionDays_6c560d31]:
        '''(experimental) The number of days log events are kept in CloudWatch Logs.

        When updating
        this property, unsetting it doesn't remove the log retention policy. To
        remove the retention policy, set the value to ``Infinity``.

        :default: - logs never expire

        :stability: experimental
        '''
        result = self._values.get("cloudwatch_logs_retention")
        return typing.cast(typing.Optional[_RetentionDays_6c560d31], result)

    @builtins.property
    def cloudwatch_logs_retention_role(self) -> typing.Optional[_IRole_59af6f50]:
        '''(experimental) The IAM role for the Lambda function associated with the custom resource that sets the retention policy.

        :default: - a new role is created.

        :stability: experimental
        '''
        result = self._values.get("cloudwatch_logs_retention_role")
        return typing.cast(typing.Optional[_IRole_59af6f50], result)

    @builtins.property
    def copy_tags_to_snapshot(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether to copy all of the user-defined tags from the DB instance to snapshots of the DB instance.

        :default: true

        :stability: experimental
        '''
        result = self._values.get("copy_tags_to_snapshot")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def delete_automated_backups(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether automated backups should be deleted or retained when you delete a DB instance.

        :default: false

        :stability: experimental
        '''
        result = self._values.get("delete_automated_backups")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def deletion_protection(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the DB instance should have deletion protection enabled.

        :default: - true if ``removalPolicy`` is RETAIN, false otherwise

        :stability: experimental
        '''
        result = self._values.get("deletion_protection")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def domain(self) -> typing.Optional[builtins.str]:
        '''(experimental) The Active Directory directory ID to create the DB instance in.

        :default: - Do not join domain

        :stability: experimental
        '''
        result = self._values.get("domain")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def domain_role(self) -> typing.Optional[_IRole_59af6f50]:
        '''(experimental) The IAM role to be used when making API calls to the Directory Service.

        The role needs the AWS-managed policy
        AmazonRDSDirectoryServiceAccess or equivalent.

        :default: - The role will be created for you if {@link DatabaseInstanceNewProps#domain} is specified

        :stability: experimental
        '''
        result = self._values.get("domain_role")
        return typing.cast(typing.Optional[_IRole_59af6f50], result)

    @builtins.property
    def enable_performance_insights(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Whether to enable Performance Insights for the DB instance.

        :default: - false, unless ``performanceInsightRentention`` or ``performanceInsightEncryptionKey`` is set.

        :stability: experimental
        '''
        result = self._values.get("enable_performance_insights")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def iam_authentication(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Whether to enable mapping of AWS Identity and Access Management (IAM) accounts to database accounts.

        :default: false

        :stability: experimental
        '''
        result = self._values.get("iam_authentication")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def instance_identifier(self) -> typing.Optional[builtins.str]:
        '''(experimental) A name for the DB instance.

        If you specify a name, AWS CloudFormation
        converts it to lowercase.

        :default: - a CloudFormation generated name

        :stability: experimental
        '''
        result = self._values.get("instance_identifier")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def iops(self) -> typing.Optional[jsii.Number]:
        '''(experimental) The number of I/O operations per second (IOPS) that the database provisions.

        The value must be equal to or greater than 1000.

        :default: - no provisioned iops

        :stability: experimental
        '''
        result = self._values.get("iops")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def max_allocated_storage(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Upper limit to which RDS can scale the storage in GiB(Gibibyte).

        :default: - No autoscaling of RDS instance

        :see: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PIOPS.StorageTypes.html#USER_PIOPS.Autoscaling
        :stability: experimental
        '''
        result = self._values.get("max_allocated_storage")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def monitoring_interval(self) -> typing.Optional[_Duration_070aa057]:
        '''(experimental) The interval, in seconds, between points when Amazon RDS collects enhanced monitoring metrics for the DB instance.

        :default: - no enhanced monitoring

        :stability: experimental
        '''
        result = self._values.get("monitoring_interval")
        return typing.cast(typing.Optional[_Duration_070aa057], result)

    @builtins.property
    def monitoring_role(self) -> typing.Optional[_IRole_59af6f50]:
        '''(experimental) Role that will be used to manage DB instance monitoring.

        :default: - A role is automatically created for you

        :stability: experimental
        '''
        result = self._values.get("monitoring_role")
        return typing.cast(typing.Optional[_IRole_59af6f50], result)

    @builtins.property
    def multi_az(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Specifies if the database instance is a multiple Availability Zone deployment.

        :default: false

        :stability: experimental
        '''
        result = self._values.get("multi_az")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def option_group(self) -> typing.Optional[IOptionGroup]:
        '''(experimental) The option group to associate with the instance.

        :default: - no option group

        :stability: experimental
        '''
        result = self._values.get("option_group")
        return typing.cast(typing.Optional[IOptionGroup], result)

    @builtins.property
    def parameter_group(self) -> typing.Optional[IParameterGroup]:
        '''(experimental) The DB parameter group to associate with the instance.

        :default: - no parameter group

        :stability: experimental
        '''
        result = self._values.get("parameter_group")
        return typing.cast(typing.Optional[IParameterGroup], result)

    @builtins.property
    def performance_insight_encryption_key(self) -> typing.Optional[_IKey_36930160]:
        '''(experimental) The AWS KMS key for encryption of Performance Insights data.

        :default: - default master key

        :stability: experimental
        '''
        result = self._values.get("performance_insight_encryption_key")
        return typing.cast(typing.Optional[_IKey_36930160], result)

    @builtins.property
    def performance_insight_retention(
        self,
    ) -> typing.Optional[PerformanceInsightRetention]:
        '''(experimental) The amount of time, in days, to retain Performance Insights data.

        :default: 7

        :stability: experimental
        '''
        result = self._values.get("performance_insight_retention")
        return typing.cast(typing.Optional[PerformanceInsightRetention], result)

    @builtins.property
    def port(self) -> typing.Optional[jsii.Number]:
        '''(experimental) The port for the instance.

        :default: - the default port for the chosen engine.

        :stability: experimental
        '''
        result = self._values.get("port")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def preferred_backup_window(self) -> typing.Optional[builtins.str]:
        '''(experimental) The daily time range during which automated backups are performed.

        Constraints:

        - Must be in the format ``hh24:mi-hh24:mi``.
        - Must be in Universal Coordinated Time (UTC).
        - Must not conflict with the preferred maintenance window.
        - Must be at least 30 minutes.

        :default:

        - a 30-minute window selected at random from an 8-hour block of
        time for each AWS Region. To see the time blocks available, see
        https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithAutomatedBackups.html#USER_WorkingWithAutomatedBackups.BackupWindow

        :stability: experimental
        '''
        result = self._values.get("preferred_backup_window")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def preferred_maintenance_window(self) -> typing.Optional[builtins.str]:
        '''(experimental) The weekly time range (in UTC) during which system maintenance can occur.

        Format: ``ddd:hh24:mi-ddd:hh24:mi``
        Constraint: Minimum 30-minute window

        :default:

        - a 30-minute window selected at random from an 8-hour block of
        time for each AWS Region, occurring on a random day of the week. To see
        the time blocks available, see https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_UpgradeDBInstance.Maintenance.html#Concepts.DBMaintenance

        :stability: experimental
        '''
        result = self._values.get("preferred_maintenance_window")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def processor_features(self) -> typing.Optional[ProcessorFeatures]:
        '''(experimental) The number of CPU cores and the number of threads per core.

        :default:

        - the default number of CPU cores and threads per core for the
        chosen instance class.

        See https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html#USER_ConfigureProcessor

        :stability: experimental
        '''
        result = self._values.get("processor_features")
        return typing.cast(typing.Optional[ProcessorFeatures], result)

    @builtins.property
    def publicly_accessible(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the DB instance is an internet-facing instance.

        :default: - ``true`` if ``vpcSubnets`` is ``subnetType: SubnetType.PUBLIC``, ``false`` otherwise

        :stability: experimental
        '''
        result = self._values.get("publicly_accessible")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def removal_policy(self) -> typing.Optional[_RemovalPolicy_c97e7a20]:
        '''(experimental) The CloudFormation policy to apply when the instance is removed from the stack or replaced during an update.

        :default: - RemovalPolicy.SNAPSHOT (remove the resource, but retain a snapshot of the data)

        :stability: experimental
        '''
        result = self._values.get("removal_policy")
        return typing.cast(typing.Optional[_RemovalPolicy_c97e7a20], result)

    @builtins.property
    def s3_export_buckets(self) -> typing.Optional[typing.List[_IBucket_73486e29]]:
        '''(experimental) S3 buckets that you want to load data into.

        This property must not be used if ``s3ExportRole`` is used.

        For Microsoft SQL Server:

        :default: - None

        :see: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/oracle-s3-integration.html
        :stability: experimental
        '''
        result = self._values.get("s3_export_buckets")
        return typing.cast(typing.Optional[typing.List[_IBucket_73486e29]], result)

    @builtins.property
    def s3_export_role(self) -> typing.Optional[_IRole_59af6f50]:
        '''(experimental) Role that will be associated with this DB instance to enable S3 export.

        This property must not be used if ``s3ExportBuckets`` is used.

        For Microsoft SQL Server:

        :default: - New role is created if ``s3ExportBuckets`` is set, no role is defined otherwise

        :see: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/oracle-s3-integration.html
        :stability: experimental
        '''
        result = self._values.get("s3_export_role")
        return typing.cast(typing.Optional[_IRole_59af6f50], result)

    @builtins.property
    def s3_import_buckets(self) -> typing.Optional[typing.List[_IBucket_73486e29]]:
        '''(experimental) S3 buckets that you want to load data from.

        This feature is only supported by the Microsoft SQL Server, Oracle, and PostgreSQL engines.

        This property must not be used if ``s3ImportRole`` is used.

        For Microsoft SQL Server:

        :default: - None

        :see: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/PostgreSQL.Procedural.Importing.html
        :stability: experimental
        '''
        result = self._values.get("s3_import_buckets")
        return typing.cast(typing.Optional[typing.List[_IBucket_73486e29]], result)

    @builtins.property
    def s3_import_role(self) -> typing.Optional[_IRole_59af6f50]:
        '''(experimental) Role that will be associated with this DB instance to enable S3 import.

        This feature is only supported by the Microsoft SQL Server, Oracle, and PostgreSQL engines.

        This property must not be used if ``s3ImportBuckets`` is used.

        For Microsoft SQL Server:

        :default: - New role is created if ``s3ImportBuckets`` is set, no role is defined otherwise

        :see: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/PostgreSQL.Procedural.Importing.html
        :stability: experimental
        '''
        result = self._values.get("s3_import_role")
        return typing.cast(typing.Optional[_IRole_59af6f50], result)

    @builtins.property
    def security_groups(self) -> typing.Optional[typing.List[_ISecurityGroup_cdbba9d3]]:
        '''(experimental) The security groups to assign to the DB instance.

        :default: - a new security group is created

        :stability: experimental
        '''
        result = self._values.get("security_groups")
        return typing.cast(typing.Optional[typing.List[_ISecurityGroup_cdbba9d3]], result)

    @builtins.property
    def storage_type(self) -> typing.Optional[StorageType]:
        '''(experimental) The storage type.

        Storage types supported are gp2, io1, standard.

        :default: GP2

        :see: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Storage.html#Concepts.Storage.GeneralSSD
        :stability: experimental
        '''
        result = self._values.get("storage_type")
        return typing.cast(typing.Optional[StorageType], result)

    @builtins.property
    def subnet_group(self) -> typing.Optional[ISubnetGroup]:
        '''(experimental) Existing subnet group for the instance.

        :default: - a new subnet group will be created.

        :stability: experimental
        '''
        result = self._values.get("subnet_group")
        return typing.cast(typing.Optional[ISubnetGroup], result)

    @builtins.property
    def vpc_placement(self) -> typing.Optional[_SubnetSelection_1284e62c]:
        '''(deprecated) The type of subnets to add to the created DB subnet group.

        :default: - private subnets

        :deprecated: use ``vpcSubnets``

        :stability: deprecated
        '''
        result = self._values.get("vpc_placement")
        return typing.cast(typing.Optional[_SubnetSelection_1284e62c], result)

    @builtins.property
    def vpc_subnets(self) -> typing.Optional[_SubnetSelection_1284e62c]:
        '''(experimental) The type of subnets to add to the created DB subnet group.

        :default: - private subnets

        :stability: experimental
        '''
        result = self._values.get("vpc_subnets")
        return typing.cast(typing.Optional[_SubnetSelection_1284e62c], result)

    @builtins.property
    def engine(self) -> IInstanceEngine:
        '''(experimental) The database engine.

        :stability: experimental
        '''
        result = self._values.get("engine")
        assert result is not None, "Required property 'engine' is missing"
        return typing.cast(IInstanceEngine, result)

    @builtins.property
    def allocated_storage(self) -> typing.Optional[jsii.Number]:
        '''(experimental) The allocated storage size, specified in gigabytes (GB).

        :default: 100

        :stability: experimental
        '''
        result = self._values.get("allocated_storage")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def allow_major_version_upgrade(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Whether to allow major version upgrades.

        :default: false

        :stability: experimental
        '''
        result = self._values.get("allow_major_version_upgrade")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def database_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) The name of the database.

        :default: - no name

        :stability: experimental
        '''
        result = self._values.get("database_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def instance_type(self) -> typing.Optional[_InstanceType_072ad323]:
        '''(experimental) The name of the compute and memory capacity for the instance.

        :default: - m5.large (or, more specifically, db.m5.large)

        :stability: experimental
        '''
        result = self._values.get("instance_type")
        return typing.cast(typing.Optional[_InstanceType_072ad323], result)

    @builtins.property
    def license_model(self) -> typing.Optional[LicenseModel]:
        '''(experimental) The license model.

        :default: - RDS default license model

        :stability: experimental
        '''
        result = self._values.get("license_model")
        return typing.cast(typing.Optional[LicenseModel], result)

    @builtins.property
    def parameters(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''(experimental) The parameters in the DBParameterGroup to create automatically.

        You can only specify parameterGroup or parameters but not both.
        You need to use a versioned engine to auto-generate a DBParameterGroup.

        :default: - None

        :stability: experimental
        '''
        result = self._values.get("parameters")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def timezone(self) -> typing.Optional[builtins.str]:
        '''(experimental) The time zone of the instance.

        This is currently supported only by Microsoft Sql Server.

        :default: - RDS default timezone

        :stability: experimental
        '''
        result = self._values.get("timezone")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def character_set_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) For supported engines, specifies the character set to associate with the DB instance.

        :default: - RDS default character set name

        :stability: experimental
        '''
        result = self._values.get("character_set_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def credentials(self) -> typing.Optional[Credentials]:
        '''(experimental) Credentials for the administrative user.

        :default: - A username of 'admin' (or 'postgres' for PostgreSQL) and SecretsManager-generated password

        :stability: experimental
        '''
        result = self._values.get("credentials")
        return typing.cast(typing.Optional[Credentials], result)

    @builtins.property
    def storage_encrypted(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the DB instance is encrypted.

        :default: - true if storageEncryptionKey has been provided, false otherwise

        :stability: experimental
        '''
        result = self._values.get("storage_encrypted")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def storage_encryption_key(self) -> typing.Optional[_IKey_36930160]:
        '''(experimental) The KMS key that's used to encrypt the DB instance.

        :default: - default master key if storageEncrypted is true, no key otherwise

        :stability: experimental
        '''
        result = self._values.get("storage_encryption_key")
        return typing.cast(typing.Optional[_IKey_36930160], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DatabaseInstanceProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(IDatabaseInstance)
class DatabaseInstanceReadReplica(
    DatabaseInstanceBase,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_rds.DatabaseInstanceReadReplica",
):
    '''(experimental) A read replica database instance.

    :stability: experimental
    :resource: AWS::RDS::DBInstance
    :exampleMetadata: infused

    Example::

        # vpc: ec2.Vpc
        
        # source_instance: rds.DatabaseInstance
        
        rds.DatabaseInstanceFromSnapshot(self, "Instance",
            snapshot_identifier="my-snapshot",
            engine=rds.DatabaseInstanceEngine.postgres(version=rds.PostgresEngineVersion.VER_12_3),
            # optional, defaults to m5.large
            instance_type=ec2.InstanceType.of(ec2.InstanceClass.BURSTABLE2, ec2.InstanceSize.LARGE),
            vpc=vpc
        )
        rds.DatabaseInstanceReadReplica(self, "ReadReplica",
            source_database_instance=source_instance,
            instance_type=ec2.InstanceType.of(ec2.InstanceClass.BURSTABLE2, ec2.InstanceSize.LARGE),
            vpc=vpc
        )
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        instance_type: _InstanceType_072ad323,
        source_database_instance: IDatabaseInstance,
        storage_encrypted: typing.Optional[builtins.bool] = None,
        storage_encryption_key: typing.Optional[_IKey_36930160] = None,
        vpc: _IVpc_6d1f76c4,
        auto_minor_version_upgrade: typing.Optional[builtins.bool] = None,
        availability_zone: typing.Optional[builtins.str] = None,
        backup_retention: typing.Optional[_Duration_070aa057] = None,
        cloudwatch_logs_exports: typing.Optional[typing.Sequence[builtins.str]] = None,
        cloudwatch_logs_retention: typing.Optional[_RetentionDays_6c560d31] = None,
        cloudwatch_logs_retention_role: typing.Optional[_IRole_59af6f50] = None,
        copy_tags_to_snapshot: typing.Optional[builtins.bool] = None,
        delete_automated_backups: typing.Optional[builtins.bool] = None,
        deletion_protection: typing.Optional[builtins.bool] = None,
        domain: typing.Optional[builtins.str] = None,
        domain_role: typing.Optional[_IRole_59af6f50] = None,
        enable_performance_insights: typing.Optional[builtins.bool] = None,
        iam_authentication: typing.Optional[builtins.bool] = None,
        instance_identifier: typing.Optional[builtins.str] = None,
        iops: typing.Optional[jsii.Number] = None,
        max_allocated_storage: typing.Optional[jsii.Number] = None,
        monitoring_interval: typing.Optional[_Duration_070aa057] = None,
        monitoring_role: typing.Optional[_IRole_59af6f50] = None,
        multi_az: typing.Optional[builtins.bool] = None,
        option_group: typing.Optional[IOptionGroup] = None,
        parameter_group: typing.Optional[IParameterGroup] = None,
        performance_insight_encryption_key: typing.Optional[_IKey_36930160] = None,
        performance_insight_retention: typing.Optional[PerformanceInsightRetention] = None,
        port: typing.Optional[jsii.Number] = None,
        preferred_backup_window: typing.Optional[builtins.str] = None,
        preferred_maintenance_window: typing.Optional[builtins.str] = None,
        processor_features: typing.Optional[typing.Union[ProcessorFeatures, typing.Dict[builtins.str, typing.Any]]] = None,
        publicly_accessible: typing.Optional[builtins.bool] = None,
        removal_policy: typing.Optional[_RemovalPolicy_c97e7a20] = None,
        s3_export_buckets: typing.Optional[typing.Sequence[_IBucket_73486e29]] = None,
        s3_export_role: typing.Optional[_IRole_59af6f50] = None,
        s3_import_buckets: typing.Optional[typing.Sequence[_IBucket_73486e29]] = None,
        s3_import_role: typing.Optional[_IRole_59af6f50] = None,
        security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
        storage_type: typing.Optional[StorageType] = None,
        subnet_group: typing.Optional[ISubnetGroup] = None,
        vpc_placement: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
        vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param instance_type: (experimental) The name of the compute and memory capacity classes.
        :param source_database_instance: (experimental) The source database instance. Each DB instance can have a limited number of read replicas. For more information, see https://docs.aws.amazon.com/AmazonRDS/latest/DeveloperGuide/USER_ReadRepl.html.
        :param storage_encrypted: (experimental) Indicates whether the DB instance is encrypted. Default: - true if storageEncryptionKey has been provided, false otherwise
        :param storage_encryption_key: (experimental) The KMS key that's used to encrypt the DB instance. Default: - default master key if storageEncrypted is true, no key otherwise
        :param vpc: (experimental) The VPC network where the DB subnet group should be created.
        :param auto_minor_version_upgrade: (experimental) Indicates that minor engine upgrades are applied automatically to the DB instance during the maintenance window. Default: true
        :param availability_zone: (experimental) The name of the Availability Zone where the DB instance will be located. Default: - no preference
        :param backup_retention: (experimental) The number of days during which automatic DB snapshots are retained. Set to zero to disable backups. When creating a read replica, you must enable automatic backups on the source database instance by setting the backup retention to a value other than zero. Default: - Duration.days(1) for source instances, disabled for read replicas
        :param cloudwatch_logs_exports: (experimental) The list of log types that need to be enabled for exporting to CloudWatch Logs. Default: - no log exports
        :param cloudwatch_logs_retention: (experimental) The number of days log events are kept in CloudWatch Logs. When updating this property, unsetting it doesn't remove the log retention policy. To remove the retention policy, set the value to ``Infinity``. Default: - logs never expire
        :param cloudwatch_logs_retention_role: (experimental) The IAM role for the Lambda function associated with the custom resource that sets the retention policy. Default: - a new role is created.
        :param copy_tags_to_snapshot: (experimental) Indicates whether to copy all of the user-defined tags from the DB instance to snapshots of the DB instance. Default: true
        :param delete_automated_backups: (experimental) Indicates whether automated backups should be deleted or retained when you delete a DB instance. Default: false
        :param deletion_protection: (experimental) Indicates whether the DB instance should have deletion protection enabled. Default: - true if ``removalPolicy`` is RETAIN, false otherwise
        :param domain: (experimental) The Active Directory directory ID to create the DB instance in. Default: - Do not join domain
        :param domain_role: (experimental) The IAM role to be used when making API calls to the Directory Service. The role needs the AWS-managed policy AmazonRDSDirectoryServiceAccess or equivalent. Default: - The role will be created for you if {@link DatabaseInstanceNewProps#domain} is specified
        :param enable_performance_insights: (experimental) Whether to enable Performance Insights for the DB instance. Default: - false, unless ``performanceInsightRentention`` or ``performanceInsightEncryptionKey`` is set.
        :param iam_authentication: (experimental) Whether to enable mapping of AWS Identity and Access Management (IAM) accounts to database accounts. Default: false
        :param instance_identifier: (experimental) A name for the DB instance. If you specify a name, AWS CloudFormation converts it to lowercase. Default: - a CloudFormation generated name
        :param iops: (experimental) The number of I/O operations per second (IOPS) that the database provisions. The value must be equal to or greater than 1000. Default: - no provisioned iops
        :param max_allocated_storage: (experimental) Upper limit to which RDS can scale the storage in GiB(Gibibyte). Default: - No autoscaling of RDS instance
        :param monitoring_interval: (experimental) The interval, in seconds, between points when Amazon RDS collects enhanced monitoring metrics for the DB instance. Default: - no enhanced monitoring
        :param monitoring_role: (experimental) Role that will be used to manage DB instance monitoring. Default: - A role is automatically created for you
        :param multi_az: (experimental) Specifies if the database instance is a multiple Availability Zone deployment. Default: false
        :param option_group: (experimental) The option group to associate with the instance. Default: - no option group
        :param parameter_group: (experimental) The DB parameter group to associate with the instance. Default: - no parameter group
        :param performance_insight_encryption_key: (experimental) The AWS KMS key for encryption of Performance Insights data. Default: - default master key
        :param performance_insight_retention: (experimental) The amount of time, in days, to retain Performance Insights data. Default: 7
        :param port: (experimental) The port for the instance. Default: - the default port for the chosen engine.
        :param preferred_backup_window: (experimental) The daily time range during which automated backups are performed. Constraints: - Must be in the format ``hh24:mi-hh24:mi``. - Must be in Universal Coordinated Time (UTC). - Must not conflict with the preferred maintenance window. - Must be at least 30 minutes. Default: - a 30-minute window selected at random from an 8-hour block of time for each AWS Region. To see the time blocks available, see https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithAutomatedBackups.html#USER_WorkingWithAutomatedBackups.BackupWindow
        :param preferred_maintenance_window: (experimental) The weekly time range (in UTC) during which system maintenance can occur. Format: ``ddd:hh24:mi-ddd:hh24:mi`` Constraint: Minimum 30-minute window Default: - a 30-minute window selected at random from an 8-hour block of time for each AWS Region, occurring on a random day of the week. To see the time blocks available, see https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_UpgradeDBInstance.Maintenance.html#Concepts.DBMaintenance
        :param processor_features: (experimental) The number of CPU cores and the number of threads per core. Default: - the default number of CPU cores and threads per core for the chosen instance class. See https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html#USER_ConfigureProcessor
        :param publicly_accessible: (experimental) Indicates whether the DB instance is an internet-facing instance. Default: - ``true`` if ``vpcSubnets`` is ``subnetType: SubnetType.PUBLIC``, ``false`` otherwise
        :param removal_policy: (experimental) The CloudFormation policy to apply when the instance is removed from the stack or replaced during an update. Default: - RemovalPolicy.SNAPSHOT (remove the resource, but retain a snapshot of the data)
        :param s3_export_buckets: (experimental) S3 buckets that you want to load data into. This property must not be used if ``s3ExportRole`` is used. For Microsoft SQL Server: Default: - None
        :param s3_export_role: (experimental) Role that will be associated with this DB instance to enable S3 export. This property must not be used if ``s3ExportBuckets`` is used. For Microsoft SQL Server: Default: - New role is created if ``s3ExportBuckets`` is set, no role is defined otherwise
        :param s3_import_buckets: (experimental) S3 buckets that you want to load data from. This feature is only supported by the Microsoft SQL Server, Oracle, and PostgreSQL engines. This property must not be used if ``s3ImportRole`` is used. For Microsoft SQL Server: Default: - None
        :param s3_import_role: (experimental) Role that will be associated with this DB instance to enable S3 import. This feature is only supported by the Microsoft SQL Server, Oracle, and PostgreSQL engines. This property must not be used if ``s3ImportBuckets`` is used. For Microsoft SQL Server: Default: - New role is created if ``s3ImportBuckets`` is set, no role is defined otherwise
        :param security_groups: (experimental) The security groups to assign to the DB instance. Default: - a new security group is created
        :param storage_type: (experimental) The storage type. Storage types supported are gp2, io1, standard. Default: GP2
        :param subnet_group: (experimental) Existing subnet group for the instance. Default: - a new subnet group will be created.
        :param vpc_placement: (deprecated) The type of subnets to add to the created DB subnet group. Default: - private subnets
        :param vpc_subnets: (experimental) The type of subnets to add to the created DB subnet group. Default: - private subnets

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f7c3227f23034379200b83fecd7b912886a12a911ccb2494f84dd181c1d19634)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = DatabaseInstanceReadReplicaProps(
            instance_type=instance_type,
            source_database_instance=source_database_instance,
            storage_encrypted=storage_encrypted,
            storage_encryption_key=storage_encryption_key,
            vpc=vpc,
            auto_minor_version_upgrade=auto_minor_version_upgrade,
            availability_zone=availability_zone,
            backup_retention=backup_retention,
            cloudwatch_logs_exports=cloudwatch_logs_exports,
            cloudwatch_logs_retention=cloudwatch_logs_retention,
            cloudwatch_logs_retention_role=cloudwatch_logs_retention_role,
            copy_tags_to_snapshot=copy_tags_to_snapshot,
            delete_automated_backups=delete_automated_backups,
            deletion_protection=deletion_protection,
            domain=domain,
            domain_role=domain_role,
            enable_performance_insights=enable_performance_insights,
            iam_authentication=iam_authentication,
            instance_identifier=instance_identifier,
            iops=iops,
            max_allocated_storage=max_allocated_storage,
            monitoring_interval=monitoring_interval,
            monitoring_role=monitoring_role,
            multi_az=multi_az,
            option_group=option_group,
            parameter_group=parameter_group,
            performance_insight_encryption_key=performance_insight_encryption_key,
            performance_insight_retention=performance_insight_retention,
            port=port,
            preferred_backup_window=preferred_backup_window,
            preferred_maintenance_window=preferred_maintenance_window,
            processor_features=processor_features,
            publicly_accessible=publicly_accessible,
            removal_policy=removal_policy,
            s3_export_buckets=s3_export_buckets,
            s3_export_role=s3_export_role,
            s3_import_buckets=s3_import_buckets,
            s3_import_role=s3_import_role,
            security_groups=security_groups,
            storage_type=storage_type,
            subnet_group=subnet_group,
            vpc_placement=vpc_placement,
            vpc_subnets=vpc_subnets,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="setLogRetention")
    def _set_log_retention(self) -> None:
        '''
        :stability: experimental
        '''
        return typing.cast(None, jsii.invoke(self, "setLogRetention", []))

    @builtins.property
    @jsii.member(jsii_name="connections")
    def connections(self) -> _Connections_57ccbda9:
        '''(experimental) Access to network connections.

        :stability: experimental
        '''
        return typing.cast(_Connections_57ccbda9, jsii.get(self, "connections"))

    @builtins.property
    @jsii.member(jsii_name="dbInstanceEndpointAddress")
    def db_instance_endpoint_address(self) -> builtins.str:
        '''(experimental) The instance endpoint address.

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "dbInstanceEndpointAddress"))

    @builtins.property
    @jsii.member(jsii_name="dbInstanceEndpointPort")
    def db_instance_endpoint_port(self) -> builtins.str:
        '''(experimental) The instance endpoint port.

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "dbInstanceEndpointPort"))

    @builtins.property
    @jsii.member(jsii_name="instanceEndpoint")
    def instance_endpoint(self) -> Endpoint:
        '''(experimental) The instance endpoint.

        :stability: experimental
        '''
        return typing.cast(Endpoint, jsii.get(self, "instanceEndpoint"))

    @builtins.property
    @jsii.member(jsii_name="instanceIdentifier")
    def instance_identifier(self) -> builtins.str:
        '''(experimental) The instance identifier.

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "instanceIdentifier"))

    @builtins.property
    @jsii.member(jsii_name="instanceType")
    def _instance_type(self) -> _InstanceType_072ad323:
        '''
        :stability: experimental
        '''
        return typing.cast(_InstanceType_072ad323, jsii.get(self, "instanceType"))

    @builtins.property
    @jsii.member(jsii_name="newCfnProps")
    def _new_cfn_props(self) -> CfnDBInstanceProps:
        '''
        :stability: experimental
        '''
        return typing.cast(CfnDBInstanceProps, jsii.get(self, "newCfnProps"))

    @builtins.property
    @jsii.member(jsii_name="vpc")
    def vpc(self) -> _IVpc_6d1f76c4:
        '''(experimental) The VPC where this database instance is deployed.

        :stability: experimental
        '''
        return typing.cast(_IVpc_6d1f76c4, jsii.get(self, "vpc"))

    @builtins.property
    @jsii.member(jsii_name="engine")
    def engine(self) -> typing.Optional[IInstanceEngine]:
        '''(experimental) The engine of this database Instance.

        May be not known for imported Instances if it wasn't provided explicitly,
        or for read replicas.

        :stability: experimental
        '''
        return typing.cast(typing.Optional[IInstanceEngine], jsii.get(self, "engine"))

    @builtins.property
    @jsii.member(jsii_name="vpcPlacement")
    def _vpc_placement(self) -> typing.Optional[_SubnetSelection_1284e62c]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[_SubnetSelection_1284e62c], jsii.get(self, "vpcPlacement"))

    @builtins.property
    @jsii.member(jsii_name="enableIamAuthentication")
    def _enable_iam_authentication(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "enableIamAuthentication"))

    @_enable_iam_authentication.setter
    def _enable_iam_authentication(self, value: typing.Optional[builtins.bool]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e2e618172fbaa9a705ca00e51115de3536c016454695084da11d0e188d0eaf52)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableIamAuthentication", value)


@jsii.implements(_IConnectable_c1c0e72c, _ISecretAttachmentTarget_b6932462, IDatabaseProxy)
class DatabaseProxy(
    _Resource_abff4495,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_rds.DatabaseProxy",
):
    '''(experimental) RDS Database Proxy.

    :stability: experimental
    :resource: AWS::RDS::DBProxy
    :exampleMetadata: infused

    Example::

        # vpc: ec2.Vpc
        
        cluster = rds.DatabaseCluster(self, "Database",
            engine=rds.DatabaseClusterEngine.AURORA,
            instance_props=ec2.aws_rds.InstanceProps(vpc=vpc)
        )
        
        proxy = rds.DatabaseProxy(self, "Proxy",
            proxy_target=rds.ProxyTarget.from_cluster(cluster),
            secrets=[cluster.secret],
            vpc=vpc
        )
        
        role = iam.Role(self, "DBProxyRole", assumed_by=iam.AccountPrincipal(self.account))
        proxy.grant_connect(role, "admin")
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        proxy_target: ProxyTarget,
        secrets: typing.Sequence[_ISecret_22fb8757],
        vpc: _IVpc_6d1f76c4,
        borrow_timeout: typing.Optional[_Duration_070aa057] = None,
        db_proxy_name: typing.Optional[builtins.str] = None,
        debug_logging: typing.Optional[builtins.bool] = None,
        iam_auth: typing.Optional[builtins.bool] = None,
        idle_client_timeout: typing.Optional[_Duration_070aa057] = None,
        init_query: typing.Optional[builtins.str] = None,
        max_connections_percent: typing.Optional[jsii.Number] = None,
        max_idle_connections_percent: typing.Optional[jsii.Number] = None,
        require_tls: typing.Optional[builtins.bool] = None,
        role: typing.Optional[_IRole_59af6f50] = None,
        security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
        session_pinning_filters: typing.Optional[typing.Sequence[SessionPinningFilter]] = None,
        vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param proxy_target: (experimental) DB proxy target: Instance or Cluster.
        :param secrets: (experimental) The secret that the proxy uses to authenticate to the RDS DB instance or Aurora DB cluster. These secrets are stored within Amazon Secrets Manager. One or more secrets are required.
        :param vpc: (experimental) The VPC to associate with the new proxy.
        :param borrow_timeout: (experimental) The duration for a proxy to wait for a connection to become available in the connection pool. Only applies when the proxy has opened its maximum number of connections and all connections are busy with client sessions. Value must be between 1 second and 1 hour, or ``Duration.seconds(0)`` to represent unlimited. Default: cdk.Duration.seconds(120)
        :param db_proxy_name: (experimental) The identifier for the proxy. This name must be unique for all proxies owned by your AWS account in the specified AWS Region. An identifier must begin with a letter and must contain only ASCII letters, digits, and hyphens; it can't end with a hyphen or contain two consecutive hyphens. Default: - Generated by CloudFormation (recommended)
        :param debug_logging: (experimental) Whether the proxy includes detailed information about SQL statements in its logs. This information helps you to debug issues involving SQL behavior or the performance and scalability of the proxy connections. The debug information includes the text of SQL statements that you submit through the proxy. Thus, only enable this setting when needed for debugging, and only when you have security measures in place to safeguard any sensitive information that appears in the logs. Default: false
        :param iam_auth: (experimental) Whether to require or disallow AWS Identity and Access Management (IAM) authentication for connections to the proxy. Default: false
        :param idle_client_timeout: (experimental) The number of seconds that a connection to the proxy can be inactive before the proxy disconnects it. You can set this value higher or lower than the connection timeout limit for the associated database. Default: cdk.Duration.minutes(30)
        :param init_query: (experimental) One or more SQL statements for the proxy to run when opening each new database connection. Typically used with SET statements to make sure that each connection has identical settings such as time zone and character set. For multiple statements, use semicolons as the separator. You can also include multiple variables in a single SET statement, such as SET x=1, y=2. not currently supported for PostgreSQL. Default: - no initialization query
        :param max_connections_percent: (experimental) The maximum size of the connection pool for each target in a target group. For Aurora MySQL, it is expressed as a percentage of the max_connections setting for the RDS DB instance or Aurora DB cluster used by the target group. 1-100 Default: 100
        :param max_idle_connections_percent: (experimental) Controls how actively the proxy closes idle database connections in the connection pool. A high value enables the proxy to leave a high percentage of idle connections open. A low value causes the proxy to close idle client connections and return the underlying database connections to the connection pool. For Aurora MySQL, it is expressed as a percentage of the max_connections setting for the RDS DB instance or Aurora DB cluster used by the target group. between 0 and MaxConnectionsPercent Default: 50
        :param require_tls: (experimental) A Boolean parameter that specifies whether Transport Layer Security (TLS) encryption is required for connections to the proxy. By enabling this setting, you can enforce encrypted TLS connections to the proxy. Default: true
        :param role: (experimental) IAM role that the proxy uses to access secrets in AWS Secrets Manager. Default: - A role will automatically be created
        :param security_groups: (experimental) One or more VPC security groups to associate with the new proxy. Default: - No security groups
        :param session_pinning_filters: (experimental) Each item in the list represents a class of SQL operations that normally cause all later statements in a session using a proxy to be pinned to the same underlying database connection. Including an item in the list exempts that class of SQL operations from the pinning behavior. Default: - no session pinning filters
        :param vpc_subnets: (experimental) The subnets used by the proxy. Default: - the VPC default strategy if not specified.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dd0393d794f315b09d2ecc70bfbec174b936dd9f2df61ad7fd84f6655518a9a5)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = DatabaseProxyProps(
            proxy_target=proxy_target,
            secrets=secrets,
            vpc=vpc,
            borrow_timeout=borrow_timeout,
            db_proxy_name=db_proxy_name,
            debug_logging=debug_logging,
            iam_auth=iam_auth,
            idle_client_timeout=idle_client_timeout,
            init_query=init_query,
            max_connections_percent=max_connections_percent,
            max_idle_connections_percent=max_idle_connections_percent,
            require_tls=require_tls,
            role=role,
            security_groups=security_groups,
            session_pinning_filters=session_pinning_filters,
            vpc_subnets=vpc_subnets,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="fromDatabaseProxyAttributes")
    @builtins.classmethod
    def from_database_proxy_attributes(
        cls,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        db_proxy_arn: builtins.str,
        db_proxy_name: builtins.str,
        endpoint: builtins.str,
        security_groups: typing.Sequence[_ISecurityGroup_cdbba9d3],
    ) -> IDatabaseProxy:
        '''(experimental) Import an existing database proxy.

        :param scope: -
        :param id: -
        :param db_proxy_arn: (experimental) DB Proxy ARN.
        :param db_proxy_name: (experimental) DB Proxy Name.
        :param endpoint: (experimental) Endpoint.
        :param security_groups: (experimental) The security groups of the instance.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0e81a921d8f050c26f550636acfbe1931790b7de953bc92d9ce913ccdc739352)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        attrs = DatabaseProxyAttributes(
            db_proxy_arn=db_proxy_arn,
            db_proxy_name=db_proxy_name,
            endpoint=endpoint,
            security_groups=security_groups,
        )

        return typing.cast(IDatabaseProxy, jsii.sinvoke(cls, "fromDatabaseProxyAttributes", [scope, id, attrs]))

    @jsii.member(jsii_name="asSecretAttachmentTarget")
    def as_secret_attachment_target(self) -> _SecretAttachmentTargetProps_ab8522eb:
        '''(experimental) Renders the secret attachment target specifications.

        :stability: experimental
        '''
        return typing.cast(_SecretAttachmentTargetProps_ab8522eb, jsii.invoke(self, "asSecretAttachmentTarget", []))

    @jsii.member(jsii_name="grantConnect")
    def grant_connect(
        self,
        grantee: _IGrantable_4c5a91d1,
        db_user: typing.Optional[builtins.str] = None,
    ) -> _Grant_bcb5eae7:
        '''(experimental) Grant the given identity connection access to the proxy.

        :param grantee: -
        :param db_user: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9f290ceb66b7659af01208e575f4d31f44aec4063c8ec1aa5960af580a0d92bf)
            check_type(argname="argument grantee", value=grantee, expected_type=type_hints["grantee"])
            check_type(argname="argument db_user", value=db_user, expected_type=type_hints["db_user"])
        return typing.cast(_Grant_bcb5eae7, jsii.invoke(self, "grantConnect", [grantee, db_user]))

    @builtins.property
    @jsii.member(jsii_name="connections")
    def connections(self) -> _Connections_57ccbda9:
        '''(experimental) Access to network connections.

        :stability: experimental
        '''
        return typing.cast(_Connections_57ccbda9, jsii.get(self, "connections"))

    @builtins.property
    @jsii.member(jsii_name="dbProxyArn")
    def db_proxy_arn(self) -> builtins.str:
        '''(experimental) DB Proxy ARN.

        :stability: experimental
        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "dbProxyArn"))

    @builtins.property
    @jsii.member(jsii_name="dbProxyName")
    def db_proxy_name(self) -> builtins.str:
        '''(experimental) DB Proxy Name.

        :stability: experimental
        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "dbProxyName"))

    @builtins.property
    @jsii.member(jsii_name="endpoint")
    def endpoint(self) -> builtins.str:
        '''(experimental) Endpoint.

        :stability: experimental
        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "endpoint"))


@jsii.interface(jsii_type="monocdk.aws_rds.IClusterEngine")
class IClusterEngine(IEngine, typing_extensions.Protocol):
    '''(experimental) The interface representing a database cluster (as opposed to instance) engine.

    :stability: experimental
    '''

    @builtins.property
    @jsii.member(jsii_name="multiUserRotationApplication")
    def multi_user_rotation_application(self) -> _SecretRotationApplication_0ac7c5d5:
        '''(experimental) The application used by this engine to perform rotation for a multi-user scenario.

        :stability: experimental
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="singleUserRotationApplication")
    def single_user_rotation_application(self) -> _SecretRotationApplication_0ac7c5d5:
        '''(experimental) The application used by this engine to perform rotation for a single-user scenario.

        :stability: experimental
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="supportedLogTypes")
    def supported_log_types(self) -> typing.List[builtins.str]:
        '''(experimental) The log types that are available with this engine type.

        :stability: experimental
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="combineImportAndExportRoles")
    def combine_import_and_export_roles(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Whether the IAM Roles used for data importing and exporting need to be combined for this Engine, or can they be kept separate.

        :default: false

        :stability: experimental
        '''
        ...

    @jsii.member(jsii_name="bindToCluster")
    def bind_to_cluster(
        self,
        scope: _Construct_e78e779f,
        *,
        parameter_group: typing.Optional[IParameterGroup] = None,
        s3_export_role: typing.Optional[_IRole_59af6f50] = None,
        s3_import_role: typing.Optional[_IRole_59af6f50] = None,
    ) -> ClusterEngineConfig:
        '''(experimental) Method called when the engine is used to create a new cluster.

        :param scope: -
        :param parameter_group: (experimental) The customer-provided ParameterGroup. Default: - none
        :param s3_export_role: (experimental) The role used for S3 exporting. Default: - none
        :param s3_import_role: (experimental) The role used for S3 importing. Default: - none

        :stability: experimental
        '''
        ...


class _IClusterEngineProxy(
    jsii.proxy_for(IEngine), # type: ignore[misc]
):
    '''(experimental) The interface representing a database cluster (as opposed to instance) engine.

    :stability: experimental
    '''

    __jsii_type__: typing.ClassVar[str] = "monocdk.aws_rds.IClusterEngine"

    @builtins.property
    @jsii.member(jsii_name="multiUserRotationApplication")
    def multi_user_rotation_application(self) -> _SecretRotationApplication_0ac7c5d5:
        '''(experimental) The application used by this engine to perform rotation for a multi-user scenario.

        :stability: experimental
        '''
        return typing.cast(_SecretRotationApplication_0ac7c5d5, jsii.get(self, "multiUserRotationApplication"))

    @builtins.property
    @jsii.member(jsii_name="singleUserRotationApplication")
    def single_user_rotation_application(self) -> _SecretRotationApplication_0ac7c5d5:
        '''(experimental) The application used by this engine to perform rotation for a single-user scenario.

        :stability: experimental
        '''
        return typing.cast(_SecretRotationApplication_0ac7c5d5, jsii.get(self, "singleUserRotationApplication"))

    @builtins.property
    @jsii.member(jsii_name="supportedLogTypes")
    def supported_log_types(self) -> typing.List[builtins.str]:
        '''(experimental) The log types that are available with this engine type.

        :stability: experimental
        '''
        return typing.cast(typing.List[builtins.str], jsii.get(self, "supportedLogTypes"))

    @builtins.property
    @jsii.member(jsii_name="combineImportAndExportRoles")
    def combine_import_and_export_roles(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Whether the IAM Roles used for data importing and exporting need to be combined for this Engine, or can they be kept separate.

        :default: false

        :stability: experimental
        '''
        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "combineImportAndExportRoles"))

    @jsii.member(jsii_name="bindToCluster")
    def bind_to_cluster(
        self,
        scope: _Construct_e78e779f,
        *,
        parameter_group: typing.Optional[IParameterGroup] = None,
        s3_export_role: typing.Optional[_IRole_59af6f50] = None,
        s3_import_role: typing.Optional[_IRole_59af6f50] = None,
    ) -> ClusterEngineConfig:
        '''(experimental) Method called when the engine is used to create a new cluster.

        :param scope: -
        :param parameter_group: (experimental) The customer-provided ParameterGroup. Default: - none
        :param s3_export_role: (experimental) The role used for S3 exporting. Default: - none
        :param s3_import_role: (experimental) The role used for S3 importing. Default: - none

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__07d465907b56c827b7150d74b90ee28822684296bf5ca7f5d7e370b1fe0a4fcf)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        options = ClusterEngineBindOptions(
            parameter_group=parameter_group,
            s3_export_role=s3_export_role,
            s3_import_role=s3_import_role,
        )

        return typing.cast(ClusterEngineConfig, jsii.invoke(self, "bindToCluster", [scope, options]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IClusterEngine).__jsii_proxy_class__ = lambda : _IClusterEngineProxy


class DatabaseCluster(
    DatabaseClusterBase,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_rds.DatabaseCluster",
):
    '''(experimental) Create a clustered database with a given number of instances.

    :stability: experimental
    :resource: AWS::RDS::DBCluster
    :exampleMetadata: infused

    Example::

        # vpc: ec2.Vpc
        
        cluster = rds.DatabaseCluster(self, "Database",
            engine=rds.DatabaseClusterEngine.AURORA,
            instance_props=ec2.aws_rds.InstanceProps(vpc=vpc)
        )
        
        proxy = rds.DatabaseProxy(self, "Proxy",
            proxy_target=rds.ProxyTarget.from_cluster(cluster),
            secrets=[cluster.secret],
            vpc=vpc
        )
        
        role = iam.Role(self, "DBProxyRole", assumed_by=iam.AccountPrincipal(self.account))
        proxy.grant_connect(role, "admin")
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        engine: IClusterEngine,
        instance_props: typing.Union[InstanceProps, typing.Dict[builtins.str, typing.Any]],
        backtrack_window: typing.Optional[_Duration_070aa057] = None,
        backup: typing.Optional[typing.Union[BackupProps, typing.Dict[builtins.str, typing.Any]]] = None,
        cloudwatch_logs_exports: typing.Optional[typing.Sequence[builtins.str]] = None,
        cloudwatch_logs_retention: typing.Optional[_RetentionDays_6c560d31] = None,
        cloudwatch_logs_retention_role: typing.Optional[_IRole_59af6f50] = None,
        cluster_identifier: typing.Optional[builtins.str] = None,
        copy_tags_to_snapshot: typing.Optional[builtins.bool] = None,
        credentials: typing.Optional[Credentials] = None,
        default_database_name: typing.Optional[builtins.str] = None,
        deletion_protection: typing.Optional[builtins.bool] = None,
        iam_authentication: typing.Optional[builtins.bool] = None,
        instance_identifier_base: typing.Optional[builtins.str] = None,
        instances: typing.Optional[jsii.Number] = None,
        monitoring_interval: typing.Optional[_Duration_070aa057] = None,
        monitoring_role: typing.Optional[_IRole_59af6f50] = None,
        parameter_group: typing.Optional[IParameterGroup] = None,
        parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        port: typing.Optional[jsii.Number] = None,
        preferred_maintenance_window: typing.Optional[builtins.str] = None,
        removal_policy: typing.Optional[_RemovalPolicy_c97e7a20] = None,
        s3_export_buckets: typing.Optional[typing.Sequence[_IBucket_73486e29]] = None,
        s3_export_role: typing.Optional[_IRole_59af6f50] = None,
        s3_import_buckets: typing.Optional[typing.Sequence[_IBucket_73486e29]] = None,
        s3_import_role: typing.Optional[_IRole_59af6f50] = None,
        storage_encrypted: typing.Optional[builtins.bool] = None,
        storage_encryption_key: typing.Optional[_IKey_36930160] = None,
        subnet_group: typing.Optional[ISubnetGroup] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param engine: (experimental) What kind of database to start.
        :param instance_props: (experimental) Settings for the individual instances that are launched.
        :param backtrack_window: (experimental) The number of seconds to set a cluster's target backtrack window to. This feature is only supported by the Aurora MySQL database engine and cannot be enabled on existing clusters. Default: 0 seconds (no backtrack)
        :param backup: (experimental) Backup settings. Default: - Backup retention period for automated backups is 1 day. Backup preferred window is set to a 30-minute window selected at random from an 8-hour block of time for each AWS Region, occurring on a random day of the week.
        :param cloudwatch_logs_exports: (experimental) The list of log types that need to be enabled for exporting to CloudWatch Logs. Default: - no log exports
        :param cloudwatch_logs_retention: (experimental) The number of days log events are kept in CloudWatch Logs. When updating this property, unsetting it doesn't remove the log retention policy. To remove the retention policy, set the value to ``Infinity``. Default: - logs never expire
        :param cloudwatch_logs_retention_role: (experimental) The IAM role for the Lambda function associated with the custom resource that sets the retention policy. Default: - a new role is created.
        :param cluster_identifier: (experimental) An optional identifier for the cluster. Default: - A name is automatically generated.
        :param copy_tags_to_snapshot: (experimental) Whether to copy tags to the snapshot when a snapshot is created. Default: - true
        :param credentials: (experimental) Credentials for the administrative user. Default: - A username of 'admin' (or 'postgres' for PostgreSQL) and SecretsManager-generated password
        :param default_database_name: (experimental) Name of a database which is automatically created inside the cluster. Default: - Database is not created in cluster.
        :param deletion_protection: (experimental) Indicates whether the DB cluster should have deletion protection enabled. Default: - true if ``removalPolicy`` is RETAIN, false otherwise
        :param iam_authentication: (experimental) Whether to enable mapping of AWS Identity and Access Management (IAM) accounts to database accounts. Default: false
        :param instance_identifier_base: (experimental) Base identifier for instances. Every replica is named by appending the replica number to this string, 1-based. Default: - clusterIdentifier is used with the word "Instance" appended. If clusterIdentifier is not provided, the identifier is automatically generated.
        :param instances: (experimental) How many replicas/instances to create. Has to be at least 1. Default: 2
        :param monitoring_interval: (experimental) The interval, in seconds, between points when Amazon RDS collects enhanced monitoring metrics for the DB instances. Default: no enhanced monitoring
        :param monitoring_role: (experimental) Role that will be used to manage DB instances monitoring. Default: - A role is automatically created for you
        :param parameter_group: (experimental) Additional parameters to pass to the database engine. Default: - No parameter group.
        :param parameters: (experimental) The parameters in the DBClusterParameterGroup to create automatically. You can only specify parameterGroup or parameters but not both. You need to use a versioned engine to auto-generate a DBClusterParameterGroup. Default: - None
        :param port: (experimental) What port to listen on. Default: - The default for the engine is used.
        :param preferred_maintenance_window: (experimental) A preferred maintenance window day/time range. Should be specified as a range ddd:hh24:mi-ddd:hh24:mi (24H Clock UTC). Example: 'Sun:23:45-Mon:00:15' Default: - 30-minute window selected at random from an 8-hour block of time for each AWS Region, occurring on a random day of the week.
        :param removal_policy: (experimental) The removal policy to apply when the cluster and its instances are removed from the stack or replaced during an update. Default: - RemovalPolicy.SNAPSHOT (remove the cluster and instances, but retain a snapshot of the data)
        :param s3_export_buckets: (experimental) S3 buckets that you want to load data into. This feature is only supported by the Aurora database engine. This property must not be used if ``s3ExportRole`` is used. For MySQL: Default: - None
        :param s3_export_role: (experimental) Role that will be associated with this DB cluster to enable S3 export. This feature is only supported by the Aurora database engine. This property must not be used if ``s3ExportBuckets`` is used. For MySQL: Default: - New role is created if ``s3ExportBuckets`` is set, no role is defined otherwise
        :param s3_import_buckets: (experimental) S3 buckets that you want to load data from. This feature is only supported by the Aurora database engine. This property must not be used if ``s3ImportRole`` is used. For MySQL: Default: - None
        :param s3_import_role: (experimental) Role that will be associated with this DB cluster to enable S3 import. This feature is only supported by the Aurora database engine. This property must not be used if ``s3ImportBuckets`` is used. For MySQL: Default: - New role is created if ``s3ImportBuckets`` is set, no role is defined otherwise
        :param storage_encrypted: (experimental) Whether to enable storage encryption. Default: - true if storageEncryptionKey is provided, false otherwise
        :param storage_encryption_key: (experimental) The KMS key for storage encryption. If specified, {@link storageEncrypted} will be set to ``true``. Default: - if storageEncrypted is true then the default master key, no key otherwise
        :param subnet_group: (experimental) Existing subnet group for the cluster. Default: - a new subnet group will be created.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ae813eaa64a4f874a0dc340aaecbad24ce58b4d22144ed46342fb54878d80f74)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = DatabaseClusterProps(
            engine=engine,
            instance_props=instance_props,
            backtrack_window=backtrack_window,
            backup=backup,
            cloudwatch_logs_exports=cloudwatch_logs_exports,
            cloudwatch_logs_retention=cloudwatch_logs_retention,
            cloudwatch_logs_retention_role=cloudwatch_logs_retention_role,
            cluster_identifier=cluster_identifier,
            copy_tags_to_snapshot=copy_tags_to_snapshot,
            credentials=credentials,
            default_database_name=default_database_name,
            deletion_protection=deletion_protection,
            iam_authentication=iam_authentication,
            instance_identifier_base=instance_identifier_base,
            instances=instances,
            monitoring_interval=monitoring_interval,
            monitoring_role=monitoring_role,
            parameter_group=parameter_group,
            parameters=parameters,
            port=port,
            preferred_maintenance_window=preferred_maintenance_window,
            removal_policy=removal_policy,
            s3_export_buckets=s3_export_buckets,
            s3_export_role=s3_export_role,
            s3_import_buckets=s3_import_buckets,
            s3_import_role=s3_import_role,
            storage_encrypted=storage_encrypted,
            storage_encryption_key=storage_encryption_key,
            subnet_group=subnet_group,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="fromDatabaseClusterAttributes")
    @builtins.classmethod
    def from_database_cluster_attributes(
        cls,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        cluster_identifier: builtins.str,
        cluster_endpoint_address: typing.Optional[builtins.str] = None,
        engine: typing.Optional[IClusterEngine] = None,
        instance_endpoint_addresses: typing.Optional[typing.Sequence[builtins.str]] = None,
        instance_identifiers: typing.Optional[typing.Sequence[builtins.str]] = None,
        port: typing.Optional[jsii.Number] = None,
        reader_endpoint_address: typing.Optional[builtins.str] = None,
        security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
    ) -> IDatabaseCluster:
        '''(experimental) Import an existing DatabaseCluster from properties.

        :param scope: -
        :param id: -
        :param cluster_identifier: (experimental) Identifier for the cluster.
        :param cluster_endpoint_address: (experimental) Cluster endpoint address. Default: - no endpoint address
        :param engine: (experimental) The engine of the existing Cluster. Default: - the imported Cluster's engine is unknown
        :param instance_endpoint_addresses: (experimental) Endpoint addresses of individual instances. Default: - no instance endpoints
        :param instance_identifiers: (experimental) Identifier for the instances. Default: - no instance identifiers
        :param port: (experimental) The database port. Default: - none
        :param reader_endpoint_address: (experimental) Reader endpoint address. Default: - no reader address
        :param security_groups: (experimental) The security groups of the database cluster. Default: - no security groups

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5d8655578b10d0b2e612e5a92c3c777a2f7a2e07ca3552ca297ccca0ae984e28)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        attrs = DatabaseClusterAttributes(
            cluster_identifier=cluster_identifier,
            cluster_endpoint_address=cluster_endpoint_address,
            engine=engine,
            instance_endpoint_addresses=instance_endpoint_addresses,
            instance_identifiers=instance_identifiers,
            port=port,
            reader_endpoint_address=reader_endpoint_address,
            security_groups=security_groups,
        )

        return typing.cast(IDatabaseCluster, jsii.sinvoke(cls, "fromDatabaseClusterAttributes", [scope, id, attrs]))

    @jsii.member(jsii_name="addRotationMultiUser")
    def add_rotation_multi_user(
        self,
        id: builtins.str,
        *,
        secret: _ISecret_22fb8757,
        automatically_after: typing.Optional[_Duration_070aa057] = None,
        endpoint: typing.Optional[_IInterfaceVpcEndpoint_6081623d] = None,
        exclude_characters: typing.Optional[builtins.str] = None,
        vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> _SecretRotation_e64158ad:
        '''(experimental) Adds the multi user rotation to this cluster.

        :param id: -
        :param secret: (experimental) The secret to rotate. It must be a JSON string with the following format:: { "engine": <required: database engine>, "host": <required: instance host name>, "username": <required: username>, "password": <required: password>, "dbname": <optional: database name>, "port": <optional: if not specified, default port will be used>, "masterarn": <required: the arn of the master secret which will be used to create users/change passwords> }
        :param automatically_after: (experimental) Specifies the number of days after the previous rotation before Secrets Manager triggers the next automatic rotation. Default: - 30 days
        :param endpoint: (experimental) The VPC interface endpoint to use for the Secrets Manager API. If you enable private DNS hostnames for your VPC private endpoint (the default), you don't need to specify an endpoint. The standard Secrets Manager DNS hostname the Secrets Manager CLI and SDKs use by default (https://secretsmanager..amazonaws.com) automatically resolves to your VPC endpoint. Default: https://secretsmanager..amazonaws.com
        :param exclude_characters: (experimental) Specifies characters to not include in generated passwords. Default: " %+~`#$&*()|[]{}:;<>?!'/
        :param vpc_subnets: (experimental) Where to place the rotation Lambda function. Default: - same placement as instance or cluster

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3ff611d4e33ff6d67d58f1db8345119f84f019a8f619bbc4fc9b15dd1bb66647)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        options = RotationMultiUserOptions(
            secret=secret,
            automatically_after=automatically_after,
            endpoint=endpoint,
            exclude_characters=exclude_characters,
            vpc_subnets=vpc_subnets,
        )

        return typing.cast(_SecretRotation_e64158ad, jsii.invoke(self, "addRotationMultiUser", [id, options]))

    @jsii.member(jsii_name="addRotationSingleUser")
    def add_rotation_single_user(
        self,
        *,
        automatically_after: typing.Optional[_Duration_070aa057] = None,
        endpoint: typing.Optional[_IInterfaceVpcEndpoint_6081623d] = None,
        exclude_characters: typing.Optional[builtins.str] = None,
        vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> _SecretRotation_e64158ad:
        '''(experimental) Adds the single user rotation of the master password to this cluster.

        :param automatically_after: (experimental) Specifies the number of days after the previous rotation before Secrets Manager triggers the next automatic rotation. Default: - 30 days
        :param endpoint: (experimental) The VPC interface endpoint to use for the Secrets Manager API. If you enable private DNS hostnames for your VPC private endpoint (the default), you don't need to specify an endpoint. The standard Secrets Manager DNS hostname the Secrets Manager CLI and SDKs use by default (https://secretsmanager..amazonaws.com) automatically resolves to your VPC endpoint. Default: https://secretsmanager..amazonaws.com
        :param exclude_characters: (experimental) Specifies characters to not include in generated passwords. Default: " %+~`#$&*()|[]{}:;<>?!'/
        :param vpc_subnets: (experimental) Where to place the rotation Lambda function. Default: - same placement as instance or cluster

        :stability: experimental
        '''
        options = RotationSingleUserOptions(
            automatically_after=automatically_after,
            endpoint=endpoint,
            exclude_characters=exclude_characters,
            vpc_subnets=vpc_subnets,
        )

        return typing.cast(_SecretRotation_e64158ad, jsii.invoke(self, "addRotationSingleUser", [options]))

    @builtins.property
    @jsii.member(jsii_name="clusterEndpoint")
    def cluster_endpoint(self) -> Endpoint:
        '''(experimental) The endpoint to use for read/write operations.

        :stability: experimental
        '''
        return typing.cast(Endpoint, jsii.get(self, "clusterEndpoint"))

    @builtins.property
    @jsii.member(jsii_name="clusterIdentifier")
    def cluster_identifier(self) -> builtins.str:
        '''(experimental) Identifier of the cluster.

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "clusterIdentifier"))

    @builtins.property
    @jsii.member(jsii_name="clusterReadEndpoint")
    def cluster_read_endpoint(self) -> Endpoint:
        '''(experimental) Endpoint to use for load-balanced read-only operations.

        :stability: experimental
        '''
        return typing.cast(Endpoint, jsii.get(self, "clusterReadEndpoint"))

    @builtins.property
    @jsii.member(jsii_name="connections")
    def connections(self) -> _Connections_57ccbda9:
        '''(experimental) Access to the network connections.

        :stability: experimental
        '''
        return typing.cast(_Connections_57ccbda9, jsii.get(self, "connections"))

    @builtins.property
    @jsii.member(jsii_name="instanceEndpoints")
    def instance_endpoints(self) -> typing.List[Endpoint]:
        '''(experimental) Endpoints which address each individual replica.

        :stability: experimental
        '''
        return typing.cast(typing.List[Endpoint], jsii.get(self, "instanceEndpoints"))

    @builtins.property
    @jsii.member(jsii_name="instanceIdentifiers")
    def instance_identifiers(self) -> typing.List[builtins.str]:
        '''(experimental) Identifiers of the replicas.

        :stability: experimental
        '''
        return typing.cast(typing.List[builtins.str], jsii.get(self, "instanceIdentifiers"))

    @builtins.property
    @jsii.member(jsii_name="multiUserRotationApplication")
    def multi_user_rotation_application(self) -> _SecretRotationApplication_0ac7c5d5:
        '''(experimental) Application for multi user rotation to this cluster.

        :stability: experimental
        '''
        return typing.cast(_SecretRotationApplication_0ac7c5d5, jsii.get(self, "multiUserRotationApplication"))

    @builtins.property
    @jsii.member(jsii_name="newCfnProps")
    def _new_cfn_props(self) -> CfnDBClusterProps:
        '''
        :stability: experimental
        '''
        return typing.cast(CfnDBClusterProps, jsii.get(self, "newCfnProps"))

    @builtins.property
    @jsii.member(jsii_name="securityGroups")
    def _security_groups(self) -> typing.List[_ISecurityGroup_cdbba9d3]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[_ISecurityGroup_cdbba9d3], jsii.get(self, "securityGroups"))

    @builtins.property
    @jsii.member(jsii_name="singleUserRotationApplication")
    def single_user_rotation_application(self) -> _SecretRotationApplication_0ac7c5d5:
        '''(experimental) Application for single user rotation of the master password to this cluster.

        :stability: experimental
        '''
        return typing.cast(_SecretRotationApplication_0ac7c5d5, jsii.get(self, "singleUserRotationApplication"))

    @builtins.property
    @jsii.member(jsii_name="subnetGroup")
    def _subnet_group(self) -> ISubnetGroup:
        '''
        :stability: experimental
        '''
        return typing.cast(ISubnetGroup, jsii.get(self, "subnetGroup"))

    @builtins.property
    @jsii.member(jsii_name="vpc")
    def vpc(self) -> _IVpc_6d1f76c4:
        '''(experimental) The VPC network to place the cluster in.

        :stability: experimental
        '''
        return typing.cast(_IVpc_6d1f76c4, jsii.get(self, "vpc"))

    @builtins.property
    @jsii.member(jsii_name="engine")
    def engine(self) -> typing.Optional[IClusterEngine]:
        '''(experimental) The engine for this Cluster.

        Never undefined.

        :stability: experimental
        '''
        return typing.cast(typing.Optional[IClusterEngine], jsii.get(self, "engine"))

    @builtins.property
    @jsii.member(jsii_name="secret")
    def secret(self) -> typing.Optional[_ISecret_22fb8757]:
        '''(experimental) The secret attached to this cluster.

        :stability: experimental
        '''
        return typing.cast(typing.Optional[_ISecret_22fb8757], jsii.get(self, "secret"))

    @builtins.property
    @jsii.member(jsii_name="vpcSubnets")
    def vpc_subnets(self) -> typing.Optional[_SubnetSelection_1284e62c]:
        '''(experimental) The cluster's subnets.

        :stability: experimental
        '''
        return typing.cast(typing.Optional[_SubnetSelection_1284e62c], jsii.get(self, "vpcSubnets"))


@jsii.implements(IDatabaseInstance)
class DatabaseInstance(
    DatabaseInstanceBase,
    metaclass=jsii.JSIIMeta,
    jsii_type="monocdk.aws_rds.DatabaseInstance",
):
    '''(experimental) A database instance.

    :stability: experimental
    :resource: AWS::RDS::DBInstance
    :exampleMetadata: infused

    Example::

        # vpc: ec2.Vpc
        
        engine = rds.DatabaseInstanceEngine.postgres(version=rds.PostgresEngineVersion.VER_12_3)
        rds.DatabaseInstance(self, "InstanceWithUsername",
            engine=engine,
            vpc=vpc,
            credentials=rds.Credentials.from_generated_secret("postgres")
        )
        
        rds.DatabaseInstance(self, "InstanceWithUsernameAndPassword",
            engine=engine,
            vpc=vpc,
            credentials=rds.Credentials.from_password("postgres", SecretValue.ssm_secure("/dbPassword", "1"))
        )
        
        my_secret = secretsmanager.Secret.from_secret_name(self, "DBSecret", "myDBLoginInfo")
        rds.DatabaseInstance(self, "InstanceWithSecretLogin",
            engine=engine,
            vpc=vpc,
            credentials=rds.Credentials.from_secret(my_secret)
        )
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        character_set_name: typing.Optional[builtins.str] = None,
        credentials: typing.Optional[Credentials] = None,
        storage_encrypted: typing.Optional[builtins.bool] = None,
        storage_encryption_key: typing.Optional[_IKey_36930160] = None,
        engine: IInstanceEngine,
        allocated_storage: typing.Optional[jsii.Number] = None,
        allow_major_version_upgrade: typing.Optional[builtins.bool] = None,
        database_name: typing.Optional[builtins.str] = None,
        instance_type: typing.Optional[_InstanceType_072ad323] = None,
        license_model: typing.Optional[LicenseModel] = None,
        parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        timezone: typing.Optional[builtins.str] = None,
        vpc: _IVpc_6d1f76c4,
        auto_minor_version_upgrade: typing.Optional[builtins.bool] = None,
        availability_zone: typing.Optional[builtins.str] = None,
        backup_retention: typing.Optional[_Duration_070aa057] = None,
        cloudwatch_logs_exports: typing.Optional[typing.Sequence[builtins.str]] = None,
        cloudwatch_logs_retention: typing.Optional[_RetentionDays_6c560d31] = None,
        cloudwatch_logs_retention_role: typing.Optional[_IRole_59af6f50] = None,
        copy_tags_to_snapshot: typing.Optional[builtins.bool] = None,
        delete_automated_backups: typing.Optional[builtins.bool] = None,
        deletion_protection: typing.Optional[builtins.bool] = None,
        domain: typing.Optional[builtins.str] = None,
        domain_role: typing.Optional[_IRole_59af6f50] = None,
        enable_performance_insights: typing.Optional[builtins.bool] = None,
        iam_authentication: typing.Optional[builtins.bool] = None,
        instance_identifier: typing.Optional[builtins.str] = None,
        iops: typing.Optional[jsii.Number] = None,
        max_allocated_storage: typing.Optional[jsii.Number] = None,
        monitoring_interval: typing.Optional[_Duration_070aa057] = None,
        monitoring_role: typing.Optional[_IRole_59af6f50] = None,
        multi_az: typing.Optional[builtins.bool] = None,
        option_group: typing.Optional[IOptionGroup] = None,
        parameter_group: typing.Optional[IParameterGroup] = None,
        performance_insight_encryption_key: typing.Optional[_IKey_36930160] = None,
        performance_insight_retention: typing.Optional[PerformanceInsightRetention] = None,
        port: typing.Optional[jsii.Number] = None,
        preferred_backup_window: typing.Optional[builtins.str] = None,
        preferred_maintenance_window: typing.Optional[builtins.str] = None,
        processor_features: typing.Optional[typing.Union[ProcessorFeatures, typing.Dict[builtins.str, typing.Any]]] = None,
        publicly_accessible: typing.Optional[builtins.bool] = None,
        removal_policy: typing.Optional[_RemovalPolicy_c97e7a20] = None,
        s3_export_buckets: typing.Optional[typing.Sequence[_IBucket_73486e29]] = None,
        s3_export_role: typing.Optional[_IRole_59af6f50] = None,
        s3_import_buckets: typing.Optional[typing.Sequence[_IBucket_73486e29]] = None,
        s3_import_role: typing.Optional[_IRole_59af6f50] = None,
        security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
        storage_type: typing.Optional[StorageType] = None,
        subnet_group: typing.Optional[ISubnetGroup] = None,
        vpc_placement: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
        vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param character_set_name: (experimental) For supported engines, specifies the character set to associate with the DB instance. Default: - RDS default character set name
        :param credentials: (experimental) Credentials for the administrative user. Default: - A username of 'admin' (or 'postgres' for PostgreSQL) and SecretsManager-generated password
        :param storage_encrypted: (experimental) Indicates whether the DB instance is encrypted. Default: - true if storageEncryptionKey has been provided, false otherwise
        :param storage_encryption_key: (experimental) The KMS key that's used to encrypt the DB instance. Default: - default master key if storageEncrypted is true, no key otherwise
        :param engine: (experimental) The database engine.
        :param allocated_storage: (experimental) The allocated storage size, specified in gigabytes (GB). Default: 100
        :param allow_major_version_upgrade: (experimental) Whether to allow major version upgrades. Default: false
        :param database_name: (experimental) The name of the database. Default: - no name
        :param instance_type: (experimental) The name of the compute and memory capacity for the instance. Default: - m5.large (or, more specifically, db.m5.large)
        :param license_model: (experimental) The license model. Default: - RDS default license model
        :param parameters: (experimental) The parameters in the DBParameterGroup to create automatically. You can only specify parameterGroup or parameters but not both. You need to use a versioned engine to auto-generate a DBParameterGroup. Default: - None
        :param timezone: (experimental) The time zone of the instance. This is currently supported only by Microsoft Sql Server. Default: - RDS default timezone
        :param vpc: (experimental) The VPC network where the DB subnet group should be created.
        :param auto_minor_version_upgrade: (experimental) Indicates that minor engine upgrades are applied automatically to the DB instance during the maintenance window. Default: true
        :param availability_zone: (experimental) The name of the Availability Zone where the DB instance will be located. Default: - no preference
        :param backup_retention: (experimental) The number of days during which automatic DB snapshots are retained. Set to zero to disable backups. When creating a read replica, you must enable automatic backups on the source database instance by setting the backup retention to a value other than zero. Default: - Duration.days(1) for source instances, disabled for read replicas
        :param cloudwatch_logs_exports: (experimental) The list of log types that need to be enabled for exporting to CloudWatch Logs. Default: - no log exports
        :param cloudwatch_logs_retention: (experimental) The number of days log events are kept in CloudWatch Logs. When updating this property, unsetting it doesn't remove the log retention policy. To remove the retention policy, set the value to ``Infinity``. Default: - logs never expire
        :param cloudwatch_logs_retention_role: (experimental) The IAM role for the Lambda function associated with the custom resource that sets the retention policy. Default: - a new role is created.
        :param copy_tags_to_snapshot: (experimental) Indicates whether to copy all of the user-defined tags from the DB instance to snapshots of the DB instance. Default: true
        :param delete_automated_backups: (experimental) Indicates whether automated backups should be deleted or retained when you delete a DB instance. Default: false
        :param deletion_protection: (experimental) Indicates whether the DB instance should have deletion protection enabled. Default: - true if ``removalPolicy`` is RETAIN, false otherwise
        :param domain: (experimental) The Active Directory directory ID to create the DB instance in. Default: - Do not join domain
        :param domain_role: (experimental) The IAM role to be used when making API calls to the Directory Service. The role needs the AWS-managed policy AmazonRDSDirectoryServiceAccess or equivalent. Default: - The role will be created for you if {@link DatabaseInstanceNewProps#domain} is specified
        :param enable_performance_insights: (experimental) Whether to enable Performance Insights for the DB instance. Default: - false, unless ``performanceInsightRentention`` or ``performanceInsightEncryptionKey`` is set.
        :param iam_authentication: (experimental) Whether to enable mapping of AWS Identity and Access Management (IAM) accounts to database accounts. Default: false
        :param instance_identifier: (experimental) A name for the DB instance. If you specify a name, AWS CloudFormation converts it to lowercase. Default: - a CloudFormation generated name
        :param iops: (experimental) The number of I/O operations per second (IOPS) that the database provisions. The value must be equal to or greater than 1000. Default: - no provisioned iops
        :param max_allocated_storage: (experimental) Upper limit to which RDS can scale the storage in GiB(Gibibyte). Default: - No autoscaling of RDS instance
        :param monitoring_interval: (experimental) The interval, in seconds, between points when Amazon RDS collects enhanced monitoring metrics for the DB instance. Default: - no enhanced monitoring
        :param monitoring_role: (experimental) Role that will be used to manage DB instance monitoring. Default: - A role is automatically created for you
        :param multi_az: (experimental) Specifies if the database instance is a multiple Availability Zone deployment. Default: false
        :param option_group: (experimental) The option group to associate with the instance. Default: - no option group
        :param parameter_group: (experimental) The DB parameter group to associate with the instance. Default: - no parameter group
        :param performance_insight_encryption_key: (experimental) The AWS KMS key for encryption of Performance Insights data. Default: - default master key
        :param performance_insight_retention: (experimental) The amount of time, in days, to retain Performance Insights data. Default: 7
        :param port: (experimental) The port for the instance. Default: - the default port for the chosen engine.
        :param preferred_backup_window: (experimental) The daily time range during which automated backups are performed. Constraints: - Must be in the format ``hh24:mi-hh24:mi``. - Must be in Universal Coordinated Time (UTC). - Must not conflict with the preferred maintenance window. - Must be at least 30 minutes. Default: - a 30-minute window selected at random from an 8-hour block of time for each AWS Region. To see the time blocks available, see https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithAutomatedBackups.html#USER_WorkingWithAutomatedBackups.BackupWindow
        :param preferred_maintenance_window: (experimental) The weekly time range (in UTC) during which system maintenance can occur. Format: ``ddd:hh24:mi-ddd:hh24:mi`` Constraint: Minimum 30-minute window Default: - a 30-minute window selected at random from an 8-hour block of time for each AWS Region, occurring on a random day of the week. To see the time blocks available, see https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_UpgradeDBInstance.Maintenance.html#Concepts.DBMaintenance
        :param processor_features: (experimental) The number of CPU cores and the number of threads per core. Default: - the default number of CPU cores and threads per core for the chosen instance class. See https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html#USER_ConfigureProcessor
        :param publicly_accessible: (experimental) Indicates whether the DB instance is an internet-facing instance. Default: - ``true`` if ``vpcSubnets`` is ``subnetType: SubnetType.PUBLIC``, ``false`` otherwise
        :param removal_policy: (experimental) The CloudFormation policy to apply when the instance is removed from the stack or replaced during an update. Default: - RemovalPolicy.SNAPSHOT (remove the resource, but retain a snapshot of the data)
        :param s3_export_buckets: (experimental) S3 buckets that you want to load data into. This property must not be used if ``s3ExportRole`` is used. For Microsoft SQL Server: Default: - None
        :param s3_export_role: (experimental) Role that will be associated with this DB instance to enable S3 export. This property must not be used if ``s3ExportBuckets`` is used. For Microsoft SQL Server: Default: - New role is created if ``s3ExportBuckets`` is set, no role is defined otherwise
        :param s3_import_buckets: (experimental) S3 buckets that you want to load data from. This feature is only supported by the Microsoft SQL Server, Oracle, and PostgreSQL engines. This property must not be used if ``s3ImportRole`` is used. For Microsoft SQL Server: Default: - None
        :param s3_import_role: (experimental) Role that will be associated with this DB instance to enable S3 import. This feature is only supported by the Microsoft SQL Server, Oracle, and PostgreSQL engines. This property must not be used if ``s3ImportBuckets`` is used. For Microsoft SQL Server: Default: - New role is created if ``s3ImportBuckets`` is set, no role is defined otherwise
        :param security_groups: (experimental) The security groups to assign to the DB instance. Default: - a new security group is created
        :param storage_type: (experimental) The storage type. Storage types supported are gp2, io1, standard. Default: GP2
        :param subnet_group: (experimental) Existing subnet group for the instance. Default: - a new subnet group will be created.
        :param vpc_placement: (deprecated) The type of subnets to add to the created DB subnet group. Default: - private subnets
        :param vpc_subnets: (experimental) The type of subnets to add to the created DB subnet group. Default: - private subnets

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__00b35388b186f844f23ee157fe66670461d385e05a93b3a493c1fb7aa8b33387)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = DatabaseInstanceProps(
            character_set_name=character_set_name,
            credentials=credentials,
            storage_encrypted=storage_encrypted,
            storage_encryption_key=storage_encryption_key,
            engine=engine,
            allocated_storage=allocated_storage,
            allow_major_version_upgrade=allow_major_version_upgrade,
            database_name=database_name,
            instance_type=instance_type,
            license_model=license_model,
            parameters=parameters,
            timezone=timezone,
            vpc=vpc,
            auto_minor_version_upgrade=auto_minor_version_upgrade,
            availability_zone=availability_zone,
            backup_retention=backup_retention,
            cloudwatch_logs_exports=cloudwatch_logs_exports,
            cloudwatch_logs_retention=cloudwatch_logs_retention,
            cloudwatch_logs_retention_role=cloudwatch_logs_retention_role,
            copy_tags_to_snapshot=copy_tags_to_snapshot,
            delete_automated_backups=delete_automated_backups,
            deletion_protection=deletion_protection,
            domain=domain,
            domain_role=domain_role,
            enable_performance_insights=enable_performance_insights,
            iam_authentication=iam_authentication,
            instance_identifier=instance_identifier,
            iops=iops,
            max_allocated_storage=max_allocated_storage,
            monitoring_interval=monitoring_interval,
            monitoring_role=monitoring_role,
            multi_az=multi_az,
            option_group=option_group,
            parameter_group=parameter_group,
            performance_insight_encryption_key=performance_insight_encryption_key,
            performance_insight_retention=performance_insight_retention,
            port=port,
            preferred_backup_window=preferred_backup_window,
            preferred_maintenance_window=preferred_maintenance_window,
            processor_features=processor_features,
            publicly_accessible=publicly_accessible,
            removal_policy=removal_policy,
            s3_export_buckets=s3_export_buckets,
            s3_export_role=s3_export_role,
            s3_import_buckets=s3_import_buckets,
            s3_import_role=s3_import_role,
            security_groups=security_groups,
            storage_type=storage_type,
            subnet_group=subnet_group,
            vpc_placement=vpc_placement,
            vpc_subnets=vpc_subnets,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="addRotationMultiUser")
    def add_rotation_multi_user(
        self,
        id: builtins.str,
        *,
        secret: _ISecret_22fb8757,
        automatically_after: typing.Optional[_Duration_070aa057] = None,
        endpoint: typing.Optional[_IInterfaceVpcEndpoint_6081623d] = None,
        exclude_characters: typing.Optional[builtins.str] = None,
        vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> _SecretRotation_e64158ad:
        '''(experimental) Adds the multi user rotation to this instance.

        :param id: -
        :param secret: (experimental) The secret to rotate. It must be a JSON string with the following format:: { "engine": <required: database engine>, "host": <required: instance host name>, "username": <required: username>, "password": <required: password>, "dbname": <optional: database name>, "port": <optional: if not specified, default port will be used>, "masterarn": <required: the arn of the master secret which will be used to create users/change passwords> }
        :param automatically_after: (experimental) Specifies the number of days after the previous rotation before Secrets Manager triggers the next automatic rotation. Default: - 30 days
        :param endpoint: (experimental) The VPC interface endpoint to use for the Secrets Manager API. If you enable private DNS hostnames for your VPC private endpoint (the default), you don't need to specify an endpoint. The standard Secrets Manager DNS hostname the Secrets Manager CLI and SDKs use by default (https://secretsmanager..amazonaws.com) automatically resolves to your VPC endpoint. Default: https://secretsmanager..amazonaws.com
        :param exclude_characters: (experimental) Specifies characters to not include in generated passwords. Default: " %+~`#$&*()|[]{}:;<>?!'/
        :param vpc_subnets: (experimental) Where to place the rotation Lambda function. Default: - same placement as instance or cluster

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7c9a68f7da0bb3cb2501c61dbe7a4fdde1e46a442aab02c12be2a7b724770e7a)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        options = RotationMultiUserOptions(
            secret=secret,
            automatically_after=automatically_after,
            endpoint=endpoint,
            exclude_characters=exclude_characters,
            vpc_subnets=vpc_subnets,
        )

        return typing.cast(_SecretRotation_e64158ad, jsii.invoke(self, "addRotationMultiUser", [id, options]))

    @jsii.member(jsii_name="addRotationSingleUser")
    def add_rotation_single_user(
        self,
        *,
        automatically_after: typing.Optional[_Duration_070aa057] = None,
        endpoint: typing.Optional[_IInterfaceVpcEndpoint_6081623d] = None,
        exclude_characters: typing.Optional[builtins.str] = None,
        vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> _SecretRotation_e64158ad:
        '''(experimental) Adds the single user rotation of the master password to this instance.

        :param automatically_after: (experimental) Specifies the number of days after the previous rotation before Secrets Manager triggers the next automatic rotation. Default: - 30 days
        :param endpoint: (experimental) The VPC interface endpoint to use for the Secrets Manager API. If you enable private DNS hostnames for your VPC private endpoint (the default), you don't need to specify an endpoint. The standard Secrets Manager DNS hostname the Secrets Manager CLI and SDKs use by default (https://secretsmanager..amazonaws.com) automatically resolves to your VPC endpoint. Default: https://secretsmanager..amazonaws.com
        :param exclude_characters: (experimental) Specifies characters to not include in generated passwords. Default: " %+~`#$&*()|[]{}:;<>?!'/
        :param vpc_subnets: (experimental) Where to place the rotation Lambda function. Default: - same placement as instance or cluster

        :stability: experimental
        '''
        options = RotationSingleUserOptions(
            automatically_after=automatically_after,
            endpoint=endpoint,
            exclude_characters=exclude_characters,
            vpc_subnets=vpc_subnets,
        )

        return typing.cast(_SecretRotation_e64158ad, jsii.invoke(self, "addRotationSingleUser", [options]))

    @jsii.member(jsii_name="setLogRetention")
    def _set_log_retention(self) -> None:
        '''
        :stability: experimental
        '''
        return typing.cast(None, jsii.invoke(self, "setLogRetention", []))

    @builtins.property
    @jsii.member(jsii_name="connections")
    def connections(self) -> _Connections_57ccbda9:
        '''(experimental) Access to network connections.

        :stability: experimental
        '''
        return typing.cast(_Connections_57ccbda9, jsii.get(self, "connections"))

    @builtins.property
    @jsii.member(jsii_name="dbInstanceEndpointAddress")
    def db_instance_endpoint_address(self) -> builtins.str:
        '''(experimental) The instance endpoint address.

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "dbInstanceEndpointAddress"))

    @builtins.property
    @jsii.member(jsii_name="dbInstanceEndpointPort")
    def db_instance_endpoint_port(self) -> builtins.str:
        '''(experimental) The instance endpoint port.

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "dbInstanceEndpointPort"))

    @builtins.property
    @jsii.member(jsii_name="instanceEndpoint")
    def instance_endpoint(self) -> Endpoint:
        '''(experimental) The instance endpoint.

        :stability: experimental
        '''
        return typing.cast(Endpoint, jsii.get(self, "instanceEndpoint"))

    @builtins.property
    @jsii.member(jsii_name="instanceIdentifier")
    def instance_identifier(self) -> builtins.str:
        '''(experimental) The instance identifier.

        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "instanceIdentifier"))

    @builtins.property
    @jsii.member(jsii_name="instanceType")
    def _instance_type(self) -> _InstanceType_072ad323:
        '''
        :stability: experimental
        '''
        return typing.cast(_InstanceType_072ad323, jsii.get(self, "instanceType"))

    @builtins.property
    @jsii.member(jsii_name="newCfnProps")
    def _new_cfn_props(self) -> CfnDBInstanceProps:
        '''
        :stability: experimental
        '''
        return typing.cast(CfnDBInstanceProps, jsii.get(self, "newCfnProps"))

    @builtins.property
    @jsii.member(jsii_name="sourceCfnProps")
    def _source_cfn_props(self) -> CfnDBInstanceProps:
        '''
        :stability: experimental
        '''
        return typing.cast(CfnDBInstanceProps, jsii.get(self, "sourceCfnProps"))

    @builtins.property
    @jsii.member(jsii_name="vpc")
    def vpc(self) -> _IVpc_6d1f76c4:
        '''(experimental) The VPC where this database instance is deployed.

        :stability: experimental
        '''
        return typing.cast(_IVpc_6d1f76c4, jsii.get(self, "vpc"))

    @builtins.property
    @jsii.member(jsii_name="engine")
    def engine(self) -> typing.Optional[IInstanceEngine]:
        '''(experimental) The engine of this database Instance.

        May be not known for imported Instances if it wasn't provided explicitly,
        or for read replicas.

        :stability: experimental
        '''
        return typing.cast(typing.Optional[IInstanceEngine], jsii.get(self, "engine"))

    @builtins.property
    @jsii.member(jsii_name="secret")
    def secret(self) -> typing.Optional[_ISecret_22fb8757]:
        '''(experimental) The AWS Secrets Manager secret attached to the instance.

        :stability: experimental
        '''
        return typing.cast(typing.Optional[_ISecret_22fb8757], jsii.get(self, "secret"))

    @builtins.property
    @jsii.member(jsii_name="vpcPlacement")
    def _vpc_placement(self) -> typing.Optional[_SubnetSelection_1284e62c]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[_SubnetSelection_1284e62c], jsii.get(self, "vpcPlacement"))

    @builtins.property
    @jsii.member(jsii_name="enableIamAuthentication")
    def _enable_iam_authentication(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "enableIamAuthentication"))

    @_enable_iam_authentication.setter
    def _enable_iam_authentication(self, value: typing.Optional[builtins.bool]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__36a482cdf219c977e02791673b8fbd848b388af62726e4429d6a8783d2116a7f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enableIamAuthentication", value)


__all__ = [
    "AuroraCapacityUnit",
    "AuroraClusterEngineProps",
    "AuroraEngineVersion",
    "AuroraMysqlClusterEngineProps",
    "AuroraMysqlEngineVersion",
    "AuroraPostgresClusterEngineProps",
    "AuroraPostgresEngineFeatures",
    "AuroraPostgresEngineVersion",
    "BackupProps",
    "CfnDBCluster",
    "CfnDBClusterParameterGroup",
    "CfnDBClusterParameterGroupProps",
    "CfnDBClusterProps",
    "CfnDBInstance",
    "CfnDBInstanceProps",
    "CfnDBParameterGroup",
    "CfnDBParameterGroupProps",
    "CfnDBProxy",
    "CfnDBProxyEndpoint",
    "CfnDBProxyEndpointProps",
    "CfnDBProxyProps",
    "CfnDBProxyTargetGroup",
    "CfnDBProxyTargetGroupProps",
    "CfnDBSecurityGroup",
    "CfnDBSecurityGroupIngress",
    "CfnDBSecurityGroupIngressProps",
    "CfnDBSecurityGroupProps",
    "CfnDBSubnetGroup",
    "CfnDBSubnetGroupProps",
    "CfnEventSubscription",
    "CfnEventSubscriptionProps",
    "CfnGlobalCluster",
    "CfnGlobalClusterProps",
    "CfnOptionGroup",
    "CfnOptionGroupProps",
    "ClusterEngineBindOptions",
    "ClusterEngineConfig",
    "ClusterEngineFeatures",
    "CommonRotationUserOptions",
    "Credentials",
    "CredentialsBaseOptions",
    "CredentialsFromUsernameOptions",
    "DatabaseCluster",
    "DatabaseClusterAttributes",
    "DatabaseClusterBase",
    "DatabaseClusterEngine",
    "DatabaseClusterFromSnapshot",
    "DatabaseClusterFromSnapshotProps",
    "DatabaseClusterProps",
    "DatabaseInstance",
    "DatabaseInstanceAttributes",
    "DatabaseInstanceBase",
    "DatabaseInstanceEngine",
    "DatabaseInstanceFromSnapshot",
    "DatabaseInstanceFromSnapshotProps",
    "DatabaseInstanceNewProps",
    "DatabaseInstanceProps",
    "DatabaseInstanceReadReplica",
    "DatabaseInstanceReadReplicaProps",
    "DatabaseInstanceSourceProps",
    "DatabaseProxy",
    "DatabaseProxyAttributes",
    "DatabaseProxyOptions",
    "DatabaseProxyProps",
    "DatabaseSecret",
    "DatabaseSecretProps",
    "Endpoint",
    "EngineVersion",
    "IClusterEngine",
    "IDatabaseCluster",
    "IDatabaseInstance",
    "IDatabaseProxy",
    "IEngine",
    "IInstanceEngine",
    "IOptionGroup",
    "IParameterGroup",
    "IServerlessCluster",
    "ISubnetGroup",
    "InstanceEngineBindOptions",
    "InstanceEngineConfig",
    "InstanceEngineFeatures",
    "InstanceProps",
    "LicenseModel",
    "MariaDbEngineVersion",
    "MariaDbInstanceEngineProps",
    "MySqlInstanceEngineProps",
    "MysqlEngineVersion",
    "OptionConfiguration",
    "OptionGroup",
    "OptionGroupProps",
    "OracleEeInstanceEngineProps",
    "OracleEngineVersion",
    "OracleLegacyEngineVersion",
    "OracleSe1InstanceEngineProps",
    "OracleSe2InstanceEngineProps",
    "OracleSeInstanceEngineProps",
    "ParameterGroup",
    "ParameterGroupClusterBindOptions",
    "ParameterGroupClusterConfig",
    "ParameterGroupInstanceBindOptions",
    "ParameterGroupInstanceConfig",
    "ParameterGroupProps",
    "PerformanceInsightRetention",
    "PostgresEngineFeatures",
    "PostgresEngineVersion",
    "PostgresInstanceEngineProps",
    "ProcessorFeatures",
    "ProxyTarget",
    "ProxyTargetConfig",
    "RotationMultiUserOptions",
    "RotationSingleUserOptions",
    "ServerlessCluster",
    "ServerlessClusterAttributes",
    "ServerlessClusterFromSnapshot",
    "ServerlessClusterFromSnapshotProps",
    "ServerlessClusterProps",
    "ServerlessScalingOptions",
    "SessionPinningFilter",
    "SnapshotCredentials",
    "SnapshotCredentialsFromGeneratedPasswordOptions",
    "SqlServerEeInstanceEngineProps",
    "SqlServerEngineVersion",
    "SqlServerExInstanceEngineProps",
    "SqlServerSeInstanceEngineProps",
    "SqlServerWebInstanceEngineProps",
    "StorageType",
    "SubnetGroup",
    "SubnetGroupProps",
]

publication.publish()

def _typecheckingstub__a24f616650b60c72d873952ceffb6175e41b94be3e3f94a2e05e75b933c46812(
    *,
    version: AuroraEngineVersion,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ad3556ca07c3b906db5600dcaeea426eaa196043bd2dd62b15e131e1869f72e2(
    aurora_full_version: builtins.str,
    aurora_major_version: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__787fcd68d6eae166bc9fd59f039099e11a193e71bf74e78042254065b2d76c45(
    *,
    version: AuroraMysqlEngineVersion,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3f909c95d19c3db62505d876444380e9b0ef8074e5fff25fcf8656ba3b1aada7(
    aurora_mysql_full_version: builtins.str,
    aurora_mysql_major_version: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2b4c629db41ee6de5308da377b29943bb89814a71ef45b451d5b51eac5419b18(
    *,
    version: AuroraPostgresEngineVersion,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9085d942b8d590a04c16a5cf0a8ad801ddd5b18585bc31461eb73244c70afbb2(
    *,
    s3_export: typing.Optional[builtins.bool] = None,
    s3_import: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a43f47cd31d05c8e2f0b7d7d37b2a2ef40c165192b1b895ae3d487142666f29d(
    aurora_postgres_full_version: builtins.str,
    aurora_postgres_major_version: builtins.str,
    *,
    s3_export: typing.Optional[builtins.bool] = None,
    s3_import: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b5a1e24e3f8c4a56060780aab12ee63c3db9c83f06c19c6efb900be0b0ac673e(
    *,
    retention: _Duration_070aa057,
    preferred_window: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fad3e37488adcfe432af638bddae1d023194b2867e142ecc7586dc9160ca1502(
    scope: _Construct_e78e779f,
    id: builtins.str,
    *,
    allocated_storage: typing.Optional[jsii.Number] = None,
    associated_roles: typing.Optional[typing.Union[_IResolvable_a771d0ef, typing.Sequence[typing.Union[typing.Union[CfnDBCluster.DBClusterRoleProperty, typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]]]] = None,
    auto_minor_version_upgrade: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    availability_zones: typing.Optional[typing.Sequence[builtins.str]] = None,
    backtrack_window: typing.Optional[jsii.Number] = None,
    backup_retention_period: typing.Optional[jsii.Number] = None,
    copy_tags_to_snapshot: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    database_name: typing.Optional[builtins.str] = None,
    db_cluster_identifier: typing.Optional[builtins.str] = None,
    db_cluster_instance_class: typing.Optional[builtins.str] = None,
    db_cluster_parameter_group_name: typing.Optional[builtins.str] = None,
    db_instance_parameter_group_name: typing.Optional[builtins.str] = None,
    db_subnet_group_name: typing.Optional[builtins.str] = None,
    db_system_id: typing.Optional[builtins.str] = None,
    deletion_protection: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    domain: typing.Optional[builtins.str] = None,
    domain_iam_role_name: typing.Optional[builtins.str] = None,
    enable_cloudwatch_logs_exports: typing.Optional[typing.Sequence[builtins.str]] = None,
    enable_http_endpoint: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    enable_iam_database_authentication: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    engine: typing.Optional[builtins.str] = None,
    engine_mode: typing.Optional[builtins.str] = None,
    engine_version: typing.Optional[builtins.str] = None,
    global_cluster_identifier: typing.Optional[builtins.str] = None,
    iops: typing.Optional[jsii.Number] = None,
    kms_key_id: typing.Optional[builtins.str] = None,
    manage_master_user_password: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    master_username: typing.Optional[builtins.str] = None,
    master_user_password: typing.Optional[builtins.str] = None,
    master_user_secret: typing.Optional[typing.Union[typing.Union[CfnDBCluster.MasterUserSecretProperty, typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]] = None,
    monitoring_interval: typing.Optional[jsii.Number] = None,
    monitoring_role_arn: typing.Optional[builtins.str] = None,
    network_type: typing.Optional[builtins.str] = None,
    performance_insights_enabled: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    performance_insights_kms_key_id: typing.Optional[builtins.str] = None,
    performance_insights_retention_period: typing.Optional[jsii.Number] = None,
    port: typing.Optional[jsii.Number] = None,
    preferred_backup_window: typing.Optional[builtins.str] = None,
    preferred_maintenance_window: typing.Optional[builtins.str] = None,
    publicly_accessible: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    replication_source_identifier: typing.Optional[builtins.str] = None,
    restore_to_time: typing.Optional[builtins.str] = None,
    restore_type: typing.Optional[builtins.str] = None,
    scaling_configuration: typing.Optional[typing.Union[typing.Union[CfnDBCluster.ScalingConfigurationProperty, typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]] = None,
    serverless_v2_scaling_configuration: typing.Optional[typing.Union[typing.Union[CfnDBCluster.ServerlessV2ScalingConfigurationProperty, typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]] = None,
    snapshot_identifier: typing.Optional[builtins.str] = None,
    source_db_cluster_identifier: typing.Optional[builtins.str] = None,
    source_region: typing.Optional[builtins.str] = None,
    storage_encrypted: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    storage_type: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_CfnTag_95fbdc29, typing.Dict[builtins.str, typing.Any]]]] = None,
    use_latest_restorable_time: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    vpc_security_group_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8960c819422abc214366fa8fa8831fd2ea2a96fef89f73a9b865ca0cc4679224(
    inspector: _TreeInspector_1cd1894e,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6b27e5abf5e16a7e4d6239e5b71687492dff36a63ced8673d12f997ebadebd0f(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__386b040cbe6f3c10c54bea81e83ebd5be3ae5d5b94c43825de9227f29bda129d(
    value: typing.Optional[jsii.Number],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dd8fb8bda40030a7a1013e4e6ea5e7095b69673294f8045a9de98c9e84376ca8(
    value: typing.Optional[typing.Union[_IResolvable_a771d0ef, typing.List[typing.Union[CfnDBCluster.DBClusterRoleProperty, _IResolvable_a771d0ef]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3771cd695e45fe4fd034db09b990167f3573c2d96699da6e172a2c3ffc8b00cf(
    value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__408f422a31dd55d1c4d71cd9c37f56c30e171aa7b3bf032caffc6e1e24faa79a(
    value: typing.Optional[typing.List[builtins.str]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__114e6ca764e3c5709ac3ea154a41e503ca665aedde4e6467d03158224c1085cd(
    value: typing.Optional[jsii.Number],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__84a87d33782031b8f18d5c5cbf42a71ce8a900cfa7a211eb1d87e4eead8e37bd(
    value: typing.Optional[jsii.Number],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9c5af09150d5eb3c46e3271d3c2507f1752387c7c6a38d78ea1d8ed345d31593(
    value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__df9c79471b7452019fd10772162b00ba6c1a77aabc4f50f3537cf0f1f6c3b087(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__20ae20303ba62c81daa1973cf3e8b55d1a437c5e4a0f77a5583e04b674a2a258(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a11ea5e9c0290b309ed3f8e5b79b20926eb9f161c140bd9573747d6be33a2546(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0bd0cc3b48b2769856c7269df2d44fb64c3a11dfa3fa4cb9bb7a96ca5272bfde(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__12397ce7c2ed833d0cadb856189d10d17d9fafa20d79a1ed9b817d7cf585ca6a(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a8aa1d06b3abd55c08a15d1077d14e9e220d661551c8bf82d6fd271ebe7012ce(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e16319c747203d89c13edef5a1628f68635e5a425f15c9aea47c9eb6dd9e67c1(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__72dd2ca3ca9fcc3cb0f3e30850f1756f5c3b14794ab3e1f47dbb66dafa66408f(
    value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c59094c7379b5e083bbb69f6b969b695cc35d99bae34da1faed0223c1e59acd9(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ba24cb5abbab23e15417f0662c332f6e5d4792db4d794638200b8d5ed50581d0(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b1ead7f2500eb97a44fa14256da4b1d83734d3ca2be89eabe6899412a23d5220(
    value: typing.Optional[typing.List[builtins.str]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0270d35e3d2e3a58c10f541c4061c4559e97e31df15ad87e24167c588e2a7dda(
    value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5e1fb594581cfc2ca49d5a581f5876986dd2dc69d697b73a97a816c4c5226927(
    value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__148c55704718e7b4e3ba61ca286080a4408f46132e485121a44a13af56a72bab(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2d2154d2777906fe3dde181298bd3f87336e9cd6d203c50a7362c8f3c5fbbc06(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__07749311fb91af0947ebd82280930fde0166cea86133118187a7f5f454c24f89(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__44a736c76227233dd1a9533f7c0cca275ff40a6685f7aa108bc015ff87ce90a2(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a573b9ee6a3ac0f71281d75363b1bb68c4019aaa71b78645630d3a5667ba3a68(
    value: typing.Optional[jsii.Number],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__00bda67b879fd009a11852793d768843d458cef98e88c1524db1dd6cc44b054a(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__453f45f621105ed50d3c78817690ccc87928e6193281304a3244ab65d0a0e7d8(
    value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8d0c16557722ac1479cd861a74288942351f74633a0e1b0aee562ae44e9a7116(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4371836148f08a2eece0d79f54c1adcd9f1ed61cdc765dbdf9f6e01e614e2aab(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__29ff472ecec59bf036f2f1495c401a191690c8e19c31cab3150e21e49c621412(
    value: typing.Optional[typing.Union[CfnDBCluster.MasterUserSecretProperty, _IResolvable_a771d0ef]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8a468cc2821ed6fdd252a8afa3c095fcdeadafa0e2ad663701dd7c53b662757d(
    value: typing.Optional[jsii.Number],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d2a15e35ddf564864bf7315f58d6ec6beac59f36768c4b5e56d5b14fcd3b5662(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e6fabbb8dc8272780aa60766b54df3062970f757d0293869f6d3968ed6dbc51e(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__de08b9e379e2bdee9e21b59affbec238cd47fe7e3745bb32c52430e950387a3d(
    value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bb1ba1a4b3f1356b6202b26b9f7d1237c5ffd81c9aa2e16e75f1d26c865a03ac(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6dbf06247962dc081e59ef9a011004bc79dbb60a3ca535edd6c7468e21460195(
    value: typing.Optional[jsii.Number],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3a1b3eedb4a4e2c1c301c73ee1a665639e00c4ff5c05c157ca57e0c3be1e40b6(
    value: typing.Optional[jsii.Number],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4fadef388e1ac8d5fbfaf98b8fa6a9859b82137981e9489dcb412bb1a12ca835(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__97429d6598b4df7a9dca7adc6cec55deec1573eaa478729342dfa07996594532(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0a106465b4c25a4b554a430dacd97283e5589f9726f3860d90ed4395a83e0574(
    value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2d03d272f3ef0a29114fae2c7eeb77ba3fc96fa4eea5c6c1ae2bf733d11cbf26(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9f477e0b738f2cbec17e7e89664eca498f31ea6ff032ada0cdeabc8bf0d807c3(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f2aa8afa0934a08d35fb27de6e01a6a913b7e3985a3381fb2a8dafc2afe55a6c(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cef7ff1673a16c0f52002910e0c1858140ba7a4e607c81aab5a8add5b1e0bafe(
    value: typing.Optional[typing.Union[CfnDBCluster.ScalingConfigurationProperty, _IResolvable_a771d0ef]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bb1866869d8ec723b9a016209cb635f88fe388d40cab68ca4ec6730103444c2a(
    value: typing.Optional[typing.Union[CfnDBCluster.ServerlessV2ScalingConfigurationProperty, _IResolvable_a771d0ef]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e9049af093eab4c1a115b792a8bf8a2f598eddbd67cec4a7f9a8d963d8223ad2(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5d4c9e9bf842efee34076c204edadcd4caffdcbcfba1dc34f3dd54708a147b1f(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2b624b0a4d2407d68684234af1dd0b66e49d527bd2cf36167bb6337a98405368(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__64b093eeea2386185a4c62bb2ac9ddbb55209d26811b2f25c7d19972f2cabcfc(
    value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a0e3bae34afb8086514d6ecb2801e23dd3d2d97fee4e8a2508c69c92922a1f79(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ad0f13f7485acfac4b30acad3d9831426f014a998dd04c63dc00681b719292a5(
    value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dc20847e8f144ebe68a3d5713cdc707a24866e4c5debc8775b6b2644afe1a150(
    value: typing.Optional[typing.List[builtins.str]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8921a8dd496922707438c02c3380215f4fa5433c121989962eba74d3d8a1e657(
    *,
    role_arn: builtins.str,
    feature_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3de0068107923a6303476d31af027f180baca0719689cde5e9bcae3c626c8cea(
    *,
    address: typing.Optional[builtins.str] = None,
    port: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0cd79980e3b22b943962d000c5ab85d20465814cc9fd11e01b1cb76f56c662b9(
    *,
    kms_key_id: typing.Optional[builtins.str] = None,
    secret_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5272855c20351f3f7704bf57212fa4962e30e2266ba267596c087afc0c189216(
    *,
    address: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ace7122a90628da035871b4bb7569ff6f4b16fd1cc2e1c17fabf135fe4908ad2(
    *,
    auto_pause: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    max_capacity: typing.Optional[jsii.Number] = None,
    min_capacity: typing.Optional[jsii.Number] = None,
    seconds_before_timeout: typing.Optional[jsii.Number] = None,
    seconds_until_auto_pause: typing.Optional[jsii.Number] = None,
    timeout_action: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__976a781e9288a5f8ae5a7857bc196a62899d4c09c197dd1f79b4a50e7e848805(
    *,
    max_capacity: typing.Optional[jsii.Number] = None,
    min_capacity: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9d40a6672126306ea0513fe149015f5f521c3a1854bcf15f8867b0f15d156dd7(
    scope: _Construct_e78e779f,
    id: builtins.str,
    *,
    description: builtins.str,
    family: builtins.str,
    parameters: typing.Any,
    db_cluster_parameter_group_name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_CfnTag_95fbdc29, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f65ea0c4f542c8675b154afd9c3185e1111643e01fb948e321c88d6206faafa7(
    inspector: _TreeInspector_1cd1894e,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__30d0dce115283c1c378440f13c8f6e5c740fe2789adbe45ee7df8c3863e4aa4d(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dac7c65ac9efeba0a1233424235cf8013e53bce8f6e642fe8096639e1e75df57(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__115a45bf8215317dbe8457c488263675a9979c7606b227bc23755aa38c5ea7e5(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__47f110e264ec4e3b6bbec842a3f0cf73cecd993c08745480997ef5e699ef91be(
    value: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b8bb28b98f764e213c5fbc10415083fe44cfe8d270cdac2fba7d1d49462980eb(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__238115cdc22754dbd716961ecfe9bb9732621e81ab75d49a93c10e743a41a7ea(
    *,
    description: builtins.str,
    family: builtins.str,
    parameters: typing.Any,
    db_cluster_parameter_group_name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_CfnTag_95fbdc29, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__df1cb8073776f728073689f404524b014453b318d53b641d003dc64b88bd7cfa(
    *,
    allocated_storage: typing.Optional[jsii.Number] = None,
    associated_roles: typing.Optional[typing.Union[_IResolvable_a771d0ef, typing.Sequence[typing.Union[typing.Union[CfnDBCluster.DBClusterRoleProperty, typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]]]] = None,
    auto_minor_version_upgrade: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    availability_zones: typing.Optional[typing.Sequence[builtins.str]] = None,
    backtrack_window: typing.Optional[jsii.Number] = None,
    backup_retention_period: typing.Optional[jsii.Number] = None,
    copy_tags_to_snapshot: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    database_name: typing.Optional[builtins.str] = None,
    db_cluster_identifier: typing.Optional[builtins.str] = None,
    db_cluster_instance_class: typing.Optional[builtins.str] = None,
    db_cluster_parameter_group_name: typing.Optional[builtins.str] = None,
    db_instance_parameter_group_name: typing.Optional[builtins.str] = None,
    db_subnet_group_name: typing.Optional[builtins.str] = None,
    db_system_id: typing.Optional[builtins.str] = None,
    deletion_protection: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    domain: typing.Optional[builtins.str] = None,
    domain_iam_role_name: typing.Optional[builtins.str] = None,
    enable_cloudwatch_logs_exports: typing.Optional[typing.Sequence[builtins.str]] = None,
    enable_http_endpoint: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    enable_iam_database_authentication: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    engine: typing.Optional[builtins.str] = None,
    engine_mode: typing.Optional[builtins.str] = None,
    engine_version: typing.Optional[builtins.str] = None,
    global_cluster_identifier: typing.Optional[builtins.str] = None,
    iops: typing.Optional[jsii.Number] = None,
    kms_key_id: typing.Optional[builtins.str] = None,
    manage_master_user_password: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    master_username: typing.Optional[builtins.str] = None,
    master_user_password: typing.Optional[builtins.str] = None,
    master_user_secret: typing.Optional[typing.Union[typing.Union[CfnDBCluster.MasterUserSecretProperty, typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]] = None,
    monitoring_interval: typing.Optional[jsii.Number] = None,
    monitoring_role_arn: typing.Optional[builtins.str] = None,
    network_type: typing.Optional[builtins.str] = None,
    performance_insights_enabled: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    performance_insights_kms_key_id: typing.Optional[builtins.str] = None,
    performance_insights_retention_period: typing.Optional[jsii.Number] = None,
    port: typing.Optional[jsii.Number] = None,
    preferred_backup_window: typing.Optional[builtins.str] = None,
    preferred_maintenance_window: typing.Optional[builtins.str] = None,
    publicly_accessible: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    replication_source_identifier: typing.Optional[builtins.str] = None,
    restore_to_time: typing.Optional[builtins.str] = None,
    restore_type: typing.Optional[builtins.str] = None,
    scaling_configuration: typing.Optional[typing.Union[typing.Union[CfnDBCluster.ScalingConfigurationProperty, typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]] = None,
    serverless_v2_scaling_configuration: typing.Optional[typing.Union[typing.Union[CfnDBCluster.ServerlessV2ScalingConfigurationProperty, typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]] = None,
    snapshot_identifier: typing.Optional[builtins.str] = None,
    source_db_cluster_identifier: typing.Optional[builtins.str] = None,
    source_region: typing.Optional[builtins.str] = None,
    storage_encrypted: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    storage_type: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_CfnTag_95fbdc29, typing.Dict[builtins.str, typing.Any]]]] = None,
    use_latest_restorable_time: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    vpc_security_group_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c606bd0a8ff590d068fe4f90d7fe83c8aaa621c6ed05600706ac1e1283b1933f(
    scope: _Construct_e78e779f,
    id: builtins.str,
    *,
    allocated_storage: typing.Optional[builtins.str] = None,
    allow_major_version_upgrade: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    associated_roles: typing.Optional[typing.Union[_IResolvable_a771d0ef, typing.Sequence[typing.Union[typing.Union[CfnDBInstance.DBInstanceRoleProperty, typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]]]] = None,
    auto_minor_version_upgrade: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    availability_zone: typing.Optional[builtins.str] = None,
    backup_retention_period: typing.Optional[jsii.Number] = None,
    ca_certificate_identifier: typing.Optional[builtins.str] = None,
    certificate_details: typing.Optional[typing.Union[typing.Union[CfnDBInstance.CertificateDetailsProperty, typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]] = None,
    certificate_rotation_restart: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    character_set_name: typing.Optional[builtins.str] = None,
    copy_tags_to_snapshot: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    custom_iam_instance_profile: typing.Optional[builtins.str] = None,
    db_cluster_identifier: typing.Optional[builtins.str] = None,
    db_cluster_snapshot_identifier: typing.Optional[builtins.str] = None,
    db_instance_class: typing.Optional[builtins.str] = None,
    db_instance_identifier: typing.Optional[builtins.str] = None,
    db_name: typing.Optional[builtins.str] = None,
    db_parameter_group_name: typing.Optional[builtins.str] = None,
    db_security_groups: typing.Optional[typing.Sequence[builtins.str]] = None,
    db_snapshot_identifier: typing.Optional[builtins.str] = None,
    db_subnet_group_name: typing.Optional[builtins.str] = None,
    delete_automated_backups: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    deletion_protection: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    domain: typing.Optional[builtins.str] = None,
    domain_iam_role_name: typing.Optional[builtins.str] = None,
    enable_cloudwatch_logs_exports: typing.Optional[typing.Sequence[builtins.str]] = None,
    enable_iam_database_authentication: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    enable_performance_insights: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    endpoint: typing.Optional[typing.Union[typing.Union[CfnDBInstance.EndpointProperty, typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]] = None,
    engine: typing.Optional[builtins.str] = None,
    engine_version: typing.Optional[builtins.str] = None,
    iops: typing.Optional[jsii.Number] = None,
    kms_key_id: typing.Optional[builtins.str] = None,
    license_model: typing.Optional[builtins.str] = None,
    manage_master_user_password: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    master_username: typing.Optional[builtins.str] = None,
    master_user_password: typing.Optional[builtins.str] = None,
    master_user_secret: typing.Optional[typing.Union[typing.Union[CfnDBInstance.MasterUserSecretProperty, typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]] = None,
    max_allocated_storage: typing.Optional[jsii.Number] = None,
    monitoring_interval: typing.Optional[jsii.Number] = None,
    monitoring_role_arn: typing.Optional[builtins.str] = None,
    multi_az: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    nchar_character_set_name: typing.Optional[builtins.str] = None,
    network_type: typing.Optional[builtins.str] = None,
    option_group_name: typing.Optional[builtins.str] = None,
    performance_insights_kms_key_id: typing.Optional[builtins.str] = None,
    performance_insights_retention_period: typing.Optional[jsii.Number] = None,
    port: typing.Optional[builtins.str] = None,
    preferred_backup_window: typing.Optional[builtins.str] = None,
    preferred_maintenance_window: typing.Optional[builtins.str] = None,
    processor_features: typing.Optional[typing.Union[_IResolvable_a771d0ef, typing.Sequence[typing.Union[typing.Union[CfnDBInstance.ProcessorFeatureProperty, typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]]]] = None,
    promotion_tier: typing.Optional[jsii.Number] = None,
    publicly_accessible: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    replica_mode: typing.Optional[builtins.str] = None,
    restore_time: typing.Optional[builtins.str] = None,
    source_db_cluster_identifier: typing.Optional[builtins.str] = None,
    source_db_instance_automated_backups_arn: typing.Optional[builtins.str] = None,
    source_db_instance_identifier: typing.Optional[builtins.str] = None,
    source_dbi_resource_id: typing.Optional[builtins.str] = None,
    source_region: typing.Optional[builtins.str] = None,
    storage_encrypted: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    storage_throughput: typing.Optional[jsii.Number] = None,
    storage_type: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_CfnTag_95fbdc29, typing.Dict[builtins.str, typing.Any]]]] = None,
    timezone: typing.Optional[builtins.str] = None,
    use_default_processor_features: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    use_latest_restorable_time: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    vpc_security_groups: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__771f4d7ea048112360e7bc3038e30aba879d80e5477f41280ef9dc248f667baf(
    inspector: _TreeInspector_1cd1894e,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__234612597441a3e579324845dad3d1e6ea039ee8d98e571fd464e79cc5efdd94(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f30ac34c92f1ed4bbc4352ef3997cf5e224ef6d6a883e6b2c8cb9ad15ad56ed8(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__74ab94e5101e04b5fb5ff83c99c5b520eeea3baf28f6e294316d894b1a5b4ef9(
    value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__180aab7f21fa6a40b6e368188a38a6ab0c898e2ea4d7b5c5144e26df0e9583f6(
    value: typing.Optional[typing.Union[_IResolvable_a771d0ef, typing.List[typing.Union[CfnDBInstance.DBInstanceRoleProperty, _IResolvable_a771d0ef]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f47631fdd86ba904175fdf3d413da9ee0611e6248c39cb97ffa408800ad60fca(
    value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__736bf61bbf857e3f5d156473dde3aec8157a869e9aa829031591bfee5577e7cb(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7c7ed9000aad473bbdca38324efe5e7c8df236468d3f50d8e515323df05c88f4(
    value: typing.Optional[jsii.Number],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fc1a30e374a43cac11871b5fbcb869f25da71d31962675a125b91d834fdba14f(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1c145766ddab759cfba073659140b34ff2f6d5084b49fdfcb48a6a6142cbc082(
    value: typing.Optional[typing.Union[CfnDBInstance.CertificateDetailsProperty, _IResolvable_a771d0ef]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cadcd0ca784fe888fce63c692136fd6694a426037faec6bc85b099d88879786a(
    value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5daa49efa52d13d99a332fd35c25369d10a56f59e9934e1ce2a1e7f73ff5322d(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a565cee18d76d8438a280751a0fc381f3a970600369212a67e8bd7cdc5f62a4b(
    value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3c1f4b5f46e062a262dc2ce1d7001c36206285cf797aaee1381e035e222556bd(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6fc3e4bb152502ba92448cf4d01648e76a6144162d08f8aedc78af23899e1bc1(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__550c49ea20b997cea5ed397642b8e0afbefd25a663bc63f164a94163b779994e(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__722688888959726be9de6dd3a15e420fb27666e2703808dd9c1d35b009cb9e30(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__094c1781a68c6868527b0557da13af1e22d17de7c6434939d6642273af8dc33d(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2cc610d1c9b1b8860675d310165f13be25673d303ac33e6da3a467f176d4ad94(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5f8edd06a989361ace23482972419a964c44920872a4177465add6d3179f00d4(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f1bdb9f09049929a348b5e80a4618176330c0f8e854d7255c8e21d6973060d7c(
    value: typing.Optional[typing.List[builtins.str]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__76bdf9d6dbcea0d2b18f3af2cb8de634ce0588f9d475733a64dcce76172e3f1d(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9e2d5400d4d20d125a177eacfc5a8d3cd86f0dd695453ea6e769b140bb7e1d1e(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b70c9262f31c23b7f158d30e6dcaadca7b4798011225eb2ce38c45dc07212cbb(
    value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1b5cc0dbf9065b76eb8f6ae42592d603d3a43171eef8d122f03bd586ecfd37bc(
    value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d564f1d05f384e48e0c8e8469eebfa538bdd306ae5f999dde42b8e2ac0d8dceb(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d1a00150fe6f5d6fa506a35d981f3d1fc4b6d879c83c7637a050123ea12ba697(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f029ffd7857beec79c7f0542ed5d44b91650b9188821223d61ae68b343a51a2e(
    value: typing.Optional[typing.List[builtins.str]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4c57eafe16db80f59e89d945a3e79d21bc2ffa64b996867b60ca8025a55ebce5(
    value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c128a767782518434c97489d60918be935d47b6c681a1a283f9f125a49963a82(
    value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__127b913ac7a8914ce02de2f07c698abe52e0c97758eaf0b0ae1f94d6be29b70c(
    value: typing.Optional[typing.Union[CfnDBInstance.EndpointProperty, _IResolvable_a771d0ef]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ffb9a98966d575a19a1d108bd10d9fa5cc6a5ef4450fa29e0eb131b4bb1cf229(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4504039382292325cf77ba17393c302d43b6046a50fa4a7694f1e62d10258cfb(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9805183f9f5e0103023052807798679b700260e9a732565ecad63e8f02664c6c(
    value: typing.Optional[jsii.Number],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__973c7ec44f61fa9a94e7fc35582c42ef927a1545f0140e3984e5b75cd3361853(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d4d0249030623e1c88b397921a64f718d8553a827ccce8e9c8d9f2fc06a1580e(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3e9f03df1ec94c95325085eb832747858d56510196b933a87ce8b1f89f91180f(
    value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__efdaa4cc868863dc09102c7f305d360a1cdc60d8f3fb9d20306d642b298a7a32(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a522181a51c056c81cabd0d3d2ac9381b98d86f249ea450522d64477f4734dd7(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7bd70e9588050997d0ffd351fbb3398e7efc5d56ec1fd71905b44c8f8735a691(
    value: typing.Optional[typing.Union[CfnDBInstance.MasterUserSecretProperty, _IResolvable_a771d0ef]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b872061b1a35df5b0679f2dbc888d81ffe4cfff5aef35794f41757fd67213594(
    value: typing.Optional[jsii.Number],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__717ffb8ddd0de94d486eb5379bfead182533ff3e0bae50393797df5312bd278f(
    value: typing.Optional[jsii.Number],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__455aabd381bdbd84d6d43a77f45827e7be21b04f982f4916a727ddc16fecd025(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9b94d073818f9a2d23622b52e8632f6d4ae4ac0564a728fc40b93f8cbcb304f4(
    value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f9448042bf220c6e34749c5c09b98e2e6ed3c46d45952bdf795c42da9fa284fe(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ecc914b64ca8cfeacffc7b2276a9dcdc64e82a7a71bfce2e60c4712725e4e314(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__20d46636651d55f1dd3c1dbb72495f4d7ac078063a57cce60320ab8eaeda5af8(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b4b1df9e801f40ad82c9538f0c471dbf5a1a8797368f4abdba3e1ee2d9936478(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5ff7ad8621f6d2153a2d623f24fb253a38d009a37ab769ee7976ad81649e78b8(
    value: typing.Optional[jsii.Number],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6e77911c19a49a842c5cbc5fa2a4157e5fe35666027020bad6b5a3a5511f508a(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__56ee09102bda13e49fec046d7f1924118906c8467a1840e41d7791f68cb4f6fb(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1be30c0799236518ef5c6d039de824301aa753c338908bca66ca580a175a2eab(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__be2f039f6710ee121d3788f9c0d1db2ebbb91965b55f689e9e1138652f8d788d(
    value: typing.Optional[typing.Union[_IResolvable_a771d0ef, typing.List[typing.Union[CfnDBInstance.ProcessorFeatureProperty, _IResolvable_a771d0ef]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ca47f2c7da4fb549a2af33e46ec25896736e9e4232b0ce5f946845d12f02e5db(
    value: typing.Optional[jsii.Number],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fffe54595977e414c09c13ae24c623caf2c4b8bed64b304ebcdb3eca7a4b78e4(
    value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__414e8fd38a6a70e2a47d5bb53520eef7288fd3a2d7ec1e08aaf4a68843b5b42a(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dcf1570561d817933fd802ffd98134ad609b566e0001158f385eb4188de74ad8(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__146050eb5a20219727266ce1e0d8de2035ea0a7179138ee0a56903052736e225(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3ba4c3ea04b55ba955fbea1252346bbe1eadb7aa3560d4791dbfcad7c1a43118(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7ee8dbbf7bf17ec5768d5f178c2cbbd5b01dd00a956d4ef34fd5380ea204fb28(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ae6b0b64230466c68662663146964977b55e0736a8468aa1af070f966eae6af3(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e5dc487b92e71ad98a01c35fb315e0612b5e20ebf104ea8decdeadd5b4c6d13f(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__002a3e5ce8b8f5cd07b2c4ff71b882c2f7438c00d511e6b88f5735acc18ff367(
    value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b59c7ed22fae8e242d3c3c1c52f17eb7d5100eba9664aad31abea30a157a4ff8(
    value: typing.Optional[jsii.Number],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7349846e2c1121d7f11b6d513f8041fb18d4ae3baca10cd96f2ac2e4ccce9c37(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4331fdf05ef3e743bcd2975717144e4dd2fd426f0e88e4f63118d5106191f2c7(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4affe4310a88cb92253e261bd1cc76d7835a67968198a9dfd02011bfca0068c4(
    value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__faa00e8e0239c97f283b46e94dc1a0fff45b34d48afab929f6276e6f006e3dff(
    value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__232e6bb7671760c1e77aed5f275375029efdde6e133f00e5ab39ab6e0f86debf(
    value: typing.Optional[typing.List[builtins.str]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bead06731748842ac4fca1ed916eb6f10016926222b8e26fa14ba6a32da86775(
    *,
    ca_identifier: typing.Optional[builtins.str] = None,
    valid_till: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1c7f2a8f46a824e6360eedb79a668893026d65dbd8bf3df7319cc1460320ac08(
    *,
    feature_name: builtins.str,
    role_arn: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f194a7b42653c68c1ce135d700efbb0703b58da0eae55325c5fe286dc8e8668b(
    *,
    address: typing.Optional[builtins.str] = None,
    hosted_zone_id: typing.Optional[builtins.str] = None,
    port: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bb851cdf1d49b20e936f0b6c311bb23e7ceb584d928276da89ea9d94203ce69b(
    *,
    kms_key_id: typing.Optional[builtins.str] = None,
    secret_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d3e5fa5a0cac4ac24f527c5fceb1e70de8aabfa0ab1b67d11510cbea792a63de(
    *,
    name: typing.Optional[builtins.str] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cbec2b622ae3e8c6fd02ef8a6a19a85d6618c55f9591759ffcab13f8f280fd92(
    *,
    allocated_storage: typing.Optional[builtins.str] = None,
    allow_major_version_upgrade: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    associated_roles: typing.Optional[typing.Union[_IResolvable_a771d0ef, typing.Sequence[typing.Union[typing.Union[CfnDBInstance.DBInstanceRoleProperty, typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]]]] = None,
    auto_minor_version_upgrade: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    availability_zone: typing.Optional[builtins.str] = None,
    backup_retention_period: typing.Optional[jsii.Number] = None,
    ca_certificate_identifier: typing.Optional[builtins.str] = None,
    certificate_details: typing.Optional[typing.Union[typing.Union[CfnDBInstance.CertificateDetailsProperty, typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]] = None,
    certificate_rotation_restart: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    character_set_name: typing.Optional[builtins.str] = None,
    copy_tags_to_snapshot: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    custom_iam_instance_profile: typing.Optional[builtins.str] = None,
    db_cluster_identifier: typing.Optional[builtins.str] = None,
    db_cluster_snapshot_identifier: typing.Optional[builtins.str] = None,
    db_instance_class: typing.Optional[builtins.str] = None,
    db_instance_identifier: typing.Optional[builtins.str] = None,
    db_name: typing.Optional[builtins.str] = None,
    db_parameter_group_name: typing.Optional[builtins.str] = None,
    db_security_groups: typing.Optional[typing.Sequence[builtins.str]] = None,
    db_snapshot_identifier: typing.Optional[builtins.str] = None,
    db_subnet_group_name: typing.Optional[builtins.str] = None,
    delete_automated_backups: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    deletion_protection: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    domain: typing.Optional[builtins.str] = None,
    domain_iam_role_name: typing.Optional[builtins.str] = None,
    enable_cloudwatch_logs_exports: typing.Optional[typing.Sequence[builtins.str]] = None,
    enable_iam_database_authentication: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    enable_performance_insights: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    endpoint: typing.Optional[typing.Union[typing.Union[CfnDBInstance.EndpointProperty, typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]] = None,
    engine: typing.Optional[builtins.str] = None,
    engine_version: typing.Optional[builtins.str] = None,
    iops: typing.Optional[jsii.Number] = None,
    kms_key_id: typing.Optional[builtins.str] = None,
    license_model: typing.Optional[builtins.str] = None,
    manage_master_user_password: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    master_username: typing.Optional[builtins.str] = None,
    master_user_password: typing.Optional[builtins.str] = None,
    master_user_secret: typing.Optional[typing.Union[typing.Union[CfnDBInstance.MasterUserSecretProperty, typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]] = None,
    max_allocated_storage: typing.Optional[jsii.Number] = None,
    monitoring_interval: typing.Optional[jsii.Number] = None,
    monitoring_role_arn: typing.Optional[builtins.str] = None,
    multi_az: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    nchar_character_set_name: typing.Optional[builtins.str] = None,
    network_type: typing.Optional[builtins.str] = None,
    option_group_name: typing.Optional[builtins.str] = None,
    performance_insights_kms_key_id: typing.Optional[builtins.str] = None,
    performance_insights_retention_period: typing.Optional[jsii.Number] = None,
    port: typing.Optional[builtins.str] = None,
    preferred_backup_window: typing.Optional[builtins.str] = None,
    preferred_maintenance_window: typing.Optional[builtins.str] = None,
    processor_features: typing.Optional[typing.Union[_IResolvable_a771d0ef, typing.Sequence[typing.Union[typing.Union[CfnDBInstance.ProcessorFeatureProperty, typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]]]] = None,
    promotion_tier: typing.Optional[jsii.Number] = None,
    publicly_accessible: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    replica_mode: typing.Optional[builtins.str] = None,
    restore_time: typing.Optional[builtins.str] = None,
    source_db_cluster_identifier: typing.Optional[builtins.str] = None,
    source_db_instance_automated_backups_arn: typing.Optional[builtins.str] = None,
    source_db_instance_identifier: typing.Optional[builtins.str] = None,
    source_dbi_resource_id: typing.Optional[builtins.str] = None,
    source_region: typing.Optional[builtins.str] = None,
    storage_encrypted: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    storage_throughput: typing.Optional[jsii.Number] = None,
    storage_type: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_CfnTag_95fbdc29, typing.Dict[builtins.str, typing.Any]]]] = None,
    timezone: typing.Optional[builtins.str] = None,
    use_default_processor_features: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    use_latest_restorable_time: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    vpc_security_groups: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8b469a4fced86a01176742c0ee985cbcbb1582925d034ed2afed4457177f67db(
    scope: _Construct_e78e779f,
    id: builtins.str,
    *,
    description: builtins.str,
    family: builtins.str,
    db_parameter_group_name: typing.Optional[builtins.str] = None,
    parameters: typing.Any = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_CfnTag_95fbdc29, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b317a67ac4dbc9ca4935a00e06892a4eb0c225b58a90b718de21bf63d31fded4(
    inspector: _TreeInspector_1cd1894e,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__91a684c87b67b3089e356900289eb5a270617740cc312f960bf0eac1ec10cb13(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bd3cc3a4b820772179c6a31d9eac61a408e487dc67852aff69b0a6daf1a04495(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8d85936df088d2f09b5b96bfaa878fc17c5da03e17a3ac82b26f2ce03ec1be54(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__99cacfa2cfbf028ef62e95634fb7dd8333b35d027219c829f4f7c48f3c218330(
    value: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c636c2d6ae6863e86614a7268efcd49cd185eaad4bc367e00c9d97daa5f38e5b(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9ca53911a1d6df64c2da5051a78db0f32f6b90e8f17ff9a39ba8d770b4454dc9(
    *,
    description: builtins.str,
    family: builtins.str,
    db_parameter_group_name: typing.Optional[builtins.str] = None,
    parameters: typing.Any = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_CfnTag_95fbdc29, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9495d46744894209d6d1bb1607877196f80d42b1af7795e4c767f04f92fd3cc5(
    scope: _Construct_e78e779f,
    id: builtins.str,
    *,
    auth: typing.Union[_IResolvable_a771d0ef, typing.Sequence[typing.Union[typing.Union[CfnDBProxy.AuthFormatProperty, typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]]],
    db_proxy_name: builtins.str,
    engine_family: builtins.str,
    role_arn: builtins.str,
    vpc_subnet_ids: typing.Sequence[builtins.str],
    debug_logging: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    idle_client_timeout: typing.Optional[jsii.Number] = None,
    require_tls: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[CfnDBProxy.TagFormatProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    vpc_security_group_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a985556d7913082516936b96e8abb30b51ddd104d14c399c8e1d3e9c3a4af725(
    inspector: _TreeInspector_1cd1894e,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__765e68e014ec6b81c3d8e54abe5a5863c2a8482561e86fdc0d9ee8256840c5eb(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f40c459770ce92eee6b1dc409038c3b5d157134ee410908805700e68af2124f7(
    value: typing.Union[_IResolvable_a771d0ef, typing.List[typing.Union[CfnDBProxy.AuthFormatProperty, _IResolvable_a771d0ef]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__676e1fa17feca75773d712c06df72f8614ac73ed63c00dbc42db7893ce13ac5e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__47dfe074e5846f7906bfb38fbfe996a0fbec41821479293928dd017876495618(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__848e9f1e0f23c37b98f20d5d80f1eea43daa039ea7181e3b4a3dd3f647ef3b72(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ab780893e01b331588409afd139045d55a03980dfabe5c2b05a4f2a8f0abfd4a(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9d96e7f6a1cbbc6984a5acc918cff293a01c7cbed0cd5a89b9aa07be0f2b0962(
    value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8af1a584de482ef2668d41b4f637f93cf5d2af96c752959cf44c17d919ec4ad9(
    value: typing.Optional[jsii.Number],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c7e9d2ebf26653242af38a796368be442b0a3cbf868c542f5db7a56e0c845cf9(
    value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7e45986aaafc274aeb72227fdbb0afb0e1fba0bcc169dd0fc8e6c85bef254456(
    value: typing.Optional[typing.List[CfnDBProxy.TagFormatProperty]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a07064958b6c136ee003d1f13739e2b6a94197d1dc450b1206bb3c090e727d17(
    value: typing.Optional[typing.List[builtins.str]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d1e33b6e31c351c09614c1bcf23cffe6553682bd162b94bb936b16cdd8ae6fc7(
    *,
    auth_scheme: typing.Optional[builtins.str] = None,
    client_password_auth_type: typing.Optional[builtins.str] = None,
    description: typing.Optional[builtins.str] = None,
    iam_auth: typing.Optional[builtins.str] = None,
    secret_arn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__999594722dc31082e96928af4fd13ea02b9ebbb85848c27f75622b9f7d2f7b42(
    *,
    key: typing.Optional[builtins.str] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f845097f272b79b09b6480cc1d5ae32acc251207614ea5136f774e999f3ef4b1(
    scope: _Construct_e78e779f,
    id: builtins.str,
    *,
    db_proxy_endpoint_name: builtins.str,
    db_proxy_name: builtins.str,
    vpc_subnet_ids: typing.Sequence[builtins.str],
    tags: typing.Optional[typing.Sequence[typing.Union[CfnDBProxyEndpoint.TagFormatProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    target_role: typing.Optional[builtins.str] = None,
    vpc_security_group_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f88b4078e7a8ed76379a1132cd4ed75f5299e67380b820ab11e76f4089052785(
    inspector: _TreeInspector_1cd1894e,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__787c6b122dbdfd7b6a81da3d03af99b355477e2280083056ab30a50741b72bf0(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f8b1a2a046a60aac05f23773eed1fb5802dc62120741d3e1fabd1d26e83a1bab(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b8a1764132ee4f6151443f30fae73ee56659f0a433c6d22ac55834849b6e254f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ee573296b273bb1ee5cb4e504adcacc50e982b3ec13d787f8dbd90fa92844263(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__953fee923a0a9d5f8d27fee1530996c0a37743137e8564209e5538dbafc87e61(
    value: typing.Optional[typing.List[CfnDBProxyEndpoint.TagFormatProperty]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ec8a1f5e210da14c13686d2d53996e9470c69baa0d83c7d177ea2c0ebc60c942(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__be0cf55b254b04a10c9624ceedefd73fc88271bf6d0e4a36f0e2144f93f9684f(
    value: typing.Optional[typing.List[builtins.str]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c46737ff6c34d6ebc46e7a005cf44a6796a0b667020fc11b49abcb5deacf6b1d(
    *,
    key: typing.Optional[builtins.str] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f24126d4f5bb320638d718f8cdca2be62c34147c1f8746a1877238ac25102dfc(
    *,
    db_proxy_endpoint_name: builtins.str,
    db_proxy_name: builtins.str,
    vpc_subnet_ids: typing.Sequence[builtins.str],
    tags: typing.Optional[typing.Sequence[typing.Union[CfnDBProxyEndpoint.TagFormatProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    target_role: typing.Optional[builtins.str] = None,
    vpc_security_group_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__54a9709bd2bf8d0f24e5e08e65a124bd095a66c41c82613fab69cb8a98c4d1db(
    *,
    auth: typing.Union[_IResolvable_a771d0ef, typing.Sequence[typing.Union[typing.Union[CfnDBProxy.AuthFormatProperty, typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]]],
    db_proxy_name: builtins.str,
    engine_family: builtins.str,
    role_arn: builtins.str,
    vpc_subnet_ids: typing.Sequence[builtins.str],
    debug_logging: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    idle_client_timeout: typing.Optional[jsii.Number] = None,
    require_tls: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[CfnDBProxy.TagFormatProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    vpc_security_group_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5389a35838dfc16fdb58bdea4137236c7895494e1a70f820e1116a45625d6ee0(
    scope: _Construct_e78e779f,
    id: builtins.str,
    *,
    db_proxy_name: builtins.str,
    target_group_name: builtins.str,
    connection_pool_configuration_info: typing.Optional[typing.Union[typing.Union[CfnDBProxyTargetGroup.ConnectionPoolConfigurationInfoFormatProperty, typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]] = None,
    db_cluster_identifiers: typing.Optional[typing.Sequence[builtins.str]] = None,
    db_instance_identifiers: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__43fbd7a5904716388dd71238ea25bcb868772e37f6fa4a4fb90a873a5dea705b(
    inspector: _TreeInspector_1cd1894e,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__167f158cc042a5f06a0eeb1868661fcab0dec0592294488cd05d2b86df32c1b1(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__877d4ced2689548f5ab4a6849d34deaa1e4cacd0055cc4344f6f10a58c88964c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__552b2c23354860d8c4b7f36d402424bb22c7da9eee4dbea3813a53ce5d7abec6(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__773ed9e61b188469d54c6dc756b3ada1c3521614924f0b5b30fc2bd5c7e71fc3(
    value: typing.Optional[typing.Union[CfnDBProxyTargetGroup.ConnectionPoolConfigurationInfoFormatProperty, _IResolvable_a771d0ef]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c919873c840e765ffa9b462429e223326001d0ab433c5e3b521b2d00cc2ff48d(
    value: typing.Optional[typing.List[builtins.str]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__26f31893b792f5568c677878d5ab2ae53b8ba629d0fed89dde24bb97d22eb0d9(
    value: typing.Optional[typing.List[builtins.str]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9a22ef16c4137223a647eac410a7ca303889b997941e0fea5de937f9ffb4ebf6(
    *,
    connection_borrow_timeout: typing.Optional[jsii.Number] = None,
    init_query: typing.Optional[builtins.str] = None,
    max_connections_percent: typing.Optional[jsii.Number] = None,
    max_idle_connections_percent: typing.Optional[jsii.Number] = None,
    session_pinning_filters: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__862d297175897be0b7f2017e74da436cdb0b52dacec41540c367a730a7540990(
    *,
    db_proxy_name: builtins.str,
    target_group_name: builtins.str,
    connection_pool_configuration_info: typing.Optional[typing.Union[typing.Union[CfnDBProxyTargetGroup.ConnectionPoolConfigurationInfoFormatProperty, typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]] = None,
    db_cluster_identifiers: typing.Optional[typing.Sequence[builtins.str]] = None,
    db_instance_identifiers: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9e9a67164f5812d523f1dcae62c6ec8f192d198b0c3e6e4fe1312a11b51a2388(
    scope: _Construct_e78e779f,
    id: builtins.str,
    *,
    db_security_group_ingress: typing.Union[_IResolvable_a771d0ef, typing.Sequence[typing.Union[typing.Union[CfnDBSecurityGroup.IngressProperty, typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]]],
    group_description: builtins.str,
    ec2_vpc_id: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_CfnTag_95fbdc29, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__671c6ad00aacd5577dfd9e623bd2e443bc7e8b81f59a59212a062586c9ceb89b(
    inspector: _TreeInspector_1cd1894e,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__78e0a25ccd5c108b35cefdec08c9e5d110d2597ac3db670e19ebf8d97524a440(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e3880dd72b4ab8729e8cc8c8aa16db47651002db898e5a28bcc55bfe90085a5e(
    value: typing.Union[_IResolvable_a771d0ef, typing.List[typing.Union[CfnDBSecurityGroup.IngressProperty, _IResolvable_a771d0ef]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2d54183b3757ae5a64dedebb677eec7291e81e826915f70217a012042c884661(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f1a41dada834ebee6a6b2d6e1420693278bd8d9889f8b5502f6cc1381535d125(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__137df241ef4b31c18276d70992aa110de2ade5bfda6b9255651aa7762a822d0e(
    *,
    cidrip: typing.Optional[builtins.str] = None,
    ec2_security_group_id: typing.Optional[builtins.str] = None,
    ec2_security_group_name: typing.Optional[builtins.str] = None,
    ec2_security_group_owner_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fb87d9a69e7afe3e87948653ff0d476b92f5d6d8d7aff75b33d649963d14412b(
    scope: _Construct_e78e779f,
    id: builtins.str,
    *,
    db_security_group_name: builtins.str,
    cidrip: typing.Optional[builtins.str] = None,
    ec2_security_group_id: typing.Optional[builtins.str] = None,
    ec2_security_group_name: typing.Optional[builtins.str] = None,
    ec2_security_group_owner_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__705f98c3c6bbfabdc5934f47d60941d41161999c4344ab85e2f5a9f58ce79d41(
    inspector: _TreeInspector_1cd1894e,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3fcb02382126a5d26ef0268f18bd7af1afff7ffaeaa8293021e02f1dee8c9ada(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__31ef9a90a6b037a9b3ef7edcda8bc35875e3eca585363c80039cca97ad85aa9e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__57bf6fc4ea2c1d01896ec23f0f1b4789c04257507e1fc107396c130614db9802(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__69486b021b641a738e72bcdb9027317af68570f2d5673a80b64240c1c32d4678(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3197b6af99c934a1323934a7644b111809a6b8426b5333f2dadca1714771e9af(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__71a9a3d77c97e5b3e30de5c25aa5ddb2dab2afd73f720a324d7f61b03611b552(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__273208fbcdd321b4ade3e99ff35cf4b3ed26cc3b236b446c64002183b79967f4(
    *,
    db_security_group_name: builtins.str,
    cidrip: typing.Optional[builtins.str] = None,
    ec2_security_group_id: typing.Optional[builtins.str] = None,
    ec2_security_group_name: typing.Optional[builtins.str] = None,
    ec2_security_group_owner_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5d7b45d4c51ec74fea2243ff00660127097652f30b72d7ca6eda0d3f7f22dcc1(
    *,
    db_security_group_ingress: typing.Union[_IResolvable_a771d0ef, typing.Sequence[typing.Union[typing.Union[CfnDBSecurityGroup.IngressProperty, typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]]],
    group_description: builtins.str,
    ec2_vpc_id: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_CfnTag_95fbdc29, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6573958d88eab2f16ea908fc2c74b206ba1369e60a7f9a93b9c124dfa4235256(
    scope: _Construct_e78e779f,
    id: builtins.str,
    *,
    db_subnet_group_description: builtins.str,
    subnet_ids: typing.Sequence[builtins.str],
    db_subnet_group_name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_CfnTag_95fbdc29, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0808eb1182fcf16b6e539f620f3bdec11ff5eb90a7e957481cf4520e6cc4ec4c(
    inspector: _TreeInspector_1cd1894e,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__56d456d0c3c25a9608af0fea2d0bf5991ce40d60b6ad73b799ec6341732b4e50(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f7ef88a58ea350c3fb70e400583c3a3266478218eb46d5a3cafb29d0acf80d4a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__db56c52ae801ce32e18b11f84caf6ae9cb060430880793d138b7a3ba4659fca3(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8248b5b586733055c35d92ec8c3509293a818b15e176c41ce96ece35f8366936(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7644001f6b7f78cefdc8efc2853d2ecd628ebd4928df6b1a1c009f5e549dc7a3(
    *,
    db_subnet_group_description: builtins.str,
    subnet_ids: typing.Sequence[builtins.str],
    db_subnet_group_name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_CfnTag_95fbdc29, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__05c1386dcccd1c8f957e6442f6e78c0dcfe68c0f8dcedb9891a83018a3716333(
    scope: _Construct_e78e779f,
    id: builtins.str,
    *,
    sns_topic_arn: builtins.str,
    enabled: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    event_categories: typing.Optional[typing.Sequence[builtins.str]] = None,
    source_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
    source_type: typing.Optional[builtins.str] = None,
    subscription_name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_CfnTag_95fbdc29, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6dbc1390a6c639e6172f4d39693640a90b786051bd0b092b82f3ea6ecc55bfc2(
    inspector: _TreeInspector_1cd1894e,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ac6208cd8c1220259b16def735c61ace211ca9731da26168ec32fcb881d5d825(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__034413275be1f06406cf06f0bbfa2779248f32838b961d58fa965b29605d9033(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__84290090507d33096b13a93a814e6196b10b99175e14d11be7a4b2c0be886db4(
    value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fc02b265e42e49275e457fd0d07a66f37efc6ae0a6f52ca461f04ffdad1a4879(
    value: typing.Optional[typing.List[builtins.str]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c3235bb3e6314e79396695d782195f4a06545bc45ea96b8ecee380c28b8564ab(
    value: typing.Optional[typing.List[builtins.str]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d2875d0ab28c6da2e841060f3bfc8c54b71f3862039fc38043842dceea61daaa(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3ae06bb01fa02e0c23aff0e77bd8b833540dee86f3e1bd1803dbc18a7bcd054c(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f37e4c28c509a8e4631e90f64afd534626bb520a342e9576709507765c73d640(
    *,
    sns_topic_arn: builtins.str,
    enabled: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    event_categories: typing.Optional[typing.Sequence[builtins.str]] = None,
    source_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
    source_type: typing.Optional[builtins.str] = None,
    subscription_name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_CfnTag_95fbdc29, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c46b83d41de2b16f0407b8e464dc0825b61c8a9f79f8f3849f1fe22db18e41bd(
    scope: _Construct_e78e779f,
    id: builtins.str,
    *,
    deletion_protection: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    engine: typing.Optional[builtins.str] = None,
    engine_version: typing.Optional[builtins.str] = None,
    global_cluster_identifier: typing.Optional[builtins.str] = None,
    source_db_cluster_identifier: typing.Optional[builtins.str] = None,
    storage_encrypted: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__265b469ce5feb12bbf47b9074883b3387ac7e3a88ab8c5024c67a836983216a5(
    inspector: _TreeInspector_1cd1894e,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ec5f859984ee61b6a5932a3f95b5f7ace16f3ff07dc18f6b83891a1986bb810c(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a73d57c3fba958a51190258f379dff439c9e8a10fee9e293b407d5903829b580(
    value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__11793b1b5cfe55c098492415e704345c828d180b0c1b8def3e86ffaa75a906b8(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__38526cc6dd5999bcf4ca969144f23a78cfb178880382de7106d5338a23a43e4f(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4fdf7243cdbc7d1df7f21d36c3828d9432f614671dded8de5bfbc66c96b750fe(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8baf66e854a64fb717ad03390d2efc852a627ead9fb4059246c36d647b2aedc6(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__84f519a003b5b3ad210294778f51fae18f203e6c5fd1cddce9e2ab6d82b077b1(
    value: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d5da71038ecfa7d978e9c386e8e79d53829a6ef257753703d1fb52f4172cbec4(
    *,
    deletion_protection: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
    engine: typing.Optional[builtins.str] = None,
    engine_version: typing.Optional[builtins.str] = None,
    global_cluster_identifier: typing.Optional[builtins.str] = None,
    source_db_cluster_identifier: typing.Optional[builtins.str] = None,
    storage_encrypted: typing.Optional[typing.Union[builtins.bool, _IResolvable_a771d0ef]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2a0b9d6d3d8a1eb0eb82d4455dc137909ef139f94873bbecb138bbf459382fca(
    scope: _Construct_e78e779f,
    id: builtins.str,
    *,
    engine_name: builtins.str,
    major_engine_version: builtins.str,
    option_group_description: builtins.str,
    option_configurations: typing.Optional[typing.Union[_IResolvable_a771d0ef, typing.Sequence[typing.Union[typing.Union[CfnOptionGroup.OptionConfigurationProperty, typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]]]] = None,
    option_group_name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_CfnTag_95fbdc29, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d48d0842f1f578354852904a78ae6f043ab83ae86fd5519791c55a6cb5ede132(
    inspector: _TreeInspector_1cd1894e,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2e85aeafffe82278bee63c041f4b210cbca109ce323cfd0f7ca5ece56de2c511(
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6369a2038fd63f7723283f19243cc81a2b1287f2f3be89d6e033926127f5648f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__64089ffeab1594291746166310ffacb9492993d73fe3b3c1ad3adc88e012ce83(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dd647832781d8856ba01ec5125c99ed33b77a8018ab376f17abee2f931cff637(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eb4bda085f49d880f349dec55ee8a8751bd3f0c64662ec7abdcbb9fb97da7da7(
    value: typing.Optional[typing.Union[_IResolvable_a771d0ef, typing.List[typing.Union[CfnOptionGroup.OptionConfigurationProperty, _IResolvable_a771d0ef]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__96bc998f1d91cdd8552d199fb99c14e3c33917b660c8aadf32330ce363a91a94(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c2253264debd5cb2dec17b7d6c5de6edcea91e79feeb9bc217e75c6c60e8d174(
    *,
    option_name: builtins.str,
    db_security_group_memberships: typing.Optional[typing.Sequence[builtins.str]] = None,
    option_settings: typing.Optional[typing.Union[_IResolvable_a771d0ef, typing.Sequence[typing.Union[typing.Union[CfnOptionGroup.OptionSettingProperty, typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]]]] = None,
    option_version: typing.Optional[builtins.str] = None,
    port: typing.Optional[jsii.Number] = None,
    vpc_security_group_memberships: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a9c24cce3b6bb39fb92389cf0fcbf2943b151c9fda59ca8639b4311a9ce19522(
    *,
    name: typing.Optional[builtins.str] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__123a3d5bfb53653a73305970f4739068b614557f3fd637bd36a641ef0a966bea(
    *,
    engine_name: builtins.str,
    major_engine_version: builtins.str,
    option_group_description: builtins.str,
    option_configurations: typing.Optional[typing.Union[_IResolvable_a771d0ef, typing.Sequence[typing.Union[typing.Union[CfnOptionGroup.OptionConfigurationProperty, typing.Dict[builtins.str, typing.Any]], _IResolvable_a771d0ef]]]] = None,
    option_group_name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_CfnTag_95fbdc29, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0ebe255ef0a32e69b21915f181f2df84868d2e33760202b7257403c1c94790e5(
    *,
    parameter_group: typing.Optional[IParameterGroup] = None,
    s3_export_role: typing.Optional[_IRole_59af6f50] = None,
    s3_import_role: typing.Optional[_IRole_59af6f50] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4080c5e394ab90cb412fd554598e910b54c9967289123325e367a5e5abb5aebb(
    *,
    features: typing.Optional[typing.Union[ClusterEngineFeatures, typing.Dict[builtins.str, typing.Any]]] = None,
    parameter_group: typing.Optional[IParameterGroup] = None,
    port: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dc323a86d68f75c8fa4b776b469fc599385f8420dd13a5b9f964eea1d02a0e7b(
    *,
    s3_export: typing.Optional[builtins.str] = None,
    s3_import: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ce752cb488ff55d96c25fdf7c1801594f1205821f5d24b695b0aee71ca83b81d(
    *,
    automatically_after: typing.Optional[_Duration_070aa057] = None,
    endpoint: typing.Optional[_IInterfaceVpcEndpoint_6081623d] = None,
    exclude_characters: typing.Optional[builtins.str] = None,
    vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__17d4e6cd9004f729a10d723bc6a7c1ae57e715478ccd0710097bc468e6e6a8d7(
    username: builtins.str,
    *,
    encryption_key: typing.Optional[_IKey_36930160] = None,
    exclude_characters: typing.Optional[builtins.str] = None,
    replica_regions: typing.Optional[typing.Sequence[typing.Union[_ReplicaRegion_ad1a6d2e, typing.Dict[builtins.str, typing.Any]]]] = None,
    secret_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e80ffe6dc03fe1872a9918ca9ae89d4f229cafc6a45c1f144ba07e035c6676d6(
    username: builtins.str,
    password: _SecretValue_c18506ef,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__046b717ff081b63304a4655291073452bcac4fd782b3119509bd301b85dc1c30(
    secret: _ISecret_22fb8757,
    username: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cc18f4f28cad27d9206d2399c07f91796e289b0995618f784142e4df41487306(
    username: builtins.str,
    *,
    password: typing.Optional[_SecretValue_c18506ef] = None,
    encryption_key: typing.Optional[_IKey_36930160] = None,
    exclude_characters: typing.Optional[builtins.str] = None,
    replica_regions: typing.Optional[typing.Sequence[typing.Union[_ReplicaRegion_ad1a6d2e, typing.Dict[builtins.str, typing.Any]]]] = None,
    secret_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a0e1890f6a5f0a3246af72af2a7014a46bab1ebd56f5b68c97b165295535106f(
    *,
    encryption_key: typing.Optional[_IKey_36930160] = None,
    exclude_characters: typing.Optional[builtins.str] = None,
    replica_regions: typing.Optional[typing.Sequence[typing.Union[_ReplicaRegion_ad1a6d2e, typing.Dict[builtins.str, typing.Any]]]] = None,
    secret_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__126eafb985242873bf988963c4853dbb0fb11ac0550e95124ac9dc4aaebab8e3(
    *,
    encryption_key: typing.Optional[_IKey_36930160] = None,
    exclude_characters: typing.Optional[builtins.str] = None,
    replica_regions: typing.Optional[typing.Sequence[typing.Union[_ReplicaRegion_ad1a6d2e, typing.Dict[builtins.str, typing.Any]]]] = None,
    secret_name: typing.Optional[builtins.str] = None,
    password: typing.Optional[_SecretValue_c18506ef] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__03bd8a06157ebdd9114eeddbc0fdacdd29b0136f15cbb0cc5ed0afce21bdeb7f(
    *,
    cluster_identifier: builtins.str,
    cluster_endpoint_address: typing.Optional[builtins.str] = None,
    engine: typing.Optional[IClusterEngine] = None,
    instance_endpoint_addresses: typing.Optional[typing.Sequence[builtins.str]] = None,
    instance_identifiers: typing.Optional[typing.Sequence[builtins.str]] = None,
    port: typing.Optional[jsii.Number] = None,
    reader_endpoint_address: typing.Optional[builtins.str] = None,
    security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bc8cb6c6d22968105f85dbbe075c7927fc3c68d40f5110d1f010b7aa6fee22ee(
    *,
    engine: IClusterEngine,
    instance_props: typing.Union[InstanceProps, typing.Dict[builtins.str, typing.Any]],
    snapshot_identifier: builtins.str,
    backtrack_window: typing.Optional[_Duration_070aa057] = None,
    backup: typing.Optional[typing.Union[BackupProps, typing.Dict[builtins.str, typing.Any]]] = None,
    cloudwatch_logs_exports: typing.Optional[typing.Sequence[builtins.str]] = None,
    cloudwatch_logs_retention: typing.Optional[_RetentionDays_6c560d31] = None,
    cloudwatch_logs_retention_role: typing.Optional[_IRole_59af6f50] = None,
    cluster_identifier: typing.Optional[builtins.str] = None,
    copy_tags_to_snapshot: typing.Optional[builtins.bool] = None,
    credentials: typing.Optional[Credentials] = None,
    default_database_name: typing.Optional[builtins.str] = None,
    deletion_protection: typing.Optional[builtins.bool] = None,
    iam_authentication: typing.Optional[builtins.bool] = None,
    instance_identifier_base: typing.Optional[builtins.str] = None,
    instances: typing.Optional[jsii.Number] = None,
    monitoring_interval: typing.Optional[_Duration_070aa057] = None,
    monitoring_role: typing.Optional[_IRole_59af6f50] = None,
    parameter_group: typing.Optional[IParameterGroup] = None,
    parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    port: typing.Optional[jsii.Number] = None,
    preferred_maintenance_window: typing.Optional[builtins.str] = None,
    removal_policy: typing.Optional[_RemovalPolicy_c97e7a20] = None,
    s3_export_buckets: typing.Optional[typing.Sequence[_IBucket_73486e29]] = None,
    s3_export_role: typing.Optional[_IRole_59af6f50] = None,
    s3_import_buckets: typing.Optional[typing.Sequence[_IBucket_73486e29]] = None,
    s3_import_role: typing.Optional[_IRole_59af6f50] = None,
    storage_encrypted: typing.Optional[builtins.bool] = None,
    storage_encryption_key: typing.Optional[_IKey_36930160] = None,
    subnet_group: typing.Optional[ISubnetGroup] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f07e3cdd76b0f7dfadadcf92b3410f8a1ac363c84a485a58d06d53aa090a81b3(
    *,
    engine: IClusterEngine,
    instance_props: typing.Union[InstanceProps, typing.Dict[builtins.str, typing.Any]],
    backtrack_window: typing.Optional[_Duration_070aa057] = None,
    backup: typing.Optional[typing.Union[BackupProps, typing.Dict[builtins.str, typing.Any]]] = None,
    cloudwatch_logs_exports: typing.Optional[typing.Sequence[builtins.str]] = None,
    cloudwatch_logs_retention: typing.Optional[_RetentionDays_6c560d31] = None,
    cloudwatch_logs_retention_role: typing.Optional[_IRole_59af6f50] = None,
    cluster_identifier: typing.Optional[builtins.str] = None,
    copy_tags_to_snapshot: typing.Optional[builtins.bool] = None,
    credentials: typing.Optional[Credentials] = None,
    default_database_name: typing.Optional[builtins.str] = None,
    deletion_protection: typing.Optional[builtins.bool] = None,
    iam_authentication: typing.Optional[builtins.bool] = None,
    instance_identifier_base: typing.Optional[builtins.str] = None,
    instances: typing.Optional[jsii.Number] = None,
    monitoring_interval: typing.Optional[_Duration_070aa057] = None,
    monitoring_role: typing.Optional[_IRole_59af6f50] = None,
    parameter_group: typing.Optional[IParameterGroup] = None,
    parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    port: typing.Optional[jsii.Number] = None,
    preferred_maintenance_window: typing.Optional[builtins.str] = None,
    removal_policy: typing.Optional[_RemovalPolicy_c97e7a20] = None,
    s3_export_buckets: typing.Optional[typing.Sequence[_IBucket_73486e29]] = None,
    s3_export_role: typing.Optional[_IRole_59af6f50] = None,
    s3_import_buckets: typing.Optional[typing.Sequence[_IBucket_73486e29]] = None,
    s3_import_role: typing.Optional[_IRole_59af6f50] = None,
    storage_encrypted: typing.Optional[builtins.bool] = None,
    storage_encryption_key: typing.Optional[_IKey_36930160] = None,
    subnet_group: typing.Optional[ISubnetGroup] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ae7f96b20cfd66bed5a8eaa1761f0cffed70aa44fae44e7e2a60e78a1fa9d990(
    *,
    instance_endpoint_address: builtins.str,
    instance_identifier: builtins.str,
    port: jsii.Number,
    security_groups: typing.Sequence[_ISecurityGroup_cdbba9d3],
    engine: typing.Optional[IInstanceEngine] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__559e2e018326d446df6e743bdf88debcde44bd9fe897c5ca76b2494aa57811bc(
    *,
    vpc: _IVpc_6d1f76c4,
    auto_minor_version_upgrade: typing.Optional[builtins.bool] = None,
    availability_zone: typing.Optional[builtins.str] = None,
    backup_retention: typing.Optional[_Duration_070aa057] = None,
    cloudwatch_logs_exports: typing.Optional[typing.Sequence[builtins.str]] = None,
    cloudwatch_logs_retention: typing.Optional[_RetentionDays_6c560d31] = None,
    cloudwatch_logs_retention_role: typing.Optional[_IRole_59af6f50] = None,
    copy_tags_to_snapshot: typing.Optional[builtins.bool] = None,
    delete_automated_backups: typing.Optional[builtins.bool] = None,
    deletion_protection: typing.Optional[builtins.bool] = None,
    domain: typing.Optional[builtins.str] = None,
    domain_role: typing.Optional[_IRole_59af6f50] = None,
    enable_performance_insights: typing.Optional[builtins.bool] = None,
    iam_authentication: typing.Optional[builtins.bool] = None,
    instance_identifier: typing.Optional[builtins.str] = None,
    iops: typing.Optional[jsii.Number] = None,
    max_allocated_storage: typing.Optional[jsii.Number] = None,
    monitoring_interval: typing.Optional[_Duration_070aa057] = None,
    monitoring_role: typing.Optional[_IRole_59af6f50] = None,
    multi_az: typing.Optional[builtins.bool] = None,
    option_group: typing.Optional[IOptionGroup] = None,
    parameter_group: typing.Optional[IParameterGroup] = None,
    performance_insight_encryption_key: typing.Optional[_IKey_36930160] = None,
    performance_insight_retention: typing.Optional[PerformanceInsightRetention] = None,
    port: typing.Optional[jsii.Number] = None,
    preferred_backup_window: typing.Optional[builtins.str] = None,
    preferred_maintenance_window: typing.Optional[builtins.str] = None,
    processor_features: typing.Optional[typing.Union[ProcessorFeatures, typing.Dict[builtins.str, typing.Any]]] = None,
    publicly_accessible: typing.Optional[builtins.bool] = None,
    removal_policy: typing.Optional[_RemovalPolicy_c97e7a20] = None,
    s3_export_buckets: typing.Optional[typing.Sequence[_IBucket_73486e29]] = None,
    s3_export_role: typing.Optional[_IRole_59af6f50] = None,
    s3_import_buckets: typing.Optional[typing.Sequence[_IBucket_73486e29]] = None,
    s3_import_role: typing.Optional[_IRole_59af6f50] = None,
    security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
    storage_type: typing.Optional[StorageType] = None,
    subnet_group: typing.Optional[ISubnetGroup] = None,
    vpc_placement: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__58b0dd09fe25ca35225a9ea6db9d11e0447bfd08008e23c086631857d9c6d3d5(
    *,
    vpc: _IVpc_6d1f76c4,
    auto_minor_version_upgrade: typing.Optional[builtins.bool] = None,
    availability_zone: typing.Optional[builtins.str] = None,
    backup_retention: typing.Optional[_Duration_070aa057] = None,
    cloudwatch_logs_exports: typing.Optional[typing.Sequence[builtins.str]] = None,
    cloudwatch_logs_retention: typing.Optional[_RetentionDays_6c560d31] = None,
    cloudwatch_logs_retention_role: typing.Optional[_IRole_59af6f50] = None,
    copy_tags_to_snapshot: typing.Optional[builtins.bool] = None,
    delete_automated_backups: typing.Optional[builtins.bool] = None,
    deletion_protection: typing.Optional[builtins.bool] = None,
    domain: typing.Optional[builtins.str] = None,
    domain_role: typing.Optional[_IRole_59af6f50] = None,
    enable_performance_insights: typing.Optional[builtins.bool] = None,
    iam_authentication: typing.Optional[builtins.bool] = None,
    instance_identifier: typing.Optional[builtins.str] = None,
    iops: typing.Optional[jsii.Number] = None,
    max_allocated_storage: typing.Optional[jsii.Number] = None,
    monitoring_interval: typing.Optional[_Duration_070aa057] = None,
    monitoring_role: typing.Optional[_IRole_59af6f50] = None,
    multi_az: typing.Optional[builtins.bool] = None,
    option_group: typing.Optional[IOptionGroup] = None,
    parameter_group: typing.Optional[IParameterGroup] = None,
    performance_insight_encryption_key: typing.Optional[_IKey_36930160] = None,
    performance_insight_retention: typing.Optional[PerformanceInsightRetention] = None,
    port: typing.Optional[jsii.Number] = None,
    preferred_backup_window: typing.Optional[builtins.str] = None,
    preferred_maintenance_window: typing.Optional[builtins.str] = None,
    processor_features: typing.Optional[typing.Union[ProcessorFeatures, typing.Dict[builtins.str, typing.Any]]] = None,
    publicly_accessible: typing.Optional[builtins.bool] = None,
    removal_policy: typing.Optional[_RemovalPolicy_c97e7a20] = None,
    s3_export_buckets: typing.Optional[typing.Sequence[_IBucket_73486e29]] = None,
    s3_export_role: typing.Optional[_IRole_59af6f50] = None,
    s3_import_buckets: typing.Optional[typing.Sequence[_IBucket_73486e29]] = None,
    s3_import_role: typing.Optional[_IRole_59af6f50] = None,
    security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
    storage_type: typing.Optional[StorageType] = None,
    subnet_group: typing.Optional[ISubnetGroup] = None,
    vpc_placement: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    instance_type: _InstanceType_072ad323,
    source_database_instance: IDatabaseInstance,
    storage_encrypted: typing.Optional[builtins.bool] = None,
    storage_encryption_key: typing.Optional[_IKey_36930160] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__667843d9cf0d0baaf429a0d6a5f46f200dc58e17e3ad3b79a0b494806f49a514(
    *,
    vpc: _IVpc_6d1f76c4,
    auto_minor_version_upgrade: typing.Optional[builtins.bool] = None,
    availability_zone: typing.Optional[builtins.str] = None,
    backup_retention: typing.Optional[_Duration_070aa057] = None,
    cloudwatch_logs_exports: typing.Optional[typing.Sequence[builtins.str]] = None,
    cloudwatch_logs_retention: typing.Optional[_RetentionDays_6c560d31] = None,
    cloudwatch_logs_retention_role: typing.Optional[_IRole_59af6f50] = None,
    copy_tags_to_snapshot: typing.Optional[builtins.bool] = None,
    delete_automated_backups: typing.Optional[builtins.bool] = None,
    deletion_protection: typing.Optional[builtins.bool] = None,
    domain: typing.Optional[builtins.str] = None,
    domain_role: typing.Optional[_IRole_59af6f50] = None,
    enable_performance_insights: typing.Optional[builtins.bool] = None,
    iam_authentication: typing.Optional[builtins.bool] = None,
    instance_identifier: typing.Optional[builtins.str] = None,
    iops: typing.Optional[jsii.Number] = None,
    max_allocated_storage: typing.Optional[jsii.Number] = None,
    monitoring_interval: typing.Optional[_Duration_070aa057] = None,
    monitoring_role: typing.Optional[_IRole_59af6f50] = None,
    multi_az: typing.Optional[builtins.bool] = None,
    option_group: typing.Optional[IOptionGroup] = None,
    parameter_group: typing.Optional[IParameterGroup] = None,
    performance_insight_encryption_key: typing.Optional[_IKey_36930160] = None,
    performance_insight_retention: typing.Optional[PerformanceInsightRetention] = None,
    port: typing.Optional[jsii.Number] = None,
    preferred_backup_window: typing.Optional[builtins.str] = None,
    preferred_maintenance_window: typing.Optional[builtins.str] = None,
    processor_features: typing.Optional[typing.Union[ProcessorFeatures, typing.Dict[builtins.str, typing.Any]]] = None,
    publicly_accessible: typing.Optional[builtins.bool] = None,
    removal_policy: typing.Optional[_RemovalPolicy_c97e7a20] = None,
    s3_export_buckets: typing.Optional[typing.Sequence[_IBucket_73486e29]] = None,
    s3_export_role: typing.Optional[_IRole_59af6f50] = None,
    s3_import_buckets: typing.Optional[typing.Sequence[_IBucket_73486e29]] = None,
    s3_import_role: typing.Optional[_IRole_59af6f50] = None,
    security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
    storage_type: typing.Optional[StorageType] = None,
    subnet_group: typing.Optional[ISubnetGroup] = None,
    vpc_placement: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    engine: IInstanceEngine,
    allocated_storage: typing.Optional[jsii.Number] = None,
    allow_major_version_upgrade: typing.Optional[builtins.bool] = None,
    database_name: typing.Optional[builtins.str] = None,
    instance_type: typing.Optional[_InstanceType_072ad323] = None,
    license_model: typing.Optional[LicenseModel] = None,
    parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    timezone: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3ba2a1dbbef0ddd5132e4d6504cf129a65440bbb9c5ce01a4eb19ec7affb8ff1(
    *,
    db_proxy_arn: builtins.str,
    db_proxy_name: builtins.str,
    endpoint: builtins.str,
    security_groups: typing.Sequence[_ISecurityGroup_cdbba9d3],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__22b95ec0c8fcd2e43cd6cc777e57247615ccad39445c198c6a3849f9ec288380(
    *,
    secrets: typing.Sequence[_ISecret_22fb8757],
    vpc: _IVpc_6d1f76c4,
    borrow_timeout: typing.Optional[_Duration_070aa057] = None,
    db_proxy_name: typing.Optional[builtins.str] = None,
    debug_logging: typing.Optional[builtins.bool] = None,
    iam_auth: typing.Optional[builtins.bool] = None,
    idle_client_timeout: typing.Optional[_Duration_070aa057] = None,
    init_query: typing.Optional[builtins.str] = None,
    max_connections_percent: typing.Optional[jsii.Number] = None,
    max_idle_connections_percent: typing.Optional[jsii.Number] = None,
    require_tls: typing.Optional[builtins.bool] = None,
    role: typing.Optional[_IRole_59af6f50] = None,
    security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
    session_pinning_filters: typing.Optional[typing.Sequence[SessionPinningFilter]] = None,
    vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c4c0e996d5f4d6be1c6c0db0738431606cef8515b906fb5ac9b650b411f39e1a(
    *,
    secrets: typing.Sequence[_ISecret_22fb8757],
    vpc: _IVpc_6d1f76c4,
    borrow_timeout: typing.Optional[_Duration_070aa057] = None,
    db_proxy_name: typing.Optional[builtins.str] = None,
    debug_logging: typing.Optional[builtins.bool] = None,
    iam_auth: typing.Optional[builtins.bool] = None,
    idle_client_timeout: typing.Optional[_Duration_070aa057] = None,
    init_query: typing.Optional[builtins.str] = None,
    max_connections_percent: typing.Optional[jsii.Number] = None,
    max_idle_connections_percent: typing.Optional[jsii.Number] = None,
    require_tls: typing.Optional[builtins.bool] = None,
    role: typing.Optional[_IRole_59af6f50] = None,
    security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
    session_pinning_filters: typing.Optional[typing.Sequence[SessionPinningFilter]] = None,
    vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    proxy_target: ProxyTarget,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__35939bd400f370e8fbc6d6a25e87466fc4592a5ac435ab1de7a830e9ea153538(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    username: builtins.str,
    encryption_key: typing.Optional[_IKey_36930160] = None,
    exclude_characters: typing.Optional[builtins.str] = None,
    master_secret: typing.Optional[_ISecret_22fb8757] = None,
    replace_on_password_criteria_changes: typing.Optional[builtins.bool] = None,
    replica_regions: typing.Optional[typing.Sequence[typing.Union[_ReplicaRegion_ad1a6d2e, typing.Dict[builtins.str, typing.Any]]]] = None,
    secret_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__65b5ea5de1c30596b896d43622fdfde204227ada6b54015cd2cfe4a08251a13d(
    *,
    username: builtins.str,
    encryption_key: typing.Optional[_IKey_36930160] = None,
    exclude_characters: typing.Optional[builtins.str] = None,
    master_secret: typing.Optional[_ISecret_22fb8757] = None,
    replace_on_password_criteria_changes: typing.Optional[builtins.bool] = None,
    replica_regions: typing.Optional[typing.Sequence[typing.Union[_ReplicaRegion_ad1a6d2e, typing.Dict[builtins.str, typing.Any]]]] = None,
    secret_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a5f66272deaf48e941173f0a5ff66438e29db9586257638428fc54f2aa73687a(
    address: builtins.str,
    port: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__020060e9440cc94a9d7fc55daa89c558756f987dc18605fcbe54526dda4affc7(
    *,
    major_version: builtins.str,
    full_version: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9a44b9bde3fbd2c11633518cd49c67f61ee324968cac3a18ab42d8437f303410(
    id: builtins.str,
    *,
    secrets: typing.Sequence[_ISecret_22fb8757],
    vpc: _IVpc_6d1f76c4,
    borrow_timeout: typing.Optional[_Duration_070aa057] = None,
    db_proxy_name: typing.Optional[builtins.str] = None,
    debug_logging: typing.Optional[builtins.bool] = None,
    iam_auth: typing.Optional[builtins.bool] = None,
    idle_client_timeout: typing.Optional[_Duration_070aa057] = None,
    init_query: typing.Optional[builtins.str] = None,
    max_connections_percent: typing.Optional[jsii.Number] = None,
    max_idle_connections_percent: typing.Optional[jsii.Number] = None,
    require_tls: typing.Optional[builtins.bool] = None,
    role: typing.Optional[_IRole_59af6f50] = None,
    security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
    session_pinning_filters: typing.Optional[typing.Sequence[SessionPinningFilter]] = None,
    vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1ccf7294b1a2d81a7849e7b695afbee877e597dcde2aedd7ea0ad94f7c8361d0(
    metric_name: builtins.str,
    *,
    account: typing.Optional[builtins.str] = None,
    color: typing.Optional[builtins.str] = None,
    dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    label: typing.Optional[builtins.str] = None,
    period: typing.Optional[_Duration_070aa057] = None,
    region: typing.Optional[builtins.str] = None,
    statistic: typing.Optional[builtins.str] = None,
    unit: typing.Optional[_Unit_113c79f9] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6188518c846fbe54982e9913b05af128f894dc1ddab533827304da029efd0581(
    id: builtins.str,
    *,
    secrets: typing.Sequence[_ISecret_22fb8757],
    vpc: _IVpc_6d1f76c4,
    borrow_timeout: typing.Optional[_Duration_070aa057] = None,
    db_proxy_name: typing.Optional[builtins.str] = None,
    debug_logging: typing.Optional[builtins.bool] = None,
    iam_auth: typing.Optional[builtins.bool] = None,
    idle_client_timeout: typing.Optional[_Duration_070aa057] = None,
    init_query: typing.Optional[builtins.str] = None,
    max_connections_percent: typing.Optional[jsii.Number] = None,
    max_idle_connections_percent: typing.Optional[jsii.Number] = None,
    require_tls: typing.Optional[builtins.bool] = None,
    role: typing.Optional[_IRole_59af6f50] = None,
    security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
    session_pinning_filters: typing.Optional[typing.Sequence[SessionPinningFilter]] = None,
    vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bfe9e239b6e9ac080d7e26d7f31bd6986baca2ff7b8c3755359b857751d23cf0(
    grantee: _IGrantable_4c5a91d1,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b25d9a45fb91674a69bf7430971692af0f294c589166cf054fdb2119d60b8f67(
    metric_name: builtins.str,
    *,
    account: typing.Optional[builtins.str] = None,
    color: typing.Optional[builtins.str] = None,
    dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    label: typing.Optional[builtins.str] = None,
    period: typing.Optional[_Duration_070aa057] = None,
    region: typing.Optional[builtins.str] = None,
    statistic: typing.Optional[builtins.str] = None,
    unit: typing.Optional[_Unit_113c79f9] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8d39e45bda44875b5e8ee2e2fa36fddee950863eb5620ca6852eeae398c82a44(
    id: builtins.str,
    *,
    description: typing.Optional[builtins.str] = None,
    event_pattern: typing.Optional[typing.Union[_EventPattern_a23fbf37, typing.Dict[builtins.str, typing.Any]]] = None,
    rule_name: typing.Optional[builtins.str] = None,
    target: typing.Optional[_IRuleTarget_d45ec729] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7225ce884c29e3698d0b0fab87752984f27c235ab41f6e0142a7cfe721b8a124(
    grantee: _IGrantable_4c5a91d1,
    db_user: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__027a95a0176a5137e2d3b88f2d71290c32d245a6a6ef6311b8c1688b455fe35a(
    scope: _Construct_e78e779f,
    *,
    domain: typing.Optional[builtins.str] = None,
    option_group: typing.Optional[IOptionGroup] = None,
    s3_export_role: typing.Optional[_IRole_59af6f50] = None,
    s3_import_role: typing.Optional[_IRole_59af6f50] = None,
    timezone: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9806a6d21521ad5e0ec67291a5af9ed2be285b98c722e96c91a31761d113bab3(
    key: builtins.str,
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0dee857ceefd98c3a523c028d897a5967f524166f51e90fbb3e593a6296aa795(
    grantee: _IGrantable_4c5a91d1,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5753200842ba0102e7f6150267872fd8c4c2bbd3d00daa9b3b69fc2ddc623bb0(
    *,
    domain: typing.Optional[builtins.str] = None,
    option_group: typing.Optional[IOptionGroup] = None,
    s3_export_role: typing.Optional[_IRole_59af6f50] = None,
    s3_import_role: typing.Optional[_IRole_59af6f50] = None,
    timezone: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4a3da857f470a63c68899fd33a29f9a056eff41e67ce1dcf7953207853ed985e(
    *,
    features: typing.Optional[typing.Union[InstanceEngineFeatures, typing.Dict[builtins.str, typing.Any]]] = None,
    option_group: typing.Optional[IOptionGroup] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__87773405f00fac26f3c90e97a557d50371038a28720f483b27d83e932fdf63ec(
    *,
    s3_export: typing.Optional[builtins.str] = None,
    s3_import: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b308d2878231216f2cda103c16b475b34e49a2a94e392299d92c47e7bc96e489(
    *,
    vpc: _IVpc_6d1f76c4,
    allow_major_version_upgrade: typing.Optional[builtins.bool] = None,
    auto_minor_version_upgrade: typing.Optional[builtins.bool] = None,
    delete_automated_backups: typing.Optional[builtins.bool] = None,
    enable_performance_insights: typing.Optional[builtins.bool] = None,
    instance_type: typing.Optional[_InstanceType_072ad323] = None,
    parameter_group: typing.Optional[IParameterGroup] = None,
    parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    performance_insight_encryption_key: typing.Optional[_IKey_36930160] = None,
    performance_insight_retention: typing.Optional[PerformanceInsightRetention] = None,
    publicly_accessible: typing.Optional[builtins.bool] = None,
    security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
    vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1caff05283e494081bdb00d420a1a2f24c69f56c5b6b635ab40f374049b5d1e8(
    maria_db_full_version: builtins.str,
    maria_db_major_version: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__588235258c7d49f16ddf977d8a48e44fa15f530cb66f134b36fca574c8a0d7a2(
    *,
    version: MariaDbEngineVersion,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3447524277970c83d31a215338805e43dc3f65073e767ef9a00bdc5eefbcd4aa(
    *,
    version: MysqlEngineVersion,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__383c79e15ac8e81ec99e177f2a43c80a3ee12edb9ebe25846bad6bde16df4d83(
    mysql_full_version: builtins.str,
    mysql_major_version: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5af3f73cf0220fd79f44c873ab6287295ab74cbbb264743f2c9fcabbcef53c57(
    *,
    name: builtins.str,
    port: typing.Optional[jsii.Number] = None,
    security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
    settings: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    version: typing.Optional[builtins.str] = None,
    vpc: typing.Optional[_IVpc_6d1f76c4] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__793a9e74affcc700ff112183795a0126ecec1acdb2187df57317558b713acbc4(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    configurations: typing.Sequence[typing.Union[OptionConfiguration, typing.Dict[builtins.str, typing.Any]]],
    engine: IInstanceEngine,
    description: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__934e675aa59866aabf3af48db7738545e6f32ad2396b751a51fde39df526eed1(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    option_group_name: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__67ea241428936d1a25b7011da11eab02483738a0563b4004bba58044716ba8f7(
    *,
    configurations: typing.Sequence[typing.Union[OptionConfiguration, typing.Dict[builtins.str, typing.Any]]],
    engine: IInstanceEngine,
    description: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0f610fbb6f28018b417f9fd287e226ce49366b96e0b69ef8c03614489fd912de(
    *,
    version: OracleEngineVersion,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8d407e1f6ebbe003beffe3846f312bdc64952ba2f774a79118c8fc10988b2507(
    oracle_full_version: builtins.str,
    oracle_major_version: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ef52a0a16bc83bb8b2efa91c4e42647f55914596f5b7ad2bcea4c163dca5e9e0(
    *,
    version: OracleLegacyEngineVersion,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3b279b88ffe683316a834ce46911c0991a4ceab3d8a0784051c91c1b1eb47c38(
    *,
    version: OracleEngineVersion,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4f7c2569ae685d5347ad9c7ae74abb3a1e37c10bbb4bc1f2f6afd52f33ea038a(
    *,
    version: OracleLegacyEngineVersion,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__90c01ed05e68e04d55d397f6e8bb36549c2b91733d5fae769136f660b8ae3678(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    engine: IEngine,
    description: typing.Optional[builtins.str] = None,
    parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6fda544cc1f62b6e28c1c8a4bcf01a21333070e4f1356ee4cd5a56f3f116dc16(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    parameter_group_name: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b239d5a2a3d7f34833af46729dfb481d8940df5fd6fcae183077be987a3057b4(
    key: builtins.str,
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b3856afadbeacddd94f57f6b344677b9b284923622062b4299752b840befc9b0(
    *,
    parameter_group_name: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8a2bcd211a18f14cc2ad9eb202e62ed95cbd5190450681961248905ae9aba0f5(
    *,
    parameter_group_name: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cfc15b0cca60651e959371413a17d7021075a5fcfb6e863405746569bd9be72b(
    *,
    engine: IEngine,
    description: typing.Optional[builtins.str] = None,
    parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__74319f9390a1fb9bf6edb0516d8b0ed2c8b80b284e60d924d08721fa035e8dae(
    *,
    s3_export: typing.Optional[builtins.bool] = None,
    s3_import: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__85d98fcae85beb46d59234eb91fbdd38c155f8103b0ec0a082bf71feb615aa53(
    postgres_full_version: builtins.str,
    postgres_major_version: builtins.str,
    *,
    s3_export: typing.Optional[builtins.bool] = None,
    s3_import: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c92574a4ef80b2701826c7adc992b4fb02b48c041c62648bd156c2e65dadeafb(
    *,
    version: PostgresEngineVersion,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__78ba48d18d789b94abe5cf92c49294fd5b445bbb8ae725723673f169835175c1(
    *,
    core_count: typing.Optional[jsii.Number] = None,
    threads_per_core: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f24797854e76ef5fe4233507517b5c21d4b86db91926c88a0743c95138f5b2f8(
    cluster: IDatabaseCluster,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9d0b4b2f9dc7bbd60360dacdc50d5851e7666c32227b3b00ec304d3145d8817f(
    instance: IDatabaseInstance,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5bb49356d51cceef0c5e66f1131f55593c941cbfe311d0ccfdd4c7cdbe7ffba5(
    proxy: DatabaseProxy,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__869414a8a0959f8f2fa42ea9743c131364ff2ce8501b50066b84e8163815922b(
    *,
    engine_family: builtins.str,
    db_clusters: typing.Optional[typing.Sequence[IDatabaseCluster]] = None,
    db_instances: typing.Optional[typing.Sequence[IDatabaseInstance]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cf9bb5f36a0d33fc4df64b28384588fa77fbae6ae43809c6ac04aea972a18af5(
    *,
    automatically_after: typing.Optional[_Duration_070aa057] = None,
    endpoint: typing.Optional[_IInterfaceVpcEndpoint_6081623d] = None,
    exclude_characters: typing.Optional[builtins.str] = None,
    vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    secret: _ISecret_22fb8757,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__18c6926712e62b3ea8e6707529765906d55166e52e3678b6225439b0ff7157ba(
    *,
    automatically_after: typing.Optional[_Duration_070aa057] = None,
    endpoint: typing.Optional[_IInterfaceVpcEndpoint_6081623d] = None,
    exclude_characters: typing.Optional[builtins.str] = None,
    vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3f4fce36b4f6fc1edc581c019e8f50b95258548065ba4fd02bf095b81316fed9(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    engine: IClusterEngine,
    backup_retention: typing.Optional[_Duration_070aa057] = None,
    cluster_identifier: typing.Optional[builtins.str] = None,
    credentials: typing.Optional[Credentials] = None,
    default_database_name: typing.Optional[builtins.str] = None,
    deletion_protection: typing.Optional[builtins.bool] = None,
    enable_data_api: typing.Optional[builtins.bool] = None,
    parameter_group: typing.Optional[IParameterGroup] = None,
    removal_policy: typing.Optional[_RemovalPolicy_c97e7a20] = None,
    scaling: typing.Optional[typing.Union[ServerlessScalingOptions, typing.Dict[builtins.str, typing.Any]]] = None,
    security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
    storage_encryption_key: typing.Optional[_IKey_36930160] = None,
    subnet_group: typing.Optional[ISubnetGroup] = None,
    vpc: typing.Optional[_IVpc_6d1f76c4] = None,
    vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0decd73735e8da13cb5c9d6431a80aface326941b2f021885f51ebe89f3e61c7(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    cluster_identifier: builtins.str,
    cluster_endpoint_address: typing.Optional[builtins.str] = None,
    port: typing.Optional[jsii.Number] = None,
    reader_endpoint_address: typing.Optional[builtins.str] = None,
    secret: typing.Optional[_ISecret_22fb8757] = None,
    security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0f6cab592c9a10b7728365d1d46309aaf0a931e91942b6d4866bbef6629bc4a4(
    id: builtins.str,
    *,
    secret: _ISecret_22fb8757,
    automatically_after: typing.Optional[_Duration_070aa057] = None,
    endpoint: typing.Optional[_IInterfaceVpcEndpoint_6081623d] = None,
    exclude_characters: typing.Optional[builtins.str] = None,
    vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9ea739497412a26bde3e636d0ec798b87c51670de46e2e00e7de359fa3899b80(
    grantee: _IGrantable_4c5a91d1,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b8239386d5e925694ab8e342dabde05b663192970c05bf5a01b50695e298a31f(
    value: typing.Optional[builtins.bool],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__100e843e41111b2230661fc3d965672dce41eae90c755f074c806f70198af10f(
    *,
    cluster_identifier: builtins.str,
    cluster_endpoint_address: typing.Optional[builtins.str] = None,
    port: typing.Optional[jsii.Number] = None,
    reader_endpoint_address: typing.Optional[builtins.str] = None,
    secret: typing.Optional[_ISecret_22fb8757] = None,
    security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__df256bf1309523cdac6667b4390d29bedb2764fe28cad8d2618c5b660f1cb96e(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    engine: IClusterEngine,
    snapshot_identifier: builtins.str,
    backup_retention: typing.Optional[_Duration_070aa057] = None,
    cluster_identifier: typing.Optional[builtins.str] = None,
    credentials: typing.Optional[SnapshotCredentials] = None,
    default_database_name: typing.Optional[builtins.str] = None,
    deletion_protection: typing.Optional[builtins.bool] = None,
    enable_data_api: typing.Optional[builtins.bool] = None,
    parameter_group: typing.Optional[IParameterGroup] = None,
    removal_policy: typing.Optional[_RemovalPolicy_c97e7a20] = None,
    scaling: typing.Optional[typing.Union[ServerlessScalingOptions, typing.Dict[builtins.str, typing.Any]]] = None,
    security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
    subnet_group: typing.Optional[ISubnetGroup] = None,
    vpc: typing.Optional[_IVpc_6d1f76c4] = None,
    vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fc541f3d3cbe5927a7d6f9e6b8215fd14a7ed4487ec91821171ef2d811e50843(
    grantee: _IGrantable_4c5a91d1,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__75063d9057fdf010bc0800cb67560572592b93e9c7a1a3942f93bbb97f209f85(
    value: typing.Optional[builtins.bool],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ae09b1a081dc5c4d4a0f74848ba7c6013aa92ca431e41e503309eefa2f4cff57(
    *,
    engine: IClusterEngine,
    snapshot_identifier: builtins.str,
    backup_retention: typing.Optional[_Duration_070aa057] = None,
    cluster_identifier: typing.Optional[builtins.str] = None,
    credentials: typing.Optional[SnapshotCredentials] = None,
    default_database_name: typing.Optional[builtins.str] = None,
    deletion_protection: typing.Optional[builtins.bool] = None,
    enable_data_api: typing.Optional[builtins.bool] = None,
    parameter_group: typing.Optional[IParameterGroup] = None,
    removal_policy: typing.Optional[_RemovalPolicy_c97e7a20] = None,
    scaling: typing.Optional[typing.Union[ServerlessScalingOptions, typing.Dict[builtins.str, typing.Any]]] = None,
    security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
    subnet_group: typing.Optional[ISubnetGroup] = None,
    vpc: typing.Optional[_IVpc_6d1f76c4] = None,
    vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2d0a4715cdde0ac9feac72f55495577f3f41f4d550e7739595836f80e150e1f0(
    *,
    engine: IClusterEngine,
    backup_retention: typing.Optional[_Duration_070aa057] = None,
    cluster_identifier: typing.Optional[builtins.str] = None,
    credentials: typing.Optional[Credentials] = None,
    default_database_name: typing.Optional[builtins.str] = None,
    deletion_protection: typing.Optional[builtins.bool] = None,
    enable_data_api: typing.Optional[builtins.bool] = None,
    parameter_group: typing.Optional[IParameterGroup] = None,
    removal_policy: typing.Optional[_RemovalPolicy_c97e7a20] = None,
    scaling: typing.Optional[typing.Union[ServerlessScalingOptions, typing.Dict[builtins.str, typing.Any]]] = None,
    security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
    storage_encryption_key: typing.Optional[_IKey_36930160] = None,
    subnet_group: typing.Optional[ISubnetGroup] = None,
    vpc: typing.Optional[_IVpc_6d1f76c4] = None,
    vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6f3daa768677410b74d362a928ed30907050bd9490b5d2e4c2c15b00b64c80c9(
    *,
    auto_pause: typing.Optional[_Duration_070aa057] = None,
    max_capacity: typing.Optional[AuroraCapacityUnit] = None,
    min_capacity: typing.Optional[AuroraCapacityUnit] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3afa4807de84f81c5119248d0b9831a5785b0d1644564c043b1a10b30638e935(
    filter_name: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__49be72e8b5ba999d7f8dab4c158ed5aa0009ba4f6ad064c115b5a6dcede198e5(
    username: builtins.str,
    *,
    encryption_key: typing.Optional[_IKey_36930160] = None,
    exclude_characters: typing.Optional[builtins.str] = None,
    replica_regions: typing.Optional[typing.Sequence[typing.Union[_ReplicaRegion_ad1a6d2e, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fcafbe3ed0f0a7c4ce170baba5462b0cb8b0976e4a85c9ffa3699686243ceebf(
    username: builtins.str,
    *,
    encryption_key: typing.Optional[_IKey_36930160] = None,
    exclude_characters: typing.Optional[builtins.str] = None,
    replica_regions: typing.Optional[typing.Sequence[typing.Union[_ReplicaRegion_ad1a6d2e, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f8b24e4f72bb8381cb20927e9fc1cfe481bcfcadabc8136bf30a0b75e9ebb5b0(
    password: _SecretValue_c18506ef,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__846c761862615dad710463a35dc1a03f4cc0ff2864fb51cad84202106963b86c(
    secret: _ISecret_22fb8757,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__beba8649819d0ec03054437e063c9b64f9509d3b314f0c0b03266fc1be49407a(
    *,
    encryption_key: typing.Optional[_IKey_36930160] = None,
    exclude_characters: typing.Optional[builtins.str] = None,
    replica_regions: typing.Optional[typing.Sequence[typing.Union[_ReplicaRegion_ad1a6d2e, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__db3bff83440d505f4cfc9c643c7e013fe5bd881feb39617be3ae3630a43af4bb(
    *,
    version: SqlServerEngineVersion,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0b2584b7e834ed144406454f1f8fc75a4f1fb9473181e079bcc166b109e46e32(
    sql_server_full_version: builtins.str,
    sql_server_major_version: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__39fe10285f46f8aab0cac1d253ab30bf947add3b58aedb00f1568bacdb4ef459(
    *,
    version: SqlServerEngineVersion,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1f51c736910b187178ab834b3beb9489bfa8a2fbf0f8aaa4d38aefa09edf3295(
    *,
    version: SqlServerEngineVersion,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__05de9a07f18e6177c022990bb7d718b43a26c4347ee88a923409163485e10d8a(
    *,
    version: SqlServerEngineVersion,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e83f7e9099f30b4f649568b531a0da0c60e5b09a4f44bebc9ac5b685bb0882d7(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    description: builtins.str,
    vpc: _IVpc_6d1f76c4,
    removal_policy: typing.Optional[_RemovalPolicy_c97e7a20] = None,
    subnet_group_name: typing.Optional[builtins.str] = None,
    vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__aca450bf2613635119900dfa4842ae53e63015c4409b4a63ef1ee757e1b7d16f(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    subnet_group_name: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__90c82cb877541d63ee328c2cf95a734a158a60e1242a0b6c1c9d02e140209c2a(
    *,
    description: builtins.str,
    vpc: _IVpc_6d1f76c4,
    removal_policy: typing.Optional[_RemovalPolicy_c97e7a20] = None,
    subnet_group_name: typing.Optional[builtins.str] = None,
    vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8c84a493c30065af253aa2a20c74b4adf09f6fa7f5a4235cb017a2023528fc46(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    account: typing.Optional[builtins.str] = None,
    environment_from_arn: typing.Optional[builtins.str] = None,
    physical_name: typing.Optional[builtins.str] = None,
    region: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__75766e271c3f5c091bf6ce657282c17c6307b632b99c2523b9d7880b081c0d01(
    id: builtins.str,
    *,
    secrets: typing.Sequence[_ISecret_22fb8757],
    vpc: _IVpc_6d1f76c4,
    borrow_timeout: typing.Optional[_Duration_070aa057] = None,
    db_proxy_name: typing.Optional[builtins.str] = None,
    debug_logging: typing.Optional[builtins.bool] = None,
    iam_auth: typing.Optional[builtins.bool] = None,
    idle_client_timeout: typing.Optional[_Duration_070aa057] = None,
    init_query: typing.Optional[builtins.str] = None,
    max_connections_percent: typing.Optional[jsii.Number] = None,
    max_idle_connections_percent: typing.Optional[jsii.Number] = None,
    require_tls: typing.Optional[builtins.bool] = None,
    role: typing.Optional[_IRole_59af6f50] = None,
    security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
    session_pinning_filters: typing.Optional[typing.Sequence[SessionPinningFilter]] = None,
    vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dd44afa3757812a08c93c3a61edfa0c9c0279e08758f3139db41c2ed6c7ef3b6(
    metric_name: builtins.str,
    *,
    account: typing.Optional[builtins.str] = None,
    color: typing.Optional[builtins.str] = None,
    dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    label: typing.Optional[builtins.str] = None,
    period: typing.Optional[_Duration_070aa057] = None,
    region: typing.Optional[builtins.str] = None,
    statistic: typing.Optional[builtins.str] = None,
    unit: typing.Optional[_Unit_113c79f9] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4a1fb5e2feb43f6d5ecb5aa4ff4c30bd8606c8066dceda258312f08f023e731e(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    engine: IClusterEngine,
    instance_props: typing.Union[InstanceProps, typing.Dict[builtins.str, typing.Any]],
    snapshot_identifier: builtins.str,
    backtrack_window: typing.Optional[_Duration_070aa057] = None,
    backup: typing.Optional[typing.Union[BackupProps, typing.Dict[builtins.str, typing.Any]]] = None,
    cloudwatch_logs_exports: typing.Optional[typing.Sequence[builtins.str]] = None,
    cloudwatch_logs_retention: typing.Optional[_RetentionDays_6c560d31] = None,
    cloudwatch_logs_retention_role: typing.Optional[_IRole_59af6f50] = None,
    cluster_identifier: typing.Optional[builtins.str] = None,
    copy_tags_to_snapshot: typing.Optional[builtins.bool] = None,
    credentials: typing.Optional[Credentials] = None,
    default_database_name: typing.Optional[builtins.str] = None,
    deletion_protection: typing.Optional[builtins.bool] = None,
    iam_authentication: typing.Optional[builtins.bool] = None,
    instance_identifier_base: typing.Optional[builtins.str] = None,
    instances: typing.Optional[jsii.Number] = None,
    monitoring_interval: typing.Optional[_Duration_070aa057] = None,
    monitoring_role: typing.Optional[_IRole_59af6f50] = None,
    parameter_group: typing.Optional[IParameterGroup] = None,
    parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    port: typing.Optional[jsii.Number] = None,
    preferred_maintenance_window: typing.Optional[builtins.str] = None,
    removal_policy: typing.Optional[_RemovalPolicy_c97e7a20] = None,
    s3_export_buckets: typing.Optional[typing.Sequence[_IBucket_73486e29]] = None,
    s3_export_role: typing.Optional[_IRole_59af6f50] = None,
    s3_import_buckets: typing.Optional[typing.Sequence[_IBucket_73486e29]] = None,
    s3_import_role: typing.Optional[_IRole_59af6f50] = None,
    storage_encrypted: typing.Optional[builtins.bool] = None,
    storage_encryption_key: typing.Optional[_IKey_36930160] = None,
    subnet_group: typing.Optional[ISubnetGroup] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cc10a92d598a414e11858ab08ef64463c3866beee755f08c5bc6a4a5916a9765(
    id: builtins.str,
    *,
    secret: _ISecret_22fb8757,
    automatically_after: typing.Optional[_Duration_070aa057] = None,
    endpoint: typing.Optional[_IInterfaceVpcEndpoint_6081623d] = None,
    exclude_characters: typing.Optional[builtins.str] = None,
    vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4ab24e4025a70ea135fbc9a5e34af9947cd775417747d8037f4ddce95d0dc4ad(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    account: typing.Optional[builtins.str] = None,
    environment_from_arn: typing.Optional[builtins.str] = None,
    physical_name: typing.Optional[builtins.str] = None,
    region: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ee1427d6f2e8781e9c421ec58b331d3ff172574263d962e8207f47d772838ad7(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    instance_endpoint_address: builtins.str,
    instance_identifier: builtins.str,
    port: jsii.Number,
    security_groups: typing.Sequence[_ISecurityGroup_cdbba9d3],
    engine: typing.Optional[IInstanceEngine] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e36deb15b067ffab9bfc343baf4c382594e4573778c86ae209e6e8190d9aea5a(
    id: builtins.str,
    *,
    secrets: typing.Sequence[_ISecret_22fb8757],
    vpc: _IVpc_6d1f76c4,
    borrow_timeout: typing.Optional[_Duration_070aa057] = None,
    db_proxy_name: typing.Optional[builtins.str] = None,
    debug_logging: typing.Optional[builtins.bool] = None,
    iam_auth: typing.Optional[builtins.bool] = None,
    idle_client_timeout: typing.Optional[_Duration_070aa057] = None,
    init_query: typing.Optional[builtins.str] = None,
    max_connections_percent: typing.Optional[jsii.Number] = None,
    max_idle_connections_percent: typing.Optional[jsii.Number] = None,
    require_tls: typing.Optional[builtins.bool] = None,
    role: typing.Optional[_IRole_59af6f50] = None,
    security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
    session_pinning_filters: typing.Optional[typing.Sequence[SessionPinningFilter]] = None,
    vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a6bdf2abeb04fa1086542575d5e77e395c2ab5427948b0e8936489aa5634e2a2(
    grantee: _IGrantable_4c5a91d1,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cb214af6808d327243fed9a086e2708146880ce10bb7cd717b694908080fdfbb(
    metric_name: builtins.str,
    *,
    account: typing.Optional[builtins.str] = None,
    color: typing.Optional[builtins.str] = None,
    dimensions: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    label: typing.Optional[builtins.str] = None,
    period: typing.Optional[_Duration_070aa057] = None,
    region: typing.Optional[builtins.str] = None,
    statistic: typing.Optional[builtins.str] = None,
    unit: typing.Optional[_Unit_113c79f9] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8df77bf6703f53ef99be278b35aa0c1f0b2dbdd60c88c4ca14f38d17d9ec4457(
    id: builtins.str,
    *,
    description: typing.Optional[builtins.str] = None,
    event_pattern: typing.Optional[typing.Union[_EventPattern_a23fbf37, typing.Dict[builtins.str, typing.Any]]] = None,
    rule_name: typing.Optional[builtins.str] = None,
    target: typing.Optional[_IRuleTarget_d45ec729] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cfe3ca15d94a6f7229e28ac5c56a67f5b1849e5c380fe10b0fa6c2ec51ee42b5(
    value: typing.Optional[builtins.bool],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__108d23c4f82e82c8b6b27c51d73170e3cbcdf0b7381208e5c2eb3c713d5ca703(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    snapshot_identifier: builtins.str,
    credentials: typing.Optional[SnapshotCredentials] = None,
    engine: IInstanceEngine,
    allocated_storage: typing.Optional[jsii.Number] = None,
    allow_major_version_upgrade: typing.Optional[builtins.bool] = None,
    database_name: typing.Optional[builtins.str] = None,
    instance_type: typing.Optional[_InstanceType_072ad323] = None,
    license_model: typing.Optional[LicenseModel] = None,
    parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    timezone: typing.Optional[builtins.str] = None,
    vpc: _IVpc_6d1f76c4,
    auto_minor_version_upgrade: typing.Optional[builtins.bool] = None,
    availability_zone: typing.Optional[builtins.str] = None,
    backup_retention: typing.Optional[_Duration_070aa057] = None,
    cloudwatch_logs_exports: typing.Optional[typing.Sequence[builtins.str]] = None,
    cloudwatch_logs_retention: typing.Optional[_RetentionDays_6c560d31] = None,
    cloudwatch_logs_retention_role: typing.Optional[_IRole_59af6f50] = None,
    copy_tags_to_snapshot: typing.Optional[builtins.bool] = None,
    delete_automated_backups: typing.Optional[builtins.bool] = None,
    deletion_protection: typing.Optional[builtins.bool] = None,
    domain: typing.Optional[builtins.str] = None,
    domain_role: typing.Optional[_IRole_59af6f50] = None,
    enable_performance_insights: typing.Optional[builtins.bool] = None,
    iam_authentication: typing.Optional[builtins.bool] = None,
    instance_identifier: typing.Optional[builtins.str] = None,
    iops: typing.Optional[jsii.Number] = None,
    max_allocated_storage: typing.Optional[jsii.Number] = None,
    monitoring_interval: typing.Optional[_Duration_070aa057] = None,
    monitoring_role: typing.Optional[_IRole_59af6f50] = None,
    multi_az: typing.Optional[builtins.bool] = None,
    option_group: typing.Optional[IOptionGroup] = None,
    parameter_group: typing.Optional[IParameterGroup] = None,
    performance_insight_encryption_key: typing.Optional[_IKey_36930160] = None,
    performance_insight_retention: typing.Optional[PerformanceInsightRetention] = None,
    port: typing.Optional[jsii.Number] = None,
    preferred_backup_window: typing.Optional[builtins.str] = None,
    preferred_maintenance_window: typing.Optional[builtins.str] = None,
    processor_features: typing.Optional[typing.Union[ProcessorFeatures, typing.Dict[builtins.str, typing.Any]]] = None,
    publicly_accessible: typing.Optional[builtins.bool] = None,
    removal_policy: typing.Optional[_RemovalPolicy_c97e7a20] = None,
    s3_export_buckets: typing.Optional[typing.Sequence[_IBucket_73486e29]] = None,
    s3_export_role: typing.Optional[_IRole_59af6f50] = None,
    s3_import_buckets: typing.Optional[typing.Sequence[_IBucket_73486e29]] = None,
    s3_import_role: typing.Optional[_IRole_59af6f50] = None,
    security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
    storage_type: typing.Optional[StorageType] = None,
    subnet_group: typing.Optional[ISubnetGroup] = None,
    vpc_placement: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__198c8b3488658ccb011ae6959bc91cf28add379ee73c78a0033e5826ffa08d02(
    id: builtins.str,
    *,
    secret: _ISecret_22fb8757,
    automatically_after: typing.Optional[_Duration_070aa057] = None,
    endpoint: typing.Optional[_IInterfaceVpcEndpoint_6081623d] = None,
    exclude_characters: typing.Optional[builtins.str] = None,
    vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__509e48ffdeac25dcc54a555a17ad3d1a377fb948128543d28d8b44c7fa3a39cb(
    value: typing.Optional[builtins.bool],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__245ec839472d26b125b71df469fef0472070f4bbc6eb321718bc7a0c92d03c3f(
    *,
    vpc: _IVpc_6d1f76c4,
    auto_minor_version_upgrade: typing.Optional[builtins.bool] = None,
    availability_zone: typing.Optional[builtins.str] = None,
    backup_retention: typing.Optional[_Duration_070aa057] = None,
    cloudwatch_logs_exports: typing.Optional[typing.Sequence[builtins.str]] = None,
    cloudwatch_logs_retention: typing.Optional[_RetentionDays_6c560d31] = None,
    cloudwatch_logs_retention_role: typing.Optional[_IRole_59af6f50] = None,
    copy_tags_to_snapshot: typing.Optional[builtins.bool] = None,
    delete_automated_backups: typing.Optional[builtins.bool] = None,
    deletion_protection: typing.Optional[builtins.bool] = None,
    domain: typing.Optional[builtins.str] = None,
    domain_role: typing.Optional[_IRole_59af6f50] = None,
    enable_performance_insights: typing.Optional[builtins.bool] = None,
    iam_authentication: typing.Optional[builtins.bool] = None,
    instance_identifier: typing.Optional[builtins.str] = None,
    iops: typing.Optional[jsii.Number] = None,
    max_allocated_storage: typing.Optional[jsii.Number] = None,
    monitoring_interval: typing.Optional[_Duration_070aa057] = None,
    monitoring_role: typing.Optional[_IRole_59af6f50] = None,
    multi_az: typing.Optional[builtins.bool] = None,
    option_group: typing.Optional[IOptionGroup] = None,
    parameter_group: typing.Optional[IParameterGroup] = None,
    performance_insight_encryption_key: typing.Optional[_IKey_36930160] = None,
    performance_insight_retention: typing.Optional[PerformanceInsightRetention] = None,
    port: typing.Optional[jsii.Number] = None,
    preferred_backup_window: typing.Optional[builtins.str] = None,
    preferred_maintenance_window: typing.Optional[builtins.str] = None,
    processor_features: typing.Optional[typing.Union[ProcessorFeatures, typing.Dict[builtins.str, typing.Any]]] = None,
    publicly_accessible: typing.Optional[builtins.bool] = None,
    removal_policy: typing.Optional[_RemovalPolicy_c97e7a20] = None,
    s3_export_buckets: typing.Optional[typing.Sequence[_IBucket_73486e29]] = None,
    s3_export_role: typing.Optional[_IRole_59af6f50] = None,
    s3_import_buckets: typing.Optional[typing.Sequence[_IBucket_73486e29]] = None,
    s3_import_role: typing.Optional[_IRole_59af6f50] = None,
    security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
    storage_type: typing.Optional[StorageType] = None,
    subnet_group: typing.Optional[ISubnetGroup] = None,
    vpc_placement: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    engine: IInstanceEngine,
    allocated_storage: typing.Optional[jsii.Number] = None,
    allow_major_version_upgrade: typing.Optional[builtins.bool] = None,
    database_name: typing.Optional[builtins.str] = None,
    instance_type: typing.Optional[_InstanceType_072ad323] = None,
    license_model: typing.Optional[LicenseModel] = None,
    parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    timezone: typing.Optional[builtins.str] = None,
    snapshot_identifier: builtins.str,
    credentials: typing.Optional[SnapshotCredentials] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ae2e23512db40ff95a1157e35b72a05ed3c84b26f517ca4cfa98e752225fae7c(
    *,
    vpc: _IVpc_6d1f76c4,
    auto_minor_version_upgrade: typing.Optional[builtins.bool] = None,
    availability_zone: typing.Optional[builtins.str] = None,
    backup_retention: typing.Optional[_Duration_070aa057] = None,
    cloudwatch_logs_exports: typing.Optional[typing.Sequence[builtins.str]] = None,
    cloudwatch_logs_retention: typing.Optional[_RetentionDays_6c560d31] = None,
    cloudwatch_logs_retention_role: typing.Optional[_IRole_59af6f50] = None,
    copy_tags_to_snapshot: typing.Optional[builtins.bool] = None,
    delete_automated_backups: typing.Optional[builtins.bool] = None,
    deletion_protection: typing.Optional[builtins.bool] = None,
    domain: typing.Optional[builtins.str] = None,
    domain_role: typing.Optional[_IRole_59af6f50] = None,
    enable_performance_insights: typing.Optional[builtins.bool] = None,
    iam_authentication: typing.Optional[builtins.bool] = None,
    instance_identifier: typing.Optional[builtins.str] = None,
    iops: typing.Optional[jsii.Number] = None,
    max_allocated_storage: typing.Optional[jsii.Number] = None,
    monitoring_interval: typing.Optional[_Duration_070aa057] = None,
    monitoring_role: typing.Optional[_IRole_59af6f50] = None,
    multi_az: typing.Optional[builtins.bool] = None,
    option_group: typing.Optional[IOptionGroup] = None,
    parameter_group: typing.Optional[IParameterGroup] = None,
    performance_insight_encryption_key: typing.Optional[_IKey_36930160] = None,
    performance_insight_retention: typing.Optional[PerformanceInsightRetention] = None,
    port: typing.Optional[jsii.Number] = None,
    preferred_backup_window: typing.Optional[builtins.str] = None,
    preferred_maintenance_window: typing.Optional[builtins.str] = None,
    processor_features: typing.Optional[typing.Union[ProcessorFeatures, typing.Dict[builtins.str, typing.Any]]] = None,
    publicly_accessible: typing.Optional[builtins.bool] = None,
    removal_policy: typing.Optional[_RemovalPolicy_c97e7a20] = None,
    s3_export_buckets: typing.Optional[typing.Sequence[_IBucket_73486e29]] = None,
    s3_export_role: typing.Optional[_IRole_59af6f50] = None,
    s3_import_buckets: typing.Optional[typing.Sequence[_IBucket_73486e29]] = None,
    s3_import_role: typing.Optional[_IRole_59af6f50] = None,
    security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
    storage_type: typing.Optional[StorageType] = None,
    subnet_group: typing.Optional[ISubnetGroup] = None,
    vpc_placement: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    engine: IInstanceEngine,
    allocated_storage: typing.Optional[jsii.Number] = None,
    allow_major_version_upgrade: typing.Optional[builtins.bool] = None,
    database_name: typing.Optional[builtins.str] = None,
    instance_type: typing.Optional[_InstanceType_072ad323] = None,
    license_model: typing.Optional[LicenseModel] = None,
    parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    timezone: typing.Optional[builtins.str] = None,
    character_set_name: typing.Optional[builtins.str] = None,
    credentials: typing.Optional[Credentials] = None,
    storage_encrypted: typing.Optional[builtins.bool] = None,
    storage_encryption_key: typing.Optional[_IKey_36930160] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f7c3227f23034379200b83fecd7b912886a12a911ccb2494f84dd181c1d19634(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    instance_type: _InstanceType_072ad323,
    source_database_instance: IDatabaseInstance,
    storage_encrypted: typing.Optional[builtins.bool] = None,
    storage_encryption_key: typing.Optional[_IKey_36930160] = None,
    vpc: _IVpc_6d1f76c4,
    auto_minor_version_upgrade: typing.Optional[builtins.bool] = None,
    availability_zone: typing.Optional[builtins.str] = None,
    backup_retention: typing.Optional[_Duration_070aa057] = None,
    cloudwatch_logs_exports: typing.Optional[typing.Sequence[builtins.str]] = None,
    cloudwatch_logs_retention: typing.Optional[_RetentionDays_6c560d31] = None,
    cloudwatch_logs_retention_role: typing.Optional[_IRole_59af6f50] = None,
    copy_tags_to_snapshot: typing.Optional[builtins.bool] = None,
    delete_automated_backups: typing.Optional[builtins.bool] = None,
    deletion_protection: typing.Optional[builtins.bool] = None,
    domain: typing.Optional[builtins.str] = None,
    domain_role: typing.Optional[_IRole_59af6f50] = None,
    enable_performance_insights: typing.Optional[builtins.bool] = None,
    iam_authentication: typing.Optional[builtins.bool] = None,
    instance_identifier: typing.Optional[builtins.str] = None,
    iops: typing.Optional[jsii.Number] = None,
    max_allocated_storage: typing.Optional[jsii.Number] = None,
    monitoring_interval: typing.Optional[_Duration_070aa057] = None,
    monitoring_role: typing.Optional[_IRole_59af6f50] = None,
    multi_az: typing.Optional[builtins.bool] = None,
    option_group: typing.Optional[IOptionGroup] = None,
    parameter_group: typing.Optional[IParameterGroup] = None,
    performance_insight_encryption_key: typing.Optional[_IKey_36930160] = None,
    performance_insight_retention: typing.Optional[PerformanceInsightRetention] = None,
    port: typing.Optional[jsii.Number] = None,
    preferred_backup_window: typing.Optional[builtins.str] = None,
    preferred_maintenance_window: typing.Optional[builtins.str] = None,
    processor_features: typing.Optional[typing.Union[ProcessorFeatures, typing.Dict[builtins.str, typing.Any]]] = None,
    publicly_accessible: typing.Optional[builtins.bool] = None,
    removal_policy: typing.Optional[_RemovalPolicy_c97e7a20] = None,
    s3_export_buckets: typing.Optional[typing.Sequence[_IBucket_73486e29]] = None,
    s3_export_role: typing.Optional[_IRole_59af6f50] = None,
    s3_import_buckets: typing.Optional[typing.Sequence[_IBucket_73486e29]] = None,
    s3_import_role: typing.Optional[_IRole_59af6f50] = None,
    security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
    storage_type: typing.Optional[StorageType] = None,
    subnet_group: typing.Optional[ISubnetGroup] = None,
    vpc_placement: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e2e618172fbaa9a705ca00e51115de3536c016454695084da11d0e188d0eaf52(
    value: typing.Optional[builtins.bool],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dd0393d794f315b09d2ecc70bfbec174b936dd9f2df61ad7fd84f6655518a9a5(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    proxy_target: ProxyTarget,
    secrets: typing.Sequence[_ISecret_22fb8757],
    vpc: _IVpc_6d1f76c4,
    borrow_timeout: typing.Optional[_Duration_070aa057] = None,
    db_proxy_name: typing.Optional[builtins.str] = None,
    debug_logging: typing.Optional[builtins.bool] = None,
    iam_auth: typing.Optional[builtins.bool] = None,
    idle_client_timeout: typing.Optional[_Duration_070aa057] = None,
    init_query: typing.Optional[builtins.str] = None,
    max_connections_percent: typing.Optional[jsii.Number] = None,
    max_idle_connections_percent: typing.Optional[jsii.Number] = None,
    require_tls: typing.Optional[builtins.bool] = None,
    role: typing.Optional[_IRole_59af6f50] = None,
    security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
    session_pinning_filters: typing.Optional[typing.Sequence[SessionPinningFilter]] = None,
    vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0e81a921d8f050c26f550636acfbe1931790b7de953bc92d9ce913ccdc739352(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    db_proxy_arn: builtins.str,
    db_proxy_name: builtins.str,
    endpoint: builtins.str,
    security_groups: typing.Sequence[_ISecurityGroup_cdbba9d3],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9f290ceb66b7659af01208e575f4d31f44aec4063c8ec1aa5960af580a0d92bf(
    grantee: _IGrantable_4c5a91d1,
    db_user: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__07d465907b56c827b7150d74b90ee28822684296bf5ca7f5d7e370b1fe0a4fcf(
    scope: _Construct_e78e779f,
    *,
    parameter_group: typing.Optional[IParameterGroup] = None,
    s3_export_role: typing.Optional[_IRole_59af6f50] = None,
    s3_import_role: typing.Optional[_IRole_59af6f50] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ae813eaa64a4f874a0dc340aaecbad24ce58b4d22144ed46342fb54878d80f74(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    engine: IClusterEngine,
    instance_props: typing.Union[InstanceProps, typing.Dict[builtins.str, typing.Any]],
    backtrack_window: typing.Optional[_Duration_070aa057] = None,
    backup: typing.Optional[typing.Union[BackupProps, typing.Dict[builtins.str, typing.Any]]] = None,
    cloudwatch_logs_exports: typing.Optional[typing.Sequence[builtins.str]] = None,
    cloudwatch_logs_retention: typing.Optional[_RetentionDays_6c560d31] = None,
    cloudwatch_logs_retention_role: typing.Optional[_IRole_59af6f50] = None,
    cluster_identifier: typing.Optional[builtins.str] = None,
    copy_tags_to_snapshot: typing.Optional[builtins.bool] = None,
    credentials: typing.Optional[Credentials] = None,
    default_database_name: typing.Optional[builtins.str] = None,
    deletion_protection: typing.Optional[builtins.bool] = None,
    iam_authentication: typing.Optional[builtins.bool] = None,
    instance_identifier_base: typing.Optional[builtins.str] = None,
    instances: typing.Optional[jsii.Number] = None,
    monitoring_interval: typing.Optional[_Duration_070aa057] = None,
    monitoring_role: typing.Optional[_IRole_59af6f50] = None,
    parameter_group: typing.Optional[IParameterGroup] = None,
    parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    port: typing.Optional[jsii.Number] = None,
    preferred_maintenance_window: typing.Optional[builtins.str] = None,
    removal_policy: typing.Optional[_RemovalPolicy_c97e7a20] = None,
    s3_export_buckets: typing.Optional[typing.Sequence[_IBucket_73486e29]] = None,
    s3_export_role: typing.Optional[_IRole_59af6f50] = None,
    s3_import_buckets: typing.Optional[typing.Sequence[_IBucket_73486e29]] = None,
    s3_import_role: typing.Optional[_IRole_59af6f50] = None,
    storage_encrypted: typing.Optional[builtins.bool] = None,
    storage_encryption_key: typing.Optional[_IKey_36930160] = None,
    subnet_group: typing.Optional[ISubnetGroup] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5d8655578b10d0b2e612e5a92c3c777a2f7a2e07ca3552ca297ccca0ae984e28(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    cluster_identifier: builtins.str,
    cluster_endpoint_address: typing.Optional[builtins.str] = None,
    engine: typing.Optional[IClusterEngine] = None,
    instance_endpoint_addresses: typing.Optional[typing.Sequence[builtins.str]] = None,
    instance_identifiers: typing.Optional[typing.Sequence[builtins.str]] = None,
    port: typing.Optional[jsii.Number] = None,
    reader_endpoint_address: typing.Optional[builtins.str] = None,
    security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3ff611d4e33ff6d67d58f1db8345119f84f019a8f619bbc4fc9b15dd1bb66647(
    id: builtins.str,
    *,
    secret: _ISecret_22fb8757,
    automatically_after: typing.Optional[_Duration_070aa057] = None,
    endpoint: typing.Optional[_IInterfaceVpcEndpoint_6081623d] = None,
    exclude_characters: typing.Optional[builtins.str] = None,
    vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__00b35388b186f844f23ee157fe66670461d385e05a93b3a493c1fb7aa8b33387(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    character_set_name: typing.Optional[builtins.str] = None,
    credentials: typing.Optional[Credentials] = None,
    storage_encrypted: typing.Optional[builtins.bool] = None,
    storage_encryption_key: typing.Optional[_IKey_36930160] = None,
    engine: IInstanceEngine,
    allocated_storage: typing.Optional[jsii.Number] = None,
    allow_major_version_upgrade: typing.Optional[builtins.bool] = None,
    database_name: typing.Optional[builtins.str] = None,
    instance_type: typing.Optional[_InstanceType_072ad323] = None,
    license_model: typing.Optional[LicenseModel] = None,
    parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    timezone: typing.Optional[builtins.str] = None,
    vpc: _IVpc_6d1f76c4,
    auto_minor_version_upgrade: typing.Optional[builtins.bool] = None,
    availability_zone: typing.Optional[builtins.str] = None,
    backup_retention: typing.Optional[_Duration_070aa057] = None,
    cloudwatch_logs_exports: typing.Optional[typing.Sequence[builtins.str]] = None,
    cloudwatch_logs_retention: typing.Optional[_RetentionDays_6c560d31] = None,
    cloudwatch_logs_retention_role: typing.Optional[_IRole_59af6f50] = None,
    copy_tags_to_snapshot: typing.Optional[builtins.bool] = None,
    delete_automated_backups: typing.Optional[builtins.bool] = None,
    deletion_protection: typing.Optional[builtins.bool] = None,
    domain: typing.Optional[builtins.str] = None,
    domain_role: typing.Optional[_IRole_59af6f50] = None,
    enable_performance_insights: typing.Optional[builtins.bool] = None,
    iam_authentication: typing.Optional[builtins.bool] = None,
    instance_identifier: typing.Optional[builtins.str] = None,
    iops: typing.Optional[jsii.Number] = None,
    max_allocated_storage: typing.Optional[jsii.Number] = None,
    monitoring_interval: typing.Optional[_Duration_070aa057] = None,
    monitoring_role: typing.Optional[_IRole_59af6f50] = None,
    multi_az: typing.Optional[builtins.bool] = None,
    option_group: typing.Optional[IOptionGroup] = None,
    parameter_group: typing.Optional[IParameterGroup] = None,
    performance_insight_encryption_key: typing.Optional[_IKey_36930160] = None,
    performance_insight_retention: typing.Optional[PerformanceInsightRetention] = None,
    port: typing.Optional[jsii.Number] = None,
    preferred_backup_window: typing.Optional[builtins.str] = None,
    preferred_maintenance_window: typing.Optional[builtins.str] = None,
    processor_features: typing.Optional[typing.Union[ProcessorFeatures, typing.Dict[builtins.str, typing.Any]]] = None,
    publicly_accessible: typing.Optional[builtins.bool] = None,
    removal_policy: typing.Optional[_RemovalPolicy_c97e7a20] = None,
    s3_export_buckets: typing.Optional[typing.Sequence[_IBucket_73486e29]] = None,
    s3_export_role: typing.Optional[_IRole_59af6f50] = None,
    s3_import_buckets: typing.Optional[typing.Sequence[_IBucket_73486e29]] = None,
    s3_import_role: typing.Optional[_IRole_59af6f50] = None,
    security_groups: typing.Optional[typing.Sequence[_ISecurityGroup_cdbba9d3]] = None,
    storage_type: typing.Optional[StorageType] = None,
    subnet_group: typing.Optional[ISubnetGroup] = None,
    vpc_placement: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
    vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7c9a68f7da0bb3cb2501c61dbe7a4fdde1e46a442aab02c12be2a7b724770e7a(
    id: builtins.str,
    *,
    secret: _ISecret_22fb8757,
    automatically_after: typing.Optional[_Duration_070aa057] = None,
    endpoint: typing.Optional[_IInterfaceVpcEndpoint_6081623d] = None,
    exclude_characters: typing.Optional[builtins.str] = None,
    vpc_subnets: typing.Optional[typing.Union[_SubnetSelection_1284e62c, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__36a482cdf219c977e02791673b8fbd848b388af62726e4429d6a8783d2116a7f(
    value: typing.Optional[builtins.bool],
) -> None:
    """Type checking stubs"""
    pass

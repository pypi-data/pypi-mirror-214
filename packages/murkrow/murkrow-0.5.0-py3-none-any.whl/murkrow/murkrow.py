"""Simple chatterbox."""

import json
from typing import Callable, List, Optional, Union
from murkrow.registry import FunctionRegistry

from pydantic import BaseModel

import openai

from .display import Markdown
from .messaging import Message, ai, assistant, human, function_called, assistant_function_call


class Murkrow:
    """A simple chat class that uses OpenAI's Chat API.

    Messages stream in as they are generated by the API.

    History is tracked and can be used to continue a conversation.

    Args:
        initial_context (str | Message): The initial context for the conversation.


    >>> from murkrow import Murkrow
    >>> murkrow = Murkrow("Hello!")
    >>> murkrow.chat("How are you?")
    Hello!
    How are you?
    >>> murkrow.chat("I'm fine, thanks.")
    Nice to hear!

    """

    messages: List[Message]
    model: str
    function_registry: FunctionRegistry

    def __init__(
        self,
        *initial_context: Union[Message, str],
        model="gpt-3.5-turbo-0613",
        function_registry: Optional[FunctionRegistry] = None,
    ):
        """Initialize a `Murkrow` object with an optional initial context of messages.

        >>> from murkrow import Murkrow, narrate
        >>> murkrow = Murkrow(narrate("You are a large bird"))
        >>> murkrow.chat("What are you?")
        I am a large bird.

        """
        if initial_context is None:
            initial_context = []  # type: ignore

        self.messages: List[Message] = []

        self.append(*initial_context)
        self.model = model

        if function_registry is None:
            self.function_registry = FunctionRegistry()
        else:
            self.function_registry = function_registry

    def chat(self, *messages: Union[Message, str]):
        """Send messages to the chat model and display the response.

        Args:
            messages (str | Message): One or more messages to send to the chat, can be strings or Message objects.

        """
        self.append(*messages)

        mark = Markdown()
        mark.display()

        resp = openai.ChatCompletion.create(
            model=self.model,
            messages=self.messages,
            functions=self.function_registry.function_definitions,
            function_call="auto",
            stream=True,
        )

        function_name = None
        function_args = None

        in_function = False

        for result in resp:  # Go through the results of the stream
            choice = result['choices'][0]  # Get the first choice, since we're not doing bulk

            # TODO: When moving from a content delta to a function call delta, we need to flush the
            #       Markdown display and instead show the function call being built out

            if 'delta' in choice:  # If there is a delta in the result
                delta = choice['delta']
                if 'content' in delta and delta['content'] is not None:  # If the delta contains content
                    mark.append(delta['content'])  # Extend the markdown with the content

                elif 'function_call' in delta:  # If the delta contains a function call
                    # Previous message finished
                    if not in_function:
                        # Wrap up the previous
                        self.messages.append(assistant(mark.message))
                        mark = Markdown()
                        mark.display()

                        in_function = True

                    function_call = delta['function_call']
                    if 'name' in function_call:
                        function_name = function_call['name']

                    if 'arguments' in function_call:
                        # Build up the arguments string
                        function_args = (function_args or "") + function_call['arguments']

                    function_block = (
                        f"<details><summary>Running {function_name}</summary><pre>{function_args}</pre></details>"
                    )

                    mark.message = function_block

            if 'finish_reason' in choice and choice['finish_reason'] == "function_call":
                if function_name and function_args and function_name in self.function_registry:
                    self.messages.append(assistant_function_call(name=function_name, arguments=function_args))

                    mark = Markdown()
                    mark.display()

                    # Evaluate the arguments as a JSON
                    arguments = json.loads(function_args)

                    # Execute the function and get the result
                    function_result = self.function_registry.call(function_name, arguments)

                    repr_llm = repr(function_result)

                    mark.message = f"<details><summary>Function results</summary>{repr_llm}</details>"

                    self.messages.append(function_called(name=function_name, content=repr_llm))

                    # Reset function name and arguments for the next function call
                    function_name = None
                    function_args = None

                    in_function = False
            elif 'finish_reason' in choice and choice['finish_reason'] is not None:
                if not in_function:
                    # Wrap up the previous assistant
                    self.messages.append(assistant(mark.message))

                if 'max_tokens' in choice['finish_reason']:
                    mark.append("\n...MAX TOKENS REACHED...\n")

    def append(self, *messages: Union[Message, str]):
        """Append messages to the conversation history.

        Note: this does not send the messages on until `chat` is called.

        Args:
            messages (str | Message): One or more messages to append to the conversation.

        """
        # Messages are either a dict respecting the {role, content} format or a str that we convert to a human message
        for message in messages:
            if isinstance(message, str):
                self.messages.append(human(message))
            else:
                self.messages.append(message)

    def register(self, function: Callable, parameters_model: "BaseModel"):
        """Register a function with the Murkrow instance.

        Args:
            function (Callable): The function to register.
            parameters_model (BaseModel): The pydantic model to use for parameters.

        """
        self.function_registry.register(function, parameters_model)

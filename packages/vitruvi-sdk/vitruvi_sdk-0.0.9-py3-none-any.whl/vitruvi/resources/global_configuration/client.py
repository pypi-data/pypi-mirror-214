# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

import httpx
import pydantic

from ...core.api_error import ApiError
from ...core.jsonable_encoder import jsonable_encoder
from ...core.remove_none_from_headers import remove_none_from_headers
from ...types.company import Company
from ...types.company_type_enum import CompanyTypeEnum
from ...types.global_configuration_list_v_1_companies_request_type import GlobalConfigurationListV1CompaniesRequestType
from ...types.paginated_company_list import PaginatedCompanyList
from ...types.user_tier_enum import UserTierEnum

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class GlobalConfigurationClient:
    def __init__(self, *, environment: str, api_key: str):
        self._environment = environment
        self.api_key = api_key

    def list_v_1_companies(
        self,
        *,
        code: typing.Optional[str] = None,
        fields: typing.Optional[str] = None,
        is_active: typing.Optional[bool] = None,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        ordering: typing.Optional[str] = None,
        search: typing.Optional[str] = None,
        type: typing.Optional[GlobalConfigurationListV1CompaniesRequestType] = None,
        with_no_subcontract: typing.Optional[int] = None,
        with_subcontract_or_epc: typing.Optional[int] = None,
    ) -> PaginatedCompanyList:
        _response = httpx.request(
            "GET",
            urllib.parse.urljoin(f"{self._environment}/", "api/v1/companies"),
            params={
                "code": code,
                "fields": fields,
                "is_active": is_active,
                "limit": limit,
                "offset": offset,
                "ordering": ordering,
                "search": search,
                "type": type,
                "with_no_subcontract": with_no_subcontract,
                "with_subcontract_or_epc": with_subcontract_or_epc,
            },
            headers=remove_none_from_headers({"Authorization": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PaginatedCompanyList, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_v_1_companies(self, *, request: Company) -> Company:
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment}/", "api/v1/companies"),
            json=jsonable_encoder(request),
            headers=remove_none_from_headers({"Authorization": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Company, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_v_1_companies(self, id: int) -> Company:
        _response = httpx.request(
            "GET",
            urllib.parse.urljoin(f"{self._environment}/", f"api/v1/companies/{id}"),
            headers=remove_none_from_headers({"Authorization": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Company, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_v_1_companies(self, id: int, *, request: Company) -> Company:
        _response = httpx.request(
            "PUT",
            urllib.parse.urljoin(f"{self._environment}/", f"api/v1/companies/{id}"),
            json=jsonable_encoder(request),
            headers=remove_none_from_headers({"Authorization": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Company, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def patch_v_1_companies(
        self,
        id: int,
        *,
        patched_company_id: typing.Optional[int] = OMIT,
        primary_contact_information: typing.Optional[str] = OMIT,
        billing_contact_information: typing.Optional[str] = OMIT,
        employee_count: typing.Optional[int] = OMIT,
        extended_properties: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        modified: typing.Optional[str] = OMIT,
        created: typing.Optional[str] = OMIT,
        code: typing.Optional[str] = OMIT,
        type: typing.Optional[CompanyTypeEnum] = OMIT,
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        is_active: typing.Optional[bool] = OMIT,
        phone_1: typing.Optional[str] = OMIT,
        phone_2: typing.Optional[str] = OMIT,
        post_code: typing.Optional[str] = OMIT,
        address_1: typing.Optional[str] = OMIT,
        address_2: typing.Optional[str] = OMIT,
        country: typing.Optional[str] = OMIT,
        region: typing.Optional[str] = OMIT,
        city: typing.Optional[str] = OMIT,
        company_color: typing.Optional[str] = OMIT,
        logo: typing.Optional[str] = OMIT,
        show_coded_labor_material_only: typing.Optional[bool] = OMIT,
        email: typing.Optional[str] = OMIT,
        default_user_tier: typing.Optional[UserTierEnum] = OMIT,
        system_admin_email: typing.Optional[str] = OMIT,
        primary_contact: typing.Optional[int] = OMIT,
        billing_contact: typing.Optional[int] = OMIT,
        permission_group: typing.Optional[int] = OMIT,
        admin_permission_group: typing.Optional[int] = OMIT,
        read_permission: typing.Optional[int] = OMIT,
        admin_permission: typing.Optional[int] = OMIT,
        denied_permission: typing.Optional[int] = OMIT,
    ) -> Company:
        _request: typing.Dict[str, typing.Any] = {}
        if patched_company_id is not OMIT:
            _request["id"] = patched_company_id
        if primary_contact_information is not OMIT:
            _request["primary_contact_information"] = primary_contact_information
        if billing_contact_information is not OMIT:
            _request["billing_contact_information"] = billing_contact_information
        if employee_count is not OMIT:
            _request["employee_count"] = employee_count
        if extended_properties is not OMIT:
            _request["extended_properties"] = extended_properties
        if modified is not OMIT:
            _request["modified"] = modified
        if created is not OMIT:
            _request["created"] = created
        if code is not OMIT:
            _request["code"] = code
        if type is not OMIT:
            _request["type"] = type
        if name is not OMIT:
            _request["name"] = name
        if description is not OMIT:
            _request["description"] = description
        if is_active is not OMIT:
            _request["is_active"] = is_active
        if phone_1 is not OMIT:
            _request["phone1"] = phone_1
        if phone_2 is not OMIT:
            _request["phone2"] = phone_2
        if post_code is not OMIT:
            _request["post_code"] = post_code
        if address_1 is not OMIT:
            _request["address1"] = address_1
        if address_2 is not OMIT:
            _request["address2"] = address_2
        if country is not OMIT:
            _request["country"] = country
        if region is not OMIT:
            _request["region"] = region
        if city is not OMIT:
            _request["city"] = city
        if company_color is not OMIT:
            _request["company_color"] = company_color
        if logo is not OMIT:
            _request["logo"] = logo
        if show_coded_labor_material_only is not OMIT:
            _request["show_coded_labor_material_only"] = show_coded_labor_material_only
        if email is not OMIT:
            _request["email"] = email
        if default_user_tier is not OMIT:
            _request["default_user_tier"] = default_user_tier
        if system_admin_email is not OMIT:
            _request["system_admin_email"] = system_admin_email
        if primary_contact is not OMIT:
            _request["primary_contact"] = primary_contact
        if billing_contact is not OMIT:
            _request["billing_contact"] = billing_contact
        if permission_group is not OMIT:
            _request["permission_group"] = permission_group
        if admin_permission_group is not OMIT:
            _request["admin_permission_group"] = admin_permission_group
        if read_permission is not OMIT:
            _request["read_permission"] = read_permission
        if admin_permission is not OMIT:
            _request["admin_permission"] = admin_permission
        if denied_permission is not OMIT:
            _request["denied_permission"] = denied_permission
        _response = httpx.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._environment}/", f"api/v1/companies/{id}"),
            json=jsonable_encoder(_request),
            headers=remove_none_from_headers({"Authorization": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Company, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_v_1_companies(self, id: int) -> None:
        _response = httpx.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._environment}/", f"api/v1/companies/{id}"),
            headers=remove_none_from_headers({"Authorization": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_company_logo(self, id: int) -> Company:
        _response = httpx.request(
            "GET",
            urllib.parse.urljoin(f"{self._environment}/", f"api/v1/companies/{id}/download_logo"),
            headers=remove_none_from_headers({"Authorization": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Company, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncGlobalConfigurationClient:
    def __init__(self, *, environment: str, api_key: str):
        self._environment = environment
        self.api_key = api_key

    async def list_v_1_companies(
        self,
        *,
        code: typing.Optional[str] = None,
        fields: typing.Optional[str] = None,
        is_active: typing.Optional[bool] = None,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        ordering: typing.Optional[str] = None,
        search: typing.Optional[str] = None,
        type: typing.Optional[GlobalConfigurationListV1CompaniesRequestType] = None,
        with_no_subcontract: typing.Optional[int] = None,
        with_subcontract_or_epc: typing.Optional[int] = None,
    ) -> PaginatedCompanyList:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "GET",
                urllib.parse.urljoin(f"{self._environment}/", "api/v1/companies"),
                params={
                    "code": code,
                    "fields": fields,
                    "is_active": is_active,
                    "limit": limit,
                    "offset": offset,
                    "ordering": ordering,
                    "search": search,
                    "type": type,
                    "with_no_subcontract": with_no_subcontract,
                    "with_subcontract_or_epc": with_subcontract_or_epc,
                },
                headers=remove_none_from_headers({"Authorization": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PaginatedCompanyList, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_v_1_companies(self, *, request: Company) -> Company:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment}/", "api/v1/companies"),
                json=jsonable_encoder(request),
                headers=remove_none_from_headers({"Authorization": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Company, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_v_1_companies(self, id: int) -> Company:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "GET",
                urllib.parse.urljoin(f"{self._environment}/", f"api/v1/companies/{id}"),
                headers=remove_none_from_headers({"Authorization": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Company, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_v_1_companies(self, id: int, *, request: Company) -> Company:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "PUT",
                urllib.parse.urljoin(f"{self._environment}/", f"api/v1/companies/{id}"),
                json=jsonable_encoder(request),
                headers=remove_none_from_headers({"Authorization": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Company, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def patch_v_1_companies(
        self,
        id: int,
        *,
        patched_company_id: typing.Optional[int] = OMIT,
        primary_contact_information: typing.Optional[str] = OMIT,
        billing_contact_information: typing.Optional[str] = OMIT,
        employee_count: typing.Optional[int] = OMIT,
        extended_properties: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        modified: typing.Optional[str] = OMIT,
        created: typing.Optional[str] = OMIT,
        code: typing.Optional[str] = OMIT,
        type: typing.Optional[CompanyTypeEnum] = OMIT,
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        is_active: typing.Optional[bool] = OMIT,
        phone_1: typing.Optional[str] = OMIT,
        phone_2: typing.Optional[str] = OMIT,
        post_code: typing.Optional[str] = OMIT,
        address_1: typing.Optional[str] = OMIT,
        address_2: typing.Optional[str] = OMIT,
        country: typing.Optional[str] = OMIT,
        region: typing.Optional[str] = OMIT,
        city: typing.Optional[str] = OMIT,
        company_color: typing.Optional[str] = OMIT,
        logo: typing.Optional[str] = OMIT,
        show_coded_labor_material_only: typing.Optional[bool] = OMIT,
        email: typing.Optional[str] = OMIT,
        default_user_tier: typing.Optional[UserTierEnum] = OMIT,
        system_admin_email: typing.Optional[str] = OMIT,
        primary_contact: typing.Optional[int] = OMIT,
        billing_contact: typing.Optional[int] = OMIT,
        permission_group: typing.Optional[int] = OMIT,
        admin_permission_group: typing.Optional[int] = OMIT,
        read_permission: typing.Optional[int] = OMIT,
        admin_permission: typing.Optional[int] = OMIT,
        denied_permission: typing.Optional[int] = OMIT,
    ) -> Company:
        _request: typing.Dict[str, typing.Any] = {}
        if patched_company_id is not OMIT:
            _request["id"] = patched_company_id
        if primary_contact_information is not OMIT:
            _request["primary_contact_information"] = primary_contact_information
        if billing_contact_information is not OMIT:
            _request["billing_contact_information"] = billing_contact_information
        if employee_count is not OMIT:
            _request["employee_count"] = employee_count
        if extended_properties is not OMIT:
            _request["extended_properties"] = extended_properties
        if modified is not OMIT:
            _request["modified"] = modified
        if created is not OMIT:
            _request["created"] = created
        if code is not OMIT:
            _request["code"] = code
        if type is not OMIT:
            _request["type"] = type
        if name is not OMIT:
            _request["name"] = name
        if description is not OMIT:
            _request["description"] = description
        if is_active is not OMIT:
            _request["is_active"] = is_active
        if phone_1 is not OMIT:
            _request["phone1"] = phone_1
        if phone_2 is not OMIT:
            _request["phone2"] = phone_2
        if post_code is not OMIT:
            _request["post_code"] = post_code
        if address_1 is not OMIT:
            _request["address1"] = address_1
        if address_2 is not OMIT:
            _request["address2"] = address_2
        if country is not OMIT:
            _request["country"] = country
        if region is not OMIT:
            _request["region"] = region
        if city is not OMIT:
            _request["city"] = city
        if company_color is not OMIT:
            _request["company_color"] = company_color
        if logo is not OMIT:
            _request["logo"] = logo
        if show_coded_labor_material_only is not OMIT:
            _request["show_coded_labor_material_only"] = show_coded_labor_material_only
        if email is not OMIT:
            _request["email"] = email
        if default_user_tier is not OMIT:
            _request["default_user_tier"] = default_user_tier
        if system_admin_email is not OMIT:
            _request["system_admin_email"] = system_admin_email
        if primary_contact is not OMIT:
            _request["primary_contact"] = primary_contact
        if billing_contact is not OMIT:
            _request["billing_contact"] = billing_contact
        if permission_group is not OMIT:
            _request["permission_group"] = permission_group
        if admin_permission_group is not OMIT:
            _request["admin_permission_group"] = admin_permission_group
        if read_permission is not OMIT:
            _request["read_permission"] = read_permission
        if admin_permission is not OMIT:
            _request["admin_permission"] = admin_permission
        if denied_permission is not OMIT:
            _request["denied_permission"] = denied_permission
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "PATCH",
                urllib.parse.urljoin(f"{self._environment}/", f"api/v1/companies/{id}"),
                json=jsonable_encoder(_request),
                headers=remove_none_from_headers({"Authorization": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Company, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_v_1_companies(self, id: int) -> None:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "DELETE",
                urllib.parse.urljoin(f"{self._environment}/", f"api/v1/companies/{id}"),
                headers=remove_none_from_headers({"Authorization": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_company_logo(self, id: int) -> Company:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "GET",
                urllib.parse.urljoin(f"{self._environment}/", f"api/v1/companies/{id}/download_logo"),
                headers=remove_none_from_headers({"Authorization": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Company, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

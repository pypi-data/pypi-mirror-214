# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

import httpx
import pydantic

from ...core.api_error import ApiError
from ...core.jsonable_encoder import jsonable_encoder
from ...core.remove_none_from_headers import remove_none_from_headers
from ...types.paginated_permission_list import PaginatedPermissionList
from ...types.paginated_role_list import PaginatedRoleList
from ...types.permission import Permission
from ...types.refresh_token import RefreshToken
from ...types.role import Role
from ...types.user_info import UserInfo
from ...types.verify_json_web_token import VerifyJsonWebToken
from ...types.web_token import WebToken

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class AuthClient:
    def __init__(self, *, environment: str, api_key: str):
        self._environment = environment
        self.api_key = api_key

    def list_auth_permissions(
        self,
        *,
        codename: typing.Optional[str] = None,
        group: typing.Union[typing.Optional[int], typing.List[int]],
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        ordering: typing.Optional[str] = None,
        search: typing.Optional[str] = None,
    ) -> PaginatedPermissionList:
        _response = httpx.request(
            "GET",
            urllib.parse.urljoin(f"{self._environment}/", "auth/permissions"),
            params={
                "codename": codename,
                "group": group,
                "limit": limit,
                "offset": offset,
                "ordering": ordering,
                "search": search,
            },
            headers=remove_none_from_headers({"Authorization": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PaginatedPermissionList, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_auth_permissions(self, *, request: Permission) -> Permission:
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment}/", "auth/permissions"),
            json=jsonable_encoder(request),
            headers=remove_none_from_headers({"Authorization": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Permission, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_auth_permissions(self, id: int) -> Permission:
        _response = httpx.request(
            "GET",
            urllib.parse.urljoin(f"{self._environment}/", f"auth/permissions/{id}"),
            headers=remove_none_from_headers({"Authorization": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Permission, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_auth_permissions(self, id: int, *, request: Permission) -> Permission:
        _response = httpx.request(
            "PUT",
            urllib.parse.urljoin(f"{self._environment}/", f"auth/permissions/{id}"),
            json=jsonable_encoder(request),
            headers=remove_none_from_headers({"Authorization": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Permission, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def patch_auth_permissions(
        self,
        id: int,
        *,
        patched_permission_id: typing.Optional[int] = OMIT,
        name: typing.Optional[str] = OMIT,
        codename: typing.Optional[str] = OMIT,
    ) -> Permission:
        _request: typing.Dict[str, typing.Any] = {}
        if patched_permission_id is not OMIT:
            _request["id"] = patched_permission_id
        if name is not OMIT:
            _request["name"] = name
        if codename is not OMIT:
            _request["codename"] = codename
        _response = httpx.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._environment}/", f"auth/permissions/{id}"),
            json=jsonable_encoder(_request),
            headers=remove_none_from_headers({"Authorization": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Permission, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_auth_permissions(self, id: int) -> None:
        _response = httpx.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._environment}/", f"auth/permissions/{id}"),
            headers=remove_none_from_headers({"Authorization": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def list_auth_security_groups(
        self,
        *,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        ordering: typing.Optional[str] = None,
        permissions: typing.Union[typing.Optional[int], typing.List[int]],
        search: typing.Optional[str] = None,
    ) -> PaginatedRoleList:
        _response = httpx.request(
            "GET",
            urllib.parse.urljoin(f"{self._environment}/", "auth/security_groups"),
            params={
                "limit": limit,
                "offset": offset,
                "ordering": ordering,
                "permissions": permissions,
                "search": search,
            },
            headers=remove_none_from_headers({"Authorization": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PaginatedRoleList, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_auth_security_groups(self, *, request: Role) -> Role:
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment}/", "auth/security_groups"),
            json=jsonable_encoder(request),
            headers=remove_none_from_headers({"Authorization": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Role, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_auth_security_groups(self, id: int) -> Role:
        _response = httpx.request(
            "GET",
            urllib.parse.urljoin(f"{self._environment}/", f"auth/security_groups/{id}"),
            headers=remove_none_from_headers({"Authorization": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Role, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_auth_security_groups(self, id: int, *, request: Role) -> Role:
        _response = httpx.request(
            "PUT",
            urllib.parse.urljoin(f"{self._environment}/", f"auth/security_groups/{id}"),
            json=jsonable_encoder(request),
            headers=remove_none_from_headers({"Authorization": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Role, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def patch_auth_security_groups(
        self,
        id: int,
        *,
        patched_role_id: typing.Optional[int] = OMIT,
        name: typing.Optional[str] = OMIT,
        permissions: typing.Optional[typing.List[int]] = OMIT,
    ) -> Role:
        _request: typing.Dict[str, typing.Any] = {}
        if patched_role_id is not OMIT:
            _request["id"] = patched_role_id
        if name is not OMIT:
            _request["name"] = name
        if permissions is not OMIT:
            _request["permissions"] = permissions
        _response = httpx.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._environment}/", f"auth/security_groups/{id}"),
            json=jsonable_encoder(_request),
            headers=remove_none_from_headers({"Authorization": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Role, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_auth_security_groups(self, id: int) -> None:
        _response = httpx.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._environment}/", f"auth/security_groups/{id}"),
            headers=remove_none_from_headers({"Authorization": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def obtain_token(self, *, request: WebToken) -> WebToken:
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment}/", "auth/token/obtain"),
            json=jsonable_encoder(request),
            headers=remove_none_from_headers({"Authorization": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(WebToken, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def refresh_token(self, *, request: RefreshToken) -> RefreshToken:
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment}/", "auth/token/refresh"),
            json=jsonable_encoder(request),
            headers=remove_none_from_headers({"Authorization": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(RefreshToken, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def verify_token(self, *, request: VerifyJsonWebToken) -> VerifyJsonWebToken:
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment}/", "auth/token/verify"),
            json=jsonable_encoder(request),
            headers=remove_none_from_headers({"Authorization": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(VerifyJsonWebToken, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def user_info(self) -> UserInfo:
        _response = httpx.request(
            "GET",
            urllib.parse.urljoin(f"{self._environment}/", "auth/user_info"),
            headers=remove_none_from_headers({"Authorization": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UserInfo, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncAuthClient:
    def __init__(self, *, environment: str, api_key: str):
        self._environment = environment
        self.api_key = api_key

    async def list_auth_permissions(
        self,
        *,
        codename: typing.Optional[str] = None,
        group: typing.Union[typing.Optional[int], typing.List[int]],
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        ordering: typing.Optional[str] = None,
        search: typing.Optional[str] = None,
    ) -> PaginatedPermissionList:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "GET",
                urllib.parse.urljoin(f"{self._environment}/", "auth/permissions"),
                params={
                    "codename": codename,
                    "group": group,
                    "limit": limit,
                    "offset": offset,
                    "ordering": ordering,
                    "search": search,
                },
                headers=remove_none_from_headers({"Authorization": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PaginatedPermissionList, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_auth_permissions(self, *, request: Permission) -> Permission:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment}/", "auth/permissions"),
                json=jsonable_encoder(request),
                headers=remove_none_from_headers({"Authorization": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Permission, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_auth_permissions(self, id: int) -> Permission:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "GET",
                urllib.parse.urljoin(f"{self._environment}/", f"auth/permissions/{id}"),
                headers=remove_none_from_headers({"Authorization": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Permission, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_auth_permissions(self, id: int, *, request: Permission) -> Permission:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "PUT",
                urllib.parse.urljoin(f"{self._environment}/", f"auth/permissions/{id}"),
                json=jsonable_encoder(request),
                headers=remove_none_from_headers({"Authorization": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Permission, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def patch_auth_permissions(
        self,
        id: int,
        *,
        patched_permission_id: typing.Optional[int] = OMIT,
        name: typing.Optional[str] = OMIT,
        codename: typing.Optional[str] = OMIT,
    ) -> Permission:
        _request: typing.Dict[str, typing.Any] = {}
        if patched_permission_id is not OMIT:
            _request["id"] = patched_permission_id
        if name is not OMIT:
            _request["name"] = name
        if codename is not OMIT:
            _request["codename"] = codename
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "PATCH",
                urllib.parse.urljoin(f"{self._environment}/", f"auth/permissions/{id}"),
                json=jsonable_encoder(_request),
                headers=remove_none_from_headers({"Authorization": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Permission, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_auth_permissions(self, id: int) -> None:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "DELETE",
                urllib.parse.urljoin(f"{self._environment}/", f"auth/permissions/{id}"),
                headers=remove_none_from_headers({"Authorization": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def list_auth_security_groups(
        self,
        *,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        ordering: typing.Optional[str] = None,
        permissions: typing.Union[typing.Optional[int], typing.List[int]],
        search: typing.Optional[str] = None,
    ) -> PaginatedRoleList:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "GET",
                urllib.parse.urljoin(f"{self._environment}/", "auth/security_groups"),
                params={
                    "limit": limit,
                    "offset": offset,
                    "ordering": ordering,
                    "permissions": permissions,
                    "search": search,
                },
                headers=remove_none_from_headers({"Authorization": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PaginatedRoleList, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_auth_security_groups(self, *, request: Role) -> Role:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment}/", "auth/security_groups"),
                json=jsonable_encoder(request),
                headers=remove_none_from_headers({"Authorization": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Role, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_auth_security_groups(self, id: int) -> Role:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "GET",
                urllib.parse.urljoin(f"{self._environment}/", f"auth/security_groups/{id}"),
                headers=remove_none_from_headers({"Authorization": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Role, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_auth_security_groups(self, id: int, *, request: Role) -> Role:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "PUT",
                urllib.parse.urljoin(f"{self._environment}/", f"auth/security_groups/{id}"),
                json=jsonable_encoder(request),
                headers=remove_none_from_headers({"Authorization": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Role, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def patch_auth_security_groups(
        self,
        id: int,
        *,
        patched_role_id: typing.Optional[int] = OMIT,
        name: typing.Optional[str] = OMIT,
        permissions: typing.Optional[typing.List[int]] = OMIT,
    ) -> Role:
        _request: typing.Dict[str, typing.Any] = {}
        if patched_role_id is not OMIT:
            _request["id"] = patched_role_id
        if name is not OMIT:
            _request["name"] = name
        if permissions is not OMIT:
            _request["permissions"] = permissions
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "PATCH",
                urllib.parse.urljoin(f"{self._environment}/", f"auth/security_groups/{id}"),
                json=jsonable_encoder(_request),
                headers=remove_none_from_headers({"Authorization": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Role, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_auth_security_groups(self, id: int) -> None:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "DELETE",
                urllib.parse.urljoin(f"{self._environment}/", f"auth/security_groups/{id}"),
                headers=remove_none_from_headers({"Authorization": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def obtain_token(self, *, request: WebToken) -> WebToken:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment}/", "auth/token/obtain"),
                json=jsonable_encoder(request),
                headers=remove_none_from_headers({"Authorization": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(WebToken, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def refresh_token(self, *, request: RefreshToken) -> RefreshToken:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment}/", "auth/token/refresh"),
                json=jsonable_encoder(request),
                headers=remove_none_from_headers({"Authorization": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(RefreshToken, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def verify_token(self, *, request: VerifyJsonWebToken) -> VerifyJsonWebToken:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment}/", "auth/token/verify"),
                json=jsonable_encoder(request),
                headers=remove_none_from_headers({"Authorization": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(VerifyJsonWebToken, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def user_info(self) -> UserInfo:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "GET",
                urllib.parse.urljoin(f"{self._environment}/", "auth/user_info"),
                headers=remove_none_from_headers({"Authorization": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UserInfo, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

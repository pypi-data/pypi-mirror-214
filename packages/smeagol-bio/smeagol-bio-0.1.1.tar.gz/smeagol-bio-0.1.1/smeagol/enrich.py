# General imports
import numpy as np
import pandas as pd

# Stats imports
import scipy.stats as stats
import statsmodels.stats.multitest as multitest

# Smeagol imports
from .utils import shuffle_records, read_bg_seqs
from .scan import (
    scan_sequences,
    get_tiling_windows_over_genome,
    _count_in_window,
)


def _enrich_over_shuffled(real_counts, shuf_stats, background="binomial",
                          records=None):
    """Function to test for enrichment of binding sites in real vs.
    shuffled genomes

    Args:
        real_counts (pd.DataFrame): counts of binding sites in real genome
        shuf_stats (pd.DataFrame): statistics for binding sites across multiple
        shuffled genomes
        background (str): 'binomial' or 'normal'
        records (SeqGroups): SeqGroups object. Only needed if
                             background='binomial'

    Returns:
        enr_full (pd.DataFrame): dataframe containing FDR-corrected p-values
        for enrichment of each PWM.

    """
    # Compare counts on real and shuffled genomes for each PWM
    if "name" in shuf_stats.columns:
        enr = real_counts.merge(
            shuf_stats, on=["Matrix_id", "width", "sense", "name"], how="outer"
        )
    else:
        enr = real_counts.merge(
            shuf_stats, on=["Matrix_id", "width", "sense"], how="outer"
        )

    # If 0 sites are present in real genome, include the entry
    enr["num"] = enr["num"].fillna(0)

    # If 0 sites are present in shuffled genomes, set a minimum of 1 site
    num_shuf = enr["len"][0]
    enr.loc[enr.avg == 0, "avg"] = 1 / num_shuf

    # Calculate normal z-score
    if (background == "normal") or (background == "both"):
        enr.loc[enr.avg == 0, "sd"] = np.std([1] + [0] * (num_shuf - 1))
        enr["z"] = (enr.num - enr.avg) / enr.sd
        enr["z"] = enr.z.replace([-np.inf], -10)

    # Calculate p-value
    if background == "normal":
        enr["pnorm"] = stats.norm.sf(abs(enr.z)) * 2
    else:
        enr["adj_len"] = sum([
            len(record) - enr.width + 1 for record in records])
        enr["p"] = enr.apply(
            lambda x: stats.binom_test(
                x["num"], x["adj_len"], x["avg"] / x["adj_len"],
                alternative="two-sided"
            ),
            axis=1,
        )
    enr_full = pd.DataFrame()

    # FDR correction per sense
    for sense in pd.unique(enr.sense):
        enr_x = enr[enr.sense == sense].copy()
        if background == "normal":
            enr_x["fdr_norm"] = multitest.fdrcorrection(enr_x.pnorm)[1]
        else:
            enr_x["fdr"] = multitest.fdrcorrection(enr_x.p)[1]
        enr_full = pd.concat([enr_full, enr_x])

    # Sort and index final results
    if background == "normal":
        enr_full.sort_values(["sense", "fdr_binom"], inplace=True)
    else:
        enr_full.sort_values(["sense", "fdr"], inplace=True)
    enr_full.reset_index(inplace=True, drop=True)

    return enr_full


def enrich_in_genome(
    records,
    model,
    rcomp,
    threshold,
    simN=1000,
    simK=2,
    sense="+",
    background="binomial",
    verbose=False,
    combine_seqs=True,
    seq_batch=0,
    shuf_seqs=None,
):
    """Function to calculate enrichment of motifs in given sequence(s)
    relative to a background. The background sequences can be supplied
    directly or generated by shuffling the given sequence(s).

    Args:
        records (list): A list of seqrecord objects containing the
                        sequence(s) to test. This list can be generated
                        by reading a fasta file using 'smeagol.io.read_fasta'.
        model (PWMModel): An object of class PWMModel for PWM scanning
        rcomp (str): 'only' to encode the reverse complements of the given
                     sequences, 'both' to encode the reverse complements
                     as well as the given sequences, or 'none' to use only
                     the given sequences without reverse complementing.
        threshold (float): Threshold motif match score to use for PWM
                           scanning. A sub-sequence that has a PWM match
                           score higher than this will be counted as a match.
        simN (int): The number of shuffled sequences to generate for the
                    background model.
        simK (int): The k-mer frequency to conserve while shuffling
        sense (str): Sense of the given sequences. Must be '+' or '-'
        background (str): Background model for calculating p-values.
                          Must be 'binomial' or 'normal'
        combine_seqs (bool): If true, combine outputs for all supplied
                             sequences into a single output dataframe
        seq_batch (int): The number of shuffled sequences to scan at
                         a time. If 0, scan all at once.
        shuf_seqs (str/list): A path to FASTA file or list of seqrecord
                              objects containing shuffled sequences. Use if
                              loading the background sequences directly
                              instead of generating them by shuffling.

    Returns:
        results (dict): dictionary containing results. Contains the following
                        keys: 'enrichment' (enrichment statistics),
                        'real_sites' (locations of motif matches on the given
                        sequences), 'real_counts' (number of sites for each
                        PWM on the given sequences), 'shuf_counts' (number of
                        sites for each PWM on the background sequences),
                        'shuf_stats' (mean and standard deviation of the
                        number of sites for each PWM on the background
                        sequences).

    """
    # Find sites on real genome
    real_preds = scan_sequences(
        records,
        model,
        threshold,
        sense,
        rcomp,
        outputs=["sites", "counts"],
        score=False,
        combine_seqs=combine_seqs,
    )

    # Shuffle genome
    if shuf_seqs is not None:
        if type(shuf_seqs) == str:
            shuf = read_bg_seqs(shuf_seqs, records, simN)
        elif type(shuf_seqs) == list:
            shuf = shuf_seqs
    else:
        shuf = shuffle_records(records, simN, simK)

    # Count sites on shuffled genomes
    shuf_preds = scan_sequences(
        shuf,
        model,
        threshold,
        sense,
        rcomp,
        outputs=["counts", "stats"],
        group_by="name",
        combine_seqs=combine_seqs,
        sep_ids=True,
        seq_batch=seq_batch,
    )

    # Calculate binding site enrichment
    enr = _enrich_over_shuffled(
        real_preds["counts"],
        shuf_preds["stats"],
        background=background,
        records=records,
    )

    # Combine results
    results = {
        "enrichment": enr,
        "real_sites": real_preds["sites"],
        "real_counts": real_preds["counts"],
        "shuf_counts": shuf_preds["counts"],
        "shuf_stats": shuf_preds["stats"],
    }
    if verbose:
        results["shuf_seqs"] = shuf
    return results


def examine_thresholds(
    records,
    model,
    simN=300,
    simK=2,
    rcomp="only",
    min_threshold=0.5,
    threshold_shift=0.1,
    sense="+",
    verbose=False,
    combine_seqs=True,
):
    """Function to scan given sequence(s) with PWMs and calculate the
    number of binding sites predicted using different cutoffs for the
    match score, for the real sequence as well as shuffled sequences.

    Args:
        records (list): A list of seqrecord objects containing the sequence(s)
                        to scan.
        model (PWMModel): An object of class PWMModel for PWM scanning
        simN (int): The number of shuffled sequences to generate for the
                    background model. Default is 300.
        simK (int): The k-mer frequency to conserve while shuffling. Default
                    is 2.
        rcomp (str): 'only' to encode the sequence reverse complements,
                     'both' to encode the reverse complements as well as
                     original sequences, or 'none'. Default is 'only'.
        min_threshold (float): Minimum threshold motif match score to use for
                               PWM scanning. Default is 0.5.
        threshold_shift (float): Difference between successive thresholds to
                                 compare. Default is 0.1.
        sense (str): Sense of the given sequences. Must be '+' or '-'. Default
                     is '+'.
        verbose (bool): If true, output all information
        combine_seqs (bool): If true, combine outputs for all supplied
                             sequences into a single output dataframe

    Returns:
        results (dict): dictionary containing results. Contains the following
                        keys: 'real_binned' (Number of motif matches for each
                        PWM in the given sequences, binned by their match
                        score), 'shuf_binned' (Number of motif matches for
                        each PWM in the background sequences, binned by their
                        match score)
    """
    # Generate a sequence of thresholds to test
    thresholds = np.arange(min_threshold, 1.0, threshold_shift)

    # scan real sequence
    real_binned = scan_sequences(
        records,
        model,
        thresholds,
        sense,
        rcomp,
        outputs=["binned_counts"],
        combine_seqs=combine_seqs,
    )["binned_counts"]

    # shuffle
    shuf = shuffle_records(records, simN, simK)

    # scan shuffled sequence
    shuf_binned = scan_sequences(
        shuf,
        model,
        thresholds,
        sense,
        rcomp,
        outputs=["binned_counts"],
        combine_seqs=combine_seqs,
        group_by="name",
        sep_ids=True,
    )["binned_counts"]

    results = {"real_binned": real_binned, "shuf_binned": shuf_binned}
    if verbose:
        results["shuf_seqs"] = shuf
    return results


def enrich_in_window(window, sites, genome, matrix_id=None,
                     alternative="two-sided"):
    """Function to test for enrichment of motifs in a subsequence
    relative to a complete sequence. This function uses Fisher's exact test.

    Args:
        window (pd.DataFrame): A Pandas dataframe with the following
                               columns: id (sequence ID), start, end
        sites (pd.DataFrame): A pandas dataframe containing the locations
                              of motifs in the genome. Should contain columns
                              id (sequence ID, start, end.
        genome (list): A list of SeqRecord objects
        matrix_id (str): Optional. The ID of the selected PWM. If supplied,
                         it must correspond to an entry in the column
                         'Matrix_id' of `sites`.
        alternative (str): Defines the alternative hypothesis. Options are
                          'two-sided', 'less' or 'greater'. Default is
                          ‘two-sided'.

    Returns:
        result (pd.DataFrame): Pandas dataframe containing the result of
                               enrichment analysis in selected window.

    """
    result = window.copy()
    # Get sites for required matrix
    if matrix_id is not None:
        matrix_sites = sites[
            sites.Matrix_id == matrix_id].reset_index(drop=True)
    # Get matrix width
    width = matrix_sites.width[0]
    # Correct window length and genome length
    effective_window_len = window.end - window.start - width + 1
    effective_genome_len = sum([len(x) for x in genome]) - width + 1
    # Calculate the number of successes and failures in selected region
    result["len"] = effective_window_len
    result["count"] = _count_in_window(window, sites, matrix_id)
    count_neg = result["len"] - result["count"]
    # Calculate the number of successes and failures in whole genome
    result["tot_count"] = len(matrix_sites)
    tot_neg = effective_genome_len - result.tot_count
    # Expected value
    result["expected"] = (result.tot_count * result.len) / effective_genome_len
    # Fisher's exact test
    odds, p = stats.fisher_exact(
        [[result["count"], count_neg], [result.tot_count, tot_neg]],
        alternative=alternative,
    )
    result["odds"] = odds
    result["p"] = p
    return result


def enrich_in_sliding_windows(
    sites, genome, width, shift=None, matrix_id=None, alternative="two-sided"
):
    """Function to test for enrichment of motifs in sliding windows
    across a genome.

    Args:
        sites (pd.DataFrame): A pandas dataframe containing the locations
                              of motifs in the genome. Should contain columns
                              `id` (the sequence ID), `start` and `end`.
        genome (list): A list of SeqRecord objects.
        width (int): The width (in bases) of tiling windows to test.
        shift (int): The shift (in bases) between successive windows. If not
                     supplied, non-overlapping windows are generated.
        matrix_id (str): Optional. The ID of the PWM to test. If supplied, it
                         should correspond to an entry in the column
                         `Matrix_id` of `sites`.
        alternative (str): Defines the alternative hypothesis. Options are
                          'two-sided', 'less' or 'greater'. Default is
                          ‘two-sided'.

    Returns:
        A Pandas DataFrame containing the results of enrichment analysis in
        windows covering all sequences in genome

    """
    # Get sliding windows across genome
    windows = get_tiling_windows_over_genome(genome, width, shift)
    # Perform enrichment in each window
    windows = windows.apply(
        enrich_in_window, axis=1, args=(sites, genome, matrix_id, alternative)
    ).reset_index(drop=True)
    # Overall FDR correction
    windows["padj"] = multitest.fdrcorrection(windows.p)[1]
    return windows

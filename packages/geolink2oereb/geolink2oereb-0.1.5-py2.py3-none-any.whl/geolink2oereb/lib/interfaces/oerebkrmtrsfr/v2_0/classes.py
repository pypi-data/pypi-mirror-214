#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Tue May  2 18:48:20 2023 by generateDS.py version 2.41.4.
# Python 3.10.10 (main, Mar  5 2023, 22:26:53) [GCC 12.2.1 20230201]
#
# Command line options:
#   ('-o', 'classes.py')
#   ('--create-mandatory-children', '')
#   ('--member-specs', 'dict')
#
# Command line arguments:
#   /home/kalle/projects/rudert-geoinformatik/openoereb/mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd
#
# Command line:
#   /home/kalle/.local/bin/generateDS -o "classes.py" --create-mandatory-children --member-specs="dict" /home/kalle/projects/rudert-geoinformatik/openoereb/mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd
#
# Current working directory (os.getcwd()):
#   2_0
#

import sys

try:
    ModulenotfoundExp_ = ModuleNotFoundError
except NameError:
    ModulenotfoundExp_ = ImportError
from six.moves import zip_longest
import os
import re as re_
import base64
import datetime as datetime_
import decimal as decimal_
from lxml import etree as etree_


Validate_simpletypes_ = True
SaveElementTreeNode = True
TagNamePrefix = ""
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    try:
        if isinstance(infile, os.PathLike):
            infile = os.path.join(infile)
    except AttributeError:
        pass
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc


def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element


#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for an example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#
# Additionally, the generatedsnamespaces module can contain a python
# dictionary named GenerateDSNamespaceTypePrefixes that associates element
# types with the namespace prefixes that are to be added to the
# "xsi:type" attribute value.  See the _exportAttributes method of
# any generated element type and the generation of "xsi:type" for an
# example of the use of this table.
# An example table:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceTypePrefixes = {
#         "ElementtypeC": "aaa:",
#         "ElementtypeD": "bbb:",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ModulenotfoundExp_:
    GenerateDSNamespaceDefs_ = {}
try:
    from generatedsnamespaces import (
        GenerateDSNamespaceTypePrefixes as GenerateDSNamespaceTypePrefixes_,
    )
except ModulenotfoundExp_:
    GenerateDSNamespaceTypePrefixes_ = {}

#
# You can replace the following class definition by defining an
# importable module named "generatedscollector" containing a class
# named "GdsCollector".  See the default class definition below for
# clues about the possible content of that class.
#
try:
    from generatedscollector import GdsCollector as GdsCollector_
except ModulenotfoundExp_:

    class GdsCollector_(object):
        def __init__(self, messages=None):
            if messages is None:
                self.messages = []
            else:
                self.messages = messages

        def add_message(self, msg):
            self.messages.append(msg)

        def get_messages(self):
            return self.messages

        def clear_messages(self):
            self.messages = []

        def print_messages(self):
            for msg in self.messages:
                print("Warning: {}".format(msg))

        def write_messages(self, outstream):
            for msg in self.messages:
                outstream.write("Warning: {}\n".format(msg))


#
# The super-class for enum types
#

try:
    from enum import Enum
except ModulenotfoundExp_:
    Enum = object

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ModulenotfoundExp_ as exp:
    try:
        from generatedssupersuper import GeneratedsSuperSuper
    except ModulenotfoundExp_ as exp:

        class GeneratedsSuperSuper(object):
            pass

    class GeneratedsSuper(GeneratedsSuperSuper):
        __hash__ = object.__hash__
        tzoff_pattern = re_.compile(r"(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$")

        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name

            def utcoffset(self, dt):
                return self.__offset

            def tzname(self, dt):
                return self.__name

            def dst(self, dt):
                return None

        def __str__(self):
            settings = {
                "str_pretty_print": True,
                "str_indent_level": 0,
                "str_namespaceprefix": "",
                "str_name": self.__class__.__name__,
                "str_namespacedefs": "",
            }
            for n in settings:
                if hasattr(self, n):
                    settings[n] = getattr(self, n)
            if sys.version_info.major == 2:
                from StringIO import StringIO
            else:
                from io import StringIO
            output = StringIO()
            self.export(
                output,
                settings["str_indent_level"],
                pretty_print=settings["str_pretty_print"],
                namespaceprefix_=settings["str_namespaceprefix"],
                name_=settings["str_name"],
                namespacedef_=settings["str_namespacedefs"],
            )
            strval = output.getvalue()
            output.close()
            return strval

        def gds_format_string(self, input_data, input_name=""):
            return input_data

        def gds_parse_string(self, input_data, node=None, input_name=""):
            return input_data

        def gds_validate_string(self, input_data, node=None, input_name=""):
            if not input_data:
                return ""
            else:
                return input_data

        def gds_format_base64(self, input_data, input_name=""):
            return base64.b64encode(input_data).decode("ascii")

        def gds_validate_base64(self, input_data, node=None, input_name=""):
            return input_data

        def gds_format_integer(self, input_data, input_name=""):
            return "%d" % int(input_data)

        def gds_parse_integer(self, input_data, node=None, input_name=""):
            try:
                ival = int(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, "Requires integer value: %s" % exp)
            return ival

        def gds_validate_integer(self, input_data, node=None, input_name=""):
            try:
                value = int(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, "Requires integer value")
            return value

        def gds_format_integer_list(self, input_data, input_name=""):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return "%s" % " ".join(input_data)

        def gds_validate_integer_list(self, input_data, node=None, input_name=""):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, "Requires sequence of integer values")
            return values

        def gds_format_float(self, input_data, input_name=""):
            value = ("%.15f" % float(input_data)).rstrip("0")
            if value.endswith("."):
                value += "0"
            return value

        def gds_parse_float(self, input_data, node=None, input_name=""):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, "Requires float or double value: %s" % exp)
            return fval_

        def gds_validate_float(self, input_data, node=None, input_name=""):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, "Requires float value")
            return value

        def gds_format_float_list(self, input_data, input_name=""):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return "%s" % " ".join(input_data)

        def gds_validate_float_list(self, input_data, node=None, input_name=""):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, "Requires sequence of float values")
            return values

        def gds_format_decimal(self, input_data, input_name=""):
            return_value = "%s" % input_data
            if "." in return_value:
                return_value = return_value.rstrip("0")
                if return_value.endswith("."):
                    return_value = return_value.rstrip(".")
            return return_value

        def gds_parse_decimal(self, input_data, node=None, input_name=""):
            try:
                decimal_value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, "Requires decimal value")
            return decimal_value

        def gds_validate_decimal(self, input_data, node=None, input_name=""):
            try:
                value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, "Requires decimal value")
            return value

        def gds_format_decimal_list(self, input_data, input_name=""):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return " ".join([self.gds_format_decimal(item) for item in input_data])

        def gds_validate_decimal_list(self, input_data, node=None, input_name=""):
            values = input_data.split()
            for value in values:
                try:
                    decimal_.Decimal(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, "Requires sequence of decimal values")
            return values

        def gds_format_double(self, input_data, input_name=""):
            return "%s" % input_data

        def gds_parse_double(self, input_data, node=None, input_name=""):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, "Requires double or float value: %s" % exp)
            return fval_

        def gds_validate_double(self, input_data, node=None, input_name=""):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, "Requires double or float value")
            return value

        def gds_format_double_list(self, input_data, input_name=""):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return "%s" % " ".join(input_data)

        def gds_validate_double_list(self, input_data, node=None, input_name=""):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, "Requires sequence of double or float values")
            return values

        def gds_format_boolean(self, input_data, input_name=""):
            return ("%s" % input_data).lower()

        def gds_parse_boolean(self, input_data, node=None, input_name=""):
            input_data = input_data.strip()
            if input_data in ("true", "1"):
                bval = True
            elif input_data in ("false", "0"):
                bval = False
            else:
                raise_parse_error(node, "Requires boolean value")
            return bval

        def gds_validate_boolean(self, input_data, node=None, input_name=""):
            if input_data not in (
                True,
                1,
                False,
                0,
            ):
                raise_parse_error(node, "Requires boolean value " "(one of True, 1, False, 0)")
            return input_data

        def gds_format_boolean_list(self, input_data, input_name=""):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return "%s" % " ".join(input_data)

        def gds_validate_boolean_list(self, input_data, node=None, input_name=""):
            values = input_data.split()
            for value in values:
                value = self.gds_parse_boolean(value, node, input_name)
                if value not in (
                    True,
                    1,
                    False,
                    0,
                ):
                    raise_parse_error(
                        node,
                        "Requires sequence of boolean values " "(one of True, 1, False, 0)",
                    )
            return values

        def gds_validate_datetime(self, input_data, node=None, input_name=""):
            return input_data

        def gds_format_datetime(self, input_data, input_name=""):
            if input_data.microsecond == 0:
                _svalue = "%04d-%02d-%02dT%02d:%02d:%02d" % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = "%04d-%02d-%02dT%02d:%02d:%02d.%s" % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ("%f" % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += "Z"
                    else:
                        if total_seconds < 0:
                            _svalue += "-"
                            total_seconds *= -1
                        else:
                            _svalue += "+"
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += "{0:02d}:{1:02d}".format(hours, minutes)
            return _svalue

        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == "Z":
                tz = GeneratedsSuper._FixedOffsetTZ(0, "UTC")
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(":")
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == "-":
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split(".")
            if len(time_parts) > 1:
                micro_seconds = int(float("0." + time_parts[1]) * 1000000)
                input_data = "%s.%s" % (
                    time_parts[0],
                    "{}".format(micro_seconds).rjust(6, "0"),
                )
                dt = datetime_.datetime.strptime(input_data, "%Y-%m-%dT%H:%M:%S.%f")
            else:
                dt = datetime_.datetime.strptime(input_data, "%Y-%m-%dT%H:%M:%S")
            dt = dt.replace(tzinfo=tz)
            return dt

        def gds_validate_date(self, input_data, node=None, input_name=""):
            return input_data

        def gds_format_date(self, input_data, input_name=""):
            _svalue = "%04d-%02d-%02d" % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += "Z"
                        else:
                            if total_seconds < 0:
                                _svalue += "-"
                                total_seconds *= -1
                            else:
                                _svalue += "+"
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += "{0:02d}:{1:02d}".format(hours, minutes)
            except AttributeError:
                pass
            return _svalue

        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == "Z":
                tz = GeneratedsSuper._FixedOffsetTZ(0, "UTC")
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(":")
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == "-":
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, "%Y-%m-%d")
            dt = dt.replace(tzinfo=tz)
            return dt.date()

        def gds_validate_time(self, input_data, node=None, input_name=""):
            return input_data

        def gds_format_time(self, input_data, input_name=""):
            if input_data.microsecond == 0:
                _svalue = "%02d:%02d:%02d" % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = "%02d:%02d:%02d.%s" % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ("%f" % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += "Z"
                    else:
                        if total_seconds < 0:
                            _svalue += "-"
                            total_seconds *= -1
                        else:
                            _svalue += "+"
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += "{0:02d}:{1:02d}".format(hours, minutes)
            return _svalue

        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            target = str(target)
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1

        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == "Z":
                tz = GeneratedsSuper._FixedOffsetTZ(0, "UTC")
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(":")
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == "-":
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split(".")) > 1:
                dt = datetime_.datetime.strptime(input_data, "%H:%M:%S.%f")
            else:
                dt = datetime_.datetime.strptime(input_data, "%H:%M:%S")
            dt = dt.replace(tzinfo=tz)
            return dt.time()

        def gds_check_cardinality_(self, value, input_name, min_occurs=0, max_occurs=1, required=None):
            if value is None:
                length = 0
            elif isinstance(value, list):
                length = len(value)
            else:
                length = 1
            if required is not None:
                if required and length < 1:
                    self.gds_collector_.add_message(
                        "Required value {}{} is missing".format(input_name, self.gds_get_node_lineno_())
                    )
            if length < min_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is below "
                    "the minimum allowed, "
                    "expected at least {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(), min_occurs, length
                    )
                )
            elif length > max_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is above "
                    "the maximum allowed, "
                    "expected at most {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(), max_occurs, length
                    )
                )

        def gds_validate_builtin_ST_(
            self,
            validator,
            value,
            input_name,
            min_occurs=None,
            max_occurs=None,
            required=None,
        ):
            if value is not None:
                try:
                    validator(value, input_name=input_name)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))

        def gds_validate_defined_ST_(
            self,
            validator,
            value,
            input_name,
            min_occurs=None,
            max_occurs=None,
            required=None,
        ):
            if value is not None:
                try:
                    validator(value)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))

        def gds_str_lower(self, instring):
            return instring.lower()

        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = "/".join(path_list)
            return path

        Tag_strip_pattern_ = re_.compile(r"\{.*\}")

        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub("", node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)

        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if "xsi" in node.nsmap:
                classname = node.get("{%s}type" % node.nsmap["xsi"])
                if classname is not None:
                    names = classname.split(":")
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1

        def gds_build_any(self, node, type_name=None):
            # provide default value in case option --disable-xml is used.
            content = ""
            content = etree_.tostring(node, encoding="unicode")
            return content

        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))

        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = "utf-8"
                return instring.encode(encoding)
            else:
                return instring

        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode("utf8")
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result

        def __eq__(self, other):
            def excl_select_objs_(obj):
                return obj[0] != "parent_object_" and obj[0] != "gds_collector_"

            if type(self) != type(other):
                return False
            return all(
                x == y
                for x, y in zip_longest(
                    filter(excl_select_objs_, self.__dict__.items()),
                    filter(excl_select_objs_, other.__dict__.items()),
                )
            )

        def __ne__(self, other):
            return not self.__eq__(other)

        # Django ETL transform hooks.
        def gds_djo_etl_transform(self):
            pass

        def gds_djo_etl_transform_db_obj(self, dbobj):
            pass

        # SQLAlchemy ETL transform hooks.
        def gds_sqa_etl_transform(self):
            return 0, None

        def gds_sqa_etl_transform_db_obj(self, dbobj):
            pass

        def gds_get_node_lineno_(self):
            if hasattr(self, "gds_elementtree_node_") and self.gds_elementtree_node_ is not None:
                return " near line {}".format(self.gds_elementtree_node_.sourceline)
            else:
                return ""

    def getSubclassFromModule_(module, class_):
        """Get the subclass of a class from a specific module."""
        name = class_.__name__ + "Sub"
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ""
# Set this to false in order to deactivate during export, the use of
# name space prefixes captured from the input document.
UseCapturedNS_ = True
CapturedNsmap_ = {}
Tag_pattern_ = re_.compile(r"({.*})?(.*)")
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r"{(.*)}(.*)")
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write("    ")


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ""
    s1 = isinstance(inStr, BaseStrType_) and inStr or "%s" % inStr
    s2 = ""
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos : mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start() : mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace("&", "&amp;")
    s1 = s1.replace("<", "&lt;")
    s1 = s1.replace(">", "&gt;")
    return s1


def quote_attrib(inStr):
    s1 = isinstance(inStr, BaseStrType_) and inStr or "%s" % inStr
    s1 = s1.replace("&", "&amp;")
    s1 = s1.replace("<", "&lt;")
    s1 = s1.replace(">", "&gt;")
    s1 = s1.replace("\n", "&#10;")
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find("\n") == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find("\n") == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ""
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(":")
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        if prefix == "xml":
            namespace = "http://www.w3.org/XML/1998/namespace"
        else:
            namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get(
                "{%s}%s"
                % (
                    namespace,
                    name,
                )
            )
    return value


def encode_str_2_3(instr):
    return instr


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if node is not None:
        msg = "%s (element %s/line %d)" % (
            msg,
            node.tag,
            node.sourceline,
        )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8

    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value

    def getCategory(self):
        return self.category

    def getContenttype(self, content_type):
        return self.content_type

    def getValue(self):
        return self.value

    def getName(self):
        return self.name

    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:  # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name_=name, pretty_print=pretty_print)

    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write("<%s>%s</%s>" % (self.name, self.value, self.name))
        elif (
            self.content_type == MixedContainer.TypeInteger or self.content_type == MixedContainer.TypeBoolean
        ):
            outfile.write("<%s>%d</%s>" % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or self.content_type == MixedContainer.TypeDecimal:
            outfile.write("<%s>%f</%s>" % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write("<%s>%g</%s>" % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write("<%s>%s</%s>" % (self.name, base64.b64encode(self.value), self.name))

    def to_etree(self, element, mapping_=None, reverse_mapping_=None, nsmap_=None):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, "%s" % self.name)
            subelement.text = self.to_etree_simple()
        else:  # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)

    def to_etree_simple(self, mapping_=None, reverse_mapping_=None, nsmap_=None):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (
            self.content_type == MixedContainer.TypeInteger or self.content_type == MixedContainer.TypeBoolean
        ):
            text = "%d" % self.value
        elif self.content_type == MixedContainer.TypeFloat or self.content_type == MixedContainer.TypeDecimal:
            text = "%f" % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = "%g" % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = "%s" % base64.b64encode(self.value)
        return text

    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n'
                % (self.category, self.content_type, self.name, self.value)
            )
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n'
                % (self.category, self.content_type, self.name, self.value)
            )
        else:  # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n'
                % (
                    self.category,
                    self.content_type,
                    self.name,
                )
            )
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(")\n")


class MemberSpec_(object):
    def __init__(
        self,
        name="",
        data_type="",
        container=0,
        optional=0,
        child_attrs=None,
        choice=None,
    ):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional

    def set_name(self, name):
        self.name = name

    def get_name(self):
        return self.name

    def set_data_type(self, data_type):
        self.data_type = data_type

    def get_data_type_chain(self):
        return self.data_type

    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return "xs:string"
        else:
            return self.data_type

    def set_container(self, container):
        self.container = container

    def get_container(self):
        return self.container

    def set_child_attrs(self, child_attrs):
        self.child_attrs = child_attrs

    def get_child_attrs(self):
        return self.child_attrs

    def set_choice(self, choice):
        self.choice = choice

    def get_choice(self):
        return self.choice

    def set_optional(self, optional):
        self.optional = optional

    def get_optional(self):
        return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)


#
# Data representation classes.
#


class CHAdminCodes_V1_CHCantonCode(str, Enum):
    ZH = "ZH"
    BE = "BE"
    LU = "LU"
    UR = "UR"
    SZ = "SZ"
    OW = "OW"
    NW = "NW"
    GL = "GL"
    ZG = "ZG"
    FR = "FR"
    SO = "SO"
    BS = "BS"
    BL = "BL"
    SH = "SH"
    AR = "AR"
    AI = "AI"
    SG = "SG"
    GR = "GR"
    AG = "AG"
    TG = "TG"
    TI = "TI"
    VD = "VD"
    VS = "VS"
    NE = "NE"
    GE = "GE"
    JU = "JU"
    FL = "FL"
    CH = "CH"


class GeometryCHLV03_V1_Accuracy(str, Enum):
    CM = "cm"
    CM_50 = "cm50"
    M = "m"
    M_10 = "m10"
    M_50 = "m50"
    VAGUE = "vague"


class GeometryCHLV03_V1_Method(str, Enum):
    MEASURED = "measured"
    SKETCHED = "sketched"
    CALCULATED = "calculated"


class GeometryCHLV95_V1_Accuracy(str, Enum):
    CM = "cm"
    CM_50 = "cm50"
    M = "m"
    M_10 = "m10"
    M_50 = "m50"
    VAGUE = "vague"


class GeometryCHLV95_V1_Method(str, Enum):
    MEASURED = "measured"
    SKETCHED = "sketched"
    CALCULATED = "calculated"


class InternationalCodes_V1_CountryCode_ISO3166_1(str, Enum):
    CHE = "CHE"
    ABW = "ABW"
    AFG = "AFG"
    AGO = "AGO"
    AIA = "AIA"
    ALA = "ALA"
    ALB = "ALB"
    AND_ = "AND_"
    ANT = "ANT"
    ARE = "ARE"
    ARG = "ARG"
    ARM = "ARM"
    ASM = "ASM"
    ATA = "ATA"
    ATF = "ATF"
    ATG = "ATG"
    AUS = "AUS"
    AUT = "AUT"
    AZE = "AZE"
    BDI = "BDI"
    BEL = "BEL"
    BEN = "BEN"
    BFA = "BFA"
    BGD = "BGD"
    BGR = "BGR"
    BHR = "BHR"
    BHS = "BHS"
    BIH = "BIH"
    BLR = "BLR"
    BLZ = "BLZ"
    BMU = "BMU"
    BOL = "BOL"
    BRA = "BRA"
    BRB = "BRB"
    BRN = "BRN"
    BTN = "BTN"
    BVT = "BVT"
    BWA = "BWA"
    CAF = "CAF"
    CAN = "CAN"
    CCK = "CCK"
    CHL = "CHL"
    CHN = "CHN"
    CIV = "CIV"
    CMR = "CMR"
    COD = "COD"
    COG = "COG"
    COK = "COK"
    COL = "COL"
    COM = "COM"
    CPV = "CPV"
    CRI = "CRI"
    CUB = "CUB"
    CXR = "CXR"
    CYM = "CYM"
    CYP = "CYP"
    CZE = "CZE"
    DEU = "DEU"
    DJI = "DJI"
    DMA = "DMA"
    DNK = "DNK"
    DOM = "DOM"
    DZA = "DZA"
    ECU = "ECU"
    EGY = "EGY"
    ERI = "ERI"
    ESH = "ESH"
    ESP = "ESP"
    EST = "EST"
    ETH = "ETH"
    FIN = "FIN"
    FJI = "FJI"
    FLK = "FLK"
    FRA = "FRA"
    FRO = "FRO"
    FSM = "FSM"
    GAB = "GAB"
    GBR = "GBR"
    GEO = "GEO"
    GGY = "GGY"
    GHA = "GHA"
    GIB = "GIB"
    GIN = "GIN"
    GLP = "GLP"
    GMB = "GMB"
    GNB = "GNB"
    GNQ = "GNQ"
    GRC = "GRC"
    GRD = "GRD"
    GRL = "GRL"
    GTM = "GTM"
    GUF = "GUF"
    GUM = "GUM"
    GUY = "GUY"
    HKG = "HKG"
    HMD = "HMD"
    HND = "HND"
    HRV = "HRV"
    HTI = "HTI"
    HUN = "HUN"
    IDN = "IDN"
    IMN = "IMN"
    IND = "IND"
    IOT = "IOT"
    IRL = "IRL"
    IRN = "IRN"
    IRQ = "IRQ"
    ISL = "ISL"
    ISR = "ISR"
    ITA = "ITA"
    JAM = "JAM"
    JEY = "JEY"
    JOR = "JOR"
    JPN = "JPN"
    KAZ = "KAZ"
    KEN = "KEN"
    KGZ = "KGZ"
    KHM = "KHM"
    KIR = "KIR"
    KNA = "KNA"
    KOR = "KOR"
    KWT = "KWT"
    LAO = "LAO"
    LBN = "LBN"
    LBR = "LBR"
    LBY = "LBY"
    LCA = "LCA"
    LIE = "LIE"
    LKA = "LKA"
    LSO = "LSO"
    LTU = "LTU"
    LUX = "LUX"
    LVA = "LVA"
    MAC = "MAC"
    MAR = "MAR"
    MCO = "MCO"
    MDA = "MDA"
    MDG = "MDG"
    MDV = "MDV"
    MEX = "MEX"
    MHL = "MHL"
    MKD = "MKD"
    MLI = "MLI"
    MLT = "MLT"
    MMR = "MMR"
    MNE = "MNE"
    MNG = "MNG"
    MNP = "MNP"
    MOZ = "MOZ"
    MRT = "MRT"
    MSR = "MSR"
    MTQ = "MTQ"
    MUS = "MUS"
    MWI = "MWI"
    MYS = "MYS"
    MYT = "MYT"
    NAM = "NAM"
    NCL = "NCL"
    NER = "NER"
    NFK = "NFK"
    NGA = "NGA"
    NIC = "NIC"
    NIU = "NIU"
    NLD = "NLD"
    NOR = "NOR"
    NPL = "NPL"
    NRU = "NRU"
    NZL = "NZL"
    OMN = "OMN"
    PAK = "PAK"
    PAN = "PAN"
    PCN = "PCN"
    PER = "PER"
    PHL = "PHL"
    PLW = "PLW"
    PNG = "PNG"
    POL = "POL"
    PRI = "PRI"
    PRK = "PRK"
    PRT = "PRT"
    PRY = "PRY"
    PSE = "PSE"
    PYF = "PYF"
    QAT = "QAT"
    REU = "REU"
    ROU = "ROU"
    RUS = "RUS"
    RWA = "RWA"
    SAU = "SAU"
    SDN = "SDN"
    SEN = "SEN"
    SGP = "SGP"
    SGS = "SGS"
    SHN = "SHN"
    SJM = "SJM"
    SLB = "SLB"
    SLE = "SLE"
    SLV = "SLV"
    SMR = "SMR"
    SOM = "SOM"
    SPM = "SPM"
    SRB = "SRB"
    STP = "STP"
    SUR = "SUR"
    SVK = "SVK"
    SVN = "SVN"
    SWE = "SWE"
    SWZ = "SWZ"
    SYC = "SYC"
    SYR = "SYR"
    TCA = "TCA"
    TCD = "TCD"
    TGO = "TGO"
    THA = "THA"
    TJK = "TJK"
    TKL = "TKL"
    TKM = "TKM"
    TLS = "TLS"
    TON = "TON"
    TTO = "TTO"
    TUN = "TUN"
    TUR = "TUR"
    TUV = "TUV"
    TWN = "TWN"
    TZA = "TZA"
    UGA = "UGA"
    UKR = "UKR"
    UMI = "UMI"
    URY = "URY"
    USA = "USA"
    UZB = "UZB"
    VAT = "VAT"
    VCT = "VCT"
    VEN = "VEN"
    VGB = "VGB"
    VIR = "VIR"
    VNM = "VNM"
    VUT = "VUT"
    WLF = "WLF"
    WSM = "WSM"
    YEM = "YEM"
    ZAF = "ZAF"
    ZMB = "ZMB"
    ZWE = "ZWE"


class InternationalCodes_V1_LanguageCode_ISO639_1(str, Enum):
    DE = "de"
    FR = "fr"
    IT = "it"
    RM = "rm"
    EN = "en"
    AA = "aa"
    AB = "ab"
    AF = "af"
    AM = "am"
    AR = "ar"
    AS = "as"
    AY = "ay"
    AZ = "az"
    BA = "ba"
    BE = "be"
    BG = "bg"
    BH = "bh"
    BI = "bi"
    BN = "bn"
    BO = "bo"
    BR = "br"
    CA = "ca"
    CO = "co"
    CS = "cs"
    CY = "cy"
    DA = "da"
    DZ = "dz"
    EL = "el"
    EO = "eo"
    ES = "es"
    ET = "et"
    EU = "eu"
    FA = "fa"
    FI = "fi"
    FJ = "fj"
    FO = "fo"
    FY = "fy"
    GA = "ga"
    GD = "gd"
    GL = "gl"
    GN = "gn"
    GU = "gu"
    HA = "ha"
    HE = "he"
    HI = "hi"
    HR = "hr"
    HU = "hu"
    HY = "hy"
    IA = "ia"
    ID = "id"
    IE = "ie"
    IK = "ik"
    IS = "is"
    IU = "iu"
    JA = "ja"
    JW = "jw"
    KA = "ka"
    KK = "kk"
    KL = "kl"
    KM = "km"
    KN = "kn"
    KO = "ko"
    KS = "ks"
    KU = "ku"
    KY = "ky"
    LA = "la"
    LN = "ln"
    LO = "lo"
    LT = "lt"
    LV = "lv"
    MG = "mg"
    MI = "mi"
    MK = "mk"
    ML = "ml"
    MN = "mn"
    MO = "mo"
    MR = "mr"
    MS = "ms"
    MT = "mt"
    MY = "my"
    NA = "na"
    NE = "ne"
    NL = "nl"
    NO = "no"
    OC = "oc"
    OM = "om"
    OR = "or"
    PA = "pa"
    PL = "pl"
    PS = "ps"
    PT = "pt"
    QU = "qu"
    RN = "rn"
    RO = "ro"
    RU = "ru"
    RW = "rw"
    SA = "sa"
    SD = "sd"
    SG = "sg"
    SH = "sh"
    SI = "si"
    SK = "sk"
    SL = "sl"
    SM = "sm"
    SN = "sn"
    SO = "so"
    SQ = "sq"
    SR = "sr"
    SS = "ss"
    ST = "st"
    SU = "su"
    SV = "sv"
    SW = "sw"
    TA = "ta"
    TE = "te"
    TG = "tg"
    TH = "th"
    TI = "ti"
    TK = "tk"
    TL = "tl"
    TN = "tn"
    TO = "to"
    TR = "tr"
    TS = "ts"
    TT = "tt"
    TW = "tw"
    UG = "ug"
    UK = "uk"
    UR = "ur"
    UZ = "uz"
    VI = "vi"
    VO = "vo"
    WO = "wo"
    XH = "xh"
    YI = "yi"
    YO = "yo"
    ZA = "za"
    ZH = "zh"
    ZU = "zu"


class OeREBKRM_V2_0_DokumentTyp(str, Enum):
    RECHTSVORSCHRIFT = "Rechtsvorschrift"
    GESETZLICHE_GRUNDLAGE = "GesetzlicheGrundlage"
    HINWEIS = "Hinweis"


class OeREBKRM_V2_0_GrundstuecksArt(str, Enum):
    LIEGENSCHAFT = "Liegenschaft"
    SELBST_RECHT_BAURECHT = "SelbstRecht.Baurecht"
    SELBST_RECHT_QUELLENRECHT = "SelbstRecht.Quellenrecht"
    SELBST_RECHT_KONZESSIONSRECHT = "SelbstRecht.Konzessionsrecht"
    SELBST_RECHTWEITERE = "SelbstRecht.weitere"
    BERGWERK = "Bergwerk"


class OeREBKRM_V2_0_RechtsStatus(str, Enum):
    IN_KRAFT = "inKraft"
    AENDERUNG_MIT_VORWIRKUNG = "AenderungMitVorwirkung"
    AENDERUNG_OHNE_VORWIRKUNG = "AenderungOhneVorwirkung"


class PrecisionType(str, Enum):
    EXACT = "exact"
    MEASURE_BASED = "measure_based"


class SystemType(str, Enum):
    NORMAL = "normal"
    ORTHOMETRIC = "orthometric"
    ELLIPSOIDAL = "ellipsoidal"
    OTHER = "other"


class Transfer(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "HEADERSECTION": MemberSpec_(
            "HEADERSECTION",
            "HeaderSection",
            0,
            0,
            {"name": "HEADERSECTION", "type": "HeaderSection"},
            None,
        ),
        "DATASECTION": MemberSpec_(
            "DATASECTION",
            "DataSection",
            0,
            0,
            {"name": "DATASECTION", "type": "DataSection"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, HEADERSECTION=None, DATASECTION=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if HEADERSECTION is None:
            self.HEADERSECTION = globals()["HeaderSection"]()
        else:
            self.HEADERSECTION = HEADERSECTION
        self.HEADERSECTION_nsprefix_ = None
        if DATASECTION is None:
            self.DATASECTION = globals()["DataSection"]()
        else:
            self.DATASECTION = DATASECTION
        self.DATASECTION_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, Transfer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Transfer.subclass:
            return Transfer.subclass(*args_, **kwargs_)
        else:
            return Transfer(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_HEADERSECTION(self):
        return self.HEADERSECTION

    def set_HEADERSECTION(self, HEADERSECTION):
        self.HEADERSECTION = HEADERSECTION

    def get_DATASECTION(self):
        return self.DATASECTION

    def set_DATASECTION(self, DATASECTION):
        self.DATASECTION = DATASECTION

    def _hasContent(self):
        if self.HEADERSECTION is not None or self.DATASECTION is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="Transfer",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("Transfer")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "Transfer":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="Transfer")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="Transfer",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_="", name_="Transfer"):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="Transfer",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.HEADERSECTION is not None:
            namespaceprefix_ = (
                self.HEADERSECTION_nsprefix_ + ":"
                if (UseCapturedNS_ and self.HEADERSECTION_nsprefix_)
                else ""
            )
            self.HEADERSECTION.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="HEADERSECTION",
                pretty_print=pretty_print,
            )
        if self.DATASECTION is not None:
            namespaceprefix_ = (
                self.DATASECTION_nsprefix_ + ":" if (UseCapturedNS_ and self.DATASECTION_nsprefix_) else ""
            )
            self.DATASECTION.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="DATASECTION",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "HEADERSECTION":
            obj_ = HeaderSection.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.HEADERSECTION = obj_
            obj_.original_tagname_ = "HEADERSECTION"
        elif nodeName_ == "DATASECTION":
            obj_ = DataSection.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DATASECTION = obj_
            obj_.original_tagname_ = "DATASECTION"


# end class Transfer


class Models(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "MODEL": MemberSpec_(
            "MODEL",
            "Model",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "MODEL",
                "type": "Model",
            },
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, MODEL=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if MODEL is None:
            self.MODEL = []
        else:
            self.MODEL = MODEL
        self.MODEL_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, Models)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Models.subclass:
            return Models.subclass(*args_, **kwargs_)
        else:
            return Models(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_MODEL(self):
        return self.MODEL

    def set_MODEL(self, MODEL):
        self.MODEL = MODEL

    def add_MODEL(self, value):
        self.MODEL.append(value)

    def insert_MODEL_at(self, index, value):
        self.MODEL.insert(index, value)

    def replace_MODEL_at(self, index, value):
        self.MODEL[index] = value

    def _hasContent(self):
        if self.MODEL:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="Models",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("Models")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "Models":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="Models")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="Models",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_="", name_="Models"):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="Models",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for MODEL_ in self.MODEL:
            namespaceprefix_ = self.MODEL_nsprefix_ + ":" if (UseCapturedNS_ and self.MODEL_nsprefix_) else ""
            MODEL_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="MODEL",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "MODEL":
            obj_ = Model.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MODEL.append(obj_)
            obj_.original_tagname_ = "MODEL"


# end class Models


class Model(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "NAME": MemberSpec_("NAME", "INTERLIS.NAME", 0, 0, {"use": "required", "name": "NAME"}),
        "VERSION": MemberSpec_("VERSION", "xsd:string", 0, 0, {"use": "required", "name": "VERSION"}),
        "URI": MemberSpec_("URI", "xsd:anyURI", 0, 0, {"use": "required", "name": "URI"}),
    }
    subclass = None
    superclass = None

    def __init__(self, NAME=None, VERSION=None, URI=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.NAME = _cast(None, NAME)
        self.NAME_nsprefix_ = None
        self.VERSION = _cast(None, VERSION)
        self.VERSION_nsprefix_ = None
        self.URI = _cast(None, URI)
        self.URI_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, Model)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Model.subclass:
            return Model.subclass(*args_, **kwargs_)
        else:
            return Model(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_NAME(self):
        return self.NAME

    def set_NAME(self, NAME):
        self.NAME = NAME

    def get_VERSION(self):
        return self.VERSION

    def set_VERSION(self, VERSION):
        self.VERSION = VERSION

    def get_URI(self):
        return self.URI

    def set_URI(self, URI):
        self.URI = URI

    def validate_INTERLIS_NAME(self, value):
        # Validate type INTERLIS.NAME, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on INTERLIS.NAME'
                    % {"value": value, "lineno": lineno}
                )
                result = False

    def _hasContent(self):
        if ():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="Model",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("Model")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "Model":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="Model")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="Model",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_="", name_="Model"):
        if self.NAME is not None and "NAME" not in already_processed:
            already_processed.add("NAME")
            outfile.write(
                " NAME=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.NAME), input_name="NAME")),)
            )
        if self.VERSION is not None and "VERSION" not in already_processed:
            already_processed.add("VERSION")
            outfile.write(
                " VERSION=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.VERSION), input_name="VERSION")),)
            )
        if self.URI is not None and "URI" not in already_processed:
            already_processed.add("URI")
            outfile.write(
                " URI=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.URI), input_name="URI")),)
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="Model",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("NAME", node)
        if value is not None and "NAME" not in already_processed:
            already_processed.add("NAME")
            self.NAME = value
            self.validate_INTERLIS_NAME(self.NAME)  # validate type INTERLIS.NAME
        value = find_attr_value_("VERSION", node)
        if value is not None and "VERSION" not in already_processed:
            already_processed.add("VERSION")
            self.VERSION = value
        value = find_attr_value_("URI", node)
        if value is not None and "URI" not in already_processed:
            already_processed.add("URI")
            self.URI = value

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class Model


class RoleType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "REF": MemberSpec_("REF", "IliID", 0, 0, {"use": "required", "name": "REF"}),
        "BID": MemberSpec_("BID", "IliID", 0, 1, {"use": "optional", "name": "BID"}),
        "ORDER_POS": MemberSpec_(
            "ORDER_POS",
            "xsd:positiveInteger",
            0,
            1,
            {"use": "optional", "name": "ORDER_POS"},
        ),
        "valueOf_": MemberSpec_("valueOf_", "xsd:string", 0),
    }
    subclass = None
    superclass = None

    def __init__(self, REF=None, BID=None, ORDER_POS=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.REF = _cast(None, REF)
        self.REF_nsprefix_ = None
        self.BID = _cast(None, BID)
        self.BID_nsprefix_ = None
        self.ORDER_POS = _cast(int, ORDER_POS)
        self.ORDER_POS_nsprefix_ = None
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, RoleType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RoleType.subclass:
            return RoleType.subclass(*args_, **kwargs_)
        else:
            return RoleType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_REF(self):
        return self.REF

    def set_REF(self, REF):
        self.REF = REF

    def get_BID(self):
        return self.BID

    def set_BID(self, BID):
        self.BID = BID

    def get_ORDER_POS(self):
        return self.ORDER_POS

    def set_ORDER_POS(self, ORDER_POS):
        self.ORDER_POS = ORDER_POS

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if 1 if type(self.valueOf_) in [int, float] else self.valueOf_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="RoleType",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("RoleType")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "RoleType":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="RoleType")
        outfile.write(">")
        self._exportChildren(
            outfile,
            level + 1,
            namespaceprefix_,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))

    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_="", name_="RoleType"):
        if self.REF is not None and "REF" not in already_processed:
            already_processed.add("REF")
            outfile.write(
                " REF=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.REF), input_name="REF")),)
            )
        if self.BID is not None and "BID" not in already_processed:
            already_processed.add("BID")
            outfile.write(
                " BID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.BID), input_name="BID")),)
            )
        if self.ORDER_POS is not None and "ORDER_POS" not in already_processed:
            already_processed.add("ORDER_POS")
            outfile.write(' ORDER_POS="%s"' % self.gds_format_integer(self.ORDER_POS, input_name="ORDER_POS"))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="RoleType",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("REF", node)
        if value is not None and "REF" not in already_processed:
            already_processed.add("REF")
            self.REF = value
            self.validate_IliID(self.REF)  # validate type IliID
        value = find_attr_value_("BID", node)
        if value is not None and "BID" not in already_processed:
            already_processed.add("BID")
            self.BID = value
            self.validate_IliID(self.BID)  # validate type IliID
        value = find_attr_value_("ORDER_POS", node)
        if value is not None and "ORDER_POS" not in already_processed:
            already_processed.add("ORDER_POS")
            self.ORDER_POS = self.gds_parse_integer(value, node, "ORDER_POS")
            if self.ORDER_POS <= 0:
                raise_parse_error(node, "Invalid PositiveInteger")

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class RoleType


class DataSection(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "AdministrativeUnitsCH_V1_CHCantons": MemberSpec_(
            "AdministrativeUnitsCH_V1_CHCantons",
            "AdministrativeUnitsCH_V1.CHCantons",
            1,
            1,
            {
                "name": "AdministrativeUnitsCH_V1.CHCantons",
                "type": "AdministrativeUnitsCH_V1.CHCantons",
            },
            1,
        ),
        "AdministrativeUnitsCH_V1_CHDistricts": MemberSpec_(
            "AdministrativeUnitsCH_V1_CHDistricts",
            "AdministrativeUnitsCH_V1.CHDistricts",
            1,
            1,
            {
                "name": "AdministrativeUnitsCH_V1.CHDistricts",
                "type": "AdministrativeUnitsCH_V1.CHDistricts",
            },
            1,
        ),
        "AdministrativeUnitsCH_V1_CHMunicipalities": MemberSpec_(
            "AdministrativeUnitsCH_V1_CHMunicipalities",
            "AdministrativeUnitsCH_V1.CHMunicipalities",
            1,
            1,
            {
                "name": "AdministrativeUnitsCH_V1.CHMunicipalities",
                "type": "AdministrativeUnitsCH_V1.CHMunicipalities",
            },
            1,
        ),
        "AdministrativeUnitsCH_V1_CHAdministrativeUnions": MemberSpec_(
            "AdministrativeUnitsCH_V1_CHAdministrativeUnions",
            "AdministrativeUnitsCH_V1.CHAdministrativeUnions",
            1,
            1,
            {
                "name": "AdministrativeUnitsCH_V1.CHAdministrativeUnions",
                "type": "AdministrativeUnitsCH_V1.CHAdministrativeUnions",
            },
            1,
        ),
        "AdministrativeUnitsCH_V1_CHAgencies": MemberSpec_(
            "AdministrativeUnitsCH_V1_CHAgencies",
            "AdministrativeUnitsCH_V1.CHAgencies",
            1,
            1,
            {
                "name": "AdministrativeUnitsCH_V1.CHAgencies",
                "type": "AdministrativeUnitsCH_V1.CHAgencies",
            },
            1,
        ),
        "AdministrativeUnits_V1_Countries": MemberSpec_(
            "AdministrativeUnits_V1_Countries",
            "AdministrativeUnits_V1.Countries",
            1,
            1,
            {
                "name": "AdministrativeUnits_V1.Countries",
                "type": "AdministrativeUnits_V1.Countries",
            },
            1,
        ),
        "AdministrativeUnits_V1_CountryNames": MemberSpec_(
            "AdministrativeUnits_V1_CountryNames",
            "AdministrativeUnits_V1.CountryNames",
            1,
            1,
            {
                "name": "AdministrativeUnits_V1.CountryNames",
                "type": "AdministrativeUnits_V1.CountryNames",
            },
            1,
        ),
        "CoordSys_CoordsysTopic": MemberSpec_(
            "CoordSys_CoordsysTopic",
            "CoordSys.CoordsysTopic",
            1,
            1,
            {"name": "CoordSys.CoordsysTopic", "type": "CoordSys.CoordsysTopic"},
            1,
        ),
        "OeREBKRM_V2_0_Amt": MemberSpec_(
            "OeREBKRM_V2_0_Amt",
            "OeREBKRM_V2_0.Amt",
            1,
            1,
            {"name": "OeREBKRM_V2_0.Amt", "type": "OeREBKRM_V2_0.Amt"},
            1,
        ),
        "OeREBKRM_V2_0_Dokumente": MemberSpec_(
            "OeREBKRM_V2_0_Dokumente",
            "OeREBKRM_V2_0.Dokumente",
            1,
            1,
            {"name": "OeREBKRM_V2_0.Dokumente", "type": "OeREBKRM_V2_0.Dokumente"},
            1,
        ),
        "OeREBKRMtrsfr_V2_0_Transferstruktur": MemberSpec_(
            "OeREBKRMtrsfr_V2_0_Transferstruktur",
            "OeREBKRMtrsfr_V2_0.Transferstruktur",
            1,
            1,
            {
                "name": "OeREBKRMtrsfr_V2_0.Transferstruktur",
                "type": "OeREBKRMtrsfr_V2_0.Transferstruktur",
            },
            1,
        ),
    }
    subclass = None
    superclass = None

    def __init__(
        self,
        AdministrativeUnitsCH_V1_CHCantons=None,
        AdministrativeUnitsCH_V1_CHDistricts=None,
        AdministrativeUnitsCH_V1_CHMunicipalities=None,
        AdministrativeUnitsCH_V1_CHAdministrativeUnions=None,
        AdministrativeUnitsCH_V1_CHAgencies=None,
        AdministrativeUnits_V1_Countries=None,
        AdministrativeUnits_V1_CountryNames=None,
        CoordSys_CoordsysTopic=None,
        OeREBKRM_V2_0_Amt=None,
        OeREBKRM_V2_0_Dokumente=None,
        OeREBKRMtrsfr_V2_0_Transferstruktur=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if AdministrativeUnitsCH_V1_CHCantons is None:
            self.AdministrativeUnitsCH_V1_CHCantons = []
        else:
            self.AdministrativeUnitsCH_V1_CHCantons = AdministrativeUnitsCH_V1_CHCantons
        self.AdministrativeUnitsCH_V1_CHCantons_nsprefix_ = None
        if AdministrativeUnitsCH_V1_CHDistricts is None:
            self.AdministrativeUnitsCH_V1_CHDistricts = []
        else:
            self.AdministrativeUnitsCH_V1_CHDistricts = AdministrativeUnitsCH_V1_CHDistricts
        self.AdministrativeUnitsCH_V1_CHDistricts_nsprefix_ = None
        if AdministrativeUnitsCH_V1_CHMunicipalities is None:
            self.AdministrativeUnitsCH_V1_CHMunicipalities = []
        else:
            self.AdministrativeUnitsCH_V1_CHMunicipalities = AdministrativeUnitsCH_V1_CHMunicipalities
        self.AdministrativeUnitsCH_V1_CHMunicipalities_nsprefix_ = None
        if AdministrativeUnitsCH_V1_CHAdministrativeUnions is None:
            self.AdministrativeUnitsCH_V1_CHAdministrativeUnions = []
        else:
            self.AdministrativeUnitsCH_V1_CHAdministrativeUnions = (
                AdministrativeUnitsCH_V1_CHAdministrativeUnions
            )
        self.AdministrativeUnitsCH_V1_CHAdministrativeUnions_nsprefix_ = None
        if AdministrativeUnitsCH_V1_CHAgencies is None:
            self.AdministrativeUnitsCH_V1_CHAgencies = []
        else:
            self.AdministrativeUnitsCH_V1_CHAgencies = AdministrativeUnitsCH_V1_CHAgencies
        self.AdministrativeUnitsCH_V1_CHAgencies_nsprefix_ = None
        if AdministrativeUnits_V1_Countries is None:
            self.AdministrativeUnits_V1_Countries = []
        else:
            self.AdministrativeUnits_V1_Countries = AdministrativeUnits_V1_Countries
        self.AdministrativeUnits_V1_Countries_nsprefix_ = None
        if AdministrativeUnits_V1_CountryNames is None:
            self.AdministrativeUnits_V1_CountryNames = []
        else:
            self.AdministrativeUnits_V1_CountryNames = AdministrativeUnits_V1_CountryNames
        self.AdministrativeUnits_V1_CountryNames_nsprefix_ = None
        if CoordSys_CoordsysTopic is None:
            self.CoordSys_CoordsysTopic = []
        else:
            self.CoordSys_CoordsysTopic = CoordSys_CoordsysTopic
        self.CoordSys_CoordsysTopic_nsprefix_ = None
        if OeREBKRM_V2_0_Amt is None:
            self.OeREBKRM_V2_0_Amt = []
        else:
            self.OeREBKRM_V2_0_Amt = OeREBKRM_V2_0_Amt
        self.OeREBKRM_V2_0_Amt_nsprefix_ = None
        if OeREBKRM_V2_0_Dokumente is None:
            self.OeREBKRM_V2_0_Dokumente = []
        else:
            self.OeREBKRM_V2_0_Dokumente = OeREBKRM_V2_0_Dokumente
        self.OeREBKRM_V2_0_Dokumente_nsprefix_ = None
        if OeREBKRMtrsfr_V2_0_Transferstruktur is None:
            self.OeREBKRMtrsfr_V2_0_Transferstruktur = []
        else:
            self.OeREBKRMtrsfr_V2_0_Transferstruktur = OeREBKRMtrsfr_V2_0_Transferstruktur
        self.OeREBKRMtrsfr_V2_0_Transferstruktur_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, DataSection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataSection.subclass:
            return DataSection.subclass(*args_, **kwargs_)
        else:
            return DataSection(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_AdministrativeUnitsCH_V1_CHCantons(self):
        return self.AdministrativeUnitsCH_V1_CHCantons

    def set_AdministrativeUnitsCH_V1_CHCantons(self, AdministrativeUnitsCH_V1_CHCantons):
        self.AdministrativeUnitsCH_V1_CHCantons = AdministrativeUnitsCH_V1_CHCantons

    def add_AdministrativeUnitsCH_V1_CHCantons(self, value):
        self.AdministrativeUnitsCH_V1_CHCantons.append(value)

    def insert_AdministrativeUnitsCH_V1_CHCantons_at(self, index, value):
        self.AdministrativeUnitsCH_V1_CHCantons.insert(index, value)

    def replace_AdministrativeUnitsCH_V1_CHCantons_at(self, index, value):
        self.AdministrativeUnitsCH_V1_CHCantons[index] = value

    def get_AdministrativeUnitsCH_V1_CHDistricts(self):
        return self.AdministrativeUnitsCH_V1_CHDistricts

    def set_AdministrativeUnitsCH_V1_CHDistricts(self, AdministrativeUnitsCH_V1_CHDistricts):
        self.AdministrativeUnitsCH_V1_CHDistricts = AdministrativeUnitsCH_V1_CHDistricts

    def add_AdministrativeUnitsCH_V1_CHDistricts(self, value):
        self.AdministrativeUnitsCH_V1_CHDistricts.append(value)

    def insert_AdministrativeUnitsCH_V1_CHDistricts_at(self, index, value):
        self.AdministrativeUnitsCH_V1_CHDistricts.insert(index, value)

    def replace_AdministrativeUnitsCH_V1_CHDistricts_at(self, index, value):
        self.AdministrativeUnitsCH_V1_CHDistricts[index] = value

    def get_AdministrativeUnitsCH_V1_CHMunicipalities(self):
        return self.AdministrativeUnitsCH_V1_CHMunicipalities

    def set_AdministrativeUnitsCH_V1_CHMunicipalities(self, AdministrativeUnitsCH_V1_CHMunicipalities):
        self.AdministrativeUnitsCH_V1_CHMunicipalities = AdministrativeUnitsCH_V1_CHMunicipalities

    def add_AdministrativeUnitsCH_V1_CHMunicipalities(self, value):
        self.AdministrativeUnitsCH_V1_CHMunicipalities.append(value)

    def insert_AdministrativeUnitsCH_V1_CHMunicipalities_at(self, index, value):
        self.AdministrativeUnitsCH_V1_CHMunicipalities.insert(index, value)

    def replace_AdministrativeUnitsCH_V1_CHMunicipalities_at(self, index, value):
        self.AdministrativeUnitsCH_V1_CHMunicipalities[index] = value

    def get_AdministrativeUnitsCH_V1_CHAdministrativeUnions(self):
        return self.AdministrativeUnitsCH_V1_CHAdministrativeUnions

    def set_AdministrativeUnitsCH_V1_CHAdministrativeUnions(
        self, AdministrativeUnitsCH_V1_CHAdministrativeUnions
    ):
        self.AdministrativeUnitsCH_V1_CHAdministrativeUnions = AdministrativeUnitsCH_V1_CHAdministrativeUnions

    def add_AdministrativeUnitsCH_V1_CHAdministrativeUnions(self, value):
        self.AdministrativeUnitsCH_V1_CHAdministrativeUnions.append(value)

    def insert_AdministrativeUnitsCH_V1_CHAdministrativeUnions_at(self, index, value):
        self.AdministrativeUnitsCH_V1_CHAdministrativeUnions.insert(index, value)

    def replace_AdministrativeUnitsCH_V1_CHAdministrativeUnions_at(self, index, value):
        self.AdministrativeUnitsCH_V1_CHAdministrativeUnions[index] = value

    def get_AdministrativeUnitsCH_V1_CHAgencies(self):
        return self.AdministrativeUnitsCH_V1_CHAgencies

    def set_AdministrativeUnitsCH_V1_CHAgencies(self, AdministrativeUnitsCH_V1_CHAgencies):
        self.AdministrativeUnitsCH_V1_CHAgencies = AdministrativeUnitsCH_V1_CHAgencies

    def add_AdministrativeUnitsCH_V1_CHAgencies(self, value):
        self.AdministrativeUnitsCH_V1_CHAgencies.append(value)

    def insert_AdministrativeUnitsCH_V1_CHAgencies_at(self, index, value):
        self.AdministrativeUnitsCH_V1_CHAgencies.insert(index, value)

    def replace_AdministrativeUnitsCH_V1_CHAgencies_at(self, index, value):
        self.AdministrativeUnitsCH_V1_CHAgencies[index] = value

    def get_AdministrativeUnits_V1_Countries(self):
        return self.AdministrativeUnits_V1_Countries

    def set_AdministrativeUnits_V1_Countries(self, AdministrativeUnits_V1_Countries):
        self.AdministrativeUnits_V1_Countries = AdministrativeUnits_V1_Countries

    def add_AdministrativeUnits_V1_Countries(self, value):
        self.AdministrativeUnits_V1_Countries.append(value)

    def insert_AdministrativeUnits_V1_Countries_at(self, index, value):
        self.AdministrativeUnits_V1_Countries.insert(index, value)

    def replace_AdministrativeUnits_V1_Countries_at(self, index, value):
        self.AdministrativeUnits_V1_Countries[index] = value

    def get_AdministrativeUnits_V1_CountryNames(self):
        return self.AdministrativeUnits_V1_CountryNames

    def set_AdministrativeUnits_V1_CountryNames(self, AdministrativeUnits_V1_CountryNames):
        self.AdministrativeUnits_V1_CountryNames = AdministrativeUnits_V1_CountryNames

    def add_AdministrativeUnits_V1_CountryNames(self, value):
        self.AdministrativeUnits_V1_CountryNames.append(value)

    def insert_AdministrativeUnits_V1_CountryNames_at(self, index, value):
        self.AdministrativeUnits_V1_CountryNames.insert(index, value)

    def replace_AdministrativeUnits_V1_CountryNames_at(self, index, value):
        self.AdministrativeUnits_V1_CountryNames[index] = value

    def get_CoordSys_CoordsysTopic(self):
        return self.CoordSys_CoordsysTopic

    def set_CoordSys_CoordsysTopic(self, CoordSys_CoordsysTopic):
        self.CoordSys_CoordsysTopic = CoordSys_CoordsysTopic

    def add_CoordSys_CoordsysTopic(self, value):
        self.CoordSys_CoordsysTopic.append(value)

    def insert_CoordSys_CoordsysTopic_at(self, index, value):
        self.CoordSys_CoordsysTopic.insert(index, value)

    def replace_CoordSys_CoordsysTopic_at(self, index, value):
        self.CoordSys_CoordsysTopic[index] = value

    def get_OeREBKRM_V2_0_Amt(self):
        return self.OeREBKRM_V2_0_Amt

    def set_OeREBKRM_V2_0_Amt(self, OeREBKRM_V2_0_Amt):
        self.OeREBKRM_V2_0_Amt = OeREBKRM_V2_0_Amt

    def add_OeREBKRM_V2_0_Amt(self, value):
        self.OeREBKRM_V2_0_Amt.append(value)

    def insert_OeREBKRM_V2_0_Amt_at(self, index, value):
        self.OeREBKRM_V2_0_Amt.insert(index, value)

    def replace_OeREBKRM_V2_0_Amt_at(self, index, value):
        self.OeREBKRM_V2_0_Amt[index] = value

    def get_OeREBKRM_V2_0_Dokumente(self):
        return self.OeREBKRM_V2_0_Dokumente

    def set_OeREBKRM_V2_0_Dokumente(self, OeREBKRM_V2_0_Dokumente):
        self.OeREBKRM_V2_0_Dokumente = OeREBKRM_V2_0_Dokumente

    def add_OeREBKRM_V2_0_Dokumente(self, value):
        self.OeREBKRM_V2_0_Dokumente.append(value)

    def insert_OeREBKRM_V2_0_Dokumente_at(self, index, value):
        self.OeREBKRM_V2_0_Dokumente.insert(index, value)

    def replace_OeREBKRM_V2_0_Dokumente_at(self, index, value):
        self.OeREBKRM_V2_0_Dokumente[index] = value

    def get_OeREBKRMtrsfr_V2_0_Transferstruktur(self):
        return self.OeREBKRMtrsfr_V2_0_Transferstruktur

    def set_OeREBKRMtrsfr_V2_0_Transferstruktur(self, OeREBKRMtrsfr_V2_0_Transferstruktur):
        self.OeREBKRMtrsfr_V2_0_Transferstruktur = OeREBKRMtrsfr_V2_0_Transferstruktur

    def add_OeREBKRMtrsfr_V2_0_Transferstruktur(self, value):
        self.OeREBKRMtrsfr_V2_0_Transferstruktur.append(value)

    def insert_OeREBKRMtrsfr_V2_0_Transferstruktur_at(self, index, value):
        self.OeREBKRMtrsfr_V2_0_Transferstruktur.insert(index, value)

    def replace_OeREBKRMtrsfr_V2_0_Transferstruktur_at(self, index, value):
        self.OeREBKRMtrsfr_V2_0_Transferstruktur[index] = value

    def _hasContent(self):
        if (
            self.AdministrativeUnitsCH_V1_CHCantons
            or self.AdministrativeUnitsCH_V1_CHDistricts
            or self.AdministrativeUnitsCH_V1_CHMunicipalities
            or self.AdministrativeUnitsCH_V1_CHAdministrativeUnions
            or self.AdministrativeUnitsCH_V1_CHAgencies
            or self.AdministrativeUnits_V1_Countries
            or self.AdministrativeUnits_V1_CountryNames
            or self.CoordSys_CoordsysTopic
            or self.OeREBKRM_V2_0_Amt
            or self.OeREBKRM_V2_0_Dokumente
            or self.OeREBKRMtrsfr_V2_0_Transferstruktur
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="DataSection",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("DataSection")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "DataSection":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="DataSection")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="DataSection",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="DataSection",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="DataSection",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for AdministrativeUnitsCH_V1_CHCantons_ in self.AdministrativeUnitsCH_V1_CHCantons:
            namespaceprefix_ = (
                self.AdministrativeUnitsCH_V1_CHCantons_nsprefix_ + ":"
                if (UseCapturedNS_ and self.AdministrativeUnitsCH_V1_CHCantons_nsprefix_)
                else ""
            )
            AdministrativeUnitsCH_V1_CHCantons_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="AdministrativeUnitsCH_V1.CHCantons",
                pretty_print=pretty_print,
            )
        for AdministrativeUnitsCH_V1_CHDistricts_ in self.AdministrativeUnitsCH_V1_CHDistricts:
            namespaceprefix_ = (
                self.AdministrativeUnitsCH_V1_CHDistricts_nsprefix_ + ":"
                if (UseCapturedNS_ and self.AdministrativeUnitsCH_V1_CHDistricts_nsprefix_)
                else ""
            )
            AdministrativeUnitsCH_V1_CHDistricts_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="AdministrativeUnitsCH_V1.CHDistricts",
                pretty_print=pretty_print,
            )
        for AdministrativeUnitsCH_V1_CHMunicipalities_ in self.AdministrativeUnitsCH_V1_CHMunicipalities:
            namespaceprefix_ = (
                self.AdministrativeUnitsCH_V1_CHMunicipalities_nsprefix_ + ":"
                if (UseCapturedNS_ and self.AdministrativeUnitsCH_V1_CHMunicipalities_nsprefix_)
                else ""
            )
            AdministrativeUnitsCH_V1_CHMunicipalities_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="AdministrativeUnitsCH_V1.CHMunicipalities",
                pretty_print=pretty_print,
            )
        for (
            AdministrativeUnitsCH_V1_CHAdministrativeUnions_
        ) in self.AdministrativeUnitsCH_V1_CHAdministrativeUnions:
            namespaceprefix_ = (
                self.AdministrativeUnitsCH_V1_CHAdministrativeUnions_nsprefix_ + ":"
                if (UseCapturedNS_ and self.AdministrativeUnitsCH_V1_CHAdministrativeUnions_nsprefix_)
                else ""
            )
            AdministrativeUnitsCH_V1_CHAdministrativeUnions_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="AdministrativeUnitsCH_V1.CHAdministrativeUnions",
                pretty_print=pretty_print,
            )
        for AdministrativeUnitsCH_V1_CHAgencies_ in self.AdministrativeUnitsCH_V1_CHAgencies:
            namespaceprefix_ = (
                self.AdministrativeUnitsCH_V1_CHAgencies_nsprefix_ + ":"
                if (UseCapturedNS_ and self.AdministrativeUnitsCH_V1_CHAgencies_nsprefix_)
                else ""
            )
            AdministrativeUnitsCH_V1_CHAgencies_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="AdministrativeUnitsCH_V1.CHAgencies",
                pretty_print=pretty_print,
            )
        for AdministrativeUnits_V1_Countries_ in self.AdministrativeUnits_V1_Countries:
            namespaceprefix_ = (
                self.AdministrativeUnits_V1_Countries_nsprefix_ + ":"
                if (UseCapturedNS_ and self.AdministrativeUnits_V1_Countries_nsprefix_)
                else ""
            )
            AdministrativeUnits_V1_Countries_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="AdministrativeUnits_V1.Countries",
                pretty_print=pretty_print,
            )
        for AdministrativeUnits_V1_CountryNames_ in self.AdministrativeUnits_V1_CountryNames:
            namespaceprefix_ = (
                self.AdministrativeUnits_V1_CountryNames_nsprefix_ + ":"
                if (UseCapturedNS_ and self.AdministrativeUnits_V1_CountryNames_nsprefix_)
                else ""
            )
            AdministrativeUnits_V1_CountryNames_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="AdministrativeUnits_V1.CountryNames",
                pretty_print=pretty_print,
            )
        for CoordSys_CoordsysTopic_ in self.CoordSys_CoordsysTopic:
            namespaceprefix_ = (
                self.CoordSys_CoordsysTopic_nsprefix_ + ":"
                if (UseCapturedNS_ and self.CoordSys_CoordsysTopic_nsprefix_)
                else ""
            )
            CoordSys_CoordsysTopic_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="CoordSys.CoordsysTopic",
                pretty_print=pretty_print,
            )
        for OeREBKRM_V2_0_Amt_ in self.OeREBKRM_V2_0_Amt:
            namespaceprefix_ = (
                self.OeREBKRM_V2_0_Amt_nsprefix_ + ":"
                if (UseCapturedNS_ and self.OeREBKRM_V2_0_Amt_nsprefix_)
                else ""
            )
            OeREBKRM_V2_0_Amt_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="OeREBKRM_V2_0.Amt",
                pretty_print=pretty_print,
            )
        for OeREBKRM_V2_0_Dokumente_ in self.OeREBKRM_V2_0_Dokumente:
            namespaceprefix_ = (
                self.OeREBKRM_V2_0_Dokumente_nsprefix_ + ":"
                if (UseCapturedNS_ and self.OeREBKRM_V2_0_Dokumente_nsprefix_)
                else ""
            )
            OeREBKRM_V2_0_Dokumente_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="OeREBKRM_V2_0.Dokumente",
                pretty_print=pretty_print,
            )
        for OeREBKRMtrsfr_V2_0_Transferstruktur_ in self.OeREBKRMtrsfr_V2_0_Transferstruktur:
            namespaceprefix_ = (
                self.OeREBKRMtrsfr_V2_0_Transferstruktur_nsprefix_ + ":"
                if (UseCapturedNS_ and self.OeREBKRMtrsfr_V2_0_Transferstruktur_nsprefix_)
                else ""
            )
            OeREBKRMtrsfr_V2_0_Transferstruktur_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="OeREBKRMtrsfr_V2_0.Transferstruktur",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "AdministrativeUnitsCH_V1.CHCantons":
            obj_ = AdministrativeUnitsCH_V1_CHCantons.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AdministrativeUnitsCH_V1_CHCantons.append(obj_)
            obj_.original_tagname_ = "AdministrativeUnitsCH_V1.CHCantons"
        elif nodeName_ == "AdministrativeUnitsCH_V1.CHDistricts":
            obj_ = AdministrativeUnitsCH_V1_CHDistricts.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AdministrativeUnitsCH_V1_CHDistricts.append(obj_)
            obj_.original_tagname_ = "AdministrativeUnitsCH_V1.CHDistricts"
        elif nodeName_ == "AdministrativeUnitsCH_V1.CHMunicipalities":
            obj_ = AdministrativeUnitsCH_V1_CHMunicipalities.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AdministrativeUnitsCH_V1_CHMunicipalities.append(obj_)
            obj_.original_tagname_ = "AdministrativeUnitsCH_V1.CHMunicipalities"
        elif nodeName_ == "AdministrativeUnitsCH_V1.CHAdministrativeUnions":
            obj_ = AdministrativeUnitsCH_V1_CHAdministrativeUnions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AdministrativeUnitsCH_V1_CHAdministrativeUnions.append(obj_)
            obj_.original_tagname_ = "AdministrativeUnitsCH_V1.CHAdministrativeUnions"
        elif nodeName_ == "AdministrativeUnitsCH_V1.CHAgencies":
            obj_ = AdministrativeUnitsCH_V1_CHAgencies.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AdministrativeUnitsCH_V1_CHAgencies.append(obj_)
            obj_.original_tagname_ = "AdministrativeUnitsCH_V1.CHAgencies"
        elif nodeName_ == "AdministrativeUnits_V1.Countries":
            obj_ = AdministrativeUnits_V1_Countries.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AdministrativeUnits_V1_Countries.append(obj_)
            obj_.original_tagname_ = "AdministrativeUnits_V1.Countries"
        elif nodeName_ == "AdministrativeUnits_V1.CountryNames":
            obj_ = AdministrativeUnits_V1_CountryNames.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AdministrativeUnits_V1_CountryNames.append(obj_)
            obj_.original_tagname_ = "AdministrativeUnits_V1.CountryNames"
        elif nodeName_ == "CoordSys.CoordsysTopic":
            obj_ = CoordSys_CoordsysTopic.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CoordSys_CoordsysTopic.append(obj_)
            obj_.original_tagname_ = "CoordSys.CoordsysTopic"
        elif nodeName_ == "OeREBKRM_V2_0.Amt":
            obj_ = OeREBKRM_V2_0_Amt.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OeREBKRM_V2_0_Amt.append(obj_)
            obj_.original_tagname_ = "OeREBKRM_V2_0.Amt"
        elif nodeName_ == "OeREBKRM_V2_0.Dokumente":
            obj_ = OeREBKRM_V2_0_Dokumente.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OeREBKRM_V2_0_Dokumente.append(obj_)
            obj_.original_tagname_ = "OeREBKRM_V2_0.Dokumente"
        elif nodeName_ == "OeREBKRMtrsfr_V2_0.Transferstruktur":
            obj_ = OeREBKRMtrsfr_V2_0_Transferstruktur.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OeREBKRMtrsfr_V2_0_Transferstruktur.append(obj_)
            obj_.original_tagname_ = "OeREBKRMtrsfr_V2_0.Transferstruktur"


# end class DataSection


class AdministrativeUnitsCH_V1_CHCantons_CHCanton(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "TID": MemberSpec_("TID", "IliID", 0, 0, {"use": "required", "name": "TID"}),
        "UpperLevelUnit": MemberSpec_(
            "UpperLevelUnit",
            "UpperLevelUnitType",
            0,
            0,
            {"name": "UpperLevelUnit", "type": "UpperLevelUnitType"},
            None,
        ),
        "Code": MemberSpec_(
            "Code",
            ["CHAdminCodes_V1.CHCantonCode", "xsd:string"],
            0,
            0,
            {"name": "Code", "type": "xsd:string"},
            None,
        ),
        "Name": MemberSpec_(
            "Name",
            "NameType",
            0,
            1,
            {"minOccurs": "0", "name": "Name", "type": "NameType"},
            None,
        ),
        "Web": MemberSpec_(
            "Web",
            ["INTERLIS.URI", "xsd:normalizedString"],
            0,
            1,
            {"minOccurs": "0", "name": "Web", "type": "xsd:normalizedString"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(
        self, TID=None, UpperLevelUnit=None, Code=None, Name=None, Web=None, gds_collector_=None, **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.TID = _cast(None, TID)
        self.TID_nsprefix_ = None
        if UpperLevelUnit is None:
            self.UpperLevelUnit = globals()["UpperLevelUnitType"]()
        else:
            self.UpperLevelUnit = UpperLevelUnit
        self.UpperLevelUnit_nsprefix_ = None
        self.Code = Code
        self.validate_CHAdminCodes_V1_CHCantonCode(self.Code)
        self.Code_nsprefix_ = None
        self.Name = Name
        self.Name_nsprefix_ = None
        self.Web = Web
        self.validate_INTERLIS_URI(self.Web)
        self.Web_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdministrativeUnitsCH_V1_CHCantons_CHCanton
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdministrativeUnitsCH_V1_CHCantons_CHCanton.subclass:
            return AdministrativeUnitsCH_V1_CHCantons_CHCanton.subclass(*args_, **kwargs_)
        else:
            return AdministrativeUnitsCH_V1_CHCantons_CHCanton(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_UpperLevelUnit(self):
        return self.UpperLevelUnit

    def set_UpperLevelUnit(self, UpperLevelUnit):
        self.UpperLevelUnit = UpperLevelUnit

    def get_Code(self):
        return self.Code

    def set_Code(self, Code):
        self.Code = Code

    def get_Name(self):
        return self.Name

    def set_Name(self, Name):
        self.Name = Name

    def get_Web(self):
        return self.Web

    def set_Web(self, Web):
        self.Web = Web

    def get_TID(self):
        return self.TID

    def set_TID(self, TID):
        self.TID = TID

    def validate_CHAdminCodes_V1_CHCantonCode(self, value):
        result = True
        # Validate type CHAdminCodes_V1.CHCantonCode, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            value = value
            enumerations = [
                "ZH",
                "BE",
                "LU",
                "UR",
                "SZ",
                "OW",
                "NW",
                "GL",
                "ZG",
                "FR",
                "SO",
                "BS",
                "BL",
                "SH",
                "AR",
                "AI",
                "SG",
                "GR",
                "AG",
                "TG",
                "TI",
                "VD",
                "VS",
                "NE",
                "GE",
                "JU",
                "FL",
                "CH",
            ]
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on CHAdminCodes_V1.CHCantonCode'
                    % {"value": encode_str_2_3(value), "lineno": lineno}
                )
                result = False
        return result

    def validate_INTERLIS_URI(self, value):
        result = True
        # Validate type INTERLIS.URI, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if len(value) > 1023:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on INTERLIS.URI'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if (
            self.UpperLevelUnit is not None
            or self.Code is not None
            or self.Name is not None
            or self.Web is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AdministrativeUnitsCH_V1.CHCantons.CHCanton",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("AdministrativeUnitsCH_V1.CHCantons.CHCanton")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "AdministrativeUnitsCH_V1.CHCantons.CHCanton":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="AdministrativeUnitsCH_V1.CHCantons.CHCanton",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="AdministrativeUnitsCH_V1.CHCantons.CHCanton",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="AdministrativeUnitsCH_V1.CHCantons.CHCanton",
    ):
        if self.TID is not None and "TID" not in already_processed:
            already_processed.add("TID")
            outfile.write(
                " TID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.TID), input_name="TID")),)
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AdministrativeUnitsCH_V1.CHCantons.CHCanton",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.UpperLevelUnit is not None:
            namespaceprefix_ = (
                self.UpperLevelUnit_nsprefix_ + ":"
                if (UseCapturedNS_ and self.UpperLevelUnit_nsprefix_)
                else ""
            )
            self.UpperLevelUnit.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="UpperLevelUnit",
                pretty_print=pretty_print,
            )
        if self.Code is not None:
            namespaceprefix_ = self.Code_nsprefix_ + ":" if (UseCapturedNS_ and self.Code_nsprefix_) else ""
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sCode>%s</%sCode>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(self.gds_format_string(quote_xml(self.Code), input_name="Code")),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.Name is not None:
            namespaceprefix_ = self.Name_nsprefix_ + ":" if (UseCapturedNS_ and self.Name_nsprefix_) else ""
            self.Name.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Name",
                pretty_print=pretty_print,
            )
        if self.Web is not None:
            namespaceprefix_ = self.Web_nsprefix_ + ":" if (UseCapturedNS_ and self.Web_nsprefix_) else ""
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sWeb>%s</%sWeb>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(self.gds_format_string(quote_xml(self.Web), input_name="Web")),
                    namespaceprefix_,
                    eol_,
                )
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("TID", node)
        if value is not None and "TID" not in already_processed:
            already_processed.add("TID")
            self.TID = value
            self.validate_IliID(self.TID)  # validate type IliID

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "UpperLevelUnit":
            obj_ = UpperLevelUnitType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.UpperLevelUnit = obj_
            obj_.original_tagname_ = "UpperLevelUnit"
        elif nodeName_ == "Code":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Code")
            value_ = self.gds_validate_string(value_, node, "Code")
            self.Code = value_
            self.Code_nsprefix_ = child_.prefix
            # validate type CHAdminCodes_V1.CHCantonCode
            self.validate_CHAdminCodes_V1_CHCantonCode(self.Code)
        elif nodeName_ == "Name":
            obj_ = NameType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Name = obj_
            obj_.original_tagname_ = "Name"
        elif nodeName_ == "Web":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Web")
            value_ = self.gds_validate_string(value_, node, "Web")
            self.Web = value_
            self.Web_nsprefix_ = child_.prefix
            # validate type INTERLIS.URI
            self.validate_INTERLIS_URI(self.Web)


# end class AdministrativeUnitsCH_V1_CHCantons_CHCanton


class AdministrativeUnitsCH_V1_CHCantons(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "BID": MemberSpec_("BID", "IliID", 0, 0, {"use": "required", "name": "BID"}),
        "AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit": MemberSpec_(
            "AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit",
            "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnit",
            1,
            1,
            {
                "name": "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnit",
                "type": "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnit",
            },
            2,
        ),
        "AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion": MemberSpec_(
            "AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion",
            "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnion",
            1,
            1,
            {
                "name": "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnion",
                "type": "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnion",
            },
            2,
        ),
        "AdministrativeUnits_V1_AdministrativeUnits_UnionMembers": MemberSpec_(
            "AdministrativeUnits_V1_AdministrativeUnits_UnionMembers",
            "AdministrativeUnits_V1.AdministrativeUnits.UnionMembers",
            1,
            1,
            {
                "name": "AdministrativeUnits_V1.AdministrativeUnits.UnionMembers",
                "type": "AdministrativeUnits_V1.AdministrativeUnits.UnionMembers",
            },
            2,
        ),
        "AdministrativeUnitsCH_V1_CHCantons_CHCanton": MemberSpec_(
            "AdministrativeUnitsCH_V1_CHCantons_CHCanton",
            "AdministrativeUnitsCH_V1.CHCantons.CHCanton",
            1,
            1,
            {
                "name": "AdministrativeUnitsCH_V1.CHCantons.CHCanton",
                "type": "AdministrativeUnitsCH_V1.CHCantons.CHCanton",
            },
            2,
        ),
    }
    subclass = None
    superclass = None

    def __init__(
        self,
        BID=None,
        AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit=None,
        AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion=None,
        AdministrativeUnits_V1_AdministrativeUnits_UnionMembers=None,
        AdministrativeUnitsCH_V1_CHCantons_CHCanton=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.BID = _cast(None, BID)
        self.BID_nsprefix_ = None
        if AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit is None:
            self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit = []
        else:
            self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit = (
                AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit
            )
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit_nsprefix_ = None
        if AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion is None:
            self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion = []
        else:
            self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion = (
                AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion
            )
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion_nsprefix_ = None
        if AdministrativeUnits_V1_AdministrativeUnits_UnionMembers is None:
            self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers = []
        else:
            self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers = (
                AdministrativeUnits_V1_AdministrativeUnits_UnionMembers
            )
        self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers_nsprefix_ = None
        if AdministrativeUnitsCH_V1_CHCantons_CHCanton is None:
            self.AdministrativeUnitsCH_V1_CHCantons_CHCanton = []
        else:
            self.AdministrativeUnitsCH_V1_CHCantons_CHCanton = AdministrativeUnitsCH_V1_CHCantons_CHCanton
        self.AdministrativeUnitsCH_V1_CHCantons_CHCanton_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, AdministrativeUnitsCH_V1_CHCantons)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdministrativeUnitsCH_V1_CHCantons.subclass:
            return AdministrativeUnitsCH_V1_CHCantons.subclass(*args_, **kwargs_)
        else:
            return AdministrativeUnitsCH_V1_CHCantons(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit(self):
        return self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit

    def set_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit(
        self, AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit
    ):
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit = (
            AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit
        )

    def add_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit(self, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit.append(value)

    def insert_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit_at(self, index, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit.insert(index, value)

    def replace_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit_at(self, index, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit[index] = value

    def get_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion(self):
        return self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion

    def set_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion(
        self, AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion
    ):
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion = (
            AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion
        )

    def add_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion(self, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion.append(value)

    def insert_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion_at(self, index, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion.insert(index, value)

    def replace_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion_at(self, index, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion[index] = value

    def get_AdministrativeUnits_V1_AdministrativeUnits_UnionMembers(self):
        return self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers

    def set_AdministrativeUnits_V1_AdministrativeUnits_UnionMembers(
        self, AdministrativeUnits_V1_AdministrativeUnits_UnionMembers
    ):
        self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers = (
            AdministrativeUnits_V1_AdministrativeUnits_UnionMembers
        )

    def add_AdministrativeUnits_V1_AdministrativeUnits_UnionMembers(self, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers.append(value)

    def insert_AdministrativeUnits_V1_AdministrativeUnits_UnionMembers_at(self, index, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers.insert(index, value)

    def replace_AdministrativeUnits_V1_AdministrativeUnits_UnionMembers_at(self, index, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers[index] = value

    def get_AdministrativeUnitsCH_V1_CHCantons_CHCanton(self):
        return self.AdministrativeUnitsCH_V1_CHCantons_CHCanton

    def set_AdministrativeUnitsCH_V1_CHCantons_CHCanton(self, AdministrativeUnitsCH_V1_CHCantons_CHCanton):
        self.AdministrativeUnitsCH_V1_CHCantons_CHCanton = AdministrativeUnitsCH_V1_CHCantons_CHCanton

    def add_AdministrativeUnitsCH_V1_CHCantons_CHCanton(self, value):
        self.AdministrativeUnitsCH_V1_CHCantons_CHCanton.append(value)

    def insert_AdministrativeUnitsCH_V1_CHCantons_CHCanton_at(self, index, value):
        self.AdministrativeUnitsCH_V1_CHCantons_CHCanton.insert(index, value)

    def replace_AdministrativeUnitsCH_V1_CHCantons_CHCanton_at(self, index, value):
        self.AdministrativeUnitsCH_V1_CHCantons_CHCanton[index] = value

    def get_BID(self):
        return self.BID

    def set_BID(self, BID):
        self.BID = BID

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if (
            self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit
            or self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion
            or self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers
            or self.AdministrativeUnitsCH_V1_CHCantons_CHCanton
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AdministrativeUnitsCH_V1.CHCantons",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("AdministrativeUnitsCH_V1.CHCantons")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "AdministrativeUnitsCH_V1.CHCantons":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="AdministrativeUnitsCH_V1.CHCantons",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="AdministrativeUnitsCH_V1.CHCantons",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="AdministrativeUnitsCH_V1.CHCantons",
    ):
        if self.BID is not None and "BID" not in already_processed:
            already_processed.add("BID")
            outfile.write(
                " BID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.BID), input_name="BID")),)
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AdministrativeUnitsCH_V1.CHCantons",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for (
            AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit_
        ) in self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit:
            namespaceprefix_ = (
                self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit_nsprefix_ + ":"
                if (
                    UseCapturedNS_
                    and self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit_nsprefix_
                )
                else ""
            )
            AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnit",
                pretty_print=pretty_print,
            )
        for (
            AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion_
        ) in self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion:
            namespaceprefix_ = (
                self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion_nsprefix_ + ":"
                if (
                    UseCapturedNS_
                    and self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion_nsprefix_
                )
                else ""
            )
            AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnion",
                pretty_print=pretty_print,
            )
        for (
            AdministrativeUnits_V1_AdministrativeUnits_UnionMembers_
        ) in self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers:
            namespaceprefix_ = (
                self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers_nsprefix_ + ":"
                if (UseCapturedNS_ and self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers_nsprefix_)
                else ""
            )
            AdministrativeUnits_V1_AdministrativeUnits_UnionMembers_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="AdministrativeUnits_V1.AdministrativeUnits.UnionMembers",
                pretty_print=pretty_print,
            )
        for AdministrativeUnitsCH_V1_CHCantons_CHCanton_ in self.AdministrativeUnitsCH_V1_CHCantons_CHCanton:
            namespaceprefix_ = (
                self.AdministrativeUnitsCH_V1_CHCantons_CHCanton_nsprefix_ + ":"
                if (UseCapturedNS_ and self.AdministrativeUnitsCH_V1_CHCantons_CHCanton_nsprefix_)
                else ""
            )
            AdministrativeUnitsCH_V1_CHCantons_CHCanton_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="AdministrativeUnitsCH_V1.CHCantons.CHCanton",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("BID", node)
        if value is not None and "BID" not in already_processed:
            already_processed.add("BID")
            self.BID = value
            self.validate_IliID(self.BID)  # validate type IliID

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnit":
            obj_ = AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit.append(obj_)
            obj_.original_tagname_ = "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnit"
        elif nodeName_ == "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnion":
            obj_ = AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion.append(obj_)
            obj_.original_tagname_ = "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnion"
        elif nodeName_ == "AdministrativeUnits_V1.AdministrativeUnits.UnionMembers":
            obj_ = AdministrativeUnits_V1_AdministrativeUnits_UnionMembers.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers.append(obj_)
            obj_.original_tagname_ = "AdministrativeUnits_V1.AdministrativeUnits.UnionMembers"
        elif nodeName_ == "AdministrativeUnitsCH_V1.CHCantons.CHCanton":
            obj_ = AdministrativeUnitsCH_V1_CHCantons_CHCanton.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AdministrativeUnitsCH_V1_CHCantons_CHCanton.append(obj_)
            obj_.original_tagname_ = "AdministrativeUnitsCH_V1.CHCantons.CHCanton"


# end class AdministrativeUnitsCH_V1_CHCantons


class AdministrativeUnitsCH_V1_CHDistricts_CHDistrict(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "TID": MemberSpec_("TID", "IliID", 0, 0, {"use": "required", "name": "TID"}),
        "UpperLevelUnit": MemberSpec_(
            "UpperLevelUnit",
            "UpperLevelUnitType1",
            0,
            0,
            {"name": "UpperLevelUnit", "type": "UpperLevelUnitType1"},
            None,
        ),
        "ShortName": MemberSpec_(
            "ShortName",
            ["ShortNameType", "xsd:normalizedString"],
            0,
            0,
            {"name": "ShortName", "type": "xsd:normalizedString"},
            None,
        ),
        "Name": MemberSpec_(
            "Name",
            "NameType2",
            0,
            1,
            {"minOccurs": "0", "name": "Name", "type": "NameType2"},
            None,
        ),
        "Web": MemberSpec_(
            "Web",
            ["INTERLIS.URI", "xsd:normalizedString"],
            0,
            0,
            {"name": "Web", "type": "xsd:normalizedString"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(
        self,
        TID=None,
        UpperLevelUnit=None,
        ShortName=None,
        Name=None,
        Web=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.TID = _cast(None, TID)
        self.TID_nsprefix_ = None
        if UpperLevelUnit is None:
            self.UpperLevelUnit = globals()["UpperLevelUnitType1"]()
        else:
            self.UpperLevelUnit = UpperLevelUnit
        self.UpperLevelUnit_nsprefix_ = None
        self.ShortName = ShortName
        self.validate_ShortNameType(self.ShortName)
        self.ShortName_nsprefix_ = None
        self.Name = Name
        self.Name_nsprefix_ = None
        self.Web = Web
        self.validate_INTERLIS_URI(self.Web)
        self.Web_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdministrativeUnitsCH_V1_CHDistricts_CHDistrict
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdministrativeUnitsCH_V1_CHDistricts_CHDistrict.subclass:
            return AdministrativeUnitsCH_V1_CHDistricts_CHDistrict.subclass(*args_, **kwargs_)
        else:
            return AdministrativeUnitsCH_V1_CHDistricts_CHDistrict(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_UpperLevelUnit(self):
        return self.UpperLevelUnit

    def set_UpperLevelUnit(self, UpperLevelUnit):
        self.UpperLevelUnit = UpperLevelUnit

    def get_ShortName(self):
        return self.ShortName

    def set_ShortName(self, ShortName):
        self.ShortName = ShortName

    def get_Name(self):
        return self.Name

    def set_Name(self, Name):
        self.Name = Name

    def get_Web(self):
        return self.Web

    def set_Web(self, Web):
        self.Web = Web

    def get_TID(self):
        return self.TID

    def set_TID(self, TID):
        self.TID = TID

    def validate_ShortNameType(self, value):
        result = True
        # Validate type ShortNameType, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ShortNameType'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_INTERLIS_URI(self, value):
        result = True
        # Validate type INTERLIS.URI, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if len(value) > 1023:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on INTERLIS.URI'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if (
            self.UpperLevelUnit is not None
            or self.ShortName is not None
            or self.Name is not None
            or self.Web is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AdministrativeUnitsCH_V1.CHDistricts.CHDistrict",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("AdministrativeUnitsCH_V1.CHDistricts.CHDistrict")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "AdministrativeUnitsCH_V1.CHDistricts.CHDistrict":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="AdministrativeUnitsCH_V1.CHDistricts.CHDistrict",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="AdministrativeUnitsCH_V1.CHDistricts.CHDistrict",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="AdministrativeUnitsCH_V1.CHDistricts.CHDistrict",
    ):
        if self.TID is not None and "TID" not in already_processed:
            already_processed.add("TID")
            outfile.write(
                " TID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.TID), input_name="TID")),)
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AdministrativeUnitsCH_V1.CHDistricts.CHDistrict",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.UpperLevelUnit is not None:
            namespaceprefix_ = (
                self.UpperLevelUnit_nsprefix_ + ":"
                if (UseCapturedNS_ and self.UpperLevelUnit_nsprefix_)
                else ""
            )
            self.UpperLevelUnit.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="UpperLevelUnit",
                pretty_print=pretty_print,
            )
        if self.ShortName is not None:
            namespaceprefix_ = (
                self.ShortName_nsprefix_ + ":" if (UseCapturedNS_ and self.ShortName_nsprefix_) else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sShortName>%s</%sShortName>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(quote_xml(self.ShortName), input_name="ShortName")
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.Name is not None:
            namespaceprefix_ = self.Name_nsprefix_ + ":" if (UseCapturedNS_ and self.Name_nsprefix_) else ""
            self.Name.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Name",
                pretty_print=pretty_print,
            )
        if self.Web is not None:
            namespaceprefix_ = self.Web_nsprefix_ + ":" if (UseCapturedNS_ and self.Web_nsprefix_) else ""
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sWeb>%s</%sWeb>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(self.gds_format_string(quote_xml(self.Web), input_name="Web")),
                    namespaceprefix_,
                    eol_,
                )
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("TID", node)
        if value is not None and "TID" not in already_processed:
            already_processed.add("TID")
            self.TID = value
            self.validate_IliID(self.TID)  # validate type IliID

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "UpperLevelUnit":
            obj_ = UpperLevelUnitType1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.UpperLevelUnit = obj_
            obj_.original_tagname_ = "UpperLevelUnit"
        elif nodeName_ == "ShortName":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "ShortName")
            value_ = self.gds_validate_string(value_, node, "ShortName")
            self.ShortName = value_
            self.ShortName_nsprefix_ = child_.prefix
            # validate type ShortNameType
            self.validate_ShortNameType(self.ShortName)
        elif nodeName_ == "Name":
            obj_ = NameType2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Name = obj_
            obj_.original_tagname_ = "Name"
        elif nodeName_ == "Web":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Web")
            value_ = self.gds_validate_string(value_, node, "Web")
            self.Web = value_
            self.Web_nsprefix_ = child_.prefix
            # validate type INTERLIS.URI
            self.validate_INTERLIS_URI(self.Web)


# end class AdministrativeUnitsCH_V1_CHDistricts_CHDistrict


class AdministrativeUnitsCH_V1_CHDistricts(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "BID": MemberSpec_("BID", "IliID", 0, 0, {"use": "required", "name": "BID"}),
        "AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit": MemberSpec_(
            "AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit",
            "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnit",
            1,
            1,
            {
                "name": "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnit",
                "type": "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnit",
            },
            3,
        ),
        "AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion": MemberSpec_(
            "AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion",
            "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnion",
            1,
            1,
            {
                "name": "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnion",
                "type": "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnion",
            },
            3,
        ),
        "AdministrativeUnits_V1_AdministrativeUnits_UnionMembers": MemberSpec_(
            "AdministrativeUnits_V1_AdministrativeUnits_UnionMembers",
            "AdministrativeUnits_V1.AdministrativeUnits.UnionMembers",
            1,
            1,
            {
                "name": "AdministrativeUnits_V1.AdministrativeUnits.UnionMembers",
                "type": "AdministrativeUnits_V1.AdministrativeUnits.UnionMembers",
            },
            3,
        ),
        "AdministrativeUnitsCH_V1_CHDistricts_CHDistrict": MemberSpec_(
            "AdministrativeUnitsCH_V1_CHDistricts_CHDistrict",
            "AdministrativeUnitsCH_V1.CHDistricts.CHDistrict",
            1,
            1,
            {
                "name": "AdministrativeUnitsCH_V1.CHDistricts.CHDistrict",
                "type": "AdministrativeUnitsCH_V1.CHDistricts.CHDistrict",
            },
            3,
        ),
    }
    subclass = None
    superclass = None

    def __init__(
        self,
        BID=None,
        AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit=None,
        AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion=None,
        AdministrativeUnits_V1_AdministrativeUnits_UnionMembers=None,
        AdministrativeUnitsCH_V1_CHDistricts_CHDistrict=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.BID = _cast(None, BID)
        self.BID_nsprefix_ = None
        if AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit is None:
            self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit = []
        else:
            self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit = (
                AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit
            )
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit_nsprefix_ = None
        if AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion is None:
            self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion = []
        else:
            self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion = (
                AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion
            )
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion_nsprefix_ = None
        if AdministrativeUnits_V1_AdministrativeUnits_UnionMembers is None:
            self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers = []
        else:
            self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers = (
                AdministrativeUnits_V1_AdministrativeUnits_UnionMembers
            )
        self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers_nsprefix_ = None
        if AdministrativeUnitsCH_V1_CHDistricts_CHDistrict is None:
            self.AdministrativeUnitsCH_V1_CHDistricts_CHDistrict = []
        else:
            self.AdministrativeUnitsCH_V1_CHDistricts_CHDistrict = (
                AdministrativeUnitsCH_V1_CHDistricts_CHDistrict
            )
        self.AdministrativeUnitsCH_V1_CHDistricts_CHDistrict_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, AdministrativeUnitsCH_V1_CHDistricts)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdministrativeUnitsCH_V1_CHDistricts.subclass:
            return AdministrativeUnitsCH_V1_CHDistricts.subclass(*args_, **kwargs_)
        else:
            return AdministrativeUnitsCH_V1_CHDistricts(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit(self):
        return self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit

    def set_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit(
        self, AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit
    ):
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit = (
            AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit
        )

    def add_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit(self, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit.append(value)

    def insert_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit_at(self, index, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit.insert(index, value)

    def replace_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit_at(self, index, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit[index] = value

    def get_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion(self):
        return self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion

    def set_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion(
        self, AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion
    ):
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion = (
            AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion
        )

    def add_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion(self, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion.append(value)

    def insert_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion_at(self, index, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion.insert(index, value)

    def replace_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion_at(self, index, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion[index] = value

    def get_AdministrativeUnits_V1_AdministrativeUnits_UnionMembers(self):
        return self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers

    def set_AdministrativeUnits_V1_AdministrativeUnits_UnionMembers(
        self, AdministrativeUnits_V1_AdministrativeUnits_UnionMembers
    ):
        self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers = (
            AdministrativeUnits_V1_AdministrativeUnits_UnionMembers
        )

    def add_AdministrativeUnits_V1_AdministrativeUnits_UnionMembers(self, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers.append(value)

    def insert_AdministrativeUnits_V1_AdministrativeUnits_UnionMembers_at(self, index, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers.insert(index, value)

    def replace_AdministrativeUnits_V1_AdministrativeUnits_UnionMembers_at(self, index, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers[index] = value

    def get_AdministrativeUnitsCH_V1_CHDistricts_CHDistrict(self):
        return self.AdministrativeUnitsCH_V1_CHDistricts_CHDistrict

    def set_AdministrativeUnitsCH_V1_CHDistricts_CHDistrict(
        self, AdministrativeUnitsCH_V1_CHDistricts_CHDistrict
    ):
        self.AdministrativeUnitsCH_V1_CHDistricts_CHDistrict = AdministrativeUnitsCH_V1_CHDistricts_CHDistrict

    def add_AdministrativeUnitsCH_V1_CHDistricts_CHDistrict(self, value):
        self.AdministrativeUnitsCH_V1_CHDistricts_CHDistrict.append(value)

    def insert_AdministrativeUnitsCH_V1_CHDistricts_CHDistrict_at(self, index, value):
        self.AdministrativeUnitsCH_V1_CHDistricts_CHDistrict.insert(index, value)

    def replace_AdministrativeUnitsCH_V1_CHDistricts_CHDistrict_at(self, index, value):
        self.AdministrativeUnitsCH_V1_CHDistricts_CHDistrict[index] = value

    def get_BID(self):
        return self.BID

    def set_BID(self, BID):
        self.BID = BID

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if (
            self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit
            or self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion
            or self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers
            or self.AdministrativeUnitsCH_V1_CHDistricts_CHDistrict
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AdministrativeUnitsCH_V1.CHDistricts",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("AdministrativeUnitsCH_V1.CHDistricts")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "AdministrativeUnitsCH_V1.CHDistricts":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="AdministrativeUnitsCH_V1.CHDistricts",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="AdministrativeUnitsCH_V1.CHDistricts",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="AdministrativeUnitsCH_V1.CHDistricts",
    ):
        if self.BID is not None and "BID" not in already_processed:
            already_processed.add("BID")
            outfile.write(
                " BID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.BID), input_name="BID")),)
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AdministrativeUnitsCH_V1.CHDistricts",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for (
            AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit_
        ) in self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit:
            namespaceprefix_ = (
                self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit_nsprefix_ + ":"
                if (
                    UseCapturedNS_
                    and self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit_nsprefix_
                )
                else ""
            )
            AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnit",
                pretty_print=pretty_print,
            )
        for (
            AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion_
        ) in self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion:
            namespaceprefix_ = (
                self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion_nsprefix_ + ":"
                if (
                    UseCapturedNS_
                    and self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion_nsprefix_
                )
                else ""
            )
            AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnion",
                pretty_print=pretty_print,
            )
        for (
            AdministrativeUnits_V1_AdministrativeUnits_UnionMembers_
        ) in self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers:
            namespaceprefix_ = (
                self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers_nsprefix_ + ":"
                if (UseCapturedNS_ and self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers_nsprefix_)
                else ""
            )
            AdministrativeUnits_V1_AdministrativeUnits_UnionMembers_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="AdministrativeUnits_V1.AdministrativeUnits.UnionMembers",
                pretty_print=pretty_print,
            )
        for (
            AdministrativeUnitsCH_V1_CHDistricts_CHDistrict_
        ) in self.AdministrativeUnitsCH_V1_CHDistricts_CHDistrict:
            namespaceprefix_ = (
                self.AdministrativeUnitsCH_V1_CHDistricts_CHDistrict_nsprefix_ + ":"
                if (UseCapturedNS_ and self.AdministrativeUnitsCH_V1_CHDistricts_CHDistrict_nsprefix_)
                else ""
            )
            AdministrativeUnitsCH_V1_CHDistricts_CHDistrict_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="AdministrativeUnitsCH_V1.CHDistricts.CHDistrict",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("BID", node)
        if value is not None and "BID" not in already_processed:
            already_processed.add("BID")
            self.BID = value
            self.validate_IliID(self.BID)  # validate type IliID

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnit":
            obj_ = AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit.append(obj_)
            obj_.original_tagname_ = "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnit"
        elif nodeName_ == "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnion":
            obj_ = AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion.append(obj_)
            obj_.original_tagname_ = "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnion"
        elif nodeName_ == "AdministrativeUnits_V1.AdministrativeUnits.UnionMembers":
            obj_ = AdministrativeUnits_V1_AdministrativeUnits_UnionMembers.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers.append(obj_)
            obj_.original_tagname_ = "AdministrativeUnits_V1.AdministrativeUnits.UnionMembers"
        elif nodeName_ == "AdministrativeUnitsCH_V1.CHDistricts.CHDistrict":
            obj_ = AdministrativeUnitsCH_V1_CHDistricts_CHDistrict.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AdministrativeUnitsCH_V1_CHDistricts_CHDistrict.append(obj_)
            obj_.original_tagname_ = "AdministrativeUnitsCH_V1.CHDistricts.CHDistrict"


# end class AdministrativeUnitsCH_V1_CHDistricts


class AdministrativeUnitsCH_V1_CHMunicipalities_CHMunicipality(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "TID": MemberSpec_("TID", "IliID", 0, 0, {"use": "required", "name": "TID"}),
        "UpperLevelUnit": MemberSpec_(
            "UpperLevelUnit",
            "UpperLevelUnitType3",
            0,
            0,
            {"name": "UpperLevelUnit", "type": "UpperLevelUnitType3"},
            None,
        ),
        "Code": MemberSpec_(
            "Code",
            ["CHAdminCodes_V1.CHMunicipalityCode", "xsd:integer"],
            0,
            0,
            {"name": "Code", "type": "xsd:integer"},
            None,
        ),
        "Name": MemberSpec_(
            "Name",
            "NameType4",
            0,
            1,
            {"minOccurs": "0", "name": "Name", "type": "NameType4"},
            None,
        ),
        "Web": MemberSpec_(
            "Web",
            ["INTERLIS.URI", "xsd:normalizedString"],
            0,
            1,
            {"minOccurs": "0", "name": "Web", "type": "xsd:normalizedString"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(
        self, TID=None, UpperLevelUnit=None, Code=None, Name=None, Web=None, gds_collector_=None, **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.TID = _cast(None, TID)
        self.TID_nsprefix_ = None
        if UpperLevelUnit is None:
            self.UpperLevelUnit = globals()["UpperLevelUnitType3"]()
        else:
            self.UpperLevelUnit = UpperLevelUnit
        self.UpperLevelUnit_nsprefix_ = None
        self.Code = Code
        self.validate_CHAdminCodes_V1_CHMunicipalityCode(self.Code)
        self.Code_nsprefix_ = None
        self.Name = Name
        self.Name_nsprefix_ = None
        self.Web = Web
        self.validate_INTERLIS_URI(self.Web)
        self.Web_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_,
                AdministrativeUnitsCH_V1_CHMunicipalities_CHMunicipality,
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdministrativeUnitsCH_V1_CHMunicipalities_CHMunicipality.subclass:
            return AdministrativeUnitsCH_V1_CHMunicipalities_CHMunicipality.subclass(*args_, **kwargs_)
        else:
            return AdministrativeUnitsCH_V1_CHMunicipalities_CHMunicipality(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_UpperLevelUnit(self):
        return self.UpperLevelUnit

    def set_UpperLevelUnit(self, UpperLevelUnit):
        self.UpperLevelUnit = UpperLevelUnit

    def get_Code(self):
        return self.Code

    def set_Code(self, Code):
        self.Code = Code

    def get_Name(self):
        return self.Name

    def set_Name(self, Name):
        self.Name = Name

    def get_Web(self):
        return self.Web

    def set_Web(self, Web):
        self.Web = Web

    def get_TID(self):
        return self.TID

    def set_TID(self, TID):
        self.TID = TID

    def validate_CHAdminCodes_V1_CHMunicipalityCode(self, value):
        result = True
        # Validate type CHAdminCodes_V1.CHMunicipalityCode, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on CHAdminCodes_V1.CHMunicipalityCode'
                    % {"value": value, "lineno": lineno}
                )
                result = False
            if value > 9999:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on CHAdminCodes_V1.CHMunicipalityCode'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_INTERLIS_URI(self, value):
        result = True
        # Validate type INTERLIS.URI, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if len(value) > 1023:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on INTERLIS.URI'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if (
            self.UpperLevelUnit is not None
            or self.Code is not None
            or self.Name is not None
            or self.Web is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AdministrativeUnitsCH_V1.CHMunicipalities.CHMunicipality",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get(
            "AdministrativeUnitsCH_V1.CHMunicipalities.CHMunicipality"
        )
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if (
            self.original_tagname_ is not None
            and name_ == "AdministrativeUnitsCH_V1.CHMunicipalities.CHMunicipality"
        ):
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="AdministrativeUnitsCH_V1.CHMunicipalities.CHMunicipality",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="AdministrativeUnitsCH_V1.CHMunicipalities.CHMunicipality",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="AdministrativeUnitsCH_V1.CHMunicipalities.CHMunicipality",
    ):
        if self.TID is not None and "TID" not in already_processed:
            already_processed.add("TID")
            outfile.write(
                " TID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.TID), input_name="TID")),)
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AdministrativeUnitsCH_V1.CHMunicipalities.CHMunicipality",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.UpperLevelUnit is not None:
            namespaceprefix_ = (
                self.UpperLevelUnit_nsprefix_ + ":"
                if (UseCapturedNS_ and self.UpperLevelUnit_nsprefix_)
                else ""
            )
            self.UpperLevelUnit.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="UpperLevelUnit",
                pretty_print=pretty_print,
            )
        if self.Code is not None:
            namespaceprefix_ = self.Code_nsprefix_ + ":" if (UseCapturedNS_ and self.Code_nsprefix_) else ""
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sCode>%s</%sCode>%s"
                % (
                    namespaceprefix_,
                    self.gds_format_integer(self.Code, input_name="Code"),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.Name is not None:
            namespaceprefix_ = self.Name_nsprefix_ + ":" if (UseCapturedNS_ and self.Name_nsprefix_) else ""
            self.Name.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Name",
                pretty_print=pretty_print,
            )
        if self.Web is not None:
            namespaceprefix_ = self.Web_nsprefix_ + ":" if (UseCapturedNS_ and self.Web_nsprefix_) else ""
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sWeb>%s</%sWeb>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(self.gds_format_string(quote_xml(self.Web), input_name="Web")),
                    namespaceprefix_,
                    eol_,
                )
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("TID", node)
        if value is not None and "TID" not in already_processed:
            already_processed.add("TID")
            self.TID = value
            self.validate_IliID(self.TID)  # validate type IliID

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "UpperLevelUnit":
            obj_ = UpperLevelUnitType3.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.UpperLevelUnit = obj_
            obj_.original_tagname_ = "UpperLevelUnit"
        elif nodeName_ == "Code" and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, "Code")
            ival_ = self.gds_validate_integer(ival_, node, "Code")
            self.Code = ival_
            self.Code_nsprefix_ = child_.prefix
            # validate type CHAdminCodes_V1.CHMunicipalityCode
            self.validate_CHAdminCodes_V1_CHMunicipalityCode(self.Code)
        elif nodeName_ == "Name":
            obj_ = NameType4.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Name = obj_
            obj_.original_tagname_ = "Name"
        elif nodeName_ == "Web":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Web")
            value_ = self.gds_validate_string(value_, node, "Web")
            self.Web = value_
            self.Web_nsprefix_ = child_.prefix
            # validate type INTERLIS.URI
            self.validate_INTERLIS_URI(self.Web)


# end class AdministrativeUnitsCH_V1_CHMunicipalities_CHMunicipality


class AdministrativeUnitsCH_V1_CHMunicipalities(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "BID": MemberSpec_("BID", "IliID", 0, 0, {"use": "required", "name": "BID"}),
        "AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit": MemberSpec_(
            "AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit",
            "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnit",
            1,
            1,
            {
                "name": "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnit",
                "type": "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnit",
            },
            4,
        ),
        "AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion": MemberSpec_(
            "AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion",
            "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnion",
            1,
            1,
            {
                "name": "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnion",
                "type": "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnion",
            },
            4,
        ),
        "AdministrativeUnits_V1_AdministrativeUnits_UnionMembers": MemberSpec_(
            "AdministrativeUnits_V1_AdministrativeUnits_UnionMembers",
            "AdministrativeUnits_V1.AdministrativeUnits.UnionMembers",
            1,
            1,
            {
                "name": "AdministrativeUnits_V1.AdministrativeUnits.UnionMembers",
                "type": "AdministrativeUnits_V1.AdministrativeUnits.UnionMembers",
            },
            4,
        ),
        "AdministrativeUnitsCH_V1_CHMunicipalities_CHMunicipality": MemberSpec_(
            "AdministrativeUnitsCH_V1_CHMunicipalities_CHMunicipality",
            "AdministrativeUnitsCH_V1.CHMunicipalities.CHMunicipality",
            1,
            1,
            {
                "name": "AdministrativeUnitsCH_V1.CHMunicipalities.CHMunicipality",
                "type": "AdministrativeUnitsCH_V1.CHMunicipalities.CHMunicipality",
            },
            4,
        ),
    }
    subclass = None
    superclass = None

    def __init__(
        self,
        BID=None,
        AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit=None,
        AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion=None,
        AdministrativeUnits_V1_AdministrativeUnits_UnionMembers=None,
        AdministrativeUnitsCH_V1_CHMunicipalities_CHMunicipality=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.BID = _cast(None, BID)
        self.BID_nsprefix_ = None
        if AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit is None:
            self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit = []
        else:
            self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit = (
                AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit
            )
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit_nsprefix_ = None
        if AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion is None:
            self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion = []
        else:
            self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion = (
                AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion
            )
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion_nsprefix_ = None
        if AdministrativeUnits_V1_AdministrativeUnits_UnionMembers is None:
            self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers = []
        else:
            self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers = (
                AdministrativeUnits_V1_AdministrativeUnits_UnionMembers
            )
        self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers_nsprefix_ = None
        if AdministrativeUnitsCH_V1_CHMunicipalities_CHMunicipality is None:
            self.AdministrativeUnitsCH_V1_CHMunicipalities_CHMunicipality = []
        else:
            self.AdministrativeUnitsCH_V1_CHMunicipalities_CHMunicipality = (
                AdministrativeUnitsCH_V1_CHMunicipalities_CHMunicipality
            )
        self.AdministrativeUnitsCH_V1_CHMunicipalities_CHMunicipality_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdministrativeUnitsCH_V1_CHMunicipalities
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdministrativeUnitsCH_V1_CHMunicipalities.subclass:
            return AdministrativeUnitsCH_V1_CHMunicipalities.subclass(*args_, **kwargs_)
        else:
            return AdministrativeUnitsCH_V1_CHMunicipalities(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit(self):
        return self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit

    def set_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit(
        self, AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit
    ):
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit = (
            AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit
        )

    def add_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit(self, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit.append(value)

    def insert_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit_at(self, index, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit.insert(index, value)

    def replace_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit_at(self, index, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit[index] = value

    def get_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion(self):
        return self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion

    def set_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion(
        self, AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion
    ):
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion = (
            AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion
        )

    def add_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion(self, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion.append(value)

    def insert_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion_at(self, index, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion.insert(index, value)

    def replace_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion_at(self, index, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion[index] = value

    def get_AdministrativeUnits_V1_AdministrativeUnits_UnionMembers(self):
        return self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers

    def set_AdministrativeUnits_V1_AdministrativeUnits_UnionMembers(
        self, AdministrativeUnits_V1_AdministrativeUnits_UnionMembers
    ):
        self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers = (
            AdministrativeUnits_V1_AdministrativeUnits_UnionMembers
        )

    def add_AdministrativeUnits_V1_AdministrativeUnits_UnionMembers(self, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers.append(value)

    def insert_AdministrativeUnits_V1_AdministrativeUnits_UnionMembers_at(self, index, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers.insert(index, value)

    def replace_AdministrativeUnits_V1_AdministrativeUnits_UnionMembers_at(self, index, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers[index] = value

    def get_AdministrativeUnitsCH_V1_CHMunicipalities_CHMunicipality(self):
        return self.AdministrativeUnitsCH_V1_CHMunicipalities_CHMunicipality

    def set_AdministrativeUnitsCH_V1_CHMunicipalities_CHMunicipality(
        self, AdministrativeUnitsCH_V1_CHMunicipalities_CHMunicipality
    ):
        self.AdministrativeUnitsCH_V1_CHMunicipalities_CHMunicipality = (
            AdministrativeUnitsCH_V1_CHMunicipalities_CHMunicipality
        )

    def add_AdministrativeUnitsCH_V1_CHMunicipalities_CHMunicipality(self, value):
        self.AdministrativeUnitsCH_V1_CHMunicipalities_CHMunicipality.append(value)

    def insert_AdministrativeUnitsCH_V1_CHMunicipalities_CHMunicipality_at(self, index, value):
        self.AdministrativeUnitsCH_V1_CHMunicipalities_CHMunicipality.insert(index, value)

    def replace_AdministrativeUnitsCH_V1_CHMunicipalities_CHMunicipality_at(self, index, value):
        self.AdministrativeUnitsCH_V1_CHMunicipalities_CHMunicipality[index] = value

    def get_BID(self):
        return self.BID

    def set_BID(self, BID):
        self.BID = BID

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if (
            self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit
            or self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion
            or self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers
            or self.AdministrativeUnitsCH_V1_CHMunicipalities_CHMunicipality
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AdministrativeUnitsCH_V1.CHMunicipalities",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("AdministrativeUnitsCH_V1.CHMunicipalities")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "AdministrativeUnitsCH_V1.CHMunicipalities":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="AdministrativeUnitsCH_V1.CHMunicipalities",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="AdministrativeUnitsCH_V1.CHMunicipalities",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="AdministrativeUnitsCH_V1.CHMunicipalities",
    ):
        if self.BID is not None and "BID" not in already_processed:
            already_processed.add("BID")
            outfile.write(
                " BID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.BID), input_name="BID")),)
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AdministrativeUnitsCH_V1.CHMunicipalities",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for (
            AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit_
        ) in self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit:
            namespaceprefix_ = (
                self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit_nsprefix_ + ":"
                if (
                    UseCapturedNS_
                    and self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit_nsprefix_
                )
                else ""
            )
            AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnit",
                pretty_print=pretty_print,
            )
        for (
            AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion_
        ) in self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion:
            namespaceprefix_ = (
                self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion_nsprefix_ + ":"
                if (
                    UseCapturedNS_
                    and self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion_nsprefix_
                )
                else ""
            )
            AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnion",
                pretty_print=pretty_print,
            )
        for (
            AdministrativeUnits_V1_AdministrativeUnits_UnionMembers_
        ) in self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers:
            namespaceprefix_ = (
                self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers_nsprefix_ + ":"
                if (UseCapturedNS_ and self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers_nsprefix_)
                else ""
            )
            AdministrativeUnits_V1_AdministrativeUnits_UnionMembers_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="AdministrativeUnits_V1.AdministrativeUnits.UnionMembers",
                pretty_print=pretty_print,
            )
        for (
            AdministrativeUnitsCH_V1_CHMunicipalities_CHMunicipality_
        ) in self.AdministrativeUnitsCH_V1_CHMunicipalities_CHMunicipality:
            namespaceprefix_ = (
                self.AdministrativeUnitsCH_V1_CHMunicipalities_CHMunicipality_nsprefix_ + ":"
                if (
                    UseCapturedNS_ and self.AdministrativeUnitsCH_V1_CHMunicipalities_CHMunicipality_nsprefix_
                )
                else ""
            )
            AdministrativeUnitsCH_V1_CHMunicipalities_CHMunicipality_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="AdministrativeUnitsCH_V1.CHMunicipalities.CHMunicipality",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("BID", node)
        if value is not None and "BID" not in already_processed:
            already_processed.add("BID")
            self.BID = value
            self.validate_IliID(self.BID)  # validate type IliID

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnit":
            obj_ = AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit.append(obj_)
            obj_.original_tagname_ = "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnit"
        elif nodeName_ == "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnion":
            obj_ = AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion.append(obj_)
            obj_.original_tagname_ = "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnion"
        elif nodeName_ == "AdministrativeUnits_V1.AdministrativeUnits.UnionMembers":
            obj_ = AdministrativeUnits_V1_AdministrativeUnits_UnionMembers.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers.append(obj_)
            obj_.original_tagname_ = "AdministrativeUnits_V1.AdministrativeUnits.UnionMembers"
        elif nodeName_ == "AdministrativeUnitsCH_V1.CHMunicipalities.CHMunicipality":
            obj_ = AdministrativeUnitsCH_V1_CHMunicipalities_CHMunicipality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AdministrativeUnitsCH_V1_CHMunicipalities_CHMunicipality.append(obj_)
            obj_.original_tagname_ = "AdministrativeUnitsCH_V1.CHMunicipalities.CHMunicipality"


# end class AdministrativeUnitsCH_V1_CHMunicipalities


class AdministrativeUnitsCH_V1_CHAdministrativeUnions_AdministrativeUnion(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "TID": MemberSpec_("TID", "IliID", 0, 0, {"use": "required", "name": "TID"}),
        "Name": MemberSpec_(
            "Name",
            "NameType5",
            0,
            1,
            {"minOccurs": "0", "name": "Name", "type": "NameType5"},
            None,
        ),
        "Web": MemberSpec_(
            "Web",
            ["INTERLIS.URI", "xsd:normalizedString"],
            0,
            1,
            {"minOccurs": "0", "name": "Web", "type": "xsd:normalizedString"},
            None,
        ),
        "Description": MemberSpec_(
            "Description",
            "DescriptionType",
            0,
            1,
            {"minOccurs": "0", "name": "Description", "type": "DescriptionType"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, TID=None, Name=None, Web=None, Description=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.TID = _cast(None, TID)
        self.TID_nsprefix_ = None
        self.Name = Name
        self.Name_nsprefix_ = None
        self.Web = Web
        self.validate_INTERLIS_URI(self.Web)
        self.Web_nsprefix_ = None
        self.Description = Description
        self.Description_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_,
                AdministrativeUnitsCH_V1_CHAdministrativeUnions_AdministrativeUnion,
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdministrativeUnitsCH_V1_CHAdministrativeUnions_AdministrativeUnion.subclass:
            return AdministrativeUnitsCH_V1_CHAdministrativeUnions_AdministrativeUnion.subclass(
                *args_, **kwargs_
            )
        else:
            return AdministrativeUnitsCH_V1_CHAdministrativeUnions_AdministrativeUnion(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Name(self):
        return self.Name

    def set_Name(self, Name):
        self.Name = Name

    def get_Web(self):
        return self.Web

    def set_Web(self, Web):
        self.Web = Web

    def get_Description(self):
        return self.Description

    def set_Description(self, Description):
        self.Description = Description

    def get_TID(self):
        return self.TID

    def set_TID(self, TID):
        self.TID = TID

    def validate_INTERLIS_URI(self, value):
        result = True
        # Validate type INTERLIS.URI, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if len(value) > 1023:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on INTERLIS.URI'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if self.Name is not None or self.Web is not None or self.Description is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AdministrativeUnitsCH_V1.CHAdministrativeUnions.AdministrativeUnion",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get(
            "AdministrativeUnitsCH_V1.CHAdministrativeUnions.AdministrativeUnion"
        )
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if (
            self.original_tagname_ is not None
            and name_ == "AdministrativeUnitsCH_V1.CHAdministrativeUnions.AdministrativeUnion"
        ):
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="AdministrativeUnitsCH_V1.CHAdministrativeUnions.AdministrativeUnion",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="AdministrativeUnitsCH_V1.CHAdministrativeUnions.AdministrativeUnion",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="AdministrativeUnitsCH_V1.CHAdministrativeUnions.AdministrativeUnion",
    ):
        if self.TID is not None and "TID" not in already_processed:
            already_processed.add("TID")
            outfile.write(
                " TID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.TID), input_name="TID")),)
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AdministrativeUnitsCH_V1.CHAdministrativeUnions.AdministrativeUnion",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.Name is not None:
            namespaceprefix_ = self.Name_nsprefix_ + ":" if (UseCapturedNS_ and self.Name_nsprefix_) else ""
            self.Name.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Name",
                pretty_print=pretty_print,
            )
        if self.Web is not None:
            namespaceprefix_ = self.Web_nsprefix_ + ":" if (UseCapturedNS_ and self.Web_nsprefix_) else ""
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sWeb>%s</%sWeb>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(self.gds_format_string(quote_xml(self.Web), input_name="Web")),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.Description is not None:
            namespaceprefix_ = (
                self.Description_nsprefix_ + ":" if (UseCapturedNS_ and self.Description_nsprefix_) else ""
            )
            self.Description.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Description",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("TID", node)
        if value is not None and "TID" not in already_processed:
            already_processed.add("TID")
            self.TID = value
            self.validate_IliID(self.TID)  # validate type IliID

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "Name":
            obj_ = NameType5.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Name = obj_
            obj_.original_tagname_ = "Name"
        elif nodeName_ == "Web":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Web")
            value_ = self.gds_validate_string(value_, node, "Web")
            self.Web = value_
            self.Web_nsprefix_ = child_.prefix
            # validate type INTERLIS.URI
            self.validate_INTERLIS_URI(self.Web)
        elif nodeName_ == "Description":
            obj_ = DescriptionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Description = obj_
            obj_.original_tagname_ = "Description"


# end class AdministrativeUnitsCH_V1_CHAdministrativeUnions_AdministrativeUnion


class AdministrativeUnitsCH_V1_CHAdministrativeUnions(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "BID": MemberSpec_("BID", "IliID", 0, 0, {"use": "required", "name": "BID"}),
        "AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit": MemberSpec_(
            "AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit",
            "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnit",
            1,
            1,
            {
                "name": "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnit",
                "type": "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnit",
            },
            5,
        ),
        "AdministrativeUnits_V1_AdministrativeUnits_UnionMembers": MemberSpec_(
            "AdministrativeUnits_V1_AdministrativeUnits_UnionMembers",
            "AdministrativeUnits_V1.AdministrativeUnits.UnionMembers",
            1,
            1,
            {
                "name": "AdministrativeUnits_V1.AdministrativeUnits.UnionMembers",
                "type": "AdministrativeUnits_V1.AdministrativeUnits.UnionMembers",
            },
            5,
        ),
        "AdministrativeUnitsCH_V1_CHAdministrativeUnions_AdministrativeUnion": MemberSpec_(
            "AdministrativeUnitsCH_V1_CHAdministrativeUnions_AdministrativeUnion",
            "AdministrativeUnitsCH_V1.CHAdministrativeUnions.AdministrativeUnion",
            1,
            1,
            {
                "name": "AdministrativeUnitsCH_V1.CHAdministrativeUnions.AdministrativeUnion",
                "type": "AdministrativeUnitsCH_V1.CHAdministrativeUnions.AdministrativeUnion",
            },
            5,
        ),
    }
    subclass = None
    superclass = None

    def __init__(
        self,
        BID=None,
        AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit=None,
        AdministrativeUnits_V1_AdministrativeUnits_UnionMembers=None,
        AdministrativeUnitsCH_V1_CHAdministrativeUnions_AdministrativeUnion=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.BID = _cast(None, BID)
        self.BID_nsprefix_ = None
        if AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit is None:
            self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit = []
        else:
            self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit = (
                AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit
            )
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit_nsprefix_ = None
        if AdministrativeUnits_V1_AdministrativeUnits_UnionMembers is None:
            self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers = []
        else:
            self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers = (
                AdministrativeUnits_V1_AdministrativeUnits_UnionMembers
            )
        self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers_nsprefix_ = None
        if AdministrativeUnitsCH_V1_CHAdministrativeUnions_AdministrativeUnion is None:
            self.AdministrativeUnitsCH_V1_CHAdministrativeUnions_AdministrativeUnion = []
        else:
            self.AdministrativeUnitsCH_V1_CHAdministrativeUnions_AdministrativeUnion = (
                AdministrativeUnitsCH_V1_CHAdministrativeUnions_AdministrativeUnion
            )
        self.AdministrativeUnitsCH_V1_CHAdministrativeUnions_AdministrativeUnion_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdministrativeUnitsCH_V1_CHAdministrativeUnions
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdministrativeUnitsCH_V1_CHAdministrativeUnions.subclass:
            return AdministrativeUnitsCH_V1_CHAdministrativeUnions.subclass(*args_, **kwargs_)
        else:
            return AdministrativeUnitsCH_V1_CHAdministrativeUnions(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit(self):
        return self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit

    def set_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit(
        self, AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit
    ):
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit = (
            AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit
        )

    def add_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit(self, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit.append(value)

    def insert_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit_at(self, index, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit.insert(index, value)

    def replace_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit_at(self, index, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit[index] = value

    def get_AdministrativeUnits_V1_AdministrativeUnits_UnionMembers(self):
        return self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers

    def set_AdministrativeUnits_V1_AdministrativeUnits_UnionMembers(
        self, AdministrativeUnits_V1_AdministrativeUnits_UnionMembers
    ):
        self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers = (
            AdministrativeUnits_V1_AdministrativeUnits_UnionMembers
        )

    def add_AdministrativeUnits_V1_AdministrativeUnits_UnionMembers(self, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers.append(value)

    def insert_AdministrativeUnits_V1_AdministrativeUnits_UnionMembers_at(self, index, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers.insert(index, value)

    def replace_AdministrativeUnits_V1_AdministrativeUnits_UnionMembers_at(self, index, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers[index] = value

    def get_AdministrativeUnitsCH_V1_CHAdministrativeUnions_AdministrativeUnion(self):
        return self.AdministrativeUnitsCH_V1_CHAdministrativeUnions_AdministrativeUnion

    def set_AdministrativeUnitsCH_V1_CHAdministrativeUnions_AdministrativeUnion(
        self, AdministrativeUnitsCH_V1_CHAdministrativeUnions_AdministrativeUnion
    ):
        self.AdministrativeUnitsCH_V1_CHAdministrativeUnions_AdministrativeUnion = (
            AdministrativeUnitsCH_V1_CHAdministrativeUnions_AdministrativeUnion
        )

    def add_AdministrativeUnitsCH_V1_CHAdministrativeUnions_AdministrativeUnion(self, value):
        self.AdministrativeUnitsCH_V1_CHAdministrativeUnions_AdministrativeUnion.append(value)

    def insert_AdministrativeUnitsCH_V1_CHAdministrativeUnions_AdministrativeUnion_at(self, index, value):
        self.AdministrativeUnitsCH_V1_CHAdministrativeUnions_AdministrativeUnion.insert(index, value)

    def replace_AdministrativeUnitsCH_V1_CHAdministrativeUnions_AdministrativeUnion_at(self, index, value):
        self.AdministrativeUnitsCH_V1_CHAdministrativeUnions_AdministrativeUnion[index] = value

    def get_BID(self):
        return self.BID

    def set_BID(self, BID):
        self.BID = BID

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if (
            self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit
            or self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers
            or self.AdministrativeUnitsCH_V1_CHAdministrativeUnions_AdministrativeUnion
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AdministrativeUnitsCH_V1.CHAdministrativeUnions",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("AdministrativeUnitsCH_V1.CHAdministrativeUnions")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "AdministrativeUnitsCH_V1.CHAdministrativeUnions":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="AdministrativeUnitsCH_V1.CHAdministrativeUnions",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="AdministrativeUnitsCH_V1.CHAdministrativeUnions",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="AdministrativeUnitsCH_V1.CHAdministrativeUnions",
    ):
        if self.BID is not None and "BID" not in already_processed:
            already_processed.add("BID")
            outfile.write(
                " BID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.BID), input_name="BID")),)
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AdministrativeUnitsCH_V1.CHAdministrativeUnions",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for (
            AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit_
        ) in self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit:
            namespaceprefix_ = (
                self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit_nsprefix_ + ":"
                if (
                    UseCapturedNS_
                    and self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit_nsprefix_
                )
                else ""
            )
            AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnit",
                pretty_print=pretty_print,
            )
        for (
            AdministrativeUnits_V1_AdministrativeUnits_UnionMembers_
        ) in self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers:
            namespaceprefix_ = (
                self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers_nsprefix_ + ":"
                if (UseCapturedNS_ and self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers_nsprefix_)
                else ""
            )
            AdministrativeUnits_V1_AdministrativeUnits_UnionMembers_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="AdministrativeUnits_V1.AdministrativeUnits.UnionMembers",
                pretty_print=pretty_print,
            )
        for (
            AdministrativeUnitsCH_V1_CHAdministrativeUnions_AdministrativeUnion_
        ) in self.AdministrativeUnitsCH_V1_CHAdministrativeUnions_AdministrativeUnion:
            namespaceprefix_ = (
                self.AdministrativeUnitsCH_V1_CHAdministrativeUnions_AdministrativeUnion_nsprefix_ + ":"
                if (
                    UseCapturedNS_
                    and self.AdministrativeUnitsCH_V1_CHAdministrativeUnions_AdministrativeUnion_nsprefix_
                )
                else ""
            )
            AdministrativeUnitsCH_V1_CHAdministrativeUnions_AdministrativeUnion_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="AdministrativeUnitsCH_V1.CHAdministrativeUnions.AdministrativeUnion",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("BID", node)
        if value is not None and "BID" not in already_processed:
            already_processed.add("BID")
            self.BID = value
            self.validate_IliID(self.BID)  # validate type IliID

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnit":
            obj_ = AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit.append(obj_)
            obj_.original_tagname_ = "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnit"
        elif nodeName_ == "AdministrativeUnits_V1.AdministrativeUnits.UnionMembers":
            obj_ = AdministrativeUnits_V1_AdministrativeUnits_UnionMembers.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers.append(obj_)
            obj_.original_tagname_ = "AdministrativeUnits_V1.AdministrativeUnits.UnionMembers"
        elif nodeName_ == "AdministrativeUnitsCH_V1.CHAdministrativeUnions.AdministrativeUnion":
            obj_ = AdministrativeUnitsCH_V1_CHAdministrativeUnions_AdministrativeUnion.factory(
                parent_object_=self
            )
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AdministrativeUnitsCH_V1_CHAdministrativeUnions_AdministrativeUnion.append(obj_)
            obj_.original_tagname_ = "AdministrativeUnitsCH_V1.CHAdministrativeUnions.AdministrativeUnion"


# end class AdministrativeUnitsCH_V1_CHAdministrativeUnions


class AdministrativeUnitsCH_V1_CHAgencies_Agency(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "TID": MemberSpec_("TID", "IliID", 0, 0, {"use": "required", "name": "TID"}),
        "Supervisor": MemberSpec_(
            "Supervisor",
            "SupervisorType",
            0,
            0,
            {"name": "Supervisor", "type": "SupervisorType"},
            None,
        ),
        "Name": MemberSpec_(
            "Name",
            "NameType6",
            0,
            1,
            {"minOccurs": "0", "name": "Name", "type": "NameType6"},
            None,
        ),
        "Web": MemberSpec_(
            "Web",
            ["INTERLIS.URI", "xsd:normalizedString"],
            0,
            1,
            {"minOccurs": "0", "name": "Web", "type": "xsd:normalizedString"},
            None,
        ),
        "Description": MemberSpec_(
            "Description",
            "DescriptionType7",
            0,
            1,
            {"minOccurs": "0", "name": "Description", "type": "DescriptionType7"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(
        self, TID=None, Supervisor=None, Name=None, Web=None, Description=None, gds_collector_=None, **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.TID = _cast(None, TID)
        self.TID_nsprefix_ = None
        if Supervisor is None:
            self.Supervisor = globals()["SupervisorType"]()
        else:
            self.Supervisor = Supervisor
        self.Supervisor_nsprefix_ = None
        self.Name = Name
        self.Name_nsprefix_ = None
        self.Web = Web
        self.validate_INTERLIS_URI(self.Web)
        self.Web_nsprefix_ = None
        self.Description = Description
        self.Description_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdministrativeUnitsCH_V1_CHAgencies_Agency
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdministrativeUnitsCH_V1_CHAgencies_Agency.subclass:
            return AdministrativeUnitsCH_V1_CHAgencies_Agency.subclass(*args_, **kwargs_)
        else:
            return AdministrativeUnitsCH_V1_CHAgencies_Agency(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Supervisor(self):
        return self.Supervisor

    def set_Supervisor(self, Supervisor):
        self.Supervisor = Supervisor

    def get_Name(self):
        return self.Name

    def set_Name(self, Name):
        self.Name = Name

    def get_Web(self):
        return self.Web

    def set_Web(self, Web):
        self.Web = Web

    def get_Description(self):
        return self.Description

    def set_Description(self, Description):
        self.Description = Description

    def get_TID(self):
        return self.TID

    def set_TID(self, TID):
        self.TID = TID

    def validate_INTERLIS_URI(self, value):
        result = True
        # Validate type INTERLIS.URI, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if len(value) > 1023:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on INTERLIS.URI'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if (
            self.Supervisor is not None
            or self.Name is not None
            or self.Web is not None
            or self.Description is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AdministrativeUnitsCH_V1.CHAgencies.Agency",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("AdministrativeUnitsCH_V1.CHAgencies.Agency")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "AdministrativeUnitsCH_V1.CHAgencies.Agency":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="AdministrativeUnitsCH_V1.CHAgencies.Agency",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="AdministrativeUnitsCH_V1.CHAgencies.Agency",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="AdministrativeUnitsCH_V1.CHAgencies.Agency",
    ):
        if self.TID is not None and "TID" not in already_processed:
            already_processed.add("TID")
            outfile.write(
                " TID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.TID), input_name="TID")),)
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AdministrativeUnitsCH_V1.CHAgencies.Agency",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.Supervisor is not None:
            namespaceprefix_ = (
                self.Supervisor_nsprefix_ + ":" if (UseCapturedNS_ and self.Supervisor_nsprefix_) else ""
            )
            self.Supervisor.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Supervisor",
                pretty_print=pretty_print,
            )
        if self.Name is not None:
            namespaceprefix_ = self.Name_nsprefix_ + ":" if (UseCapturedNS_ and self.Name_nsprefix_) else ""
            self.Name.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Name",
                pretty_print=pretty_print,
            )
        if self.Web is not None:
            namespaceprefix_ = self.Web_nsprefix_ + ":" if (UseCapturedNS_ and self.Web_nsprefix_) else ""
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sWeb>%s</%sWeb>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(self.gds_format_string(quote_xml(self.Web), input_name="Web")),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.Description is not None:
            namespaceprefix_ = (
                self.Description_nsprefix_ + ":" if (UseCapturedNS_ and self.Description_nsprefix_) else ""
            )
            self.Description.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Description",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("TID", node)
        if value is not None and "TID" not in already_processed:
            already_processed.add("TID")
            self.TID = value
            self.validate_IliID(self.TID)  # validate type IliID

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "Supervisor":
            obj_ = SupervisorType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Supervisor = obj_
            obj_.original_tagname_ = "Supervisor"
        elif nodeName_ == "Name":
            obj_ = NameType6.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Name = obj_
            obj_.original_tagname_ = "Name"
        elif nodeName_ == "Web":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Web")
            value_ = self.gds_validate_string(value_, node, "Web")
            self.Web = value_
            self.Web_nsprefix_ = child_.prefix
            # validate type INTERLIS.URI
            self.validate_INTERLIS_URI(self.Web)
        elif nodeName_ == "Description":
            obj_ = DescriptionType7.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Description = obj_
            obj_.original_tagname_ = "Description"


# end class AdministrativeUnitsCH_V1_CHAgencies_Agency


class AdministrativeUnitsCH_V1_CHAgencies(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "BID": MemberSpec_("BID", "IliID", 0, 0, {"use": "required", "name": "BID"}),
        "AdministrativeUnits_V1_Agencies_Organisation": MemberSpec_(
            "AdministrativeUnits_V1_Agencies_Organisation",
            "AdministrativeUnits_V1.Agencies.Organisation",
            1,
            1,
            {
                "name": "AdministrativeUnits_V1.Agencies.Organisation",
                "type": "AdministrativeUnits_V1.Agencies.Organisation",
            },
            6,
        ),
        "AdministrativeUnitsCH_V1_CHAgencies_Agency": MemberSpec_(
            "AdministrativeUnitsCH_V1_CHAgencies_Agency",
            "AdministrativeUnitsCH_V1.CHAgencies.Agency",
            1,
            1,
            {
                "name": "AdministrativeUnitsCH_V1.CHAgencies.Agency",
                "type": "AdministrativeUnitsCH_V1.CHAgencies.Agency",
            },
            6,
        ),
    }
    subclass = None
    superclass = None

    def __init__(
        self,
        BID=None,
        AdministrativeUnits_V1_Agencies_Organisation=None,
        AdministrativeUnitsCH_V1_CHAgencies_Agency=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.BID = _cast(None, BID)
        self.BID_nsprefix_ = None
        if AdministrativeUnits_V1_Agencies_Organisation is None:
            self.AdministrativeUnits_V1_Agencies_Organisation = []
        else:
            self.AdministrativeUnits_V1_Agencies_Organisation = AdministrativeUnits_V1_Agencies_Organisation
        self.AdministrativeUnits_V1_Agencies_Organisation_nsprefix_ = None
        if AdministrativeUnitsCH_V1_CHAgencies_Agency is None:
            self.AdministrativeUnitsCH_V1_CHAgencies_Agency = []
        else:
            self.AdministrativeUnitsCH_V1_CHAgencies_Agency = AdministrativeUnitsCH_V1_CHAgencies_Agency
        self.AdministrativeUnitsCH_V1_CHAgencies_Agency_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, AdministrativeUnitsCH_V1_CHAgencies)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdministrativeUnitsCH_V1_CHAgencies.subclass:
            return AdministrativeUnitsCH_V1_CHAgencies.subclass(*args_, **kwargs_)
        else:
            return AdministrativeUnitsCH_V1_CHAgencies(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_AdministrativeUnits_V1_Agencies_Organisation(self):
        return self.AdministrativeUnits_V1_Agencies_Organisation

    def set_AdministrativeUnits_V1_Agencies_Organisation(self, AdministrativeUnits_V1_Agencies_Organisation):
        self.AdministrativeUnits_V1_Agencies_Organisation = AdministrativeUnits_V1_Agencies_Organisation

    def add_AdministrativeUnits_V1_Agencies_Organisation(self, value):
        self.AdministrativeUnits_V1_Agencies_Organisation.append(value)

    def insert_AdministrativeUnits_V1_Agencies_Organisation_at(self, index, value):
        self.AdministrativeUnits_V1_Agencies_Organisation.insert(index, value)

    def replace_AdministrativeUnits_V1_Agencies_Organisation_at(self, index, value):
        self.AdministrativeUnits_V1_Agencies_Organisation[index] = value

    def get_AdministrativeUnitsCH_V1_CHAgencies_Agency(self):
        return self.AdministrativeUnitsCH_V1_CHAgencies_Agency

    def set_AdministrativeUnitsCH_V1_CHAgencies_Agency(self, AdministrativeUnitsCH_V1_CHAgencies_Agency):
        self.AdministrativeUnitsCH_V1_CHAgencies_Agency = AdministrativeUnitsCH_V1_CHAgencies_Agency

    def add_AdministrativeUnitsCH_V1_CHAgencies_Agency(self, value):
        self.AdministrativeUnitsCH_V1_CHAgencies_Agency.append(value)

    def insert_AdministrativeUnitsCH_V1_CHAgencies_Agency_at(self, index, value):
        self.AdministrativeUnitsCH_V1_CHAgencies_Agency.insert(index, value)

    def replace_AdministrativeUnitsCH_V1_CHAgencies_Agency_at(self, index, value):
        self.AdministrativeUnitsCH_V1_CHAgencies_Agency[index] = value

    def get_BID(self):
        return self.BID

    def set_BID(self, BID):
        self.BID = BID

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if (
            self.AdministrativeUnits_V1_Agencies_Organisation
            or self.AdministrativeUnitsCH_V1_CHAgencies_Agency
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AdministrativeUnitsCH_V1.CHAgencies",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("AdministrativeUnitsCH_V1.CHAgencies")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "AdministrativeUnitsCH_V1.CHAgencies":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="AdministrativeUnitsCH_V1.CHAgencies",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="AdministrativeUnitsCH_V1.CHAgencies",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="AdministrativeUnitsCH_V1.CHAgencies",
    ):
        if self.BID is not None and "BID" not in already_processed:
            already_processed.add("BID")
            outfile.write(
                " BID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.BID), input_name="BID")),)
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AdministrativeUnitsCH_V1.CHAgencies",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for (
            AdministrativeUnits_V1_Agencies_Organisation_
        ) in self.AdministrativeUnits_V1_Agencies_Organisation:
            namespaceprefix_ = (
                self.AdministrativeUnits_V1_Agencies_Organisation_nsprefix_ + ":"
                if (UseCapturedNS_ and self.AdministrativeUnits_V1_Agencies_Organisation_nsprefix_)
                else ""
            )
            AdministrativeUnits_V1_Agencies_Organisation_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="AdministrativeUnits_V1.Agencies.Organisation",
                pretty_print=pretty_print,
            )
        for AdministrativeUnitsCH_V1_CHAgencies_Agency_ in self.AdministrativeUnitsCH_V1_CHAgencies_Agency:
            namespaceprefix_ = (
                self.AdministrativeUnitsCH_V1_CHAgencies_Agency_nsprefix_ + ":"
                if (UseCapturedNS_ and self.AdministrativeUnitsCH_V1_CHAgencies_Agency_nsprefix_)
                else ""
            )
            AdministrativeUnitsCH_V1_CHAgencies_Agency_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="AdministrativeUnitsCH_V1.CHAgencies.Agency",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("BID", node)
        if value is not None and "BID" not in already_processed:
            already_processed.add("BID")
            self.BID = value
            self.validate_IliID(self.BID)  # validate type IliID

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "AdministrativeUnits_V1.Agencies.Organisation":
            obj_ = AdministrativeUnits_V1_Agencies_Organisation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AdministrativeUnits_V1_Agencies_Organisation.append(obj_)
            obj_.original_tagname_ = "AdministrativeUnits_V1.Agencies.Organisation"
        elif nodeName_ == "AdministrativeUnitsCH_V1.CHAgencies.Agency":
            obj_ = AdministrativeUnitsCH_V1_CHAgencies_Agency.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AdministrativeUnitsCH_V1_CHAgencies_Agency.append(obj_)
            obj_.original_tagname_ = "AdministrativeUnitsCH_V1.CHAgencies.Agency"


# end class AdministrativeUnitsCH_V1_CHAgencies


class AdministrativeUnits_V1_AdministrativeUnits_AdministrativeElement(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "TID": MemberSpec_("TID", "IliID", 0, 0, {"use": "required", "name": "TID"}),
    }
    subclass = None
    superclass = None

    def __init__(self, TID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.TID = _cast(None, TID)
        self.TID_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_,
                AdministrativeUnits_V1_AdministrativeUnits_AdministrativeElement,
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdministrativeUnits_V1_AdministrativeUnits_AdministrativeElement.subclass:
            return AdministrativeUnits_V1_AdministrativeUnits_AdministrativeElement.subclass(
                *args_, **kwargs_
            )
        else:
            return AdministrativeUnits_V1_AdministrativeUnits_AdministrativeElement(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_TID(self):
        return self.TID

    def set_TID(self, TID):
        self.TID = TID

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if ():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="AdministrativeUnits_V1.AdministrativeUnits.AdministrativeElement",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get(
            "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeElement"
        )
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if (
            self.original_tagname_ is not None
            and name_ == "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeElement"
        ):
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="AdministrativeUnits_V1.AdministrativeUnits.AdministrativeElement",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="AdministrativeUnits_V1.AdministrativeUnits.AdministrativeElement",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="AdministrativeUnits_V1.AdministrativeUnits.AdministrativeElement",
    ):
        if self.TID is not None and "TID" not in already_processed:
            already_processed.add("TID")
            outfile.write(
                " TID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.TID), input_name="TID")),)
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="AdministrativeUnits_V1.AdministrativeUnits.AdministrativeElement",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("TID", node)
        if value is not None and "TID" not in already_processed:
            already_processed.add("TID")
            self.TID = value
            self.validate_IliID(self.TID)  # validate type IliID

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class AdministrativeUnits_V1_AdministrativeUnits_AdministrativeElement


class AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "TID": MemberSpec_("TID", "IliID", 0, 0, {"use": "required", "name": "TID"}),
        "UpperLevelUnit": MemberSpec_(
            "UpperLevelUnit",
            "UpperLevelUnitType8",
            0,
            1,
            {"minOccurs": "0", "name": "UpperLevelUnit", "type": "UpperLevelUnitType8"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, TID=None, UpperLevelUnit=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.TID = _cast(None, TID)
        self.TID_nsprefix_ = None
        self.UpperLevelUnit = UpperLevelUnit
        self.UpperLevelUnit_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_,
                AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit,
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit.subclass:
            return AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit.subclass(*args_, **kwargs_)
        else:
            return AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_UpperLevelUnit(self):
        return self.UpperLevelUnit

    def set_UpperLevelUnit(self, UpperLevelUnit):
        self.UpperLevelUnit = UpperLevelUnit

    def get_TID(self):
        return self.TID

    def set_TID(self, TID):
        self.TID = TID

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if self.UpperLevelUnit is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnit",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get(
            "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnit"
        )
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if (
            self.original_tagname_ is not None
            and name_ == "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnit"
        ):
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnit",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnit",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnit",
    ):
        if self.TID is not None and "TID" not in already_processed:
            already_processed.add("TID")
            outfile.write(
                " TID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.TID), input_name="TID")),)
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnit",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.UpperLevelUnit is not None:
            namespaceprefix_ = (
                self.UpperLevelUnit_nsprefix_ + ":"
                if (UseCapturedNS_ and self.UpperLevelUnit_nsprefix_)
                else ""
            )
            self.UpperLevelUnit.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="UpperLevelUnit",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("TID", node)
        if value is not None and "TID" not in already_processed:
            already_processed.add("TID")
            self.TID = value
            self.validate_IliID(self.TID)  # validate type IliID

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "UpperLevelUnit":
            obj_ = UpperLevelUnitType8.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.UpperLevelUnit = obj_
            obj_.original_tagname_ = "UpperLevelUnit"


# end class AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit


class AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "TID": MemberSpec_("TID", "IliID", 0, 0, {"use": "required", "name": "TID"}),
    }
    subclass = None
    superclass = None

    def __init__(self, TID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.TID = _cast(None, TID)
        self.TID_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_,
                AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion,
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion.subclass:
            return AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion.subclass(*args_, **kwargs_)
        else:
            return AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_TID(self):
        return self.TID

    def set_TID(self, TID):
        self.TID = TID

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if ():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnion",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get(
            "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnion"
        )
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if (
            self.original_tagname_ is not None
            and name_ == "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnion"
        ):
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnion",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnion",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnion",
    ):
        if self.TID is not None and "TID" not in already_processed:
            already_processed.add("TID")
            outfile.write(
                " TID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.TID), input_name="TID")),)
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnion",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("TID", node)
        if value is not None and "TID" not in already_processed:
            already_processed.add("TID")
            self.TID = value
            self.validate_IliID(self.TID)  # validate type IliID

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion


class AdministrativeUnits_V1_AdministrativeUnits_UnionMembers(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "Union": MemberSpec_("Union", "RoleType", 0, 0, {"name": "Union", "type": "RoleType"}, None),
        "Member": MemberSpec_("Member", "RoleType", 0, 0, {"name": "Member", "type": "RoleType"}, None),
    }
    subclass = None
    superclass = None

    def __init__(self, Union=None, Member=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.Union = Union
        self.Union_nsprefix_ = None
        self.Member = Member
        self.Member_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_,
                AdministrativeUnits_V1_AdministrativeUnits_UnionMembers,
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdministrativeUnits_V1_AdministrativeUnits_UnionMembers.subclass:
            return AdministrativeUnits_V1_AdministrativeUnits_UnionMembers.subclass(*args_, **kwargs_)
        else:
            return AdministrativeUnits_V1_AdministrativeUnits_UnionMembers(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Union(self):
        return self.Union

    def set_Union(self, Union):
        self.Union = Union

    def get_Member(self):
        return self.Member

    def set_Member(self, Member):
        self.Member = Member

    def _hasContent(self):
        if self.Union is not None or self.Member is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AdministrativeUnits_V1.AdministrativeUnits.UnionMembers",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get(
            "AdministrativeUnits_V1.AdministrativeUnits.UnionMembers"
        )
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if (
            self.original_tagname_ is not None
            and name_ == "AdministrativeUnits_V1.AdministrativeUnits.UnionMembers"
        ):
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="AdministrativeUnits_V1.AdministrativeUnits.UnionMembers",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="AdministrativeUnits_V1.AdministrativeUnits.UnionMembers",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="AdministrativeUnits_V1.AdministrativeUnits.UnionMembers",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AdministrativeUnits_V1.AdministrativeUnits.UnionMembers",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.Union is not None:
            namespaceprefix_ = self.Union_nsprefix_ + ":" if (UseCapturedNS_ and self.Union_nsprefix_) else ""
            self.Union.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Union",
                pretty_print=pretty_print,
            )
        if self.Member is not None:
            namespaceprefix_ = (
                self.Member_nsprefix_ + ":" if (UseCapturedNS_ and self.Member_nsprefix_) else ""
            )
            self.Member.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Member",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "Union":
            obj_ = RoleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Union = obj_
            obj_.original_tagname_ = "Union"
        elif nodeName_ == "Member":
            obj_ = RoleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Member = obj_
            obj_.original_tagname_ = "Member"


# end class AdministrativeUnits_V1_AdministrativeUnits_UnionMembers


class AdministrativeUnits_V1_AdministrativeUnits(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "BID": MemberSpec_("BID", "IliID", 0, 0, {"use": "required", "name": "BID"}),
        "AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit": MemberSpec_(
            "AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit",
            "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnit",
            1,
            1,
            {
                "name": "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnit",
                "type": "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnit",
            },
            7,
        ),
        "AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion": MemberSpec_(
            "AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion",
            "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnion",
            1,
            1,
            {
                "name": "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnion",
                "type": "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnion",
            },
            7,
        ),
        "AdministrativeUnits_V1_AdministrativeUnits_UnionMembers": MemberSpec_(
            "AdministrativeUnits_V1_AdministrativeUnits_UnionMembers",
            "AdministrativeUnits_V1.AdministrativeUnits.UnionMembers",
            1,
            1,
            {
                "name": "AdministrativeUnits_V1.AdministrativeUnits.UnionMembers",
                "type": "AdministrativeUnits_V1.AdministrativeUnits.UnionMembers",
            },
            7,
        ),
    }
    subclass = None
    superclass = None

    def __init__(
        self,
        BID=None,
        AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit=None,
        AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion=None,
        AdministrativeUnits_V1_AdministrativeUnits_UnionMembers=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.BID = _cast(None, BID)
        self.BID_nsprefix_ = None
        if AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit is None:
            self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit = []
        else:
            self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit = (
                AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit
            )
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit_nsprefix_ = None
        if AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion is None:
            self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion = []
        else:
            self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion = (
                AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion
            )
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion_nsprefix_ = None
        if AdministrativeUnits_V1_AdministrativeUnits_UnionMembers is None:
            self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers = []
        else:
            self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers = (
                AdministrativeUnits_V1_AdministrativeUnits_UnionMembers
            )
        self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdministrativeUnits_V1_AdministrativeUnits
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdministrativeUnits_V1_AdministrativeUnits.subclass:
            return AdministrativeUnits_V1_AdministrativeUnits.subclass(*args_, **kwargs_)
        else:
            return AdministrativeUnits_V1_AdministrativeUnits(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit(self):
        return self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit

    def set_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit(
        self, AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit
    ):
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit = (
            AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit
        )

    def add_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit(self, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit.append(value)

    def insert_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit_at(self, index, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit.insert(index, value)

    def replace_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit_at(self, index, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit[index] = value

    def get_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion(self):
        return self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion

    def set_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion(
        self, AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion
    ):
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion = (
            AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion
        )

    def add_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion(self, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion.append(value)

    def insert_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion_at(self, index, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion.insert(index, value)

    def replace_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion_at(self, index, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion[index] = value

    def get_AdministrativeUnits_V1_AdministrativeUnits_UnionMembers(self):
        return self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers

    def set_AdministrativeUnits_V1_AdministrativeUnits_UnionMembers(
        self, AdministrativeUnits_V1_AdministrativeUnits_UnionMembers
    ):
        self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers = (
            AdministrativeUnits_V1_AdministrativeUnits_UnionMembers
        )

    def add_AdministrativeUnits_V1_AdministrativeUnits_UnionMembers(self, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers.append(value)

    def insert_AdministrativeUnits_V1_AdministrativeUnits_UnionMembers_at(self, index, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers.insert(index, value)

    def replace_AdministrativeUnits_V1_AdministrativeUnits_UnionMembers_at(self, index, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers[index] = value

    def get_BID(self):
        return self.BID

    def set_BID(self, BID):
        self.BID = BID

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if (
            self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit
            or self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion
            or self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AdministrativeUnits_V1.AdministrativeUnits",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("AdministrativeUnits_V1.AdministrativeUnits")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "AdministrativeUnits_V1.AdministrativeUnits":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="AdministrativeUnits_V1.AdministrativeUnits",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="AdministrativeUnits_V1.AdministrativeUnits",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="AdministrativeUnits_V1.AdministrativeUnits",
    ):
        if self.BID is not None and "BID" not in already_processed:
            already_processed.add("BID")
            outfile.write(
                " BID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.BID), input_name="BID")),)
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AdministrativeUnits_V1.AdministrativeUnits",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for (
            AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit_
        ) in self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit:
            namespaceprefix_ = (
                self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit_nsprefix_ + ":"
                if (
                    UseCapturedNS_
                    and self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit_nsprefix_
                )
                else ""
            )
            AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnit",
                pretty_print=pretty_print,
            )
        for (
            AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion_
        ) in self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion:
            namespaceprefix_ = (
                self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion_nsprefix_ + ":"
                if (
                    UseCapturedNS_
                    and self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion_nsprefix_
                )
                else ""
            )
            AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnion",
                pretty_print=pretty_print,
            )
        for (
            AdministrativeUnits_V1_AdministrativeUnits_UnionMembers_
        ) in self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers:
            namespaceprefix_ = (
                self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers_nsprefix_ + ":"
                if (UseCapturedNS_ and self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers_nsprefix_)
                else ""
            )
            AdministrativeUnits_V1_AdministrativeUnits_UnionMembers_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="AdministrativeUnits_V1.AdministrativeUnits.UnionMembers",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("BID", node)
        if value is not None and "BID" not in already_processed:
            already_processed.add("BID")
            self.BID = value
            self.validate_IliID(self.BID)  # validate type IliID

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnit":
            obj_ = AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit.append(obj_)
            obj_.original_tagname_ = "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnit"
        elif nodeName_ == "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnion":
            obj_ = AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion.append(obj_)
            obj_.original_tagname_ = "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnion"
        elif nodeName_ == "AdministrativeUnits_V1.AdministrativeUnits.UnionMembers":
            obj_ = AdministrativeUnits_V1_AdministrativeUnits_UnionMembers.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers.append(obj_)
            obj_.original_tagname_ = "AdministrativeUnits_V1.AdministrativeUnits.UnionMembers"


# end class AdministrativeUnits_V1_AdministrativeUnits


class AdministrativeUnits_V1_Countries_Country(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "TID": MemberSpec_("TID", "IliID", 0, 0, {"use": "required", "name": "TID"}),
        "UpperLevelUnit": MemberSpec_(
            "UpperLevelUnit",
            "UpperLevelUnitType9",
            0,
            1,
            {"minOccurs": "0", "name": "UpperLevelUnit", "type": "UpperLevelUnitType9"},
            None,
        ),
        "Code": MemberSpec_(
            "Code",
            ["InternationalCodes_V1.CountryCode_ISO3166_1", "xsd:string"],
            0,
            0,
            {"name": "Code", "type": "xsd:string"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, TID=None, UpperLevelUnit=None, Code=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.TID = _cast(None, TID)
        self.TID_nsprefix_ = None
        self.UpperLevelUnit = UpperLevelUnit
        self.UpperLevelUnit_nsprefix_ = None
        self.Code = Code
        self.validate_InternationalCodes_V1_CountryCode_ISO3166_1(self.Code)
        self.Code_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdministrativeUnits_V1_Countries_Country
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdministrativeUnits_V1_Countries_Country.subclass:
            return AdministrativeUnits_V1_Countries_Country.subclass(*args_, **kwargs_)
        else:
            return AdministrativeUnits_V1_Countries_Country(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_UpperLevelUnit(self):
        return self.UpperLevelUnit

    def set_UpperLevelUnit(self, UpperLevelUnit):
        self.UpperLevelUnit = UpperLevelUnit

    def get_Code(self):
        return self.Code

    def set_Code(self, Code):
        self.Code = Code

    def get_TID(self):
        return self.TID

    def set_TID(self, TID):
        self.TID = TID

    def validate_InternationalCodes_V1_CountryCode_ISO3166_1(self, value):
        result = True
        # Validate type InternationalCodes_V1.CountryCode_ISO3166_1, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            value = value
            enumerations = [
                "CHE",
                "ABW",
                "AFG",
                "AGO",
                "AIA",
                "ALA",
                "ALB",
                "AND_",
                "ANT",
                "ARE",
                "ARG",
                "ARM",
                "ASM",
                "ATA",
                "ATF",
                "ATG",
                "AUS",
                "AUT",
                "AZE",
                "BDI",
                "BEL",
                "BEN",
                "BFA",
                "BGD",
                "BGR",
                "BHR",
                "BHS",
                "BIH",
                "BLR",
                "BLZ",
                "BMU",
                "BOL",
                "BRA",
                "BRB",
                "BRN",
                "BTN",
                "BVT",
                "BWA",
                "CAF",
                "CAN",
                "CCK",
                "CHL",
                "CHN",
                "CIV",
                "CMR",
                "COD",
                "COG",
                "COK",
                "COL",
                "COM",
                "CPV",
                "CRI",
                "CUB",
                "CXR",
                "CYM",
                "CYP",
                "CZE",
                "DEU",
                "DJI",
                "DMA",
                "DNK",
                "DOM",
                "DZA",
                "ECU",
                "EGY",
                "ERI",
                "ESH",
                "ESP",
                "EST",
                "ETH",
                "FIN",
                "FJI",
                "FLK",
                "FRA",
                "FRO",
                "FSM",
                "GAB",
                "GBR",
                "GEO",
                "GGY",
                "GHA",
                "GIB",
                "GIN",
                "GLP",
                "GMB",
                "GNB",
                "GNQ",
                "GRC",
                "GRD",
                "GRL",
                "GTM",
                "GUF",
                "GUM",
                "GUY",
                "HKG",
                "HMD",
                "HND",
                "HRV",
                "HTI",
                "HUN",
                "IDN",
                "IMN",
                "IND",
                "IOT",
                "IRL",
                "IRN",
                "IRQ",
                "ISL",
                "ISR",
                "ITA",
                "JAM",
                "JEY",
                "JOR",
                "JPN",
                "KAZ",
                "KEN",
                "KGZ",
                "KHM",
                "KIR",
                "KNA",
                "KOR",
                "KWT",
                "LAO",
                "LBN",
                "LBR",
                "LBY",
                "LCA",
                "LIE",
                "LKA",
                "LSO",
                "LTU",
                "LUX",
                "LVA",
                "MAC",
                "MAR",
                "MCO",
                "MDA",
                "MDG",
                "MDV",
                "MEX",
                "MHL",
                "MKD",
                "MLI",
                "MLT",
                "MMR",
                "MNE",
                "MNG",
                "MNP",
                "MOZ",
                "MRT",
                "MSR",
                "MTQ",
                "MUS",
                "MWI",
                "MYS",
                "MYT",
                "NAM",
                "NCL",
                "NER",
                "NFK",
                "NGA",
                "NIC",
                "NIU",
                "NLD",
                "NOR",
                "NPL",
                "NRU",
                "NZL",
                "OMN",
                "PAK",
                "PAN",
                "PCN",
                "PER",
                "PHL",
                "PLW",
                "PNG",
                "POL",
                "PRI",
                "PRK",
                "PRT",
                "PRY",
                "PSE",
                "PYF",
                "QAT",
                "REU",
                "ROU",
                "RUS",
                "RWA",
                "SAU",
                "SDN",
                "SEN",
                "SGP",
                "SGS",
                "SHN",
                "SJM",
                "SLB",
                "SLE",
                "SLV",
                "SMR",
                "SOM",
                "SPM",
                "SRB",
                "STP",
                "SUR",
                "SVK",
                "SVN",
                "SWE",
                "SWZ",
                "SYC",
                "SYR",
                "TCA",
                "TCD",
                "TGO",
                "THA",
                "TJK",
                "TKL",
                "TKM",
                "TLS",
                "TON",
                "TTO",
                "TUN",
                "TUR",
                "TUV",
                "TWN",
                "TZA",
                "UGA",
                "UKR",
                "UMI",
                "URY",
                "USA",
                "UZB",
                "VAT",
                "VCT",
                "VEN",
                "VGB",
                "VIR",
                "VNM",
                "VUT",
                "WLF",
                "WSM",
                "YEM",
                "ZAF",
                "ZMB",
                "ZWE",
            ]
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on InternationalCodes_V1.CountryCode_ISO3166_1'
                    % {"value": encode_str_2_3(value), "lineno": lineno}
                )
                result = False
        return result

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if self.UpperLevelUnit is not None or self.Code is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AdministrativeUnits_V1.Countries.Country",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("AdministrativeUnits_V1.Countries.Country")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "AdministrativeUnits_V1.Countries.Country":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="AdministrativeUnits_V1.Countries.Country",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="AdministrativeUnits_V1.Countries.Country",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="AdministrativeUnits_V1.Countries.Country",
    ):
        if self.TID is not None and "TID" not in already_processed:
            already_processed.add("TID")
            outfile.write(
                " TID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.TID), input_name="TID")),)
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AdministrativeUnits_V1.Countries.Country",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.UpperLevelUnit is not None:
            namespaceprefix_ = (
                self.UpperLevelUnit_nsprefix_ + ":"
                if (UseCapturedNS_ and self.UpperLevelUnit_nsprefix_)
                else ""
            )
            self.UpperLevelUnit.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="UpperLevelUnit",
                pretty_print=pretty_print,
            )
        if self.Code is not None:
            namespaceprefix_ = self.Code_nsprefix_ + ":" if (UseCapturedNS_ and self.Code_nsprefix_) else ""
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sCode>%s</%sCode>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(self.gds_format_string(quote_xml(self.Code), input_name="Code")),
                    namespaceprefix_,
                    eol_,
                )
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("TID", node)
        if value is not None and "TID" not in already_processed:
            already_processed.add("TID")
            self.TID = value
            self.validate_IliID(self.TID)  # validate type IliID

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "UpperLevelUnit":
            obj_ = UpperLevelUnitType9.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.UpperLevelUnit = obj_
            obj_.original_tagname_ = "UpperLevelUnit"
        elif nodeName_ == "Code":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Code")
            value_ = self.gds_validate_string(value_, node, "Code")
            self.Code = value_
            self.Code_nsprefix_ = child_.prefix
            # validate type InternationalCodes_V1.CountryCode_ISO3166_1
            self.validate_InternationalCodes_V1_CountryCode_ISO3166_1(self.Code)


# end class AdministrativeUnits_V1_Countries_Country


class AdministrativeUnits_V1_Countries(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "BID": MemberSpec_("BID", "IliID", 0, 0, {"use": "required", "name": "BID"}),
        "AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit": MemberSpec_(
            "AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit",
            "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnit",
            1,
            1,
            {
                "name": "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnit",
                "type": "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnit",
            },
            8,
        ),
        "AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion": MemberSpec_(
            "AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion",
            "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnion",
            1,
            1,
            {
                "name": "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnion",
                "type": "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnion",
            },
            8,
        ),
        "AdministrativeUnits_V1_AdministrativeUnits_UnionMembers": MemberSpec_(
            "AdministrativeUnits_V1_AdministrativeUnits_UnionMembers",
            "AdministrativeUnits_V1.AdministrativeUnits.UnionMembers",
            1,
            1,
            {
                "name": "AdministrativeUnits_V1.AdministrativeUnits.UnionMembers",
                "type": "AdministrativeUnits_V1.AdministrativeUnits.UnionMembers",
            },
            8,
        ),
        "AdministrativeUnits_V1_Countries_Country": MemberSpec_(
            "AdministrativeUnits_V1_Countries_Country",
            "AdministrativeUnits_V1.Countries.Country",
            1,
            1,
            {
                "name": "AdministrativeUnits_V1.Countries.Country",
                "type": "AdministrativeUnits_V1.Countries.Country",
            },
            8,
        ),
    }
    subclass = None
    superclass = None

    def __init__(
        self,
        BID=None,
        AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit=None,
        AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion=None,
        AdministrativeUnits_V1_AdministrativeUnits_UnionMembers=None,
        AdministrativeUnits_V1_Countries_Country=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.BID = _cast(None, BID)
        self.BID_nsprefix_ = None
        if AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit is None:
            self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit = []
        else:
            self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit = (
                AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit
            )
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit_nsprefix_ = None
        if AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion is None:
            self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion = []
        else:
            self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion = (
                AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion
            )
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion_nsprefix_ = None
        if AdministrativeUnits_V1_AdministrativeUnits_UnionMembers is None:
            self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers = []
        else:
            self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers = (
                AdministrativeUnits_V1_AdministrativeUnits_UnionMembers
            )
        self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers_nsprefix_ = None
        if AdministrativeUnits_V1_Countries_Country is None:
            self.AdministrativeUnits_V1_Countries_Country = []
        else:
            self.AdministrativeUnits_V1_Countries_Country = AdministrativeUnits_V1_Countries_Country
        self.AdministrativeUnits_V1_Countries_Country_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, AdministrativeUnits_V1_Countries)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdministrativeUnits_V1_Countries.subclass:
            return AdministrativeUnits_V1_Countries.subclass(*args_, **kwargs_)
        else:
            return AdministrativeUnits_V1_Countries(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit(self):
        return self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit

    def set_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit(
        self, AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit
    ):
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit = (
            AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit
        )

    def add_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit(self, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit.append(value)

    def insert_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit_at(self, index, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit.insert(index, value)

    def replace_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit_at(self, index, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit[index] = value

    def get_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion(self):
        return self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion

    def set_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion(
        self, AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion
    ):
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion = (
            AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion
        )

    def add_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion(self, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion.append(value)

    def insert_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion_at(self, index, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion.insert(index, value)

    def replace_AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion_at(self, index, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion[index] = value

    def get_AdministrativeUnits_V1_AdministrativeUnits_UnionMembers(self):
        return self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers

    def set_AdministrativeUnits_V1_AdministrativeUnits_UnionMembers(
        self, AdministrativeUnits_V1_AdministrativeUnits_UnionMembers
    ):
        self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers = (
            AdministrativeUnits_V1_AdministrativeUnits_UnionMembers
        )

    def add_AdministrativeUnits_V1_AdministrativeUnits_UnionMembers(self, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers.append(value)

    def insert_AdministrativeUnits_V1_AdministrativeUnits_UnionMembers_at(self, index, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers.insert(index, value)

    def replace_AdministrativeUnits_V1_AdministrativeUnits_UnionMembers_at(self, index, value):
        self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers[index] = value

    def get_AdministrativeUnits_V1_Countries_Country(self):
        return self.AdministrativeUnits_V1_Countries_Country

    def set_AdministrativeUnits_V1_Countries_Country(self, AdministrativeUnits_V1_Countries_Country):
        self.AdministrativeUnits_V1_Countries_Country = AdministrativeUnits_V1_Countries_Country

    def add_AdministrativeUnits_V1_Countries_Country(self, value):
        self.AdministrativeUnits_V1_Countries_Country.append(value)

    def insert_AdministrativeUnits_V1_Countries_Country_at(self, index, value):
        self.AdministrativeUnits_V1_Countries_Country.insert(index, value)

    def replace_AdministrativeUnits_V1_Countries_Country_at(self, index, value):
        self.AdministrativeUnits_V1_Countries_Country[index] = value

    def get_BID(self):
        return self.BID

    def set_BID(self, BID):
        self.BID = BID

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if (
            self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit
            or self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion
            or self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers
            or self.AdministrativeUnits_V1_Countries_Country
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AdministrativeUnits_V1.Countries",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("AdministrativeUnits_V1.Countries")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "AdministrativeUnits_V1.Countries":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="AdministrativeUnits_V1.Countries",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="AdministrativeUnits_V1.Countries",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="AdministrativeUnits_V1.Countries",
    ):
        if self.BID is not None and "BID" not in already_processed:
            already_processed.add("BID")
            outfile.write(
                " BID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.BID), input_name="BID")),)
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AdministrativeUnits_V1.Countries",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for (
            AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit_
        ) in self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit:
            namespaceprefix_ = (
                self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit_nsprefix_ + ":"
                if (
                    UseCapturedNS_
                    and self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit_nsprefix_
                )
                else ""
            )
            AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnit",
                pretty_print=pretty_print,
            )
        for (
            AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion_
        ) in self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion:
            namespaceprefix_ = (
                self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion_nsprefix_ + ":"
                if (
                    UseCapturedNS_
                    and self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion_nsprefix_
                )
                else ""
            )
            AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnion",
                pretty_print=pretty_print,
            )
        for (
            AdministrativeUnits_V1_AdministrativeUnits_UnionMembers_
        ) in self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers:
            namespaceprefix_ = (
                self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers_nsprefix_ + ":"
                if (UseCapturedNS_ and self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers_nsprefix_)
                else ""
            )
            AdministrativeUnits_V1_AdministrativeUnits_UnionMembers_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="AdministrativeUnits_V1.AdministrativeUnits.UnionMembers",
                pretty_print=pretty_print,
            )
        for AdministrativeUnits_V1_Countries_Country_ in self.AdministrativeUnits_V1_Countries_Country:
            namespaceprefix_ = (
                self.AdministrativeUnits_V1_Countries_Country_nsprefix_ + ":"
                if (UseCapturedNS_ and self.AdministrativeUnits_V1_Countries_Country_nsprefix_)
                else ""
            )
            AdministrativeUnits_V1_Countries_Country_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="AdministrativeUnits_V1.Countries.Country",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("BID", node)
        if value is not None and "BID" not in already_processed:
            already_processed.add("BID")
            self.BID = value
            self.validate_IliID(self.BID)  # validate type IliID

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnit":
            obj_ = AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit.append(obj_)
            obj_.original_tagname_ = "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnit"
        elif nodeName_ == "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnion":
            obj_ = AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion.append(obj_)
            obj_.original_tagname_ = "AdministrativeUnits_V1.AdministrativeUnits.AdministrativeUnion"
        elif nodeName_ == "AdministrativeUnits_V1.AdministrativeUnits.UnionMembers":
            obj_ = AdministrativeUnits_V1_AdministrativeUnits_UnionMembers.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AdministrativeUnits_V1_AdministrativeUnits_UnionMembers.append(obj_)
            obj_.original_tagname_ = "AdministrativeUnits_V1.AdministrativeUnits.UnionMembers"
        elif nodeName_ == "AdministrativeUnits_V1.Countries.Country":
            obj_ = AdministrativeUnits_V1_Countries_Country.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AdministrativeUnits_V1_Countries_Country.append(obj_)
            obj_.original_tagname_ = "AdministrativeUnits_V1.Countries.Country"


# end class AdministrativeUnits_V1_Countries


class AdministrativeUnits_V1_CountryNames_CountryName(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "Text": MemberSpec_(
            "Text",
            ["TextType", "xsd:normalizedString"],
            0,
            0,
            {"name": "Text", "type": "xsd:normalizedString"},
            None,
        ),
        "Code": MemberSpec_(
            "Code",
            ["InternationalCodes_V1.CountryCode_ISO3166_1", "xsd:string"],
            0,
            0,
            {"name": "Code", "type": "xsd:string"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, Text=None, Code=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.Text = Text
        self.validate_TextType(self.Text)
        self.Text_nsprefix_ = None
        self.Code = Code
        self.validate_InternationalCodes_V1_CountryCode_ISO3166_1(self.Code)
        self.Code_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdministrativeUnits_V1_CountryNames_CountryName
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdministrativeUnits_V1_CountryNames_CountryName.subclass:
            return AdministrativeUnits_V1_CountryNames_CountryName.subclass(*args_, **kwargs_)
        else:
            return AdministrativeUnits_V1_CountryNames_CountryName(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Text(self):
        return self.Text

    def set_Text(self, Text):
        self.Text = Text

    def get_Code(self):
        return self.Code

    def set_Code(self, Code):
        self.Code = Code

    def validate_TextType(self, value):
        result = True
        # Validate type TextType, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            pass
        return result

    def validate_InternationalCodes_V1_CountryCode_ISO3166_1(self, value):
        result = True
        # Validate type InternationalCodes_V1.CountryCode_ISO3166_1, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            value = value
            enumerations = [
                "CHE",
                "ABW",
                "AFG",
                "AGO",
                "AIA",
                "ALA",
                "ALB",
                "AND_",
                "ANT",
                "ARE",
                "ARG",
                "ARM",
                "ASM",
                "ATA",
                "ATF",
                "ATG",
                "AUS",
                "AUT",
                "AZE",
                "BDI",
                "BEL",
                "BEN",
                "BFA",
                "BGD",
                "BGR",
                "BHR",
                "BHS",
                "BIH",
                "BLR",
                "BLZ",
                "BMU",
                "BOL",
                "BRA",
                "BRB",
                "BRN",
                "BTN",
                "BVT",
                "BWA",
                "CAF",
                "CAN",
                "CCK",
                "CHL",
                "CHN",
                "CIV",
                "CMR",
                "COD",
                "COG",
                "COK",
                "COL",
                "COM",
                "CPV",
                "CRI",
                "CUB",
                "CXR",
                "CYM",
                "CYP",
                "CZE",
                "DEU",
                "DJI",
                "DMA",
                "DNK",
                "DOM",
                "DZA",
                "ECU",
                "EGY",
                "ERI",
                "ESH",
                "ESP",
                "EST",
                "ETH",
                "FIN",
                "FJI",
                "FLK",
                "FRA",
                "FRO",
                "FSM",
                "GAB",
                "GBR",
                "GEO",
                "GGY",
                "GHA",
                "GIB",
                "GIN",
                "GLP",
                "GMB",
                "GNB",
                "GNQ",
                "GRC",
                "GRD",
                "GRL",
                "GTM",
                "GUF",
                "GUM",
                "GUY",
                "HKG",
                "HMD",
                "HND",
                "HRV",
                "HTI",
                "HUN",
                "IDN",
                "IMN",
                "IND",
                "IOT",
                "IRL",
                "IRN",
                "IRQ",
                "ISL",
                "ISR",
                "ITA",
                "JAM",
                "JEY",
                "JOR",
                "JPN",
                "KAZ",
                "KEN",
                "KGZ",
                "KHM",
                "KIR",
                "KNA",
                "KOR",
                "KWT",
                "LAO",
                "LBN",
                "LBR",
                "LBY",
                "LCA",
                "LIE",
                "LKA",
                "LSO",
                "LTU",
                "LUX",
                "LVA",
                "MAC",
                "MAR",
                "MCO",
                "MDA",
                "MDG",
                "MDV",
                "MEX",
                "MHL",
                "MKD",
                "MLI",
                "MLT",
                "MMR",
                "MNE",
                "MNG",
                "MNP",
                "MOZ",
                "MRT",
                "MSR",
                "MTQ",
                "MUS",
                "MWI",
                "MYS",
                "MYT",
                "NAM",
                "NCL",
                "NER",
                "NFK",
                "NGA",
                "NIC",
                "NIU",
                "NLD",
                "NOR",
                "NPL",
                "NRU",
                "NZL",
                "OMN",
                "PAK",
                "PAN",
                "PCN",
                "PER",
                "PHL",
                "PLW",
                "PNG",
                "POL",
                "PRI",
                "PRK",
                "PRT",
                "PRY",
                "PSE",
                "PYF",
                "QAT",
                "REU",
                "ROU",
                "RUS",
                "RWA",
                "SAU",
                "SDN",
                "SEN",
                "SGP",
                "SGS",
                "SHN",
                "SJM",
                "SLB",
                "SLE",
                "SLV",
                "SMR",
                "SOM",
                "SPM",
                "SRB",
                "STP",
                "SUR",
                "SVK",
                "SVN",
                "SWE",
                "SWZ",
                "SYC",
                "SYR",
                "TCA",
                "TCD",
                "TGO",
                "THA",
                "TJK",
                "TKL",
                "TKM",
                "TLS",
                "TON",
                "TTO",
                "TUN",
                "TUR",
                "TUV",
                "TWN",
                "TZA",
                "UGA",
                "UKR",
                "UMI",
                "URY",
                "USA",
                "UZB",
                "VAT",
                "VCT",
                "VEN",
                "VGB",
                "VIR",
                "VNM",
                "VUT",
                "WLF",
                "WSM",
                "YEM",
                "ZAF",
                "ZMB",
                "ZWE",
            ]
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on InternationalCodes_V1.CountryCode_ISO3166_1'
                    % {"value": encode_str_2_3(value), "lineno": lineno}
                )
                result = False
        return result

    def _hasContent(self):
        if self.Text is not None or self.Code is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AdministrativeUnits_V1.CountryNames.CountryName",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("AdministrativeUnits_V1.CountryNames.CountryName")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "AdministrativeUnits_V1.CountryNames.CountryName":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="AdministrativeUnits_V1.CountryNames.CountryName",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="AdministrativeUnits_V1.CountryNames.CountryName",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="AdministrativeUnits_V1.CountryNames.CountryName",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AdministrativeUnits_V1.CountryNames.CountryName",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.Text is not None:
            namespaceprefix_ = self.Text_nsprefix_ + ":" if (UseCapturedNS_ and self.Text_nsprefix_) else ""
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sText>%s</%sText>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(self.gds_format_string(quote_xml(self.Text), input_name="Text")),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.Code is not None:
            namespaceprefix_ = self.Code_nsprefix_ + ":" if (UseCapturedNS_ and self.Code_nsprefix_) else ""
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sCode>%s</%sCode>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(self.gds_format_string(quote_xml(self.Code), input_name="Code")),
                    namespaceprefix_,
                    eol_,
                )
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "Text":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Text")
            value_ = self.gds_validate_string(value_, node, "Text")
            self.Text = value_
            self.Text_nsprefix_ = child_.prefix
            # validate type TextType
            self.validate_TextType(self.Text)
        elif nodeName_ == "Code":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Code")
            value_ = self.gds_validate_string(value_, node, "Code")
            self.Code = value_
            self.Code_nsprefix_ = child_.prefix
            # validate type InternationalCodes_V1.CountryCode_ISO3166_1
            self.validate_InternationalCodes_V1_CountryCode_ISO3166_1(self.Code)


# end class AdministrativeUnits_V1_CountryNames_CountryName


class AdministrativeUnits_V1_CountryNames_CountryNamesTranslation(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "TID": MemberSpec_("TID", "IliID", 0, 0, {"use": "required", "name": "TID"}),
        "Language": MemberSpec_(
            "Language",
            ["InternationalCodes_V1.LanguageCode_ISO639_1", "xsd:string"],
            0,
            0,
            {"name": "Language", "type": "xsd:string"},
            None,
        ),
        "Entries": MemberSpec_(
            "Entries",
            "EntriesType",
            0,
            1,
            {"minOccurs": "0", "name": "Entries", "type": "EntriesType"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, TID=None, Language=None, Entries=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.TID = _cast(None, TID)
        self.TID_nsprefix_ = None
        self.Language = Language
        self.validate_InternationalCodes_V1_LanguageCode_ISO639_1(self.Language)
        self.Language_nsprefix_ = None
        self.Entries = Entries
        self.Entries_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_,
                AdministrativeUnits_V1_CountryNames_CountryNamesTranslation,
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdministrativeUnits_V1_CountryNames_CountryNamesTranslation.subclass:
            return AdministrativeUnits_V1_CountryNames_CountryNamesTranslation.subclass(*args_, **kwargs_)
        else:
            return AdministrativeUnits_V1_CountryNames_CountryNamesTranslation(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Language(self):
        return self.Language

    def set_Language(self, Language):
        self.Language = Language

    def get_Entries(self):
        return self.Entries

    def set_Entries(self, Entries):
        self.Entries = Entries

    def get_TID(self):
        return self.TID

    def set_TID(self, TID):
        self.TID = TID

    def validate_InternationalCodes_V1_LanguageCode_ISO639_1(self, value):
        result = True
        # Validate type InternationalCodes_V1.LanguageCode_ISO639_1, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            value = value
            enumerations = [
                "de",
                "fr",
                "it",
                "rm",
                "en",
                "aa",
                "ab",
                "af",
                "am",
                "ar",
                "as",
                "ay",
                "az",
                "ba",
                "be",
                "bg",
                "bh",
                "bi",
                "bn",
                "bo",
                "br",
                "ca",
                "co",
                "cs",
                "cy",
                "da",
                "dz",
                "el",
                "eo",
                "es",
                "et",
                "eu",
                "fa",
                "fi",
                "fj",
                "fo",
                "fy",
                "ga",
                "gd",
                "gl",
                "gn",
                "gu",
                "ha",
                "he",
                "hi",
                "hr",
                "hu",
                "hy",
                "ia",
                "id",
                "ie",
                "ik",
                "is",
                "iu",
                "ja",
                "jw",
                "ka",
                "kk",
                "kl",
                "km",
                "kn",
                "ko",
                "ks",
                "ku",
                "ky",
                "la",
                "ln",
                "lo",
                "lt",
                "lv",
                "mg",
                "mi",
                "mk",
                "ml",
                "mn",
                "mo",
                "mr",
                "ms",
                "mt",
                "my",
                "na",
                "ne",
                "nl",
                "no",
                "oc",
                "om",
                "or",
                "pa",
                "pl",
                "ps",
                "pt",
                "qu",
                "rn",
                "ro",
                "ru",
                "rw",
                "sa",
                "sd",
                "sg",
                "sh",
                "si",
                "sk",
                "sl",
                "sm",
                "sn",
                "so",
                "sq",
                "sr",
                "ss",
                "st",
                "su",
                "sv",
                "sw",
                "ta",
                "te",
                "tg",
                "th",
                "ti",
                "tk",
                "tl",
                "tn",
                "to",
                "tr",
                "ts",
                "tt",
                "tw",
                "ug",
                "uk",
                "ur",
                "uz",
                "vi",
                "vo",
                "wo",
                "xh",
                "yi",
                "yo",
                "za",
                "zh",
                "zu",
            ]
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on InternationalCodes_V1.LanguageCode_ISO639_1'
                    % {"value": encode_str_2_3(value), "lineno": lineno}
                )
                result = False
        return result

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if self.Language is not None or self.Entries is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AdministrativeUnits_V1.CountryNames.CountryNamesTranslation",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get(
            "AdministrativeUnits_V1.CountryNames.CountryNamesTranslation"
        )
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if (
            self.original_tagname_ is not None
            and name_ == "AdministrativeUnits_V1.CountryNames.CountryNamesTranslation"
        ):
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="AdministrativeUnits_V1.CountryNames.CountryNamesTranslation",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="AdministrativeUnits_V1.CountryNames.CountryNamesTranslation",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="AdministrativeUnits_V1.CountryNames.CountryNamesTranslation",
    ):
        if self.TID is not None and "TID" not in already_processed:
            already_processed.add("TID")
            outfile.write(
                " TID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.TID), input_name="TID")),)
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AdministrativeUnits_V1.CountryNames.CountryNamesTranslation",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.Language is not None:
            namespaceprefix_ = (
                self.Language_nsprefix_ + ":" if (UseCapturedNS_ and self.Language_nsprefix_) else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sLanguage>%s</%sLanguage>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(self.gds_format_string(quote_xml(self.Language), input_name="Language")),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.Entries is not None:
            namespaceprefix_ = (
                self.Entries_nsprefix_ + ":" if (UseCapturedNS_ and self.Entries_nsprefix_) else ""
            )
            self.Entries.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Entries",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("TID", node)
        if value is not None and "TID" not in already_processed:
            already_processed.add("TID")
            self.TID = value
            self.validate_IliID(self.TID)  # validate type IliID

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "Language":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Language")
            value_ = self.gds_validate_string(value_, node, "Language")
            self.Language = value_
            self.Language_nsprefix_ = child_.prefix
            # validate type InternationalCodes_V1.LanguageCode_ISO639_1
            self.validate_InternationalCodes_V1_LanguageCode_ISO639_1(self.Language)
        elif nodeName_ == "Entries":
            obj_ = EntriesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Entries = obj_
            obj_.original_tagname_ = "Entries"


# end class AdministrativeUnits_V1_CountryNames_CountryNamesTranslation


class AdministrativeUnits_V1_CountryNames(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "BID": MemberSpec_("BID", "IliID", 0, 0, {"use": "required", "name": "BID"}),
        "Dictionaries_V1_Dictionaries_Dictionary": MemberSpec_(
            "Dictionaries_V1_Dictionaries_Dictionary",
            "Dictionaries_V1.Dictionaries.Dictionary",
            1,
            1,
            {
                "name": "Dictionaries_V1.Dictionaries.Dictionary",
                "type": "Dictionaries_V1.Dictionaries.Dictionary",
            },
            9,
        ),
        "AdministrativeUnits_V1_CountryNames_CountryNamesTranslation": MemberSpec_(
            "AdministrativeUnits_V1_CountryNames_CountryNamesTranslation",
            "AdministrativeUnits_V1.CountryNames.CountryNamesTranslation",
            1,
            1,
            {
                "name": "AdministrativeUnits_V1.CountryNames.CountryNamesTranslation",
                "type": "AdministrativeUnits_V1.CountryNames.CountryNamesTranslation",
            },
            9,
        ),
    }
    subclass = None
    superclass = None

    def __init__(
        self,
        BID=None,
        Dictionaries_V1_Dictionaries_Dictionary=None,
        AdministrativeUnits_V1_CountryNames_CountryNamesTranslation=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.BID = _cast(None, BID)
        self.BID_nsprefix_ = None
        if Dictionaries_V1_Dictionaries_Dictionary is None:
            self.Dictionaries_V1_Dictionaries_Dictionary = []
        else:
            self.Dictionaries_V1_Dictionaries_Dictionary = Dictionaries_V1_Dictionaries_Dictionary
        self.Dictionaries_V1_Dictionaries_Dictionary_nsprefix_ = None
        if AdministrativeUnits_V1_CountryNames_CountryNamesTranslation is None:
            self.AdministrativeUnits_V1_CountryNames_CountryNamesTranslation = []
        else:
            self.AdministrativeUnits_V1_CountryNames_CountryNamesTranslation = (
                AdministrativeUnits_V1_CountryNames_CountryNamesTranslation
            )
        self.AdministrativeUnits_V1_CountryNames_CountryNamesTranslation_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, AdministrativeUnits_V1_CountryNames)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdministrativeUnits_V1_CountryNames.subclass:
            return AdministrativeUnits_V1_CountryNames.subclass(*args_, **kwargs_)
        else:
            return AdministrativeUnits_V1_CountryNames(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Dictionaries_V1_Dictionaries_Dictionary(self):
        return self.Dictionaries_V1_Dictionaries_Dictionary

    def set_Dictionaries_V1_Dictionaries_Dictionary(self, Dictionaries_V1_Dictionaries_Dictionary):
        self.Dictionaries_V1_Dictionaries_Dictionary = Dictionaries_V1_Dictionaries_Dictionary

    def add_Dictionaries_V1_Dictionaries_Dictionary(self, value):
        self.Dictionaries_V1_Dictionaries_Dictionary.append(value)

    def insert_Dictionaries_V1_Dictionaries_Dictionary_at(self, index, value):
        self.Dictionaries_V1_Dictionaries_Dictionary.insert(index, value)

    def replace_Dictionaries_V1_Dictionaries_Dictionary_at(self, index, value):
        self.Dictionaries_V1_Dictionaries_Dictionary[index] = value

    def get_AdministrativeUnits_V1_CountryNames_CountryNamesTranslation(self):
        return self.AdministrativeUnits_V1_CountryNames_CountryNamesTranslation

    def set_AdministrativeUnits_V1_CountryNames_CountryNamesTranslation(
        self, AdministrativeUnits_V1_CountryNames_CountryNamesTranslation
    ):
        self.AdministrativeUnits_V1_CountryNames_CountryNamesTranslation = (
            AdministrativeUnits_V1_CountryNames_CountryNamesTranslation
        )

    def add_AdministrativeUnits_V1_CountryNames_CountryNamesTranslation(self, value):
        self.AdministrativeUnits_V1_CountryNames_CountryNamesTranslation.append(value)

    def insert_AdministrativeUnits_V1_CountryNames_CountryNamesTranslation_at(self, index, value):
        self.AdministrativeUnits_V1_CountryNames_CountryNamesTranslation.insert(index, value)

    def replace_AdministrativeUnits_V1_CountryNames_CountryNamesTranslation_at(self, index, value):
        self.AdministrativeUnits_V1_CountryNames_CountryNamesTranslation[index] = value

    def get_BID(self):
        return self.BID

    def set_BID(self, BID):
        self.BID = BID

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if (
            self.Dictionaries_V1_Dictionaries_Dictionary
            or self.AdministrativeUnits_V1_CountryNames_CountryNamesTranslation
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AdministrativeUnits_V1.CountryNames",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("AdministrativeUnits_V1.CountryNames")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "AdministrativeUnits_V1.CountryNames":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="AdministrativeUnits_V1.CountryNames",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="AdministrativeUnits_V1.CountryNames",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="AdministrativeUnits_V1.CountryNames",
    ):
        if self.BID is not None and "BID" not in already_processed:
            already_processed.add("BID")
            outfile.write(
                " BID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.BID), input_name="BID")),)
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AdministrativeUnits_V1.CountryNames",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for Dictionaries_V1_Dictionaries_Dictionary_ in self.Dictionaries_V1_Dictionaries_Dictionary:
            namespaceprefix_ = (
                self.Dictionaries_V1_Dictionaries_Dictionary_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Dictionaries_V1_Dictionaries_Dictionary_nsprefix_)
                else ""
            )
            Dictionaries_V1_Dictionaries_Dictionary_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Dictionaries_V1.Dictionaries.Dictionary",
                pretty_print=pretty_print,
            )
        for (
            AdministrativeUnits_V1_CountryNames_CountryNamesTranslation_
        ) in self.AdministrativeUnits_V1_CountryNames_CountryNamesTranslation:
            namespaceprefix_ = (
                self.AdministrativeUnits_V1_CountryNames_CountryNamesTranslation_nsprefix_ + ":"
                if (
                    UseCapturedNS_
                    and self.AdministrativeUnits_V1_CountryNames_CountryNamesTranslation_nsprefix_
                )
                else ""
            )
            AdministrativeUnits_V1_CountryNames_CountryNamesTranslation_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="AdministrativeUnits_V1.CountryNames.CountryNamesTranslation",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("BID", node)
        if value is not None and "BID" not in already_processed:
            already_processed.add("BID")
            self.BID = value
            self.validate_IliID(self.BID)  # validate type IliID

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "Dictionaries_V1.Dictionaries.Dictionary":
            obj_ = Dictionaries_V1_Dictionaries_Dictionary.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Dictionaries_V1_Dictionaries_Dictionary.append(obj_)
            obj_.original_tagname_ = "Dictionaries_V1.Dictionaries.Dictionary"
        elif nodeName_ == "AdministrativeUnits_V1.CountryNames.CountryNamesTranslation":
            obj_ = AdministrativeUnits_V1_CountryNames_CountryNamesTranslation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AdministrativeUnits_V1_CountryNames_CountryNamesTranslation.append(obj_)
            obj_.original_tagname_ = "AdministrativeUnits_V1.CountryNames.CountryNamesTranslation"


# end class AdministrativeUnits_V1_CountryNames


class AdministrativeUnits_V1_Agencies_Agency(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "TID": MemberSpec_("TID", "IliID", 0, 0, {"use": "required", "name": "TID"}),
        "Supervisor": MemberSpec_(
            "Supervisor",
            "SupervisorType10",
            0,
            0,
            {"name": "Supervisor", "type": "SupervisorType10"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, TID=None, Supervisor=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.TID = _cast(None, TID)
        self.TID_nsprefix_ = None
        if Supervisor is None:
            self.Supervisor = globals()["SupervisorType10"]()
        else:
            self.Supervisor = Supervisor
        self.Supervisor_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, AdministrativeUnits_V1_Agencies_Agency)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdministrativeUnits_V1_Agencies_Agency.subclass:
            return AdministrativeUnits_V1_Agencies_Agency.subclass(*args_, **kwargs_)
        else:
            return AdministrativeUnits_V1_Agencies_Agency(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Supervisor(self):
        return self.Supervisor

    def set_Supervisor(self, Supervisor):
        self.Supervisor = Supervisor

    def get_TID(self):
        return self.TID

    def set_TID(self, TID):
        self.TID = TID

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if self.Supervisor is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AdministrativeUnits_V1.Agencies.Agency",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("AdministrativeUnits_V1.Agencies.Agency")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "AdministrativeUnits_V1.Agencies.Agency":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="AdministrativeUnits_V1.Agencies.Agency",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="AdministrativeUnits_V1.Agencies.Agency",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="AdministrativeUnits_V1.Agencies.Agency",
    ):
        if self.TID is not None and "TID" not in already_processed:
            already_processed.add("TID")
            outfile.write(
                " TID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.TID), input_name="TID")),)
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AdministrativeUnits_V1.Agencies.Agency",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.Supervisor is not None:
            namespaceprefix_ = (
                self.Supervisor_nsprefix_ + ":" if (UseCapturedNS_ and self.Supervisor_nsprefix_) else ""
            )
            self.Supervisor.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Supervisor",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("TID", node)
        if value is not None and "TID" not in already_processed:
            already_processed.add("TID")
            self.TID = value
            self.validate_IliID(self.TID)  # validate type IliID

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "Supervisor":
            obj_ = SupervisorType10.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Supervisor = obj_
            obj_.original_tagname_ = "Supervisor"


# end class AdministrativeUnits_V1_Agencies_Agency


class AdministrativeUnits_V1_Agencies_Organisation(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "Orderer": MemberSpec_("Orderer", "RoleType", 0, 0, {"name": "Orderer", "type": "RoleType"}, None),
        "Executor": MemberSpec_("Executor", "RoleType", 0, 0, {"name": "Executor", "type": "RoleType"}, None),
    }
    subclass = None
    superclass = None

    def __init__(self, Orderer=None, Executor=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.Orderer = Orderer
        self.Orderer_nsprefix_ = None
        self.Executor = Executor
        self.Executor_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdministrativeUnits_V1_Agencies_Organisation
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdministrativeUnits_V1_Agencies_Organisation.subclass:
            return AdministrativeUnits_V1_Agencies_Organisation.subclass(*args_, **kwargs_)
        else:
            return AdministrativeUnits_V1_Agencies_Organisation(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Orderer(self):
        return self.Orderer

    def set_Orderer(self, Orderer):
        self.Orderer = Orderer

    def get_Executor(self):
        return self.Executor

    def set_Executor(self, Executor):
        self.Executor = Executor

    def _hasContent(self):
        if self.Orderer is not None or self.Executor is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AdministrativeUnits_V1.Agencies.Organisation",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("AdministrativeUnits_V1.Agencies.Organisation")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "AdministrativeUnits_V1.Agencies.Organisation":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="AdministrativeUnits_V1.Agencies.Organisation",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="AdministrativeUnits_V1.Agencies.Organisation",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="AdministrativeUnits_V1.Agencies.Organisation",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AdministrativeUnits_V1.Agencies.Organisation",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.Orderer is not None:
            namespaceprefix_ = (
                self.Orderer_nsprefix_ + ":" if (UseCapturedNS_ and self.Orderer_nsprefix_) else ""
            )
            self.Orderer.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Orderer",
                pretty_print=pretty_print,
            )
        if self.Executor is not None:
            namespaceprefix_ = (
                self.Executor_nsprefix_ + ":" if (UseCapturedNS_ and self.Executor_nsprefix_) else ""
            )
            self.Executor.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Executor",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "Orderer":
            obj_ = RoleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Orderer = obj_
            obj_.original_tagname_ = "Orderer"
        elif nodeName_ == "Executor":
            obj_ = RoleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Executor = obj_
            obj_.original_tagname_ = "Executor"


# end class AdministrativeUnits_V1_Agencies_Organisation


class AdministrativeUnits_V1_Agencies(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "BID": MemberSpec_("BID", "IliID", 0, 0, {"use": "required", "name": "BID"}),
        "AdministrativeUnits_V1_Agencies_Organisation": MemberSpec_(
            "AdministrativeUnits_V1_Agencies_Organisation",
            "AdministrativeUnits_V1.Agencies.Organisation",
            1,
            1,
            {
                "name": "AdministrativeUnits_V1.Agencies.Organisation",
                "type": "AdministrativeUnits_V1.Agencies.Organisation",
            },
            10,
        ),
    }
    subclass = None
    superclass = None

    def __init__(
        self, BID=None, AdministrativeUnits_V1_Agencies_Organisation=None, gds_collector_=None, **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.BID = _cast(None, BID)
        self.BID_nsprefix_ = None
        if AdministrativeUnits_V1_Agencies_Organisation is None:
            self.AdministrativeUnits_V1_Agencies_Organisation = []
        else:
            self.AdministrativeUnits_V1_Agencies_Organisation = AdministrativeUnits_V1_Agencies_Organisation
        self.AdministrativeUnits_V1_Agencies_Organisation_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, AdministrativeUnits_V1_Agencies)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdministrativeUnits_V1_Agencies.subclass:
            return AdministrativeUnits_V1_Agencies.subclass(*args_, **kwargs_)
        else:
            return AdministrativeUnits_V1_Agencies(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_AdministrativeUnits_V1_Agencies_Organisation(self):
        return self.AdministrativeUnits_V1_Agencies_Organisation

    def set_AdministrativeUnits_V1_Agencies_Organisation(self, AdministrativeUnits_V1_Agencies_Organisation):
        self.AdministrativeUnits_V1_Agencies_Organisation = AdministrativeUnits_V1_Agencies_Organisation

    def add_AdministrativeUnits_V1_Agencies_Organisation(self, value):
        self.AdministrativeUnits_V1_Agencies_Organisation.append(value)

    def insert_AdministrativeUnits_V1_Agencies_Organisation_at(self, index, value):
        self.AdministrativeUnits_V1_Agencies_Organisation.insert(index, value)

    def replace_AdministrativeUnits_V1_Agencies_Organisation_at(self, index, value):
        self.AdministrativeUnits_V1_Agencies_Organisation[index] = value

    def get_BID(self):
        return self.BID

    def set_BID(self, BID):
        self.BID = BID

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if self.AdministrativeUnits_V1_Agencies_Organisation:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AdministrativeUnits_V1.Agencies",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("AdministrativeUnits_V1.Agencies")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "AdministrativeUnits_V1.Agencies":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="AdministrativeUnits_V1.Agencies",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="AdministrativeUnits_V1.Agencies",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="AdministrativeUnits_V1.Agencies",
    ):
        if self.BID is not None and "BID" not in already_processed:
            already_processed.add("BID")
            outfile.write(
                " BID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.BID), input_name="BID")),)
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AdministrativeUnits_V1.Agencies",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for (
            AdministrativeUnits_V1_Agencies_Organisation_
        ) in self.AdministrativeUnits_V1_Agencies_Organisation:
            namespaceprefix_ = (
                self.AdministrativeUnits_V1_Agencies_Organisation_nsprefix_ + ":"
                if (UseCapturedNS_ and self.AdministrativeUnits_V1_Agencies_Organisation_nsprefix_)
                else ""
            )
            AdministrativeUnits_V1_Agencies_Organisation_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="AdministrativeUnits_V1.Agencies.Organisation",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("BID", node)
        if value is not None and "BID" not in already_processed:
            already_processed.add("BID")
            self.BID = value
            self.validate_IliID(self.BID)  # validate type IliID

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "AdministrativeUnits_V1.Agencies.Organisation":
            obj_ = AdministrativeUnits_V1_Agencies_Organisation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AdministrativeUnits_V1_Agencies_Organisation.append(obj_)
            obj_.original_tagname_ = "AdministrativeUnits_V1.Agencies.Organisation"


# end class AdministrativeUnits_V1_Agencies


class CoordSys_Angle_DMS_S(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "Degrees": MemberSpec_(
            "Degrees",
            ["DegreesType", "xsd:integer"],
            0,
            1,
            {"minOccurs": "0", "name": "Degrees", "type": "xsd:integer"},
            None,
        ),
        "Minutes": MemberSpec_(
            "Minutes",
            ["MinutesType", "xsd:integer"],
            0,
            1,
            {"minOccurs": "0", "name": "Minutes", "type": "xsd:integer"},
            None,
        ),
        "Seconds": MemberSpec_(
            "Seconds",
            ["SecondsType", "xsd:double"],
            0,
            1,
            {"minOccurs": "0", "name": "Seconds", "type": "xsd:double"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, Degrees=None, Minutes=None, Seconds=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.Degrees = Degrees
        self.validate_DegreesType(self.Degrees)
        self.Degrees_nsprefix_ = None
        self.Minutes = Minutes
        self.validate_MinutesType(self.Minutes)
        self.Minutes_nsprefix_ = None
        self.Seconds = Seconds
        self.validate_SecondsType(self.Seconds)
        self.Seconds_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, CoordSys_Angle_DMS_S)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoordSys_Angle_DMS_S.subclass:
            return CoordSys_Angle_DMS_S.subclass(*args_, **kwargs_)
        else:
            return CoordSys_Angle_DMS_S(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Degrees(self):
        return self.Degrees

    def set_Degrees(self, Degrees):
        self.Degrees = Degrees

    def get_Minutes(self):
        return self.Minutes

    def set_Minutes(self, Minutes):
        self.Minutes = Minutes

    def get_Seconds(self):
        return self.Seconds

    def set_Seconds(self, Seconds):
        self.Seconds = Seconds

    def validate_DegreesType(self, value):
        result = True
        # Validate type DegreesType, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if value < -180:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on DegreesType'
                    % {"value": value, "lineno": lineno}
                )
                result = False
            if value > 180:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on DegreesType'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_MinutesType(self, value):
        result = True
        # Validate type MinutesType, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on MinutesType'
                    % {"value": value, "lineno": lineno}
                )
                result = False
            if value > 59:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on MinutesType'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_SecondsType(self, value):
        result = True
        # Validate type SecondsType, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (float)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if value < 0.000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on SecondsType'
                    % {"value": value, "lineno": lineno}
                )
                result = False
            if value > 59.999:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on SecondsType'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def _hasContent(self):
        if self.Degrees is not None or self.Minutes is not None or self.Seconds is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.Angle_DMS_S",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("CoordSys.Angle_DMS_S")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "CoordSys.Angle_DMS_S":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="CoordSys.Angle_DMS_S",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="CoordSys.Angle_DMS_S",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="CoordSys.Angle_DMS_S",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.Angle_DMS_S",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.Degrees is not None:
            namespaceprefix_ = (
                self.Degrees_nsprefix_ + ":" if (UseCapturedNS_ and self.Degrees_nsprefix_) else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sDegrees>%s</%sDegrees>%s"
                % (
                    namespaceprefix_,
                    self.gds_format_integer(self.Degrees, input_name="Degrees"),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.Minutes is not None:
            namespaceprefix_ = (
                self.Minutes_nsprefix_ + ":" if (UseCapturedNS_ and self.Minutes_nsprefix_) else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sMinutes>%s</%sMinutes>%s"
                % (
                    namespaceprefix_,
                    self.gds_format_integer(self.Minutes, input_name="Minutes"),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.Seconds is not None:
            namespaceprefix_ = (
                self.Seconds_nsprefix_ + ":" if (UseCapturedNS_ and self.Seconds_nsprefix_) else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sSeconds>%s</%sSeconds>%s"
                % (
                    namespaceprefix_,
                    self.gds_format_double(self.Seconds, input_name="Seconds"),
                    namespaceprefix_,
                    eol_,
                )
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "Degrees" and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, "Degrees")
            ival_ = self.gds_validate_integer(ival_, node, "Degrees")
            self.Degrees = ival_
            self.Degrees_nsprefix_ = child_.prefix
            # validate type DegreesType
            self.validate_DegreesType(self.Degrees)
        elif nodeName_ == "Minutes" and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, "Minutes")
            ival_ = self.gds_validate_integer(ival_, node, "Minutes")
            self.Minutes = ival_
            self.Minutes_nsprefix_ = child_.prefix
            # validate type MinutesType
            self.validate_MinutesType(self.Minutes)
        elif nodeName_ == "Seconds" and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, "Seconds")
            fval_ = self.gds_validate_double(fval_, node, "Seconds")
            self.Seconds = fval_
            self.Seconds_nsprefix_ = child_.prefix
            # validate type SecondsType
            self.validate_SecondsType(self.Seconds)


# end class CoordSys_Angle_DMS_S


class CoordSys_CoordsysTopic_Ellipsoid(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "TID": MemberSpec_("TID", "IliID", 0, 0, {"use": "required", "name": "TID"}),
        "Name": MemberSpec_(
            "Name",
            ["INTERLIS.NAME", "xsd:normalizedString"],
            0,
            0,
            {"name": "Name", "type": "xsd:normalizedString"},
            None,
        ),
        "EllipsoidAlias": MemberSpec_(
            "EllipsoidAlias",
            ["EllipsoidAliasType", "xsd:normalizedString"],
            0,
            1,
            {
                "minOccurs": "0",
                "name": "EllipsoidAlias",
                "type": "xsd:normalizedString",
            },
            None,
        ),
        "SemiMajorAxis": MemberSpec_(
            "SemiMajorAxis",
            ["SemiMajorAxisType", "xsd:double"],
            0,
            0,
            {"name": "SemiMajorAxis", "type": "xsd:double"},
            None,
        ),
        "InverseFlattening": MemberSpec_(
            "InverseFlattening",
            ["InverseFlatteningType", "xsd:double"],
            0,
            0,
            {"name": "InverseFlattening", "type": "xsd:double"},
            None,
        ),
        "Remarks": MemberSpec_(
            "Remarks",
            ["RemarksType", "xsd:normalizedString"],
            0,
            1,
            {"minOccurs": "0", "name": "Remarks", "type": "xsd:normalizedString"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(
        self,
        TID=None,
        Name=None,
        EllipsoidAlias=None,
        SemiMajorAxis=None,
        InverseFlattening=None,
        Remarks=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.TID = _cast(None, TID)
        self.TID_nsprefix_ = None
        self.Name = Name
        self.validate_INTERLIS_NAME(self.Name)
        self.Name_nsprefix_ = None
        self.EllipsoidAlias = EllipsoidAlias
        self.validate_EllipsoidAliasType(self.EllipsoidAlias)
        self.EllipsoidAlias_nsprefix_ = None
        self.SemiMajorAxis = SemiMajorAxis
        self.validate_SemiMajorAxisType(self.SemiMajorAxis)
        self.SemiMajorAxis_nsprefix_ = None
        self.InverseFlattening = InverseFlattening
        self.validate_InverseFlatteningType(self.InverseFlattening)
        self.InverseFlattening_nsprefix_ = None
        self.Remarks = Remarks
        self.validate_RemarksType(self.Remarks)
        self.Remarks_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, CoordSys_CoordsysTopic_Ellipsoid)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoordSys_CoordsysTopic_Ellipsoid.subclass:
            return CoordSys_CoordsysTopic_Ellipsoid.subclass(*args_, **kwargs_)
        else:
            return CoordSys_CoordsysTopic_Ellipsoid(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Name(self):
        return self.Name

    def set_Name(self, Name):
        self.Name = Name

    def get_EllipsoidAlias(self):
        return self.EllipsoidAlias

    def set_EllipsoidAlias(self, EllipsoidAlias):
        self.EllipsoidAlias = EllipsoidAlias

    def get_SemiMajorAxis(self):
        return self.SemiMajorAxis

    def set_SemiMajorAxis(self, SemiMajorAxis):
        self.SemiMajorAxis = SemiMajorAxis

    def get_InverseFlattening(self):
        return self.InverseFlattening

    def set_InverseFlattening(self, InverseFlattening):
        self.InverseFlattening = InverseFlattening

    def get_Remarks(self):
        return self.Remarks

    def set_Remarks(self, Remarks):
        self.Remarks = Remarks

    def get_TID(self):
        return self.TID

    def set_TID(self, TID):
        self.TID = TID

    def validate_INTERLIS_NAME(self, value):
        result = True
        # Validate type INTERLIS.NAME, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on INTERLIS.NAME'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_EllipsoidAliasType(self, value):
        result = True
        # Validate type EllipsoidAliasType, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if len(value) > 70:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on EllipsoidAliasType'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_SemiMajorAxisType(self, value):
        result = True
        # Validate type SemiMajorAxisType, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (float)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if value < 6360000.0000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on SemiMajorAxisType'
                    % {"value": value, "lineno": lineno}
                )
                result = False
            if value > 6390000.0000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on SemiMajorAxisType'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_InverseFlatteningType(self, value):
        result = True
        # Validate type InverseFlatteningType, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (float)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if value < 0.00000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on InverseFlatteningType'
                    % {"value": value, "lineno": lineno}
                )
                result = False
            if value > 350.00000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on InverseFlatteningType'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_RemarksType(self, value):
        result = True
        # Validate type RemarksType, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if len(value) > 70:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on RemarksType'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if (
            self.Name is not None
            or self.EllipsoidAlias is not None
            or self.SemiMajorAxis is not None
            or self.InverseFlattening is not None
            or self.Remarks is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.Ellipsoid",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("CoordSys.CoordsysTopic.Ellipsoid")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "CoordSys.CoordsysTopic.Ellipsoid":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="CoordSys.CoordsysTopic.Ellipsoid",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="CoordSys.CoordsysTopic.Ellipsoid",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="CoordSys.CoordsysTopic.Ellipsoid",
    ):
        if self.TID is not None and "TID" not in already_processed:
            already_processed.add("TID")
            outfile.write(
                " TID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.TID), input_name="TID")),)
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.Ellipsoid",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.Name is not None:
            namespaceprefix_ = self.Name_nsprefix_ + ":" if (UseCapturedNS_ and self.Name_nsprefix_) else ""
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sName>%s</%sName>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name="Name")),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.EllipsoidAlias is not None:
            namespaceprefix_ = (
                self.EllipsoidAlias_nsprefix_ + ":"
                if (UseCapturedNS_ and self.EllipsoidAlias_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sEllipsoidAlias>%s</%sEllipsoidAlias>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(quote_xml(self.EllipsoidAlias), input_name="EllipsoidAlias")
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.SemiMajorAxis is not None:
            namespaceprefix_ = (
                self.SemiMajorAxis_nsprefix_ + ":"
                if (UseCapturedNS_ and self.SemiMajorAxis_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sSemiMajorAxis>%s</%sSemiMajorAxis>%s"
                % (
                    namespaceprefix_,
                    self.gds_format_double(self.SemiMajorAxis, input_name="SemiMajorAxis"),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.InverseFlattening is not None:
            namespaceprefix_ = (
                self.InverseFlattening_nsprefix_ + ":"
                if (UseCapturedNS_ and self.InverseFlattening_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sInverseFlattening>%s</%sInverseFlattening>%s"
                % (
                    namespaceprefix_,
                    self.gds_format_double(self.InverseFlattening, input_name="InverseFlattening"),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.Remarks is not None:
            namespaceprefix_ = (
                self.Remarks_nsprefix_ + ":" if (UseCapturedNS_ and self.Remarks_nsprefix_) else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sRemarks>%s</%sRemarks>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(self.gds_format_string(quote_xml(self.Remarks), input_name="Remarks")),
                    namespaceprefix_,
                    eol_,
                )
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("TID", node)
        if value is not None and "TID" not in already_processed:
            already_processed.add("TID")
            self.TID = value
            self.validate_IliID(self.TID)  # validate type IliID

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "Name":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Name")
            value_ = self.gds_validate_string(value_, node, "Name")
            self.Name = value_
            self.Name_nsprefix_ = child_.prefix
            # validate type INTERLIS.NAME
            self.validate_INTERLIS_NAME(self.Name)
        elif nodeName_ == "EllipsoidAlias":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "EllipsoidAlias")
            value_ = self.gds_validate_string(value_, node, "EllipsoidAlias")
            self.EllipsoidAlias = value_
            self.EllipsoidAlias_nsprefix_ = child_.prefix
            # validate type EllipsoidAliasType
            self.validate_EllipsoidAliasType(self.EllipsoidAlias)
        elif nodeName_ == "SemiMajorAxis" and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, "SemiMajorAxis")
            fval_ = self.gds_validate_double(fval_, node, "SemiMajorAxis")
            self.SemiMajorAxis = fval_
            self.SemiMajorAxis_nsprefix_ = child_.prefix
            # validate type SemiMajorAxisType
            self.validate_SemiMajorAxisType(self.SemiMajorAxis)
        elif nodeName_ == "InverseFlattening" and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, "InverseFlattening")
            fval_ = self.gds_validate_double(fval_, node, "InverseFlattening")
            self.InverseFlattening = fval_
            self.InverseFlattening_nsprefix_ = child_.prefix
            # validate type InverseFlatteningType
            self.validate_InverseFlatteningType(self.InverseFlattening)
        elif nodeName_ == "Remarks":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Remarks")
            value_ = self.gds_validate_string(value_, node, "Remarks")
            self.Remarks = value_
            self.Remarks_nsprefix_ = child_.prefix
            # validate type RemarksType
            self.validate_RemarksType(self.Remarks)


# end class CoordSys_CoordsysTopic_Ellipsoid


class CoordSys_CoordsysTopic_GravityModel(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "TID": MemberSpec_("TID", "IliID", 0, 0, {"use": "required", "name": "TID"}),
        "Name": MemberSpec_(
            "Name",
            ["INTERLIS.NAME", "xsd:normalizedString"],
            0,
            0,
            {"name": "Name", "type": "xsd:normalizedString"},
            None,
        ),
        "GravityModAlias": MemberSpec_(
            "GravityModAlias",
            ["GravityModAliasType", "xsd:normalizedString"],
            0,
            1,
            {
                "minOccurs": "0",
                "name": "GravityModAlias",
                "type": "xsd:normalizedString",
            },
            None,
        ),
        "Definition": MemberSpec_(
            "Definition",
            ["DefinitionType", "xsd:normalizedString"],
            0,
            1,
            {"minOccurs": "0", "name": "Definition", "type": "xsd:normalizedString"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(
        self, TID=None, Name=None, GravityModAlias=None, Definition=None, gds_collector_=None, **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.TID = _cast(None, TID)
        self.TID_nsprefix_ = None
        self.Name = Name
        self.validate_INTERLIS_NAME(self.Name)
        self.Name_nsprefix_ = None
        self.GravityModAlias = GravityModAlias
        self.validate_GravityModAliasType(self.GravityModAlias)
        self.GravityModAlias_nsprefix_ = None
        self.Definition = Definition
        self.validate_DefinitionType(self.Definition)
        self.Definition_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, CoordSys_CoordsysTopic_GravityModel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoordSys_CoordsysTopic_GravityModel.subclass:
            return CoordSys_CoordsysTopic_GravityModel.subclass(*args_, **kwargs_)
        else:
            return CoordSys_CoordsysTopic_GravityModel(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Name(self):
        return self.Name

    def set_Name(self, Name):
        self.Name = Name

    def get_GravityModAlias(self):
        return self.GravityModAlias

    def set_GravityModAlias(self, GravityModAlias):
        self.GravityModAlias = GravityModAlias

    def get_Definition(self):
        return self.Definition

    def set_Definition(self, Definition):
        self.Definition = Definition

    def get_TID(self):
        return self.TID

    def set_TID(self, TID):
        self.TID = TID

    def validate_INTERLIS_NAME(self, value):
        result = True
        # Validate type INTERLIS.NAME, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on INTERLIS.NAME'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_GravityModAliasType(self, value):
        result = True
        # Validate type GravityModAliasType, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if len(value) > 70:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on GravityModAliasType'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_DefinitionType(self, value):
        result = True
        # Validate type DefinitionType, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if len(value) > 70:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on DefinitionType'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if self.Name is not None or self.GravityModAlias is not None or self.Definition is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.GravityModel",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("CoordSys.CoordsysTopic.GravityModel")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "CoordSys.CoordsysTopic.GravityModel":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="CoordSys.CoordsysTopic.GravityModel",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="CoordSys.CoordsysTopic.GravityModel",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="CoordSys.CoordsysTopic.GravityModel",
    ):
        if self.TID is not None and "TID" not in already_processed:
            already_processed.add("TID")
            outfile.write(
                " TID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.TID), input_name="TID")),)
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.GravityModel",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.Name is not None:
            namespaceprefix_ = self.Name_nsprefix_ + ":" if (UseCapturedNS_ and self.Name_nsprefix_) else ""
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sName>%s</%sName>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name="Name")),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.GravityModAlias is not None:
            namespaceprefix_ = (
                self.GravityModAlias_nsprefix_ + ":"
                if (UseCapturedNS_ and self.GravityModAlias_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sGravityModAlias>%s</%sGravityModAlias>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(
                            quote_xml(self.GravityModAlias),
                            input_name="GravityModAlias",
                        )
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.Definition is not None:
            namespaceprefix_ = (
                self.Definition_nsprefix_ + ":" if (UseCapturedNS_ and self.Definition_nsprefix_) else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sDefinition>%s</%sDefinition>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(quote_xml(self.Definition), input_name="Definition")
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("TID", node)
        if value is not None and "TID" not in already_processed:
            already_processed.add("TID")
            self.TID = value
            self.validate_IliID(self.TID)  # validate type IliID

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "Name":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Name")
            value_ = self.gds_validate_string(value_, node, "Name")
            self.Name = value_
            self.Name_nsprefix_ = child_.prefix
            # validate type INTERLIS.NAME
            self.validate_INTERLIS_NAME(self.Name)
        elif nodeName_ == "GravityModAlias":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "GravityModAlias")
            value_ = self.gds_validate_string(value_, node, "GravityModAlias")
            self.GravityModAlias = value_
            self.GravityModAlias_nsprefix_ = child_.prefix
            # validate type GravityModAliasType
            self.validate_GravityModAliasType(self.GravityModAlias)
        elif nodeName_ == "Definition":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Definition")
            value_ = self.gds_validate_string(value_, node, "Definition")
            self.Definition = value_
            self.Definition_nsprefix_ = child_.prefix
            # validate type DefinitionType
            self.validate_DefinitionType(self.Definition)


# end class CoordSys_CoordsysTopic_GravityModel


class CoordSys_CoordsysTopic_GeoidModel(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "TID": MemberSpec_("TID", "IliID", 0, 0, {"use": "required", "name": "TID"}),
        "Name": MemberSpec_(
            "Name",
            ["INTERLIS.NAME", "xsd:normalizedString"],
            0,
            0,
            {"name": "Name", "type": "xsd:normalizedString"},
            None,
        ),
        "GeoidModAlias": MemberSpec_(
            "GeoidModAlias",
            ["GeoidModAliasType", "xsd:normalizedString"],
            0,
            1,
            {"minOccurs": "0", "name": "GeoidModAlias", "type": "xsd:normalizedString"},
            None,
        ),
        "Definition": MemberSpec_(
            "Definition",
            ["DefinitionType11", "xsd:normalizedString"],
            0,
            1,
            {"minOccurs": "0", "name": "Definition", "type": "xsd:normalizedString"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(
        self, TID=None, Name=None, GeoidModAlias=None, Definition=None, gds_collector_=None, **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.TID = _cast(None, TID)
        self.TID_nsprefix_ = None
        self.Name = Name
        self.validate_INTERLIS_NAME(self.Name)
        self.Name_nsprefix_ = None
        self.GeoidModAlias = GeoidModAlias
        self.validate_GeoidModAliasType(self.GeoidModAlias)
        self.GeoidModAlias_nsprefix_ = None
        self.Definition = Definition
        self.validate_DefinitionType11(self.Definition)
        self.Definition_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, CoordSys_CoordsysTopic_GeoidModel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoordSys_CoordsysTopic_GeoidModel.subclass:
            return CoordSys_CoordsysTopic_GeoidModel.subclass(*args_, **kwargs_)
        else:
            return CoordSys_CoordsysTopic_GeoidModel(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Name(self):
        return self.Name

    def set_Name(self, Name):
        self.Name = Name

    def get_GeoidModAlias(self):
        return self.GeoidModAlias

    def set_GeoidModAlias(self, GeoidModAlias):
        self.GeoidModAlias = GeoidModAlias

    def get_Definition(self):
        return self.Definition

    def set_Definition(self, Definition):
        self.Definition = Definition

    def get_TID(self):
        return self.TID

    def set_TID(self, TID):
        self.TID = TID

    def validate_INTERLIS_NAME(self, value):
        result = True
        # Validate type INTERLIS.NAME, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on INTERLIS.NAME'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_GeoidModAliasType(self, value):
        result = True
        # Validate type GeoidModAliasType, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if len(value) > 70:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on GeoidModAliasType'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_DefinitionType11(self, value):
        result = True
        # Validate type DefinitionType11, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if len(value) > 70:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on DefinitionType11'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if self.Name is not None or self.GeoidModAlias is not None or self.Definition is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.GeoidModel",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("CoordSys.CoordsysTopic.GeoidModel")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "CoordSys.CoordsysTopic.GeoidModel":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="CoordSys.CoordsysTopic.GeoidModel",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="CoordSys.CoordsysTopic.GeoidModel",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="CoordSys.CoordsysTopic.GeoidModel",
    ):
        if self.TID is not None and "TID" not in already_processed:
            already_processed.add("TID")
            outfile.write(
                " TID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.TID), input_name="TID")),)
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.GeoidModel",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.Name is not None:
            namespaceprefix_ = self.Name_nsprefix_ + ":" if (UseCapturedNS_ and self.Name_nsprefix_) else ""
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sName>%s</%sName>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name="Name")),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.GeoidModAlias is not None:
            namespaceprefix_ = (
                self.GeoidModAlias_nsprefix_ + ":"
                if (UseCapturedNS_ and self.GeoidModAlias_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sGeoidModAlias>%s</%sGeoidModAlias>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(quote_xml(self.GeoidModAlias), input_name="GeoidModAlias")
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.Definition is not None:
            namespaceprefix_ = (
                self.Definition_nsprefix_ + ":" if (UseCapturedNS_ and self.Definition_nsprefix_) else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sDefinition>%s</%sDefinition>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(quote_xml(self.Definition), input_name="Definition")
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("TID", node)
        if value is not None and "TID" not in already_processed:
            already_processed.add("TID")
            self.TID = value
            self.validate_IliID(self.TID)  # validate type IliID

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "Name":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Name")
            value_ = self.gds_validate_string(value_, node, "Name")
            self.Name = value_
            self.Name_nsprefix_ = child_.prefix
            # validate type INTERLIS.NAME
            self.validate_INTERLIS_NAME(self.Name)
        elif nodeName_ == "GeoidModAlias":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "GeoidModAlias")
            value_ = self.gds_validate_string(value_, node, "GeoidModAlias")
            self.GeoidModAlias = value_
            self.GeoidModAlias_nsprefix_ = child_.prefix
            # validate type GeoidModAliasType
            self.validate_GeoidModAliasType(self.GeoidModAlias)
        elif nodeName_ == "Definition":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Definition")
            value_ = self.gds_validate_string(value_, node, "Definition")
            self.Definition = value_
            self.Definition_nsprefix_ = child_.prefix
            # validate type DefinitionType11
            self.validate_DefinitionType11(self.Definition)


# end class CoordSys_CoordsysTopic_GeoidModel


class CoordSys_CoordsysTopic_LengthAXIS(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "ShortName": MemberSpec_(
            "ShortName",
            ["ShortNameType12", "xsd:normalizedString"],
            0,
            1,
            {"minOccurs": "0", "name": "ShortName", "type": "xsd:normalizedString"},
            None,
        ),
        "Description": MemberSpec_(
            "Description",
            ["DescriptionType13", "xsd:normalizedString"],
            0,
            1,
            {"minOccurs": "0", "name": "Description", "type": "xsd:normalizedString"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, ShortName=None, Description=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.ShortName = ShortName
        self.validate_ShortNameType12(self.ShortName)
        self.ShortName_nsprefix_ = None
        self.Description = Description
        self.validate_DescriptionType13(self.Description)
        self.Description_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, CoordSys_CoordsysTopic_LengthAXIS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoordSys_CoordsysTopic_LengthAXIS.subclass:
            return CoordSys_CoordsysTopic_LengthAXIS.subclass(*args_, **kwargs_)
        else:
            return CoordSys_CoordsysTopic_LengthAXIS(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ShortName(self):
        return self.ShortName

    def set_ShortName(self, ShortName):
        self.ShortName = ShortName

    def get_Description(self):
        return self.Description

    def set_Description(self, Description):
        self.Description = Description

    def validate_ShortNameType12(self, value):
        result = True
        # Validate type ShortNameType12, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if len(value) > 12:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ShortNameType12'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_DescriptionType13(self, value):
        result = True
        # Validate type DescriptionType13, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on DescriptionType13'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def _hasContent(self):
        if self.ShortName is not None or self.Description is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.LengthAXIS",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("CoordSys.CoordsysTopic.LengthAXIS")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "CoordSys.CoordsysTopic.LengthAXIS":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="CoordSys.CoordsysTopic.LengthAXIS",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="CoordSys.CoordsysTopic.LengthAXIS",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="CoordSys.CoordsysTopic.LengthAXIS",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.LengthAXIS",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.ShortName is not None:
            namespaceprefix_ = (
                self.ShortName_nsprefix_ + ":" if (UseCapturedNS_ and self.ShortName_nsprefix_) else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sShortName>%s</%sShortName>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(quote_xml(self.ShortName), input_name="ShortName")
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.Description is not None:
            namespaceprefix_ = (
                self.Description_nsprefix_ + ":" if (UseCapturedNS_ and self.Description_nsprefix_) else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sDescription>%s</%sDescription>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(quote_xml(self.Description), input_name="Description")
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "ShortName":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "ShortName")
            value_ = self.gds_validate_string(value_, node, "ShortName")
            self.ShortName = value_
            self.ShortName_nsprefix_ = child_.prefix
            # validate type ShortNameType12
            self.validate_ShortNameType12(self.ShortName)
        elif nodeName_ == "Description":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Description")
            value_ = self.gds_validate_string(value_, node, "Description")
            self.Description = value_
            self.Description_nsprefix_ = child_.prefix
            # validate type DescriptionType13
            self.validate_DescriptionType13(self.Description)


# end class CoordSys_CoordsysTopic_LengthAXIS


class CoordSys_CoordsysTopic_AngleAXIS(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "ShortName": MemberSpec_(
            "ShortName",
            ["ShortNameType14", "xsd:normalizedString"],
            0,
            1,
            {"minOccurs": "0", "name": "ShortName", "type": "xsd:normalizedString"},
            None,
        ),
        "Description": MemberSpec_(
            "Description",
            ["DescriptionType15", "xsd:normalizedString"],
            0,
            1,
            {"minOccurs": "0", "name": "Description", "type": "xsd:normalizedString"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, ShortName=None, Description=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.ShortName = ShortName
        self.validate_ShortNameType14(self.ShortName)
        self.ShortName_nsprefix_ = None
        self.Description = Description
        self.validate_DescriptionType15(self.Description)
        self.Description_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, CoordSys_CoordsysTopic_AngleAXIS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoordSys_CoordsysTopic_AngleAXIS.subclass:
            return CoordSys_CoordsysTopic_AngleAXIS.subclass(*args_, **kwargs_)
        else:
            return CoordSys_CoordsysTopic_AngleAXIS(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ShortName(self):
        return self.ShortName

    def set_ShortName(self, ShortName):
        self.ShortName = ShortName

    def get_Description(self):
        return self.Description

    def set_Description(self, Description):
        self.Description = Description

    def validate_ShortNameType14(self, value):
        result = True
        # Validate type ShortNameType14, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if len(value) > 12:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ShortNameType14'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_DescriptionType15(self, value):
        result = True
        # Validate type DescriptionType15, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on DescriptionType15'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def _hasContent(self):
        if self.ShortName is not None or self.Description is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.AngleAXIS",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("CoordSys.CoordsysTopic.AngleAXIS")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "CoordSys.CoordsysTopic.AngleAXIS":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="CoordSys.CoordsysTopic.AngleAXIS",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="CoordSys.CoordsysTopic.AngleAXIS",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="CoordSys.CoordsysTopic.AngleAXIS",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.AngleAXIS",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.ShortName is not None:
            namespaceprefix_ = (
                self.ShortName_nsprefix_ + ":" if (UseCapturedNS_ and self.ShortName_nsprefix_) else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sShortName>%s</%sShortName>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(quote_xml(self.ShortName), input_name="ShortName")
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.Description is not None:
            namespaceprefix_ = (
                self.Description_nsprefix_ + ":" if (UseCapturedNS_ and self.Description_nsprefix_) else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sDescription>%s</%sDescription>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(quote_xml(self.Description), input_name="Description")
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "ShortName":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "ShortName")
            value_ = self.gds_validate_string(value_, node, "ShortName")
            self.ShortName = value_
            self.ShortName_nsprefix_ = child_.prefix
            # validate type ShortNameType14
            self.validate_ShortNameType14(self.ShortName)
        elif nodeName_ == "Description":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Description")
            value_ = self.gds_validate_string(value_, node, "Description")
            self.Description = value_
            self.Description_nsprefix_ = child_.prefix
            # validate type DescriptionType15
            self.validate_DescriptionType15(self.Description)


# end class CoordSys_CoordsysTopic_AngleAXIS


class CoordSys_CoordsysTopic_GeoCartesian1D(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "TID": MemberSpec_("TID", "IliID", 0, 0, {"use": "required", "name": "TID"}),
        "Name": MemberSpec_(
            "Name",
            ["INTERLIS.NAME", "xsd:normalizedString"],
            0,
            0,
            {"name": "Name", "type": "xsd:normalizedString"},
            None,
        ),
        "Axis": MemberSpec_("Axis", "AxisType", 0, 0, {"name": "Axis", "type": "AxisType"}, None),
    }
    subclass = None
    superclass = None

    def __init__(self, TID=None, Name=None, Axis=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.TID = _cast(None, TID)
        self.TID_nsprefix_ = None
        self.Name = Name
        self.validate_INTERLIS_NAME(self.Name)
        self.Name_nsprefix_ = None
        if Axis is None:
            self.Axis = globals()["AxisType"]()
        else:
            self.Axis = Axis
        self.Axis_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, CoordSys_CoordsysTopic_GeoCartesian1D)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoordSys_CoordsysTopic_GeoCartesian1D.subclass:
            return CoordSys_CoordsysTopic_GeoCartesian1D.subclass(*args_, **kwargs_)
        else:
            return CoordSys_CoordsysTopic_GeoCartesian1D(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Name(self):
        return self.Name

    def set_Name(self, Name):
        self.Name = Name

    def get_Axis(self):
        return self.Axis

    def set_Axis(self, Axis):
        self.Axis = Axis

    def get_TID(self):
        return self.TID

    def set_TID(self, TID):
        self.TID = TID

    def validate_INTERLIS_NAME(self, value):
        result = True
        # Validate type INTERLIS.NAME, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on INTERLIS.NAME'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if self.Name is not None or self.Axis is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.GeoCartesian1D",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("CoordSys.CoordsysTopic.GeoCartesian1D")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "CoordSys.CoordsysTopic.GeoCartesian1D":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="CoordSys.CoordsysTopic.GeoCartesian1D",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="CoordSys.CoordsysTopic.GeoCartesian1D",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="CoordSys.CoordsysTopic.GeoCartesian1D",
    ):
        if self.TID is not None and "TID" not in already_processed:
            already_processed.add("TID")
            outfile.write(
                " TID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.TID), input_name="TID")),)
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.GeoCartesian1D",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.Name is not None:
            namespaceprefix_ = self.Name_nsprefix_ + ":" if (UseCapturedNS_ and self.Name_nsprefix_) else ""
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sName>%s</%sName>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name="Name")),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.Axis is not None:
            namespaceprefix_ = self.Axis_nsprefix_ + ":" if (UseCapturedNS_ and self.Axis_nsprefix_) else ""
            self.Axis.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Axis",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("TID", node)
        if value is not None and "TID" not in already_processed:
            already_processed.add("TID")
            self.TID = value
            self.validate_IliID(self.TID)  # validate type IliID

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "Name":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Name")
            value_ = self.gds_validate_string(value_, node, "Name")
            self.Name = value_
            self.Name_nsprefix_ = child_.prefix
            # validate type INTERLIS.NAME
            self.validate_INTERLIS_NAME(self.Name)
        elif nodeName_ == "Axis":
            obj_ = AxisType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Axis = obj_
            obj_.original_tagname_ = "Axis"


# end class CoordSys_CoordsysTopic_GeoCartesian1D


class CoordSys_CoordsysTopic_GeoHeight(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "TID": MemberSpec_("TID", "IliID", 0, 0, {"use": "required", "name": "TID"}),
        "Name": MemberSpec_(
            "Name",
            ["INTERLIS.NAME", "xsd:normalizedString"],
            0,
            0,
            {"name": "Name", "type": "xsd:normalizedString"},
            None,
        ),
        "Axis": MemberSpec_("Axis", "AxisType16", 0, 0, {"name": "Axis", "type": "AxisType16"}, None),
        "System": MemberSpec_(
            "System",
            ["SystemType", "xsd:string"],
            0,
            0,
            {"name": "System", "type": "xsd:string"},
            None,
        ),
        "ReferenceHeight": MemberSpec_(
            "ReferenceHeight",
            ["ReferenceHeightType", "xsd:double"],
            0,
            0,
            {"name": "ReferenceHeight", "type": "xsd:double"},
            None,
        ),
        "ReferenceHeightDescr": MemberSpec_(
            "ReferenceHeightDescr",
            ["ReferenceHeightDescrType", "xsd:normalizedString"],
            0,
            1,
            {
                "minOccurs": "0",
                "name": "ReferenceHeightDescr",
                "type": "xsd:normalizedString",
            },
            None,
        ),
        "EllipsoidRef": MemberSpec_(
            "EllipsoidRef",
            "EllipsoidRefType",
            0,
            0,
            {"name": "EllipsoidRef", "type": "EllipsoidRefType"},
            None,
        ),
        "GeoidRef": MemberSpec_(
            "GeoidRef",
            "GeoidRefType",
            0,
            0,
            {"name": "GeoidRef", "type": "GeoidRefType"},
            None,
        ),
        "GravityRef": MemberSpec_(
            "GravityRef",
            "GravityRefType",
            0,
            0,
            {"name": "GravityRef", "type": "GravityRefType"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(
        self,
        TID=None,
        Name=None,
        Axis=None,
        System=None,
        ReferenceHeight=None,
        ReferenceHeightDescr=None,
        EllipsoidRef=None,
        GeoidRef=None,
        GravityRef=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.TID = _cast(None, TID)
        self.TID_nsprefix_ = None
        self.Name = Name
        self.validate_INTERLIS_NAME(self.Name)
        self.Name_nsprefix_ = None
        if Axis is None:
            self.Axis = globals()["AxisType16"]()
        else:
            self.Axis = Axis
        self.Axis_nsprefix_ = None
        self.System = System
        self.validate_SystemType(self.System)
        self.System_nsprefix_ = None
        self.ReferenceHeight = ReferenceHeight
        self.validate_ReferenceHeightType(self.ReferenceHeight)
        self.ReferenceHeight_nsprefix_ = None
        self.ReferenceHeightDescr = ReferenceHeightDescr
        self.validate_ReferenceHeightDescrType(self.ReferenceHeightDescr)
        self.ReferenceHeightDescr_nsprefix_ = None
        if EllipsoidRef is None:
            self.EllipsoidRef = globals()["EllipsoidRefType"]()
        else:
            self.EllipsoidRef = EllipsoidRef
        self.EllipsoidRef_nsprefix_ = None
        if GeoidRef is None:
            self.GeoidRef = globals()["GeoidRefType"]()
        else:
            self.GeoidRef = GeoidRef
        self.GeoidRef_nsprefix_ = None
        if GravityRef is None:
            self.GravityRef = globals()["GravityRefType"]()
        else:
            self.GravityRef = GravityRef
        self.GravityRef_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, CoordSys_CoordsysTopic_GeoHeight)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoordSys_CoordsysTopic_GeoHeight.subclass:
            return CoordSys_CoordsysTopic_GeoHeight.subclass(*args_, **kwargs_)
        else:
            return CoordSys_CoordsysTopic_GeoHeight(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Name(self):
        return self.Name

    def set_Name(self, Name):
        self.Name = Name

    def get_Axis(self):
        return self.Axis

    def set_Axis(self, Axis):
        self.Axis = Axis

    def get_System(self):
        return self.System

    def set_System(self, System):
        self.System = System

    def get_ReferenceHeight(self):
        return self.ReferenceHeight

    def set_ReferenceHeight(self, ReferenceHeight):
        self.ReferenceHeight = ReferenceHeight

    def get_ReferenceHeightDescr(self):
        return self.ReferenceHeightDescr

    def set_ReferenceHeightDescr(self, ReferenceHeightDescr):
        self.ReferenceHeightDescr = ReferenceHeightDescr

    def get_EllipsoidRef(self):
        return self.EllipsoidRef

    def set_EllipsoidRef(self, EllipsoidRef):
        self.EllipsoidRef = EllipsoidRef

    def get_GeoidRef(self):
        return self.GeoidRef

    def set_GeoidRef(self, GeoidRef):
        self.GeoidRef = GeoidRef

    def get_GravityRef(self):
        return self.GravityRef

    def set_GravityRef(self, GravityRef):
        self.GravityRef = GravityRef

    def get_TID(self):
        return self.TID

    def set_TID(self, TID):
        self.TID = TID

    def validate_INTERLIS_NAME(self, value):
        result = True
        # Validate type INTERLIS.NAME, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on INTERLIS.NAME'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_SystemType(self, value):
        result = True
        # Validate type SystemType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            value = value
            enumerations = ["normal", "orthometric", "ellipsoidal", "other"]
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SystemType'
                    % {"value": encode_str_2_3(value), "lineno": lineno}
                )
                result = False
        return result

    def validate_ReferenceHeightType(self, value):
        result = True
        # Validate type ReferenceHeightType, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (float)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if value < -10000.000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on ReferenceHeightType'
                    % {"value": value, "lineno": lineno}
                )
                result = False
            if value > 10000.000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on ReferenceHeightType'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_ReferenceHeightDescrType(self, value):
        result = True
        # Validate type ReferenceHeightDescrType, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if len(value) > 70:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ReferenceHeightDescrType'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if (
            self.Name is not None
            or self.Axis is not None
            or self.System is not None
            or self.ReferenceHeight is not None
            or self.ReferenceHeightDescr is not None
            or self.EllipsoidRef is not None
            or self.GeoidRef is not None
            or self.GravityRef is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.GeoHeight",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("CoordSys.CoordsysTopic.GeoHeight")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "CoordSys.CoordsysTopic.GeoHeight":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="CoordSys.CoordsysTopic.GeoHeight",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="CoordSys.CoordsysTopic.GeoHeight",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="CoordSys.CoordsysTopic.GeoHeight",
    ):
        if self.TID is not None and "TID" not in already_processed:
            already_processed.add("TID")
            outfile.write(
                " TID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.TID), input_name="TID")),)
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.GeoHeight",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.Name is not None:
            namespaceprefix_ = self.Name_nsprefix_ + ":" if (UseCapturedNS_ and self.Name_nsprefix_) else ""
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sName>%s</%sName>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name="Name")),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.Axis is not None:
            namespaceprefix_ = self.Axis_nsprefix_ + ":" if (UseCapturedNS_ and self.Axis_nsprefix_) else ""
            self.Axis.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Axis",
                pretty_print=pretty_print,
            )
        if self.System is not None:
            namespaceprefix_ = (
                self.System_nsprefix_ + ":" if (UseCapturedNS_ and self.System_nsprefix_) else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sSystem>%s</%sSystem>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(self.gds_format_string(quote_xml(self.System), input_name="System")),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.ReferenceHeight is not None:
            namespaceprefix_ = (
                self.ReferenceHeight_nsprefix_ + ":"
                if (UseCapturedNS_ and self.ReferenceHeight_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sReferenceHeight>%s</%sReferenceHeight>%s"
                % (
                    namespaceprefix_,
                    self.gds_format_double(self.ReferenceHeight, input_name="ReferenceHeight"),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.ReferenceHeightDescr is not None:
            namespaceprefix_ = (
                self.ReferenceHeightDescr_nsprefix_ + ":"
                if (UseCapturedNS_ and self.ReferenceHeightDescr_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sReferenceHeightDescr>%s</%sReferenceHeightDescr>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(
                            quote_xml(self.ReferenceHeightDescr),
                            input_name="ReferenceHeightDescr",
                        )
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.EllipsoidRef is not None:
            namespaceprefix_ = (
                self.EllipsoidRef_nsprefix_ + ":" if (UseCapturedNS_ and self.EllipsoidRef_nsprefix_) else ""
            )
            self.EllipsoidRef.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="EllipsoidRef",
                pretty_print=pretty_print,
            )
        if self.GeoidRef is not None:
            namespaceprefix_ = (
                self.GeoidRef_nsprefix_ + ":" if (UseCapturedNS_ and self.GeoidRef_nsprefix_) else ""
            )
            self.GeoidRef.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="GeoidRef",
                pretty_print=pretty_print,
            )
        if self.GravityRef is not None:
            namespaceprefix_ = (
                self.GravityRef_nsprefix_ + ":" if (UseCapturedNS_ and self.GravityRef_nsprefix_) else ""
            )
            self.GravityRef.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="GravityRef",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("TID", node)
        if value is not None and "TID" not in already_processed:
            already_processed.add("TID")
            self.TID = value
            self.validate_IliID(self.TID)  # validate type IliID

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "Name":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Name")
            value_ = self.gds_validate_string(value_, node, "Name")
            self.Name = value_
            self.Name_nsprefix_ = child_.prefix
            # validate type INTERLIS.NAME
            self.validate_INTERLIS_NAME(self.Name)
        elif nodeName_ == "Axis":
            obj_ = AxisType16.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Axis = obj_
            obj_.original_tagname_ = "Axis"
        elif nodeName_ == "System":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "System")
            value_ = self.gds_validate_string(value_, node, "System")
            self.System = value_
            self.System_nsprefix_ = child_.prefix
            # validate type SystemType
            self.validate_SystemType(self.System)
        elif nodeName_ == "ReferenceHeight" and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, "ReferenceHeight")
            fval_ = self.gds_validate_double(fval_, node, "ReferenceHeight")
            self.ReferenceHeight = fval_
            self.ReferenceHeight_nsprefix_ = child_.prefix
            # validate type ReferenceHeightType
            self.validate_ReferenceHeightType(self.ReferenceHeight)
        elif nodeName_ == "ReferenceHeightDescr":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "ReferenceHeightDescr")
            value_ = self.gds_validate_string(value_, node, "ReferenceHeightDescr")
            self.ReferenceHeightDescr = value_
            self.ReferenceHeightDescr_nsprefix_ = child_.prefix
            # validate type ReferenceHeightDescrType
            self.validate_ReferenceHeightDescrType(self.ReferenceHeightDescr)
        elif nodeName_ == "EllipsoidRef":
            obj_ = EllipsoidRefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EllipsoidRef = obj_
            obj_.original_tagname_ = "EllipsoidRef"
        elif nodeName_ == "GeoidRef":
            obj_ = GeoidRefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.GeoidRef = obj_
            obj_.original_tagname_ = "GeoidRef"
        elif nodeName_ == "GravityRef":
            obj_ = GravityRefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.GravityRef = obj_
            obj_.original_tagname_ = "GravityRef"


# end class CoordSys_CoordsysTopic_GeoHeight


class CoordSys_CoordsysTopic_GeoCartesian2D(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "TID": MemberSpec_("TID", "IliID", 0, 0, {"use": "required", "name": "TID"}),
        "Name": MemberSpec_(
            "Name",
            ["INTERLIS.NAME", "xsd:normalizedString"],
            0,
            0,
            {"name": "Name", "type": "xsd:normalizedString"},
            None,
        ),
        "Axis": MemberSpec_("Axis", "AxisType17", 0, 0, {"name": "Axis", "type": "AxisType17"}, None),
        "Definition": MemberSpec_(
            "Definition",
            ["DefinitionType18", "xsd:normalizedString"],
            0,
            1,
            {"minOccurs": "0", "name": "Definition", "type": "xsd:normalizedString"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, TID=None, Name=None, Axis=None, Definition=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.TID = _cast(None, TID)
        self.TID_nsprefix_ = None
        self.Name = Name
        self.validate_INTERLIS_NAME(self.Name)
        self.Name_nsprefix_ = None
        if Axis is None:
            self.Axis = globals()["AxisType17"]()
        else:
            self.Axis = Axis
        self.Axis_nsprefix_ = None
        self.Definition = Definition
        self.validate_DefinitionType18(self.Definition)
        self.Definition_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, CoordSys_CoordsysTopic_GeoCartesian2D)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoordSys_CoordsysTopic_GeoCartesian2D.subclass:
            return CoordSys_CoordsysTopic_GeoCartesian2D.subclass(*args_, **kwargs_)
        else:
            return CoordSys_CoordsysTopic_GeoCartesian2D(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Name(self):
        return self.Name

    def set_Name(self, Name):
        self.Name = Name

    def get_Axis(self):
        return self.Axis

    def set_Axis(self, Axis):
        self.Axis = Axis

    def get_Definition(self):
        return self.Definition

    def set_Definition(self, Definition):
        self.Definition = Definition

    def get_TID(self):
        return self.TID

    def set_TID(self, TID):
        self.TID = TID

    def validate_INTERLIS_NAME(self, value):
        result = True
        # Validate type INTERLIS.NAME, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on INTERLIS.NAME'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_DefinitionType18(self, value):
        result = True
        # Validate type DefinitionType18, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if len(value) > 70:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on DefinitionType18'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if self.Name is not None or self.Axis is not None or self.Definition is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.GeoCartesian2D",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("CoordSys.CoordsysTopic.GeoCartesian2D")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "CoordSys.CoordsysTopic.GeoCartesian2D":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="CoordSys.CoordsysTopic.GeoCartesian2D",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="CoordSys.CoordsysTopic.GeoCartesian2D",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="CoordSys.CoordsysTopic.GeoCartesian2D",
    ):
        if self.TID is not None and "TID" not in already_processed:
            already_processed.add("TID")
            outfile.write(
                " TID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.TID), input_name="TID")),)
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.GeoCartesian2D",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.Name is not None:
            namespaceprefix_ = self.Name_nsprefix_ + ":" if (UseCapturedNS_ and self.Name_nsprefix_) else ""
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sName>%s</%sName>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name="Name")),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.Axis is not None:
            namespaceprefix_ = self.Axis_nsprefix_ + ":" if (UseCapturedNS_ and self.Axis_nsprefix_) else ""
            self.Axis.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Axis",
                pretty_print=pretty_print,
            )
        if self.Definition is not None:
            namespaceprefix_ = (
                self.Definition_nsprefix_ + ":" if (UseCapturedNS_ and self.Definition_nsprefix_) else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sDefinition>%s</%sDefinition>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(quote_xml(self.Definition), input_name="Definition")
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("TID", node)
        if value is not None and "TID" not in already_processed:
            already_processed.add("TID")
            self.TID = value
            self.validate_IliID(self.TID)  # validate type IliID

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "Name":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Name")
            value_ = self.gds_validate_string(value_, node, "Name")
            self.Name = value_
            self.Name_nsprefix_ = child_.prefix
            # validate type INTERLIS.NAME
            self.validate_INTERLIS_NAME(self.Name)
        elif nodeName_ == "Axis":
            obj_ = AxisType17.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Axis = obj_
            obj_.original_tagname_ = "Axis"
        elif nodeName_ == "Definition":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Definition")
            value_ = self.gds_validate_string(value_, node, "Definition")
            self.Definition = value_
            self.Definition_nsprefix_ = child_.prefix
            # validate type DefinitionType18
            self.validate_DefinitionType18(self.Definition)


# end class CoordSys_CoordsysTopic_GeoCartesian2D


class CoordSys_CoordsysTopic_GeoCartesian3D(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "TID": MemberSpec_("TID", "IliID", 0, 0, {"use": "required", "name": "TID"}),
        "Name": MemberSpec_(
            "Name",
            ["INTERLIS.NAME", "xsd:normalizedString"],
            0,
            0,
            {"name": "Name", "type": "xsd:normalizedString"},
            None,
        ),
        "Axis": MemberSpec_("Axis", "AxisType19", 0, 0, {"name": "Axis", "type": "AxisType19"}, None),
        "Definition": MemberSpec_(
            "Definition",
            ["DefinitionType20", "xsd:normalizedString"],
            0,
            1,
            {"minOccurs": "0", "name": "Definition", "type": "xsd:normalizedString"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, TID=None, Name=None, Axis=None, Definition=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.TID = _cast(None, TID)
        self.TID_nsprefix_ = None
        self.Name = Name
        self.validate_INTERLIS_NAME(self.Name)
        self.Name_nsprefix_ = None
        if Axis is None:
            self.Axis = globals()["AxisType19"]()
        else:
            self.Axis = Axis
        self.Axis_nsprefix_ = None
        self.Definition = Definition
        self.validate_DefinitionType20(self.Definition)
        self.Definition_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, CoordSys_CoordsysTopic_GeoCartesian3D)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoordSys_CoordsysTopic_GeoCartesian3D.subclass:
            return CoordSys_CoordsysTopic_GeoCartesian3D.subclass(*args_, **kwargs_)
        else:
            return CoordSys_CoordsysTopic_GeoCartesian3D(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Name(self):
        return self.Name

    def set_Name(self, Name):
        self.Name = Name

    def get_Axis(self):
        return self.Axis

    def set_Axis(self, Axis):
        self.Axis = Axis

    def get_Definition(self):
        return self.Definition

    def set_Definition(self, Definition):
        self.Definition = Definition

    def get_TID(self):
        return self.TID

    def set_TID(self, TID):
        self.TID = TID

    def validate_INTERLIS_NAME(self, value):
        result = True
        # Validate type INTERLIS.NAME, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on INTERLIS.NAME'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_DefinitionType20(self, value):
        result = True
        # Validate type DefinitionType20, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if len(value) > 70:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on DefinitionType20'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if self.Name is not None or self.Axis is not None or self.Definition is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.GeoCartesian3D",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("CoordSys.CoordsysTopic.GeoCartesian3D")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "CoordSys.CoordsysTopic.GeoCartesian3D":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="CoordSys.CoordsysTopic.GeoCartesian3D",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="CoordSys.CoordsysTopic.GeoCartesian3D",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="CoordSys.CoordsysTopic.GeoCartesian3D",
    ):
        if self.TID is not None and "TID" not in already_processed:
            already_processed.add("TID")
            outfile.write(
                " TID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.TID), input_name="TID")),)
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.GeoCartesian3D",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.Name is not None:
            namespaceprefix_ = self.Name_nsprefix_ + ":" if (UseCapturedNS_ and self.Name_nsprefix_) else ""
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sName>%s</%sName>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name="Name")),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.Axis is not None:
            namespaceprefix_ = self.Axis_nsprefix_ + ":" if (UseCapturedNS_ and self.Axis_nsprefix_) else ""
            self.Axis.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Axis",
                pretty_print=pretty_print,
            )
        if self.Definition is not None:
            namespaceprefix_ = (
                self.Definition_nsprefix_ + ":" if (UseCapturedNS_ and self.Definition_nsprefix_) else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sDefinition>%s</%sDefinition>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(quote_xml(self.Definition), input_name="Definition")
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("TID", node)
        if value is not None and "TID" not in already_processed:
            already_processed.add("TID")
            self.TID = value
            self.validate_IliID(self.TID)  # validate type IliID

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "Name":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Name")
            value_ = self.gds_validate_string(value_, node, "Name")
            self.Name = value_
            self.Name_nsprefix_ = child_.prefix
            # validate type INTERLIS.NAME
            self.validate_INTERLIS_NAME(self.Name)
        elif nodeName_ == "Axis":
            obj_ = AxisType19.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Axis = obj_
            obj_.original_tagname_ = "Axis"
        elif nodeName_ == "Definition":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Definition")
            value_ = self.gds_validate_string(value_, node, "Definition")
            self.Definition = value_
            self.Definition_nsprefix_ = child_.prefix
            # validate type DefinitionType20
            self.validate_DefinitionType20(self.Definition)


# end class CoordSys_CoordsysTopic_GeoCartesian3D


class CoordSys_CoordsysTopic_GeoEllipsoidal(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "TID": MemberSpec_("TID", "IliID", 0, 0, {"use": "required", "name": "TID"}),
        "Name": MemberSpec_(
            "Name",
            ["INTERLIS.NAME", "xsd:normalizedString"],
            0,
            0,
            {"name": "Name", "type": "xsd:normalizedString"},
            None,
        ),
        "Axis": MemberSpec_("Axis", "AxisType21", 0, 0, {"name": "Axis", "type": "AxisType21"}, None),
        "Definition": MemberSpec_(
            "Definition",
            ["DefinitionType22", "xsd:normalizedString"],
            0,
            1,
            {"minOccurs": "0", "name": "Definition", "type": "xsd:normalizedString"},
            None,
        ),
        "EllipsoidRef": MemberSpec_(
            "EllipsoidRef",
            "EllipsoidRefType23",
            0,
            0,
            {"name": "EllipsoidRef", "type": "EllipsoidRefType23"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(
        self,
        TID=None,
        Name=None,
        Axis=None,
        Definition=None,
        EllipsoidRef=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.TID = _cast(None, TID)
        self.TID_nsprefix_ = None
        self.Name = Name
        self.validate_INTERLIS_NAME(self.Name)
        self.Name_nsprefix_ = None
        if Axis is None:
            self.Axis = globals()["AxisType21"]()
        else:
            self.Axis = Axis
        self.Axis_nsprefix_ = None
        self.Definition = Definition
        self.validate_DefinitionType22(self.Definition)
        self.Definition_nsprefix_ = None
        if EllipsoidRef is None:
            self.EllipsoidRef = globals()["EllipsoidRefType23"]()
        else:
            self.EllipsoidRef = EllipsoidRef
        self.EllipsoidRef_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, CoordSys_CoordsysTopic_GeoEllipsoidal)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoordSys_CoordsysTopic_GeoEllipsoidal.subclass:
            return CoordSys_CoordsysTopic_GeoEllipsoidal.subclass(*args_, **kwargs_)
        else:
            return CoordSys_CoordsysTopic_GeoEllipsoidal(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Name(self):
        return self.Name

    def set_Name(self, Name):
        self.Name = Name

    def get_Axis(self):
        return self.Axis

    def set_Axis(self, Axis):
        self.Axis = Axis

    def get_Definition(self):
        return self.Definition

    def set_Definition(self, Definition):
        self.Definition = Definition

    def get_EllipsoidRef(self):
        return self.EllipsoidRef

    def set_EllipsoidRef(self, EllipsoidRef):
        self.EllipsoidRef = EllipsoidRef

    def get_TID(self):
        return self.TID

    def set_TID(self, TID):
        self.TID = TID

    def validate_INTERLIS_NAME(self, value):
        result = True
        # Validate type INTERLIS.NAME, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on INTERLIS.NAME'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_DefinitionType22(self, value):
        result = True
        # Validate type DefinitionType22, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if len(value) > 70:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on DefinitionType22'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if (
            self.Name is not None
            or self.Axis is not None
            or self.Definition is not None
            or self.EllipsoidRef is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.GeoEllipsoidal",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("CoordSys.CoordsysTopic.GeoEllipsoidal")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "CoordSys.CoordsysTopic.GeoEllipsoidal":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="CoordSys.CoordsysTopic.GeoEllipsoidal",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="CoordSys.CoordsysTopic.GeoEllipsoidal",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="CoordSys.CoordsysTopic.GeoEllipsoidal",
    ):
        if self.TID is not None and "TID" not in already_processed:
            already_processed.add("TID")
            outfile.write(
                " TID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.TID), input_name="TID")),)
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.GeoEllipsoidal",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.Name is not None:
            namespaceprefix_ = self.Name_nsprefix_ + ":" if (UseCapturedNS_ and self.Name_nsprefix_) else ""
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sName>%s</%sName>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name="Name")),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.Axis is not None:
            namespaceprefix_ = self.Axis_nsprefix_ + ":" if (UseCapturedNS_ and self.Axis_nsprefix_) else ""
            self.Axis.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Axis",
                pretty_print=pretty_print,
            )
        if self.Definition is not None:
            namespaceprefix_ = (
                self.Definition_nsprefix_ + ":" if (UseCapturedNS_ and self.Definition_nsprefix_) else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sDefinition>%s</%sDefinition>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(quote_xml(self.Definition), input_name="Definition")
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.EllipsoidRef is not None:
            namespaceprefix_ = (
                self.EllipsoidRef_nsprefix_ + ":" if (UseCapturedNS_ and self.EllipsoidRef_nsprefix_) else ""
            )
            self.EllipsoidRef.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="EllipsoidRef",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("TID", node)
        if value is not None and "TID" not in already_processed:
            already_processed.add("TID")
            self.TID = value
            self.validate_IliID(self.TID)  # validate type IliID

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "Name":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Name")
            value_ = self.gds_validate_string(value_, node, "Name")
            self.Name = value_
            self.Name_nsprefix_ = child_.prefix
            # validate type INTERLIS.NAME
            self.validate_INTERLIS_NAME(self.Name)
        elif nodeName_ == "Axis":
            obj_ = AxisType21.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Axis = obj_
            obj_.original_tagname_ = "Axis"
        elif nodeName_ == "Definition":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Definition")
            value_ = self.gds_validate_string(value_, node, "Definition")
            self.Definition = value_
            self.Definition_nsprefix_ = child_.prefix
            # validate type DefinitionType22
            self.validate_DefinitionType22(self.Definition)
        elif nodeName_ == "EllipsoidRef":
            obj_ = EllipsoidRefType23.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EllipsoidRef = obj_
            obj_.original_tagname_ = "EllipsoidRef"


# end class CoordSys_CoordsysTopic_GeoEllipsoidal


class CoordSys_CoordsysTopic_ToGeoEllipsoidal(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "From": MemberSpec_("From", "RoleType", 0, 0, {"name": "From", "type": "RoleType"}, None),
        "To": MemberSpec_("To", "RoleType", 0, 0, {"name": "To", "type": "RoleType"}, None),
        "ToHeight": MemberSpec_("ToHeight", "RoleType", 0, 0, {"name": "ToHeight", "type": "RoleType"}, None),
    }
    subclass = None
    superclass = None

    def __init__(self, From=None, To=None, ToHeight=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.From = From
        self.From_nsprefix_ = None
        self.To = To
        self.To_nsprefix_ = None
        self.ToHeight = ToHeight
        self.ToHeight_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, CoordSys_CoordsysTopic_ToGeoEllipsoidal)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoordSys_CoordsysTopic_ToGeoEllipsoidal.subclass:
            return CoordSys_CoordsysTopic_ToGeoEllipsoidal.subclass(*args_, **kwargs_)
        else:
            return CoordSys_CoordsysTopic_ToGeoEllipsoidal(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_From(self):
        return self.From

    def set_From(self, From):
        self.From = From

    def get_To(self):
        return self.To

    def set_To(self, To):
        self.To = To

    def get_ToHeight(self):
        return self.ToHeight

    def set_ToHeight(self, ToHeight):
        self.ToHeight = ToHeight

    def _hasContent(self):
        if self.From is not None or self.To is not None or self.ToHeight is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.ToGeoEllipsoidal",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("CoordSys.CoordsysTopic.ToGeoEllipsoidal")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "CoordSys.CoordsysTopic.ToGeoEllipsoidal":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="CoordSys.CoordsysTopic.ToGeoEllipsoidal",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="CoordSys.CoordsysTopic.ToGeoEllipsoidal",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="CoordSys.CoordsysTopic.ToGeoEllipsoidal",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.ToGeoEllipsoidal",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.From is not None:
            namespaceprefix_ = self.From_nsprefix_ + ":" if (UseCapturedNS_ and self.From_nsprefix_) else ""
            self.From.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="From",
                pretty_print=pretty_print,
            )
        if self.To is not None:
            namespaceprefix_ = self.To_nsprefix_ + ":" if (UseCapturedNS_ and self.To_nsprefix_) else ""
            self.To.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="To",
                pretty_print=pretty_print,
            )
        if self.ToHeight is not None:
            namespaceprefix_ = (
                self.ToHeight_nsprefix_ + ":" if (UseCapturedNS_ and self.ToHeight_nsprefix_) else ""
            )
            self.ToHeight.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="ToHeight",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "From":
            obj_ = RoleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.From = obj_
            obj_.original_tagname_ = "From"
        elif nodeName_ == "To":
            obj_ = RoleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.To = obj_
            obj_.original_tagname_ = "To"
        elif nodeName_ == "ToHeight":
            obj_ = RoleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ToHeight = obj_
            obj_.original_tagname_ = "ToHeight"


# end class CoordSys_CoordsysTopic_ToGeoEllipsoidal


class CoordSys_CoordsysTopic_ToGeoCartesian3D(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "From2": MemberSpec_("From2", "RoleType", 0, 0, {"name": "From2", "type": "RoleType"}, None),
        "FromHeight": MemberSpec_(
            "FromHeight",
            "RoleType",
            0,
            0,
            {"name": "FromHeight", "type": "RoleType"},
            None,
        ),
        "To3": MemberSpec_("To3", "RoleType", 0, 0, {"name": "To3", "type": "RoleType"}, None),
    }
    subclass = None
    superclass = None

    def __init__(self, From2=None, FromHeight=None, To3=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.From2 = From2
        self.From2_nsprefix_ = None
        self.FromHeight = FromHeight
        self.FromHeight_nsprefix_ = None
        self.To3 = To3
        self.To3_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, CoordSys_CoordsysTopic_ToGeoCartesian3D)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoordSys_CoordsysTopic_ToGeoCartesian3D.subclass:
            return CoordSys_CoordsysTopic_ToGeoCartesian3D.subclass(*args_, **kwargs_)
        else:
            return CoordSys_CoordsysTopic_ToGeoCartesian3D(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_From2(self):
        return self.From2

    def set_From2(self, From2):
        self.From2 = From2

    def get_FromHeight(self):
        return self.FromHeight

    def set_FromHeight(self, FromHeight):
        self.FromHeight = FromHeight

    def get_To3(self):
        return self.To3

    def set_To3(self, To3):
        self.To3 = To3

    def _hasContent(self):
        if self.From2 is not None or self.FromHeight is not None or self.To3 is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.ToGeoCartesian3D",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("CoordSys.CoordsysTopic.ToGeoCartesian3D")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "CoordSys.CoordsysTopic.ToGeoCartesian3D":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="CoordSys.CoordsysTopic.ToGeoCartesian3D",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="CoordSys.CoordsysTopic.ToGeoCartesian3D",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="CoordSys.CoordsysTopic.ToGeoCartesian3D",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.ToGeoCartesian3D",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.From2 is not None:
            namespaceprefix_ = self.From2_nsprefix_ + ":" if (UseCapturedNS_ and self.From2_nsprefix_) else ""
            self.From2.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="From2",
                pretty_print=pretty_print,
            )
        if self.FromHeight is not None:
            namespaceprefix_ = (
                self.FromHeight_nsprefix_ + ":" if (UseCapturedNS_ and self.FromHeight_nsprefix_) else ""
            )
            self.FromHeight.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="FromHeight",
                pretty_print=pretty_print,
            )
        if self.To3 is not None:
            namespaceprefix_ = self.To3_nsprefix_ + ":" if (UseCapturedNS_ and self.To3_nsprefix_) else ""
            self.To3.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="To3",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "From2":
            obj_ = RoleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.From2 = obj_
            obj_.original_tagname_ = "From2"
        elif nodeName_ == "FromHeight":
            obj_ = RoleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FromHeight = obj_
            obj_.original_tagname_ = "FromHeight"
        elif nodeName_ == "To3":
            obj_ = RoleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.To3 = obj_
            obj_.original_tagname_ = "To3"


# end class CoordSys_CoordsysTopic_ToGeoCartesian3D


class CoordSys_CoordsysTopic_BidirectGeoCartesian2D(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "From": MemberSpec_("From", "RoleType", 0, 0, {"name": "From", "type": "RoleType"}, None),
        "To": MemberSpec_("To", "RoleType", 0, 0, {"name": "To", "type": "RoleType"}, None),
    }
    subclass = None
    superclass = None

    def __init__(self, From=None, To=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.From = From
        self.From_nsprefix_ = None
        self.To = To
        self.To_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CoordSys_CoordsysTopic_BidirectGeoCartesian2D
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoordSys_CoordsysTopic_BidirectGeoCartesian2D.subclass:
            return CoordSys_CoordsysTopic_BidirectGeoCartesian2D.subclass(*args_, **kwargs_)
        else:
            return CoordSys_CoordsysTopic_BidirectGeoCartesian2D(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_From(self):
        return self.From

    def set_From(self, From):
        self.From = From

    def get_To(self):
        return self.To

    def set_To(self, To):
        self.To = To

    def _hasContent(self):
        if self.From is not None or self.To is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.BidirectGeoCartesian2D",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("CoordSys.CoordsysTopic.BidirectGeoCartesian2D")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "CoordSys.CoordsysTopic.BidirectGeoCartesian2D":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="CoordSys.CoordsysTopic.BidirectGeoCartesian2D",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="CoordSys.CoordsysTopic.BidirectGeoCartesian2D",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="CoordSys.CoordsysTopic.BidirectGeoCartesian2D",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.BidirectGeoCartesian2D",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.From is not None:
            namespaceprefix_ = self.From_nsprefix_ + ":" if (UseCapturedNS_ and self.From_nsprefix_) else ""
            self.From.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="From",
                pretty_print=pretty_print,
            )
        if self.To is not None:
            namespaceprefix_ = self.To_nsprefix_ + ":" if (UseCapturedNS_ and self.To_nsprefix_) else ""
            self.To.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="To",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "From":
            obj_ = RoleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.From = obj_
            obj_.original_tagname_ = "From"
        elif nodeName_ == "To":
            obj_ = RoleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.To = obj_
            obj_.original_tagname_ = "To"


# end class CoordSys_CoordsysTopic_BidirectGeoCartesian2D


class CoordSys_CoordsysTopic_BidirectGeoCartesian3D(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "From": MemberSpec_("From", "RoleType", 0, 0, {"name": "From", "type": "RoleType"}, None),
        "To2": MemberSpec_("To2", "RoleType", 0, 0, {"name": "To2", "type": "RoleType"}, None),
        "Precision": MemberSpec_(
            "Precision",
            ["PrecisionType", "xsd:string"],
            0,
            0,
            {"name": "Precision", "type": "xsd:string"},
            None,
        ),
        "ShiftAxis1": MemberSpec_(
            "ShiftAxis1",
            ["ShiftAxis1Type", "xsd:double"],
            0,
            0,
            {"name": "ShiftAxis1", "type": "xsd:double"},
            None,
        ),
        "ShiftAxis2": MemberSpec_(
            "ShiftAxis2",
            ["ShiftAxis2Type", "xsd:double"],
            0,
            0,
            {"name": "ShiftAxis2", "type": "xsd:double"},
            None,
        ),
        "ShiftAxis3": MemberSpec_(
            "ShiftAxis3",
            ["ShiftAxis3Type", "xsd:double"],
            0,
            0,
            {"name": "ShiftAxis3", "type": "xsd:double"},
            None,
        ),
        "RotationAxis1": MemberSpec_(
            "RotationAxis1",
            ["CoordSys.Angle_DMS_90", "xsd:normalizedString"],
            0,
            1,
            {"minOccurs": "0", "name": "RotationAxis1", "type": "xsd:normalizedString"},
            None,
        ),
        "RotationAxis2": MemberSpec_(
            "RotationAxis2",
            ["CoordSys.Angle_DMS_90", "xsd:normalizedString"],
            0,
            1,
            {"minOccurs": "0", "name": "RotationAxis2", "type": "xsd:normalizedString"},
            None,
        ),
        "RotationAxis3": MemberSpec_(
            "RotationAxis3",
            ["CoordSys.Angle_DMS_90", "xsd:normalizedString"],
            0,
            1,
            {"minOccurs": "0", "name": "RotationAxis3", "type": "xsd:normalizedString"},
            None,
        ),
        "NewScale": MemberSpec_(
            "NewScale",
            ["NewScaleType", "xsd:double"],
            0,
            1,
            {"minOccurs": "0", "name": "NewScale", "type": "xsd:double"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(
        self,
        From=None,
        To2=None,
        Precision=None,
        ShiftAxis1=None,
        ShiftAxis2=None,
        ShiftAxis3=None,
        RotationAxis1=None,
        RotationAxis2=None,
        RotationAxis3=None,
        NewScale=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.From = From
        self.From_nsprefix_ = None
        self.To2 = To2
        self.To2_nsprefix_ = None
        self.Precision = Precision
        self.validate_PrecisionType(self.Precision)
        self.Precision_nsprefix_ = None
        self.ShiftAxis1 = ShiftAxis1
        self.validate_ShiftAxis1Type(self.ShiftAxis1)
        self.ShiftAxis1_nsprefix_ = None
        self.ShiftAxis2 = ShiftAxis2
        self.validate_ShiftAxis2Type(self.ShiftAxis2)
        self.ShiftAxis2_nsprefix_ = None
        self.ShiftAxis3 = ShiftAxis3
        self.validate_ShiftAxis3Type(self.ShiftAxis3)
        self.ShiftAxis3_nsprefix_ = None
        self.RotationAxis1 = RotationAxis1
        self.validate_CoordSys_Angle_DMS_90(self.RotationAxis1)
        self.RotationAxis1_nsprefix_ = None
        self.RotationAxis2 = RotationAxis2
        self.validate_CoordSys_Angle_DMS_90(self.RotationAxis2)
        self.RotationAxis2_nsprefix_ = None
        self.RotationAxis3 = RotationAxis3
        self.validate_CoordSys_Angle_DMS_90(self.RotationAxis3)
        self.RotationAxis3_nsprefix_ = None
        self.NewScale = NewScale
        self.validate_NewScaleType(self.NewScale)
        self.NewScale_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CoordSys_CoordsysTopic_BidirectGeoCartesian3D
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoordSys_CoordsysTopic_BidirectGeoCartesian3D.subclass:
            return CoordSys_CoordsysTopic_BidirectGeoCartesian3D.subclass(*args_, **kwargs_)
        else:
            return CoordSys_CoordsysTopic_BidirectGeoCartesian3D(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_From(self):
        return self.From

    def set_From(self, From):
        self.From = From

    def get_To2(self):
        return self.To2

    def set_To2(self, To2):
        self.To2 = To2

    def get_Precision(self):
        return self.Precision

    def set_Precision(self, Precision):
        self.Precision = Precision

    def get_ShiftAxis1(self):
        return self.ShiftAxis1

    def set_ShiftAxis1(self, ShiftAxis1):
        self.ShiftAxis1 = ShiftAxis1

    def get_ShiftAxis2(self):
        return self.ShiftAxis2

    def set_ShiftAxis2(self, ShiftAxis2):
        self.ShiftAxis2 = ShiftAxis2

    def get_ShiftAxis3(self):
        return self.ShiftAxis3

    def set_ShiftAxis3(self, ShiftAxis3):
        self.ShiftAxis3 = ShiftAxis3

    def get_RotationAxis1(self):
        return self.RotationAxis1

    def set_RotationAxis1(self, RotationAxis1):
        self.RotationAxis1 = RotationAxis1

    def get_RotationAxis2(self):
        return self.RotationAxis2

    def set_RotationAxis2(self, RotationAxis2):
        self.RotationAxis2 = RotationAxis2

    def get_RotationAxis3(self):
        return self.RotationAxis3

    def set_RotationAxis3(self, RotationAxis3):
        self.RotationAxis3 = RotationAxis3

    def get_NewScale(self):
        return self.NewScale

    def set_NewScale(self, NewScale):
        self.NewScale = NewScale

    def validate_PrecisionType(self, value):
        result = True
        # Validate type PrecisionType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            value = value
            enumerations = ["exact", "measure_based"]
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on PrecisionType'
                    % {"value": encode_str_2_3(value), "lineno": lineno}
                )
                result = False
        return result

    def validate_ShiftAxis1Type(self, value):
        result = True
        # Validate type ShiftAxis1Type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (float)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if value < -10000.000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on ShiftAxis1Type'
                    % {"value": value, "lineno": lineno}
                )
                result = False
            if value > 10000.000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on ShiftAxis1Type'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_ShiftAxis2Type(self, value):
        result = True
        # Validate type ShiftAxis2Type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (float)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if value < -10000.000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on ShiftAxis2Type'
                    % {"value": value, "lineno": lineno}
                )
                result = False
            if value > 10000.000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on ShiftAxis2Type'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_ShiftAxis3Type(self, value):
        result = True
        # Validate type ShiftAxis3Type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (float)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if value < -10000.000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on ShiftAxis3Type'
                    % {"value": value, "lineno": lineno}
                )
                result = False
            if value > 10000.000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on ShiftAxis3Type'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_CoordSys_Angle_DMS_90(self, value):
        result = True
        # Validate type CoordSys.Angle_DMS_90, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            pass
        return result

    def validate_NewScaleType(self, value):
        result = True
        # Validate type NewScaleType, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (float)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if value < 0.000001:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on NewScaleType'
                    % {"value": value, "lineno": lineno}
                )
                result = False
            if value > 1000000.000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on NewScaleType'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def _hasContent(self):
        if (
            self.From is not None
            or self.To2 is not None
            or self.Precision is not None
            or self.ShiftAxis1 is not None
            or self.ShiftAxis2 is not None
            or self.ShiftAxis3 is not None
            or self.RotationAxis1 is not None
            or self.RotationAxis2 is not None
            or self.RotationAxis3 is not None
            or self.NewScale is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.BidirectGeoCartesian3D",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("CoordSys.CoordsysTopic.BidirectGeoCartesian3D")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "CoordSys.CoordsysTopic.BidirectGeoCartesian3D":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="CoordSys.CoordsysTopic.BidirectGeoCartesian3D",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="CoordSys.CoordsysTopic.BidirectGeoCartesian3D",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="CoordSys.CoordsysTopic.BidirectGeoCartesian3D",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.BidirectGeoCartesian3D",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.From is not None:
            namespaceprefix_ = self.From_nsprefix_ + ":" if (UseCapturedNS_ and self.From_nsprefix_) else ""
            self.From.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="From",
                pretty_print=pretty_print,
            )
        if self.To2 is not None:
            namespaceprefix_ = self.To2_nsprefix_ + ":" if (UseCapturedNS_ and self.To2_nsprefix_) else ""
            self.To2.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="To2",
                pretty_print=pretty_print,
            )
        if self.Precision is not None:
            namespaceprefix_ = (
                self.Precision_nsprefix_ + ":" if (UseCapturedNS_ and self.Precision_nsprefix_) else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sPrecision>%s</%sPrecision>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(quote_xml(self.Precision), input_name="Precision")
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.ShiftAxis1 is not None:
            namespaceprefix_ = (
                self.ShiftAxis1_nsprefix_ + ":" if (UseCapturedNS_ and self.ShiftAxis1_nsprefix_) else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sShiftAxis1>%s</%sShiftAxis1>%s"
                % (
                    namespaceprefix_,
                    self.gds_format_double(self.ShiftAxis1, input_name="ShiftAxis1"),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.ShiftAxis2 is not None:
            namespaceprefix_ = (
                self.ShiftAxis2_nsprefix_ + ":" if (UseCapturedNS_ and self.ShiftAxis2_nsprefix_) else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sShiftAxis2>%s</%sShiftAxis2>%s"
                % (
                    namespaceprefix_,
                    self.gds_format_double(self.ShiftAxis2, input_name="ShiftAxis2"),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.ShiftAxis3 is not None:
            namespaceprefix_ = (
                self.ShiftAxis3_nsprefix_ + ":" if (UseCapturedNS_ and self.ShiftAxis3_nsprefix_) else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sShiftAxis3>%s</%sShiftAxis3>%s"
                % (
                    namespaceprefix_,
                    self.gds_format_double(self.ShiftAxis3, input_name="ShiftAxis3"),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.RotationAxis1 is not None:
            namespaceprefix_ = (
                self.RotationAxis1_nsprefix_ + ":"
                if (UseCapturedNS_ and self.RotationAxis1_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sRotationAxis1>%s</%sRotationAxis1>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(quote_xml(self.RotationAxis1), input_name="RotationAxis1")
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.RotationAxis2 is not None:
            namespaceprefix_ = (
                self.RotationAxis2_nsprefix_ + ":"
                if (UseCapturedNS_ and self.RotationAxis2_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sRotationAxis2>%s</%sRotationAxis2>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(quote_xml(self.RotationAxis2), input_name="RotationAxis2")
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.RotationAxis3 is not None:
            namespaceprefix_ = (
                self.RotationAxis3_nsprefix_ + ":"
                if (UseCapturedNS_ and self.RotationAxis3_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sRotationAxis3>%s</%sRotationAxis3>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(quote_xml(self.RotationAxis3), input_name="RotationAxis3")
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.NewScale is not None:
            namespaceprefix_ = (
                self.NewScale_nsprefix_ + ":" if (UseCapturedNS_ and self.NewScale_nsprefix_) else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sNewScale>%s</%sNewScale>%s"
                % (
                    namespaceprefix_,
                    self.gds_format_double(self.NewScale, input_name="NewScale"),
                    namespaceprefix_,
                    eol_,
                )
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "From":
            obj_ = RoleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.From = obj_
            obj_.original_tagname_ = "From"
        elif nodeName_ == "To2":
            obj_ = RoleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.To2 = obj_
            obj_.original_tagname_ = "To2"
        elif nodeName_ == "Precision":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Precision")
            value_ = self.gds_validate_string(value_, node, "Precision")
            self.Precision = value_
            self.Precision_nsprefix_ = child_.prefix
            # validate type PrecisionType
            self.validate_PrecisionType(self.Precision)
        elif nodeName_ == "ShiftAxis1" and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, "ShiftAxis1")
            fval_ = self.gds_validate_double(fval_, node, "ShiftAxis1")
            self.ShiftAxis1 = fval_
            self.ShiftAxis1_nsprefix_ = child_.prefix
            # validate type ShiftAxis1Type
            self.validate_ShiftAxis1Type(self.ShiftAxis1)
        elif nodeName_ == "ShiftAxis2" and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, "ShiftAxis2")
            fval_ = self.gds_validate_double(fval_, node, "ShiftAxis2")
            self.ShiftAxis2 = fval_
            self.ShiftAxis2_nsprefix_ = child_.prefix
            # validate type ShiftAxis2Type
            self.validate_ShiftAxis2Type(self.ShiftAxis2)
        elif nodeName_ == "ShiftAxis3" and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, "ShiftAxis3")
            fval_ = self.gds_validate_double(fval_, node, "ShiftAxis3")
            self.ShiftAxis3 = fval_
            self.ShiftAxis3_nsprefix_ = child_.prefix
            # validate type ShiftAxis3Type
            self.validate_ShiftAxis3Type(self.ShiftAxis3)
        elif nodeName_ == "RotationAxis1":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "RotationAxis1")
            value_ = self.gds_validate_string(value_, node, "RotationAxis1")
            self.RotationAxis1 = value_
            self.RotationAxis1_nsprefix_ = child_.prefix
            # validate type CoordSys.Angle_DMS_90
            self.validate_CoordSys_Angle_DMS_90(self.RotationAxis1)
        elif nodeName_ == "RotationAxis2":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "RotationAxis2")
            value_ = self.gds_validate_string(value_, node, "RotationAxis2")
            self.RotationAxis2 = value_
            self.RotationAxis2_nsprefix_ = child_.prefix
            # validate type CoordSys.Angle_DMS_90
            self.validate_CoordSys_Angle_DMS_90(self.RotationAxis2)
        elif nodeName_ == "RotationAxis3":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "RotationAxis3")
            value_ = self.gds_validate_string(value_, node, "RotationAxis3")
            self.RotationAxis3 = value_
            self.RotationAxis3_nsprefix_ = child_.prefix
            # validate type CoordSys.Angle_DMS_90
            self.validate_CoordSys_Angle_DMS_90(self.RotationAxis3)
        elif nodeName_ == "NewScale" and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, "NewScale")
            fval_ = self.gds_validate_double(fval_, node, "NewScale")
            self.NewScale = fval_
            self.NewScale_nsprefix_ = child_.prefix
            # validate type NewScaleType
            self.validate_NewScaleType(self.NewScale)


# end class CoordSys_CoordsysTopic_BidirectGeoCartesian3D


class CoordSys_CoordsysTopic_BidirectGeoEllipsoidal(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "From4": MemberSpec_("From4", "RoleType", 0, 0, {"name": "From4", "type": "RoleType"}, None),
        "To4": MemberSpec_("To4", "RoleType", 0, 0, {"name": "To4", "type": "RoleType"}, None),
    }
    subclass = None
    superclass = None

    def __init__(self, From4=None, To4=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.From4 = From4
        self.From4_nsprefix_ = None
        self.To4 = To4
        self.To4_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CoordSys_CoordsysTopic_BidirectGeoEllipsoidal
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoordSys_CoordsysTopic_BidirectGeoEllipsoidal.subclass:
            return CoordSys_CoordsysTopic_BidirectGeoEllipsoidal.subclass(*args_, **kwargs_)
        else:
            return CoordSys_CoordsysTopic_BidirectGeoEllipsoidal(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_From4(self):
        return self.From4

    def set_From4(self, From4):
        self.From4 = From4

    def get_To4(self):
        return self.To4

    def set_To4(self, To4):
        self.To4 = To4

    def _hasContent(self):
        if self.From4 is not None or self.To4 is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.BidirectGeoEllipsoidal",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("CoordSys.CoordsysTopic.BidirectGeoEllipsoidal")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "CoordSys.CoordsysTopic.BidirectGeoEllipsoidal":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="CoordSys.CoordsysTopic.BidirectGeoEllipsoidal",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="CoordSys.CoordsysTopic.BidirectGeoEllipsoidal",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="CoordSys.CoordsysTopic.BidirectGeoEllipsoidal",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.BidirectGeoEllipsoidal",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.From4 is not None:
            namespaceprefix_ = self.From4_nsprefix_ + ":" if (UseCapturedNS_ and self.From4_nsprefix_) else ""
            self.From4.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="From4",
                pretty_print=pretty_print,
            )
        if self.To4 is not None:
            namespaceprefix_ = self.To4_nsprefix_ + ":" if (UseCapturedNS_ and self.To4_nsprefix_) else ""
            self.To4.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="To4",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "From4":
            obj_ = RoleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.From4 = obj_
            obj_.original_tagname_ = "From4"
        elif nodeName_ == "To4":
            obj_ = RoleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.To4 = obj_
            obj_.original_tagname_ = "To4"


# end class CoordSys_CoordsysTopic_BidirectGeoEllipsoidal


class CoordSys_CoordsysTopic_MapProjection(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "From5": MemberSpec_("From5", "RoleType", 0, 0, {"name": "From5", "type": "RoleType"}, None),
        "To5": MemberSpec_("To5", "RoleType", 0, 0, {"name": "To5", "type": "RoleType"}, None),
        "FromCo1_FundPt": MemberSpec_(
            "FromCo1_FundPt",
            ["CoordSys.Angle_DMS_90", "xsd:normalizedString"],
            0,
            0,
            {"name": "FromCo1_FundPt", "type": "xsd:normalizedString"},
            None,
        ),
        "FromCo2_FundPt": MemberSpec_(
            "FromCo2_FundPt",
            ["CoordSys.Angle_DMS_90", "xsd:normalizedString"],
            0,
            0,
            {"name": "FromCo2_FundPt", "type": "xsd:normalizedString"},
            None,
        ),
        "ToCoord1_FundPt": MemberSpec_(
            "ToCoord1_FundPt",
            ["ToCoord1_FundPtType", "xsd:integer"],
            0,
            0,
            {"name": "ToCoord1_FundPt", "type": "xsd:integer"},
            None,
        ),
        "ToCoord2_FundPt": MemberSpec_(
            "ToCoord2_FundPt",
            ["ToCoord2_FundPtType", "xsd:integer"],
            0,
            0,
            {"name": "ToCoord2_FundPt", "type": "xsd:integer"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(
        self,
        From5=None,
        To5=None,
        FromCo1_FundPt=None,
        FromCo2_FundPt=None,
        ToCoord1_FundPt=None,
        ToCoord2_FundPt=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.From5 = From5
        self.From5_nsprefix_ = None
        self.To5 = To5
        self.To5_nsprefix_ = None
        self.FromCo1_FundPt = FromCo1_FundPt
        self.validate_CoordSys_Angle_DMS_90(self.FromCo1_FundPt)
        self.FromCo1_FundPt_nsprefix_ = None
        self.FromCo2_FundPt = FromCo2_FundPt
        self.validate_CoordSys_Angle_DMS_90(self.FromCo2_FundPt)
        self.FromCo2_FundPt_nsprefix_ = None
        self.ToCoord1_FundPt = ToCoord1_FundPt
        self.validate_ToCoord1_FundPtType(self.ToCoord1_FundPt)
        self.ToCoord1_FundPt_nsprefix_ = None
        self.ToCoord2_FundPt = ToCoord2_FundPt
        self.validate_ToCoord2_FundPtType(self.ToCoord2_FundPt)
        self.ToCoord2_FundPt_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, CoordSys_CoordsysTopic_MapProjection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoordSys_CoordsysTopic_MapProjection.subclass:
            return CoordSys_CoordsysTopic_MapProjection.subclass(*args_, **kwargs_)
        else:
            return CoordSys_CoordsysTopic_MapProjection(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_From5(self):
        return self.From5

    def set_From5(self, From5):
        self.From5 = From5

    def get_To5(self):
        return self.To5

    def set_To5(self, To5):
        self.To5 = To5

    def get_FromCo1_FundPt(self):
        return self.FromCo1_FundPt

    def set_FromCo1_FundPt(self, FromCo1_FundPt):
        self.FromCo1_FundPt = FromCo1_FundPt

    def get_FromCo2_FundPt(self):
        return self.FromCo2_FundPt

    def set_FromCo2_FundPt(self, FromCo2_FundPt):
        self.FromCo2_FundPt = FromCo2_FundPt

    def get_ToCoord1_FundPt(self):
        return self.ToCoord1_FundPt

    def set_ToCoord1_FundPt(self, ToCoord1_FundPt):
        self.ToCoord1_FundPt = ToCoord1_FundPt

    def get_ToCoord2_FundPt(self):
        return self.ToCoord2_FundPt

    def set_ToCoord2_FundPt(self, ToCoord2_FundPt):
        self.ToCoord2_FundPt = ToCoord2_FundPt

    def validate_CoordSys_Angle_DMS_90(self, value):
        result = True
        # Validate type CoordSys.Angle_DMS_90, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            pass
        return result

    def validate_ToCoord1_FundPtType(self, value):
        result = True
        # Validate type ToCoord1_FundPtType, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if value < -10000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on ToCoord1_FundPtType'
                    % {"value": value, "lineno": lineno}
                )
                result = False
            if value > 10000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on ToCoord1_FundPtType'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_ToCoord2_FundPtType(self, value):
        result = True
        # Validate type ToCoord2_FundPtType, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if value < -10000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on ToCoord2_FundPtType'
                    % {"value": value, "lineno": lineno}
                )
                result = False
            if value > 10000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on ToCoord2_FundPtType'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def _hasContent(self):
        if (
            self.From5 is not None
            or self.To5 is not None
            or self.FromCo1_FundPt is not None
            or self.FromCo2_FundPt is not None
            or self.ToCoord1_FundPt is not None
            or self.ToCoord2_FundPt is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.MapProjection",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("CoordSys.CoordsysTopic.MapProjection")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "CoordSys.CoordsysTopic.MapProjection":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="CoordSys.CoordsysTopic.MapProjection",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="CoordSys.CoordsysTopic.MapProjection",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="CoordSys.CoordsysTopic.MapProjection",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.MapProjection",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.From5 is not None:
            namespaceprefix_ = self.From5_nsprefix_ + ":" if (UseCapturedNS_ and self.From5_nsprefix_) else ""
            self.From5.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="From5",
                pretty_print=pretty_print,
            )
        if self.To5 is not None:
            namespaceprefix_ = self.To5_nsprefix_ + ":" if (UseCapturedNS_ and self.To5_nsprefix_) else ""
            self.To5.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="To5",
                pretty_print=pretty_print,
            )
        if self.FromCo1_FundPt is not None:
            namespaceprefix_ = (
                self.FromCo1_FundPt_nsprefix_ + ":"
                if (UseCapturedNS_ and self.FromCo1_FundPt_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sFromCo1_FundPt>%s</%sFromCo1_FundPt>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(quote_xml(self.FromCo1_FundPt), input_name="FromCo1_FundPt")
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.FromCo2_FundPt is not None:
            namespaceprefix_ = (
                self.FromCo2_FundPt_nsprefix_ + ":"
                if (UseCapturedNS_ and self.FromCo2_FundPt_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sFromCo2_FundPt>%s</%sFromCo2_FundPt>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(quote_xml(self.FromCo2_FundPt), input_name="FromCo2_FundPt")
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.ToCoord1_FundPt is not None:
            namespaceprefix_ = (
                self.ToCoord1_FundPt_nsprefix_ + ":"
                if (UseCapturedNS_ and self.ToCoord1_FundPt_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sToCoord1_FundPt>%s</%sToCoord1_FundPt>%s"
                % (
                    namespaceprefix_,
                    self.gds_format_integer(self.ToCoord1_FundPt, input_name="ToCoord1_FundPt"),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.ToCoord2_FundPt is not None:
            namespaceprefix_ = (
                self.ToCoord2_FundPt_nsprefix_ + ":"
                if (UseCapturedNS_ and self.ToCoord2_FundPt_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sToCoord2_FundPt>%s</%sToCoord2_FundPt>%s"
                % (
                    namespaceprefix_,
                    self.gds_format_integer(self.ToCoord2_FundPt, input_name="ToCoord2_FundPt"),
                    namespaceprefix_,
                    eol_,
                )
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "From5":
            obj_ = RoleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.From5 = obj_
            obj_.original_tagname_ = "From5"
        elif nodeName_ == "To5":
            obj_ = RoleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.To5 = obj_
            obj_.original_tagname_ = "To5"
        elif nodeName_ == "FromCo1_FundPt":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "FromCo1_FundPt")
            value_ = self.gds_validate_string(value_, node, "FromCo1_FundPt")
            self.FromCo1_FundPt = value_
            self.FromCo1_FundPt_nsprefix_ = child_.prefix
            # validate type CoordSys.Angle_DMS_90
            self.validate_CoordSys_Angle_DMS_90(self.FromCo1_FundPt)
        elif nodeName_ == "FromCo2_FundPt":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "FromCo2_FundPt")
            value_ = self.gds_validate_string(value_, node, "FromCo2_FundPt")
            self.FromCo2_FundPt = value_
            self.FromCo2_FundPt_nsprefix_ = child_.prefix
            # validate type CoordSys.Angle_DMS_90
            self.validate_CoordSys_Angle_DMS_90(self.FromCo2_FundPt)
        elif nodeName_ == "ToCoord1_FundPt" and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, "ToCoord1_FundPt")
            ival_ = self.gds_validate_integer(ival_, node, "ToCoord1_FundPt")
            self.ToCoord1_FundPt = ival_
            self.ToCoord1_FundPt_nsprefix_ = child_.prefix
            # validate type ToCoord1_FundPtType
            self.validate_ToCoord1_FundPtType(self.ToCoord1_FundPt)
        elif nodeName_ == "ToCoord2_FundPt" and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, "ToCoord2_FundPt")
            ival_ = self.gds_validate_integer(ival_, node, "ToCoord2_FundPt")
            self.ToCoord2_FundPt = ival_
            self.ToCoord2_FundPt_nsprefix_ = child_.prefix
            # validate type ToCoord2_FundPtType
            self.validate_ToCoord2_FundPtType(self.ToCoord2_FundPt)


# end class CoordSys_CoordsysTopic_MapProjection


class CoordSys_CoordsysTopic_TransverseMercator(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "From5": MemberSpec_("From5", "RoleType", 0, 0, {"name": "From5", "type": "RoleType"}, None),
        "To5": MemberSpec_("To5", "RoleType", 0, 0, {"name": "To5", "type": "RoleType"}, None),
        "FromCo1_FundPt": MemberSpec_(
            "FromCo1_FundPt",
            ["CoordSys.Angle_DMS_90", "xsd:normalizedString"],
            0,
            0,
            {"name": "FromCo1_FundPt", "type": "xsd:normalizedString"},
            None,
        ),
        "FromCo2_FundPt": MemberSpec_(
            "FromCo2_FundPt",
            ["CoordSys.Angle_DMS_90", "xsd:normalizedString"],
            0,
            0,
            {"name": "FromCo2_FundPt", "type": "xsd:normalizedString"},
            None,
        ),
        "ToCoord1_FundPt": MemberSpec_(
            "ToCoord1_FundPt",
            ["ToCoord1_FundPtType24", "xsd:integer"],
            0,
            0,
            {"name": "ToCoord1_FundPt", "type": "xsd:integer"},
            None,
        ),
        "ToCoord2_FundPt": MemberSpec_(
            "ToCoord2_FundPt",
            ["ToCoord2_FundPtType25", "xsd:integer"],
            0,
            0,
            {"name": "ToCoord2_FundPt", "type": "xsd:integer"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(
        self,
        From5=None,
        To5=None,
        FromCo1_FundPt=None,
        FromCo2_FundPt=None,
        ToCoord1_FundPt=None,
        ToCoord2_FundPt=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.From5 = From5
        self.From5_nsprefix_ = None
        self.To5 = To5
        self.To5_nsprefix_ = None
        self.FromCo1_FundPt = FromCo1_FundPt
        self.validate_CoordSys_Angle_DMS_90(self.FromCo1_FundPt)
        self.FromCo1_FundPt_nsprefix_ = None
        self.FromCo2_FundPt = FromCo2_FundPt
        self.validate_CoordSys_Angle_DMS_90(self.FromCo2_FundPt)
        self.FromCo2_FundPt_nsprefix_ = None
        self.ToCoord1_FundPt = ToCoord1_FundPt
        self.validate_ToCoord1_FundPtType24(self.ToCoord1_FundPt)
        self.ToCoord1_FundPt_nsprefix_ = None
        self.ToCoord2_FundPt = ToCoord2_FundPt
        self.validate_ToCoord2_FundPtType25(self.ToCoord2_FundPt)
        self.ToCoord2_FundPt_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CoordSys_CoordsysTopic_TransverseMercator
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoordSys_CoordsysTopic_TransverseMercator.subclass:
            return CoordSys_CoordsysTopic_TransverseMercator.subclass(*args_, **kwargs_)
        else:
            return CoordSys_CoordsysTopic_TransverseMercator(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_From5(self):
        return self.From5

    def set_From5(self, From5):
        self.From5 = From5

    def get_To5(self):
        return self.To5

    def set_To5(self, To5):
        self.To5 = To5

    def get_FromCo1_FundPt(self):
        return self.FromCo1_FundPt

    def set_FromCo1_FundPt(self, FromCo1_FundPt):
        self.FromCo1_FundPt = FromCo1_FundPt

    def get_FromCo2_FundPt(self):
        return self.FromCo2_FundPt

    def set_FromCo2_FundPt(self, FromCo2_FundPt):
        self.FromCo2_FundPt = FromCo2_FundPt

    def get_ToCoord1_FundPt(self):
        return self.ToCoord1_FundPt

    def set_ToCoord1_FundPt(self, ToCoord1_FundPt):
        self.ToCoord1_FundPt = ToCoord1_FundPt

    def get_ToCoord2_FundPt(self):
        return self.ToCoord2_FundPt

    def set_ToCoord2_FundPt(self, ToCoord2_FundPt):
        self.ToCoord2_FundPt = ToCoord2_FundPt

    def validate_CoordSys_Angle_DMS_90(self, value):
        result = True
        # Validate type CoordSys.Angle_DMS_90, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            pass
        return result

    def validate_ToCoord1_FundPtType24(self, value):
        result = True
        # Validate type ToCoord1_FundPtType24, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if value < -10000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on ToCoord1_FundPtType24'
                    % {"value": value, "lineno": lineno}
                )
                result = False
            if value > 10000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on ToCoord1_FundPtType24'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_ToCoord2_FundPtType25(self, value):
        result = True
        # Validate type ToCoord2_FundPtType25, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if value < -10000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on ToCoord2_FundPtType25'
                    % {"value": value, "lineno": lineno}
                )
                result = False
            if value > 10000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on ToCoord2_FundPtType25'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def _hasContent(self):
        if (
            self.From5 is not None
            or self.To5 is not None
            or self.FromCo1_FundPt is not None
            or self.FromCo2_FundPt is not None
            or self.ToCoord1_FundPt is not None
            or self.ToCoord2_FundPt is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.TransverseMercator",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("CoordSys.CoordsysTopic.TransverseMercator")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "CoordSys.CoordsysTopic.TransverseMercator":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="CoordSys.CoordsysTopic.TransverseMercator",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="CoordSys.CoordsysTopic.TransverseMercator",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="CoordSys.CoordsysTopic.TransverseMercator",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.TransverseMercator",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.From5 is not None:
            namespaceprefix_ = self.From5_nsprefix_ + ":" if (UseCapturedNS_ and self.From5_nsprefix_) else ""
            self.From5.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="From5",
                pretty_print=pretty_print,
            )
        if self.To5 is not None:
            namespaceprefix_ = self.To5_nsprefix_ + ":" if (UseCapturedNS_ and self.To5_nsprefix_) else ""
            self.To5.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="To5",
                pretty_print=pretty_print,
            )
        if self.FromCo1_FundPt is not None:
            namespaceprefix_ = (
                self.FromCo1_FundPt_nsprefix_ + ":"
                if (UseCapturedNS_ and self.FromCo1_FundPt_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sFromCo1_FundPt>%s</%sFromCo1_FundPt>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(quote_xml(self.FromCo1_FundPt), input_name="FromCo1_FundPt")
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.FromCo2_FundPt is not None:
            namespaceprefix_ = (
                self.FromCo2_FundPt_nsprefix_ + ":"
                if (UseCapturedNS_ and self.FromCo2_FundPt_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sFromCo2_FundPt>%s</%sFromCo2_FundPt>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(quote_xml(self.FromCo2_FundPt), input_name="FromCo2_FundPt")
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.ToCoord1_FundPt is not None:
            namespaceprefix_ = (
                self.ToCoord1_FundPt_nsprefix_ + ":"
                if (UseCapturedNS_ and self.ToCoord1_FundPt_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sToCoord1_FundPt>%s</%sToCoord1_FundPt>%s"
                % (
                    namespaceprefix_,
                    self.gds_format_integer(self.ToCoord1_FundPt, input_name="ToCoord1_FundPt"),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.ToCoord2_FundPt is not None:
            namespaceprefix_ = (
                self.ToCoord2_FundPt_nsprefix_ + ":"
                if (UseCapturedNS_ and self.ToCoord2_FundPt_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sToCoord2_FundPt>%s</%sToCoord2_FundPt>%s"
                % (
                    namespaceprefix_,
                    self.gds_format_integer(self.ToCoord2_FundPt, input_name="ToCoord2_FundPt"),
                    namespaceprefix_,
                    eol_,
                )
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "From5":
            obj_ = RoleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.From5 = obj_
            obj_.original_tagname_ = "From5"
        elif nodeName_ == "To5":
            obj_ = RoleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.To5 = obj_
            obj_.original_tagname_ = "To5"
        elif nodeName_ == "FromCo1_FundPt":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "FromCo1_FundPt")
            value_ = self.gds_validate_string(value_, node, "FromCo1_FundPt")
            self.FromCo1_FundPt = value_
            self.FromCo1_FundPt_nsprefix_ = child_.prefix
            # validate type CoordSys.Angle_DMS_90
            self.validate_CoordSys_Angle_DMS_90(self.FromCo1_FundPt)
        elif nodeName_ == "FromCo2_FundPt":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "FromCo2_FundPt")
            value_ = self.gds_validate_string(value_, node, "FromCo2_FundPt")
            self.FromCo2_FundPt = value_
            self.FromCo2_FundPt_nsprefix_ = child_.prefix
            # validate type CoordSys.Angle_DMS_90
            self.validate_CoordSys_Angle_DMS_90(self.FromCo2_FundPt)
        elif nodeName_ == "ToCoord1_FundPt" and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, "ToCoord1_FundPt")
            ival_ = self.gds_validate_integer(ival_, node, "ToCoord1_FundPt")
            self.ToCoord1_FundPt = ival_
            self.ToCoord1_FundPt_nsprefix_ = child_.prefix
            # validate type ToCoord1_FundPtType24
            self.validate_ToCoord1_FundPtType24(self.ToCoord1_FundPt)
        elif nodeName_ == "ToCoord2_FundPt" and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, "ToCoord2_FundPt")
            ival_ = self.gds_validate_integer(ival_, node, "ToCoord2_FundPt")
            self.ToCoord2_FundPt = ival_
            self.ToCoord2_FundPt_nsprefix_ = child_.prefix
            # validate type ToCoord2_FundPtType25
            self.validate_ToCoord2_FundPtType25(self.ToCoord2_FundPt)


# end class CoordSys_CoordsysTopic_TransverseMercator


class CoordSys_CoordsysTopic_SwissProjection(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "From5": MemberSpec_("From5", "RoleType", 0, 0, {"name": "From5", "type": "RoleType"}, None),
        "To5": MemberSpec_("To5", "RoleType", 0, 0, {"name": "To5", "type": "RoleType"}, None),
        "FromCo1_FundPt": MemberSpec_(
            "FromCo1_FundPt",
            ["CoordSys.Angle_DMS_90", "xsd:normalizedString"],
            0,
            0,
            {"name": "FromCo1_FundPt", "type": "xsd:normalizedString"},
            None,
        ),
        "FromCo2_FundPt": MemberSpec_(
            "FromCo2_FundPt",
            ["CoordSys.Angle_DMS_90", "xsd:normalizedString"],
            0,
            0,
            {"name": "FromCo2_FundPt", "type": "xsd:normalizedString"},
            None,
        ),
        "ToCoord1_FundPt": MemberSpec_(
            "ToCoord1_FundPt",
            ["ToCoord1_FundPtType26", "xsd:integer"],
            0,
            0,
            {"name": "ToCoord1_FundPt", "type": "xsd:integer"},
            None,
        ),
        "ToCoord2_FundPt": MemberSpec_(
            "ToCoord2_FundPt",
            ["ToCoord2_FundPtType27", "xsd:integer"],
            0,
            0,
            {"name": "ToCoord2_FundPt", "type": "xsd:integer"},
            None,
        ),
        "IntermFundP1": MemberSpec_(
            "IntermFundP1",
            ["CoordSys.Angle_DMS_90", "xsd:normalizedString"],
            0,
            0,
            {"name": "IntermFundP1", "type": "xsd:normalizedString"},
            None,
        ),
        "IntermFundP2": MemberSpec_(
            "IntermFundP2",
            ["CoordSys.Angle_DMS_90", "xsd:normalizedString"],
            0,
            0,
            {"name": "IntermFundP2", "type": "xsd:normalizedString"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(
        self,
        From5=None,
        To5=None,
        FromCo1_FundPt=None,
        FromCo2_FundPt=None,
        ToCoord1_FundPt=None,
        ToCoord2_FundPt=None,
        IntermFundP1=None,
        IntermFundP2=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.From5 = From5
        self.From5_nsprefix_ = None
        self.To5 = To5
        self.To5_nsprefix_ = None
        self.FromCo1_FundPt = FromCo1_FundPt
        self.validate_CoordSys_Angle_DMS_90(self.FromCo1_FundPt)
        self.FromCo1_FundPt_nsprefix_ = None
        self.FromCo2_FundPt = FromCo2_FundPt
        self.validate_CoordSys_Angle_DMS_90(self.FromCo2_FundPt)
        self.FromCo2_FundPt_nsprefix_ = None
        self.ToCoord1_FundPt = ToCoord1_FundPt
        self.validate_ToCoord1_FundPtType26(self.ToCoord1_FundPt)
        self.ToCoord1_FundPt_nsprefix_ = None
        self.ToCoord2_FundPt = ToCoord2_FundPt
        self.validate_ToCoord2_FundPtType27(self.ToCoord2_FundPt)
        self.ToCoord2_FundPt_nsprefix_ = None
        self.IntermFundP1 = IntermFundP1
        self.validate_CoordSys_Angle_DMS_90(self.IntermFundP1)
        self.IntermFundP1_nsprefix_ = None
        self.IntermFundP2 = IntermFundP2
        self.validate_CoordSys_Angle_DMS_90(self.IntermFundP2)
        self.IntermFundP2_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, CoordSys_CoordsysTopic_SwissProjection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoordSys_CoordsysTopic_SwissProjection.subclass:
            return CoordSys_CoordsysTopic_SwissProjection.subclass(*args_, **kwargs_)
        else:
            return CoordSys_CoordsysTopic_SwissProjection(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_From5(self):
        return self.From5

    def set_From5(self, From5):
        self.From5 = From5

    def get_To5(self):
        return self.To5

    def set_To5(self, To5):
        self.To5 = To5

    def get_FromCo1_FundPt(self):
        return self.FromCo1_FundPt

    def set_FromCo1_FundPt(self, FromCo1_FundPt):
        self.FromCo1_FundPt = FromCo1_FundPt

    def get_FromCo2_FundPt(self):
        return self.FromCo2_FundPt

    def set_FromCo2_FundPt(self, FromCo2_FundPt):
        self.FromCo2_FundPt = FromCo2_FundPt

    def get_ToCoord1_FundPt(self):
        return self.ToCoord1_FundPt

    def set_ToCoord1_FundPt(self, ToCoord1_FundPt):
        self.ToCoord1_FundPt = ToCoord1_FundPt

    def get_ToCoord2_FundPt(self):
        return self.ToCoord2_FundPt

    def set_ToCoord2_FundPt(self, ToCoord2_FundPt):
        self.ToCoord2_FundPt = ToCoord2_FundPt

    def get_IntermFundP1(self):
        return self.IntermFundP1

    def set_IntermFundP1(self, IntermFundP1):
        self.IntermFundP1 = IntermFundP1

    def get_IntermFundP2(self):
        return self.IntermFundP2

    def set_IntermFundP2(self, IntermFundP2):
        self.IntermFundP2 = IntermFundP2

    def validate_CoordSys_Angle_DMS_90(self, value):
        result = True
        # Validate type CoordSys.Angle_DMS_90, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            pass
        return result

    def validate_ToCoord1_FundPtType26(self, value):
        result = True
        # Validate type ToCoord1_FundPtType26, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if value < -10000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on ToCoord1_FundPtType26'
                    % {"value": value, "lineno": lineno}
                )
                result = False
            if value > 10000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on ToCoord1_FundPtType26'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_ToCoord2_FundPtType27(self, value):
        result = True
        # Validate type ToCoord2_FundPtType27, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if value < -10000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on ToCoord2_FundPtType27'
                    % {"value": value, "lineno": lineno}
                )
                result = False
            if value > 10000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on ToCoord2_FundPtType27'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def _hasContent(self):
        if (
            self.From5 is not None
            or self.To5 is not None
            or self.FromCo1_FundPt is not None
            or self.FromCo2_FundPt is not None
            or self.ToCoord1_FundPt is not None
            or self.ToCoord2_FundPt is not None
            or self.IntermFundP1 is not None
            or self.IntermFundP2 is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.SwissProjection",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("CoordSys.CoordsysTopic.SwissProjection")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "CoordSys.CoordsysTopic.SwissProjection":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="CoordSys.CoordsysTopic.SwissProjection",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="CoordSys.CoordsysTopic.SwissProjection",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="CoordSys.CoordsysTopic.SwissProjection",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.SwissProjection",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.From5 is not None:
            namespaceprefix_ = self.From5_nsprefix_ + ":" if (UseCapturedNS_ and self.From5_nsprefix_) else ""
            self.From5.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="From5",
                pretty_print=pretty_print,
            )
        if self.To5 is not None:
            namespaceprefix_ = self.To5_nsprefix_ + ":" if (UseCapturedNS_ and self.To5_nsprefix_) else ""
            self.To5.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="To5",
                pretty_print=pretty_print,
            )
        if self.FromCo1_FundPt is not None:
            namespaceprefix_ = (
                self.FromCo1_FundPt_nsprefix_ + ":"
                if (UseCapturedNS_ and self.FromCo1_FundPt_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sFromCo1_FundPt>%s</%sFromCo1_FundPt>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(quote_xml(self.FromCo1_FundPt), input_name="FromCo1_FundPt")
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.FromCo2_FundPt is not None:
            namespaceprefix_ = (
                self.FromCo2_FundPt_nsprefix_ + ":"
                if (UseCapturedNS_ and self.FromCo2_FundPt_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sFromCo2_FundPt>%s</%sFromCo2_FundPt>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(quote_xml(self.FromCo2_FundPt), input_name="FromCo2_FundPt")
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.ToCoord1_FundPt is not None:
            namespaceprefix_ = (
                self.ToCoord1_FundPt_nsprefix_ + ":"
                if (UseCapturedNS_ and self.ToCoord1_FundPt_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sToCoord1_FundPt>%s</%sToCoord1_FundPt>%s"
                % (
                    namespaceprefix_,
                    self.gds_format_integer(self.ToCoord1_FundPt, input_name="ToCoord1_FundPt"),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.ToCoord2_FundPt is not None:
            namespaceprefix_ = (
                self.ToCoord2_FundPt_nsprefix_ + ":"
                if (UseCapturedNS_ and self.ToCoord2_FundPt_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sToCoord2_FundPt>%s</%sToCoord2_FundPt>%s"
                % (
                    namespaceprefix_,
                    self.gds_format_integer(self.ToCoord2_FundPt, input_name="ToCoord2_FundPt"),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.IntermFundP1 is not None:
            namespaceprefix_ = (
                self.IntermFundP1_nsprefix_ + ":" if (UseCapturedNS_ and self.IntermFundP1_nsprefix_) else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sIntermFundP1>%s</%sIntermFundP1>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(quote_xml(self.IntermFundP1), input_name="IntermFundP1")
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.IntermFundP2 is not None:
            namespaceprefix_ = (
                self.IntermFundP2_nsprefix_ + ":" if (UseCapturedNS_ and self.IntermFundP2_nsprefix_) else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sIntermFundP2>%s</%sIntermFundP2>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(quote_xml(self.IntermFundP2), input_name="IntermFundP2")
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "From5":
            obj_ = RoleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.From5 = obj_
            obj_.original_tagname_ = "From5"
        elif nodeName_ == "To5":
            obj_ = RoleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.To5 = obj_
            obj_.original_tagname_ = "To5"
        elif nodeName_ == "FromCo1_FundPt":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "FromCo1_FundPt")
            value_ = self.gds_validate_string(value_, node, "FromCo1_FundPt")
            self.FromCo1_FundPt = value_
            self.FromCo1_FundPt_nsprefix_ = child_.prefix
            # validate type CoordSys.Angle_DMS_90
            self.validate_CoordSys_Angle_DMS_90(self.FromCo1_FundPt)
        elif nodeName_ == "FromCo2_FundPt":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "FromCo2_FundPt")
            value_ = self.gds_validate_string(value_, node, "FromCo2_FundPt")
            self.FromCo2_FundPt = value_
            self.FromCo2_FundPt_nsprefix_ = child_.prefix
            # validate type CoordSys.Angle_DMS_90
            self.validate_CoordSys_Angle_DMS_90(self.FromCo2_FundPt)
        elif nodeName_ == "ToCoord1_FundPt" and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, "ToCoord1_FundPt")
            ival_ = self.gds_validate_integer(ival_, node, "ToCoord1_FundPt")
            self.ToCoord1_FundPt = ival_
            self.ToCoord1_FundPt_nsprefix_ = child_.prefix
            # validate type ToCoord1_FundPtType26
            self.validate_ToCoord1_FundPtType26(self.ToCoord1_FundPt)
        elif nodeName_ == "ToCoord2_FundPt" and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, "ToCoord2_FundPt")
            ival_ = self.gds_validate_integer(ival_, node, "ToCoord2_FundPt")
            self.ToCoord2_FundPt = ival_
            self.ToCoord2_FundPt_nsprefix_ = child_.prefix
            # validate type ToCoord2_FundPtType27
            self.validate_ToCoord2_FundPtType27(self.ToCoord2_FundPt)
        elif nodeName_ == "IntermFundP1":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "IntermFundP1")
            value_ = self.gds_validate_string(value_, node, "IntermFundP1")
            self.IntermFundP1 = value_
            self.IntermFundP1_nsprefix_ = child_.prefix
            # validate type CoordSys.Angle_DMS_90
            self.validate_CoordSys_Angle_DMS_90(self.IntermFundP1)
        elif nodeName_ == "IntermFundP2":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "IntermFundP2")
            value_ = self.gds_validate_string(value_, node, "IntermFundP2")
            self.IntermFundP2 = value_
            self.IntermFundP2_nsprefix_ = child_.prefix
            # validate type CoordSys.Angle_DMS_90
            self.validate_CoordSys_Angle_DMS_90(self.IntermFundP2)


# end class CoordSys_CoordsysTopic_SwissProjection


class CoordSys_CoordsysTopic_Mercator(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "From5": MemberSpec_("From5", "RoleType", 0, 0, {"name": "From5", "type": "RoleType"}, None),
        "To5": MemberSpec_("To5", "RoleType", 0, 0, {"name": "To5", "type": "RoleType"}, None),
        "FromCo1_FundPt": MemberSpec_(
            "FromCo1_FundPt",
            ["CoordSys.Angle_DMS_90", "xsd:normalizedString"],
            0,
            0,
            {"name": "FromCo1_FundPt", "type": "xsd:normalizedString"},
            None,
        ),
        "FromCo2_FundPt": MemberSpec_(
            "FromCo2_FundPt",
            ["CoordSys.Angle_DMS_90", "xsd:normalizedString"],
            0,
            0,
            {"name": "FromCo2_FundPt", "type": "xsd:normalizedString"},
            None,
        ),
        "ToCoord1_FundPt": MemberSpec_(
            "ToCoord1_FundPt",
            ["ToCoord1_FundPtType28", "xsd:integer"],
            0,
            0,
            {"name": "ToCoord1_FundPt", "type": "xsd:integer"},
            None,
        ),
        "ToCoord2_FundPt": MemberSpec_(
            "ToCoord2_FundPt",
            ["ToCoord2_FundPtType29", "xsd:integer"],
            0,
            0,
            {"name": "ToCoord2_FundPt", "type": "xsd:integer"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(
        self,
        From5=None,
        To5=None,
        FromCo1_FundPt=None,
        FromCo2_FundPt=None,
        ToCoord1_FundPt=None,
        ToCoord2_FundPt=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.From5 = From5
        self.From5_nsprefix_ = None
        self.To5 = To5
        self.To5_nsprefix_ = None
        self.FromCo1_FundPt = FromCo1_FundPt
        self.validate_CoordSys_Angle_DMS_90(self.FromCo1_FundPt)
        self.FromCo1_FundPt_nsprefix_ = None
        self.FromCo2_FundPt = FromCo2_FundPt
        self.validate_CoordSys_Angle_DMS_90(self.FromCo2_FundPt)
        self.FromCo2_FundPt_nsprefix_ = None
        self.ToCoord1_FundPt = ToCoord1_FundPt
        self.validate_ToCoord1_FundPtType28(self.ToCoord1_FundPt)
        self.ToCoord1_FundPt_nsprefix_ = None
        self.ToCoord2_FundPt = ToCoord2_FundPt
        self.validate_ToCoord2_FundPtType29(self.ToCoord2_FundPt)
        self.ToCoord2_FundPt_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, CoordSys_CoordsysTopic_Mercator)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoordSys_CoordsysTopic_Mercator.subclass:
            return CoordSys_CoordsysTopic_Mercator.subclass(*args_, **kwargs_)
        else:
            return CoordSys_CoordsysTopic_Mercator(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_From5(self):
        return self.From5

    def set_From5(self, From5):
        self.From5 = From5

    def get_To5(self):
        return self.To5

    def set_To5(self, To5):
        self.To5 = To5

    def get_FromCo1_FundPt(self):
        return self.FromCo1_FundPt

    def set_FromCo1_FundPt(self, FromCo1_FundPt):
        self.FromCo1_FundPt = FromCo1_FundPt

    def get_FromCo2_FundPt(self):
        return self.FromCo2_FundPt

    def set_FromCo2_FundPt(self, FromCo2_FundPt):
        self.FromCo2_FundPt = FromCo2_FundPt

    def get_ToCoord1_FundPt(self):
        return self.ToCoord1_FundPt

    def set_ToCoord1_FundPt(self, ToCoord1_FundPt):
        self.ToCoord1_FundPt = ToCoord1_FundPt

    def get_ToCoord2_FundPt(self):
        return self.ToCoord2_FundPt

    def set_ToCoord2_FundPt(self, ToCoord2_FundPt):
        self.ToCoord2_FundPt = ToCoord2_FundPt

    def validate_CoordSys_Angle_DMS_90(self, value):
        result = True
        # Validate type CoordSys.Angle_DMS_90, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            pass
        return result

    def validate_ToCoord1_FundPtType28(self, value):
        result = True
        # Validate type ToCoord1_FundPtType28, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if value < -10000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on ToCoord1_FundPtType28'
                    % {"value": value, "lineno": lineno}
                )
                result = False
            if value > 10000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on ToCoord1_FundPtType28'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_ToCoord2_FundPtType29(self, value):
        result = True
        # Validate type ToCoord2_FundPtType29, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if value < -10000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on ToCoord2_FundPtType29'
                    % {"value": value, "lineno": lineno}
                )
                result = False
            if value > 10000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on ToCoord2_FundPtType29'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def _hasContent(self):
        if (
            self.From5 is not None
            or self.To5 is not None
            or self.FromCo1_FundPt is not None
            or self.FromCo2_FundPt is not None
            or self.ToCoord1_FundPt is not None
            or self.ToCoord2_FundPt is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.Mercator",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("CoordSys.CoordsysTopic.Mercator")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "CoordSys.CoordsysTopic.Mercator":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="CoordSys.CoordsysTopic.Mercator",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="CoordSys.CoordsysTopic.Mercator",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="CoordSys.CoordsysTopic.Mercator",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.Mercator",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.From5 is not None:
            namespaceprefix_ = self.From5_nsprefix_ + ":" if (UseCapturedNS_ and self.From5_nsprefix_) else ""
            self.From5.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="From5",
                pretty_print=pretty_print,
            )
        if self.To5 is not None:
            namespaceprefix_ = self.To5_nsprefix_ + ":" if (UseCapturedNS_ and self.To5_nsprefix_) else ""
            self.To5.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="To5",
                pretty_print=pretty_print,
            )
        if self.FromCo1_FundPt is not None:
            namespaceprefix_ = (
                self.FromCo1_FundPt_nsprefix_ + ":"
                if (UseCapturedNS_ and self.FromCo1_FundPt_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sFromCo1_FundPt>%s</%sFromCo1_FundPt>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(quote_xml(self.FromCo1_FundPt), input_name="FromCo1_FundPt")
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.FromCo2_FundPt is not None:
            namespaceprefix_ = (
                self.FromCo2_FundPt_nsprefix_ + ":"
                if (UseCapturedNS_ and self.FromCo2_FundPt_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sFromCo2_FundPt>%s</%sFromCo2_FundPt>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(quote_xml(self.FromCo2_FundPt), input_name="FromCo2_FundPt")
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.ToCoord1_FundPt is not None:
            namespaceprefix_ = (
                self.ToCoord1_FundPt_nsprefix_ + ":"
                if (UseCapturedNS_ and self.ToCoord1_FundPt_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sToCoord1_FundPt>%s</%sToCoord1_FundPt>%s"
                % (
                    namespaceprefix_,
                    self.gds_format_integer(self.ToCoord1_FundPt, input_name="ToCoord1_FundPt"),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.ToCoord2_FundPt is not None:
            namespaceprefix_ = (
                self.ToCoord2_FundPt_nsprefix_ + ":"
                if (UseCapturedNS_ and self.ToCoord2_FundPt_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sToCoord2_FundPt>%s</%sToCoord2_FundPt>%s"
                % (
                    namespaceprefix_,
                    self.gds_format_integer(self.ToCoord2_FundPt, input_name="ToCoord2_FundPt"),
                    namespaceprefix_,
                    eol_,
                )
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "From5":
            obj_ = RoleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.From5 = obj_
            obj_.original_tagname_ = "From5"
        elif nodeName_ == "To5":
            obj_ = RoleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.To5 = obj_
            obj_.original_tagname_ = "To5"
        elif nodeName_ == "FromCo1_FundPt":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "FromCo1_FundPt")
            value_ = self.gds_validate_string(value_, node, "FromCo1_FundPt")
            self.FromCo1_FundPt = value_
            self.FromCo1_FundPt_nsprefix_ = child_.prefix
            # validate type CoordSys.Angle_DMS_90
            self.validate_CoordSys_Angle_DMS_90(self.FromCo1_FundPt)
        elif nodeName_ == "FromCo2_FundPt":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "FromCo2_FundPt")
            value_ = self.gds_validate_string(value_, node, "FromCo2_FundPt")
            self.FromCo2_FundPt = value_
            self.FromCo2_FundPt_nsprefix_ = child_.prefix
            # validate type CoordSys.Angle_DMS_90
            self.validate_CoordSys_Angle_DMS_90(self.FromCo2_FundPt)
        elif nodeName_ == "ToCoord1_FundPt" and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, "ToCoord1_FundPt")
            ival_ = self.gds_validate_integer(ival_, node, "ToCoord1_FundPt")
            self.ToCoord1_FundPt = ival_
            self.ToCoord1_FundPt_nsprefix_ = child_.prefix
            # validate type ToCoord1_FundPtType28
            self.validate_ToCoord1_FundPtType28(self.ToCoord1_FundPt)
        elif nodeName_ == "ToCoord2_FundPt" and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, "ToCoord2_FundPt")
            ival_ = self.gds_validate_integer(ival_, node, "ToCoord2_FundPt")
            self.ToCoord2_FundPt = ival_
            self.ToCoord2_FundPt_nsprefix_ = child_.prefix
            # validate type ToCoord2_FundPtType29
            self.validate_ToCoord2_FundPtType29(self.ToCoord2_FundPt)


# end class CoordSys_CoordsysTopic_Mercator


class CoordSys_CoordsysTopic_ObliqueMercator(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "From5": MemberSpec_("From5", "RoleType", 0, 0, {"name": "From5", "type": "RoleType"}, None),
        "To5": MemberSpec_("To5", "RoleType", 0, 0, {"name": "To5", "type": "RoleType"}, None),
        "FromCo1_FundPt": MemberSpec_(
            "FromCo1_FundPt",
            ["CoordSys.Angle_DMS_90", "xsd:normalizedString"],
            0,
            0,
            {"name": "FromCo1_FundPt", "type": "xsd:normalizedString"},
            None,
        ),
        "FromCo2_FundPt": MemberSpec_(
            "FromCo2_FundPt",
            ["CoordSys.Angle_DMS_90", "xsd:normalizedString"],
            0,
            0,
            {"name": "FromCo2_FundPt", "type": "xsd:normalizedString"},
            None,
        ),
        "ToCoord1_FundPt": MemberSpec_(
            "ToCoord1_FundPt",
            ["ToCoord1_FundPtType30", "xsd:integer"],
            0,
            0,
            {"name": "ToCoord1_FundPt", "type": "xsd:integer"},
            None,
        ),
        "ToCoord2_FundPt": MemberSpec_(
            "ToCoord2_FundPt",
            ["ToCoord2_FundPtType31", "xsd:integer"],
            0,
            0,
            {"name": "ToCoord2_FundPt", "type": "xsd:integer"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(
        self,
        From5=None,
        To5=None,
        FromCo1_FundPt=None,
        FromCo2_FundPt=None,
        ToCoord1_FundPt=None,
        ToCoord2_FundPt=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.From5 = From5
        self.From5_nsprefix_ = None
        self.To5 = To5
        self.To5_nsprefix_ = None
        self.FromCo1_FundPt = FromCo1_FundPt
        self.validate_CoordSys_Angle_DMS_90(self.FromCo1_FundPt)
        self.FromCo1_FundPt_nsprefix_ = None
        self.FromCo2_FundPt = FromCo2_FundPt
        self.validate_CoordSys_Angle_DMS_90(self.FromCo2_FundPt)
        self.FromCo2_FundPt_nsprefix_ = None
        self.ToCoord1_FundPt = ToCoord1_FundPt
        self.validate_ToCoord1_FundPtType30(self.ToCoord1_FundPt)
        self.ToCoord1_FundPt_nsprefix_ = None
        self.ToCoord2_FundPt = ToCoord2_FundPt
        self.validate_ToCoord2_FundPtType31(self.ToCoord2_FundPt)
        self.ToCoord2_FundPt_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, CoordSys_CoordsysTopic_ObliqueMercator)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoordSys_CoordsysTopic_ObliqueMercator.subclass:
            return CoordSys_CoordsysTopic_ObliqueMercator.subclass(*args_, **kwargs_)
        else:
            return CoordSys_CoordsysTopic_ObliqueMercator(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_From5(self):
        return self.From5

    def set_From5(self, From5):
        self.From5 = From5

    def get_To5(self):
        return self.To5

    def set_To5(self, To5):
        self.To5 = To5

    def get_FromCo1_FundPt(self):
        return self.FromCo1_FundPt

    def set_FromCo1_FundPt(self, FromCo1_FundPt):
        self.FromCo1_FundPt = FromCo1_FundPt

    def get_FromCo2_FundPt(self):
        return self.FromCo2_FundPt

    def set_FromCo2_FundPt(self, FromCo2_FundPt):
        self.FromCo2_FundPt = FromCo2_FundPt

    def get_ToCoord1_FundPt(self):
        return self.ToCoord1_FundPt

    def set_ToCoord1_FundPt(self, ToCoord1_FundPt):
        self.ToCoord1_FundPt = ToCoord1_FundPt

    def get_ToCoord2_FundPt(self):
        return self.ToCoord2_FundPt

    def set_ToCoord2_FundPt(self, ToCoord2_FundPt):
        self.ToCoord2_FundPt = ToCoord2_FundPt

    def validate_CoordSys_Angle_DMS_90(self, value):
        result = True
        # Validate type CoordSys.Angle_DMS_90, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            pass
        return result

    def validate_ToCoord1_FundPtType30(self, value):
        result = True
        # Validate type ToCoord1_FundPtType30, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if value < -10000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on ToCoord1_FundPtType30'
                    % {"value": value, "lineno": lineno}
                )
                result = False
            if value > 10000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on ToCoord1_FundPtType30'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_ToCoord2_FundPtType31(self, value):
        result = True
        # Validate type ToCoord2_FundPtType31, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if value < -10000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on ToCoord2_FundPtType31'
                    % {"value": value, "lineno": lineno}
                )
                result = False
            if value > 10000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on ToCoord2_FundPtType31'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def _hasContent(self):
        if (
            self.From5 is not None
            or self.To5 is not None
            or self.FromCo1_FundPt is not None
            or self.FromCo2_FundPt is not None
            or self.ToCoord1_FundPt is not None
            or self.ToCoord2_FundPt is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.ObliqueMercator",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("CoordSys.CoordsysTopic.ObliqueMercator")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "CoordSys.CoordsysTopic.ObliqueMercator":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="CoordSys.CoordsysTopic.ObliqueMercator",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="CoordSys.CoordsysTopic.ObliqueMercator",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="CoordSys.CoordsysTopic.ObliqueMercator",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.ObliqueMercator",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.From5 is not None:
            namespaceprefix_ = self.From5_nsprefix_ + ":" if (UseCapturedNS_ and self.From5_nsprefix_) else ""
            self.From5.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="From5",
                pretty_print=pretty_print,
            )
        if self.To5 is not None:
            namespaceprefix_ = self.To5_nsprefix_ + ":" if (UseCapturedNS_ and self.To5_nsprefix_) else ""
            self.To5.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="To5",
                pretty_print=pretty_print,
            )
        if self.FromCo1_FundPt is not None:
            namespaceprefix_ = (
                self.FromCo1_FundPt_nsprefix_ + ":"
                if (UseCapturedNS_ and self.FromCo1_FundPt_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sFromCo1_FundPt>%s</%sFromCo1_FundPt>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(quote_xml(self.FromCo1_FundPt), input_name="FromCo1_FundPt")
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.FromCo2_FundPt is not None:
            namespaceprefix_ = (
                self.FromCo2_FundPt_nsprefix_ + ":"
                if (UseCapturedNS_ and self.FromCo2_FundPt_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sFromCo2_FundPt>%s</%sFromCo2_FundPt>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(quote_xml(self.FromCo2_FundPt), input_name="FromCo2_FundPt")
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.ToCoord1_FundPt is not None:
            namespaceprefix_ = (
                self.ToCoord1_FundPt_nsprefix_ + ":"
                if (UseCapturedNS_ and self.ToCoord1_FundPt_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sToCoord1_FundPt>%s</%sToCoord1_FundPt>%s"
                % (
                    namespaceprefix_,
                    self.gds_format_integer(self.ToCoord1_FundPt, input_name="ToCoord1_FundPt"),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.ToCoord2_FundPt is not None:
            namespaceprefix_ = (
                self.ToCoord2_FundPt_nsprefix_ + ":"
                if (UseCapturedNS_ and self.ToCoord2_FundPt_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sToCoord2_FundPt>%s</%sToCoord2_FundPt>%s"
                % (
                    namespaceprefix_,
                    self.gds_format_integer(self.ToCoord2_FundPt, input_name="ToCoord2_FundPt"),
                    namespaceprefix_,
                    eol_,
                )
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "From5":
            obj_ = RoleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.From5 = obj_
            obj_.original_tagname_ = "From5"
        elif nodeName_ == "To5":
            obj_ = RoleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.To5 = obj_
            obj_.original_tagname_ = "To5"
        elif nodeName_ == "FromCo1_FundPt":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "FromCo1_FundPt")
            value_ = self.gds_validate_string(value_, node, "FromCo1_FundPt")
            self.FromCo1_FundPt = value_
            self.FromCo1_FundPt_nsprefix_ = child_.prefix
            # validate type CoordSys.Angle_DMS_90
            self.validate_CoordSys_Angle_DMS_90(self.FromCo1_FundPt)
        elif nodeName_ == "FromCo2_FundPt":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "FromCo2_FundPt")
            value_ = self.gds_validate_string(value_, node, "FromCo2_FundPt")
            self.FromCo2_FundPt = value_
            self.FromCo2_FundPt_nsprefix_ = child_.prefix
            # validate type CoordSys.Angle_DMS_90
            self.validate_CoordSys_Angle_DMS_90(self.FromCo2_FundPt)
        elif nodeName_ == "ToCoord1_FundPt" and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, "ToCoord1_FundPt")
            ival_ = self.gds_validate_integer(ival_, node, "ToCoord1_FundPt")
            self.ToCoord1_FundPt = ival_
            self.ToCoord1_FundPt_nsprefix_ = child_.prefix
            # validate type ToCoord1_FundPtType30
            self.validate_ToCoord1_FundPtType30(self.ToCoord1_FundPt)
        elif nodeName_ == "ToCoord2_FundPt" and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, "ToCoord2_FundPt")
            ival_ = self.gds_validate_integer(ival_, node, "ToCoord2_FundPt")
            self.ToCoord2_FundPt = ival_
            self.ToCoord2_FundPt_nsprefix_ = child_.prefix
            # validate type ToCoord2_FundPtType31
            self.validate_ToCoord2_FundPtType31(self.ToCoord2_FundPt)


# end class CoordSys_CoordsysTopic_ObliqueMercator


class CoordSys_CoordsysTopic_Lambert(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "From5": MemberSpec_("From5", "RoleType", 0, 0, {"name": "From5", "type": "RoleType"}, None),
        "To5": MemberSpec_("To5", "RoleType", 0, 0, {"name": "To5", "type": "RoleType"}, None),
        "FromCo1_FundPt": MemberSpec_(
            "FromCo1_FundPt",
            ["CoordSys.Angle_DMS_90", "xsd:normalizedString"],
            0,
            0,
            {"name": "FromCo1_FundPt", "type": "xsd:normalizedString"},
            None,
        ),
        "FromCo2_FundPt": MemberSpec_(
            "FromCo2_FundPt",
            ["CoordSys.Angle_DMS_90", "xsd:normalizedString"],
            0,
            0,
            {"name": "FromCo2_FundPt", "type": "xsd:normalizedString"},
            None,
        ),
        "ToCoord1_FundPt": MemberSpec_(
            "ToCoord1_FundPt",
            ["ToCoord1_FundPtType32", "xsd:integer"],
            0,
            0,
            {"name": "ToCoord1_FundPt", "type": "xsd:integer"},
            None,
        ),
        "ToCoord2_FundPt": MemberSpec_(
            "ToCoord2_FundPt",
            ["ToCoord2_FundPtType33", "xsd:integer"],
            0,
            0,
            {"name": "ToCoord2_FundPt", "type": "xsd:integer"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(
        self,
        From5=None,
        To5=None,
        FromCo1_FundPt=None,
        FromCo2_FundPt=None,
        ToCoord1_FundPt=None,
        ToCoord2_FundPt=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.From5 = From5
        self.From5_nsprefix_ = None
        self.To5 = To5
        self.To5_nsprefix_ = None
        self.FromCo1_FundPt = FromCo1_FundPt
        self.validate_CoordSys_Angle_DMS_90(self.FromCo1_FundPt)
        self.FromCo1_FundPt_nsprefix_ = None
        self.FromCo2_FundPt = FromCo2_FundPt
        self.validate_CoordSys_Angle_DMS_90(self.FromCo2_FundPt)
        self.FromCo2_FundPt_nsprefix_ = None
        self.ToCoord1_FundPt = ToCoord1_FundPt
        self.validate_ToCoord1_FundPtType32(self.ToCoord1_FundPt)
        self.ToCoord1_FundPt_nsprefix_ = None
        self.ToCoord2_FundPt = ToCoord2_FundPt
        self.validate_ToCoord2_FundPtType33(self.ToCoord2_FundPt)
        self.ToCoord2_FundPt_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, CoordSys_CoordsysTopic_Lambert)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoordSys_CoordsysTopic_Lambert.subclass:
            return CoordSys_CoordsysTopic_Lambert.subclass(*args_, **kwargs_)
        else:
            return CoordSys_CoordsysTopic_Lambert(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_From5(self):
        return self.From5

    def set_From5(self, From5):
        self.From5 = From5

    def get_To5(self):
        return self.To5

    def set_To5(self, To5):
        self.To5 = To5

    def get_FromCo1_FundPt(self):
        return self.FromCo1_FundPt

    def set_FromCo1_FundPt(self, FromCo1_FundPt):
        self.FromCo1_FundPt = FromCo1_FundPt

    def get_FromCo2_FundPt(self):
        return self.FromCo2_FundPt

    def set_FromCo2_FundPt(self, FromCo2_FundPt):
        self.FromCo2_FundPt = FromCo2_FundPt

    def get_ToCoord1_FundPt(self):
        return self.ToCoord1_FundPt

    def set_ToCoord1_FundPt(self, ToCoord1_FundPt):
        self.ToCoord1_FundPt = ToCoord1_FundPt

    def get_ToCoord2_FundPt(self):
        return self.ToCoord2_FundPt

    def set_ToCoord2_FundPt(self, ToCoord2_FundPt):
        self.ToCoord2_FundPt = ToCoord2_FundPt

    def validate_CoordSys_Angle_DMS_90(self, value):
        result = True
        # Validate type CoordSys.Angle_DMS_90, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            pass
        return result

    def validate_ToCoord1_FundPtType32(self, value):
        result = True
        # Validate type ToCoord1_FundPtType32, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if value < -10000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on ToCoord1_FundPtType32'
                    % {"value": value, "lineno": lineno}
                )
                result = False
            if value > 10000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on ToCoord1_FundPtType32'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_ToCoord2_FundPtType33(self, value):
        result = True
        # Validate type ToCoord2_FundPtType33, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if value < -10000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on ToCoord2_FundPtType33'
                    % {"value": value, "lineno": lineno}
                )
                result = False
            if value > 10000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on ToCoord2_FundPtType33'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def _hasContent(self):
        if (
            self.From5 is not None
            or self.To5 is not None
            or self.FromCo1_FundPt is not None
            or self.FromCo2_FundPt is not None
            or self.ToCoord1_FundPt is not None
            or self.ToCoord2_FundPt is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.Lambert",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("CoordSys.CoordsysTopic.Lambert")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "CoordSys.CoordsysTopic.Lambert":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="CoordSys.CoordsysTopic.Lambert",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="CoordSys.CoordsysTopic.Lambert",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="CoordSys.CoordsysTopic.Lambert",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.Lambert",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.From5 is not None:
            namespaceprefix_ = self.From5_nsprefix_ + ":" if (UseCapturedNS_ and self.From5_nsprefix_) else ""
            self.From5.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="From5",
                pretty_print=pretty_print,
            )
        if self.To5 is not None:
            namespaceprefix_ = self.To5_nsprefix_ + ":" if (UseCapturedNS_ and self.To5_nsprefix_) else ""
            self.To5.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="To5",
                pretty_print=pretty_print,
            )
        if self.FromCo1_FundPt is not None:
            namespaceprefix_ = (
                self.FromCo1_FundPt_nsprefix_ + ":"
                if (UseCapturedNS_ and self.FromCo1_FundPt_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sFromCo1_FundPt>%s</%sFromCo1_FundPt>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(quote_xml(self.FromCo1_FundPt), input_name="FromCo1_FundPt")
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.FromCo2_FundPt is not None:
            namespaceprefix_ = (
                self.FromCo2_FundPt_nsprefix_ + ":"
                if (UseCapturedNS_ and self.FromCo2_FundPt_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sFromCo2_FundPt>%s</%sFromCo2_FundPt>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(quote_xml(self.FromCo2_FundPt), input_name="FromCo2_FundPt")
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.ToCoord1_FundPt is not None:
            namespaceprefix_ = (
                self.ToCoord1_FundPt_nsprefix_ + ":"
                if (UseCapturedNS_ and self.ToCoord1_FundPt_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sToCoord1_FundPt>%s</%sToCoord1_FundPt>%s"
                % (
                    namespaceprefix_,
                    self.gds_format_integer(self.ToCoord1_FundPt, input_name="ToCoord1_FundPt"),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.ToCoord2_FundPt is not None:
            namespaceprefix_ = (
                self.ToCoord2_FundPt_nsprefix_ + ":"
                if (UseCapturedNS_ and self.ToCoord2_FundPt_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sToCoord2_FundPt>%s</%sToCoord2_FundPt>%s"
                % (
                    namespaceprefix_,
                    self.gds_format_integer(self.ToCoord2_FundPt, input_name="ToCoord2_FundPt"),
                    namespaceprefix_,
                    eol_,
                )
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "From5":
            obj_ = RoleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.From5 = obj_
            obj_.original_tagname_ = "From5"
        elif nodeName_ == "To5":
            obj_ = RoleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.To5 = obj_
            obj_.original_tagname_ = "To5"
        elif nodeName_ == "FromCo1_FundPt":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "FromCo1_FundPt")
            value_ = self.gds_validate_string(value_, node, "FromCo1_FundPt")
            self.FromCo1_FundPt = value_
            self.FromCo1_FundPt_nsprefix_ = child_.prefix
            # validate type CoordSys.Angle_DMS_90
            self.validate_CoordSys_Angle_DMS_90(self.FromCo1_FundPt)
        elif nodeName_ == "FromCo2_FundPt":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "FromCo2_FundPt")
            value_ = self.gds_validate_string(value_, node, "FromCo2_FundPt")
            self.FromCo2_FundPt = value_
            self.FromCo2_FundPt_nsprefix_ = child_.prefix
            # validate type CoordSys.Angle_DMS_90
            self.validate_CoordSys_Angle_DMS_90(self.FromCo2_FundPt)
        elif nodeName_ == "ToCoord1_FundPt" and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, "ToCoord1_FundPt")
            ival_ = self.gds_validate_integer(ival_, node, "ToCoord1_FundPt")
            self.ToCoord1_FundPt = ival_
            self.ToCoord1_FundPt_nsprefix_ = child_.prefix
            # validate type ToCoord1_FundPtType32
            self.validate_ToCoord1_FundPtType32(self.ToCoord1_FundPt)
        elif nodeName_ == "ToCoord2_FundPt" and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, "ToCoord2_FundPt")
            ival_ = self.gds_validate_integer(ival_, node, "ToCoord2_FundPt")
            self.ToCoord2_FundPt = ival_
            self.ToCoord2_FundPt_nsprefix_ = child_.prefix
            # validate type ToCoord2_FundPtType33
            self.validate_ToCoord2_FundPtType33(self.ToCoord2_FundPt)


# end class CoordSys_CoordsysTopic_Lambert


class CoordSys_CoordsysTopic_Polyconic(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "From5": MemberSpec_("From5", "RoleType", 0, 0, {"name": "From5", "type": "RoleType"}, None),
        "To5": MemberSpec_("To5", "RoleType", 0, 0, {"name": "To5", "type": "RoleType"}, None),
        "FromCo1_FundPt": MemberSpec_(
            "FromCo1_FundPt",
            ["CoordSys.Angle_DMS_90", "xsd:normalizedString"],
            0,
            0,
            {"name": "FromCo1_FundPt", "type": "xsd:normalizedString"},
            None,
        ),
        "FromCo2_FundPt": MemberSpec_(
            "FromCo2_FundPt",
            ["CoordSys.Angle_DMS_90", "xsd:normalizedString"],
            0,
            0,
            {"name": "FromCo2_FundPt", "type": "xsd:normalizedString"},
            None,
        ),
        "ToCoord1_FundPt": MemberSpec_(
            "ToCoord1_FundPt",
            ["ToCoord1_FundPtType34", "xsd:integer"],
            0,
            0,
            {"name": "ToCoord1_FundPt", "type": "xsd:integer"},
            None,
        ),
        "ToCoord2_FundPt": MemberSpec_(
            "ToCoord2_FundPt",
            ["ToCoord2_FundPtType35", "xsd:integer"],
            0,
            0,
            {"name": "ToCoord2_FundPt", "type": "xsd:integer"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(
        self,
        From5=None,
        To5=None,
        FromCo1_FundPt=None,
        FromCo2_FundPt=None,
        ToCoord1_FundPt=None,
        ToCoord2_FundPt=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.From5 = From5
        self.From5_nsprefix_ = None
        self.To5 = To5
        self.To5_nsprefix_ = None
        self.FromCo1_FundPt = FromCo1_FundPt
        self.validate_CoordSys_Angle_DMS_90(self.FromCo1_FundPt)
        self.FromCo1_FundPt_nsprefix_ = None
        self.FromCo2_FundPt = FromCo2_FundPt
        self.validate_CoordSys_Angle_DMS_90(self.FromCo2_FundPt)
        self.FromCo2_FundPt_nsprefix_ = None
        self.ToCoord1_FundPt = ToCoord1_FundPt
        self.validate_ToCoord1_FundPtType34(self.ToCoord1_FundPt)
        self.ToCoord1_FundPt_nsprefix_ = None
        self.ToCoord2_FundPt = ToCoord2_FundPt
        self.validate_ToCoord2_FundPtType35(self.ToCoord2_FundPt)
        self.ToCoord2_FundPt_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, CoordSys_CoordsysTopic_Polyconic)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoordSys_CoordsysTopic_Polyconic.subclass:
            return CoordSys_CoordsysTopic_Polyconic.subclass(*args_, **kwargs_)
        else:
            return CoordSys_CoordsysTopic_Polyconic(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_From5(self):
        return self.From5

    def set_From5(self, From5):
        self.From5 = From5

    def get_To5(self):
        return self.To5

    def set_To5(self, To5):
        self.To5 = To5

    def get_FromCo1_FundPt(self):
        return self.FromCo1_FundPt

    def set_FromCo1_FundPt(self, FromCo1_FundPt):
        self.FromCo1_FundPt = FromCo1_FundPt

    def get_FromCo2_FundPt(self):
        return self.FromCo2_FundPt

    def set_FromCo2_FundPt(self, FromCo2_FundPt):
        self.FromCo2_FundPt = FromCo2_FundPt

    def get_ToCoord1_FundPt(self):
        return self.ToCoord1_FundPt

    def set_ToCoord1_FundPt(self, ToCoord1_FundPt):
        self.ToCoord1_FundPt = ToCoord1_FundPt

    def get_ToCoord2_FundPt(self):
        return self.ToCoord2_FundPt

    def set_ToCoord2_FundPt(self, ToCoord2_FundPt):
        self.ToCoord2_FundPt = ToCoord2_FundPt

    def validate_CoordSys_Angle_DMS_90(self, value):
        result = True
        # Validate type CoordSys.Angle_DMS_90, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            pass
        return result

    def validate_ToCoord1_FundPtType34(self, value):
        result = True
        # Validate type ToCoord1_FundPtType34, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if value < -10000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on ToCoord1_FundPtType34'
                    % {"value": value, "lineno": lineno}
                )
                result = False
            if value > 10000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on ToCoord1_FundPtType34'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_ToCoord2_FundPtType35(self, value):
        result = True
        # Validate type ToCoord2_FundPtType35, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if value < -10000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on ToCoord2_FundPtType35'
                    % {"value": value, "lineno": lineno}
                )
                result = False
            if value > 10000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on ToCoord2_FundPtType35'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def _hasContent(self):
        if (
            self.From5 is not None
            or self.To5 is not None
            or self.FromCo1_FundPt is not None
            or self.FromCo2_FundPt is not None
            or self.ToCoord1_FundPt is not None
            or self.ToCoord2_FundPt is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.Polyconic",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("CoordSys.CoordsysTopic.Polyconic")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "CoordSys.CoordsysTopic.Polyconic":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="CoordSys.CoordsysTopic.Polyconic",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="CoordSys.CoordsysTopic.Polyconic",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="CoordSys.CoordsysTopic.Polyconic",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.Polyconic",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.From5 is not None:
            namespaceprefix_ = self.From5_nsprefix_ + ":" if (UseCapturedNS_ and self.From5_nsprefix_) else ""
            self.From5.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="From5",
                pretty_print=pretty_print,
            )
        if self.To5 is not None:
            namespaceprefix_ = self.To5_nsprefix_ + ":" if (UseCapturedNS_ and self.To5_nsprefix_) else ""
            self.To5.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="To5",
                pretty_print=pretty_print,
            )
        if self.FromCo1_FundPt is not None:
            namespaceprefix_ = (
                self.FromCo1_FundPt_nsprefix_ + ":"
                if (UseCapturedNS_ and self.FromCo1_FundPt_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sFromCo1_FundPt>%s</%sFromCo1_FundPt>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(quote_xml(self.FromCo1_FundPt), input_name="FromCo1_FundPt")
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.FromCo2_FundPt is not None:
            namespaceprefix_ = (
                self.FromCo2_FundPt_nsprefix_ + ":"
                if (UseCapturedNS_ and self.FromCo2_FundPt_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sFromCo2_FundPt>%s</%sFromCo2_FundPt>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(quote_xml(self.FromCo2_FundPt), input_name="FromCo2_FundPt")
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.ToCoord1_FundPt is not None:
            namespaceprefix_ = (
                self.ToCoord1_FundPt_nsprefix_ + ":"
                if (UseCapturedNS_ and self.ToCoord1_FundPt_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sToCoord1_FundPt>%s</%sToCoord1_FundPt>%s"
                % (
                    namespaceprefix_,
                    self.gds_format_integer(self.ToCoord1_FundPt, input_name="ToCoord1_FundPt"),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.ToCoord2_FundPt is not None:
            namespaceprefix_ = (
                self.ToCoord2_FundPt_nsprefix_ + ":"
                if (UseCapturedNS_ and self.ToCoord2_FundPt_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sToCoord2_FundPt>%s</%sToCoord2_FundPt>%s"
                % (
                    namespaceprefix_,
                    self.gds_format_integer(self.ToCoord2_FundPt, input_name="ToCoord2_FundPt"),
                    namespaceprefix_,
                    eol_,
                )
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "From5":
            obj_ = RoleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.From5 = obj_
            obj_.original_tagname_ = "From5"
        elif nodeName_ == "To5":
            obj_ = RoleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.To5 = obj_
            obj_.original_tagname_ = "To5"
        elif nodeName_ == "FromCo1_FundPt":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "FromCo1_FundPt")
            value_ = self.gds_validate_string(value_, node, "FromCo1_FundPt")
            self.FromCo1_FundPt = value_
            self.FromCo1_FundPt_nsprefix_ = child_.prefix
            # validate type CoordSys.Angle_DMS_90
            self.validate_CoordSys_Angle_DMS_90(self.FromCo1_FundPt)
        elif nodeName_ == "FromCo2_FundPt":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "FromCo2_FundPt")
            value_ = self.gds_validate_string(value_, node, "FromCo2_FundPt")
            self.FromCo2_FundPt = value_
            self.FromCo2_FundPt_nsprefix_ = child_.prefix
            # validate type CoordSys.Angle_DMS_90
            self.validate_CoordSys_Angle_DMS_90(self.FromCo2_FundPt)
        elif nodeName_ == "ToCoord1_FundPt" and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, "ToCoord1_FundPt")
            ival_ = self.gds_validate_integer(ival_, node, "ToCoord1_FundPt")
            self.ToCoord1_FundPt = ival_
            self.ToCoord1_FundPt_nsprefix_ = child_.prefix
            # validate type ToCoord1_FundPtType34
            self.validate_ToCoord1_FundPtType34(self.ToCoord1_FundPt)
        elif nodeName_ == "ToCoord2_FundPt" and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, "ToCoord2_FundPt")
            ival_ = self.gds_validate_integer(ival_, node, "ToCoord2_FundPt")
            self.ToCoord2_FundPt = ival_
            self.ToCoord2_FundPt_nsprefix_ = child_.prefix
            # validate type ToCoord2_FundPtType35
            self.validate_ToCoord2_FundPtType35(self.ToCoord2_FundPt)


# end class CoordSys_CoordsysTopic_Polyconic


class CoordSys_CoordsysTopic_Albus(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "From5": MemberSpec_("From5", "RoleType", 0, 0, {"name": "From5", "type": "RoleType"}, None),
        "To5": MemberSpec_("To5", "RoleType", 0, 0, {"name": "To5", "type": "RoleType"}, None),
        "FromCo1_FundPt": MemberSpec_(
            "FromCo1_FundPt",
            ["CoordSys.Angle_DMS_90", "xsd:normalizedString"],
            0,
            0,
            {"name": "FromCo1_FundPt", "type": "xsd:normalizedString"},
            None,
        ),
        "FromCo2_FundPt": MemberSpec_(
            "FromCo2_FundPt",
            ["CoordSys.Angle_DMS_90", "xsd:normalizedString"],
            0,
            0,
            {"name": "FromCo2_FundPt", "type": "xsd:normalizedString"},
            None,
        ),
        "ToCoord1_FundPt": MemberSpec_(
            "ToCoord1_FundPt",
            ["ToCoord1_FundPtType36", "xsd:integer"],
            0,
            0,
            {"name": "ToCoord1_FundPt", "type": "xsd:integer"},
            None,
        ),
        "ToCoord2_FundPt": MemberSpec_(
            "ToCoord2_FundPt",
            ["ToCoord2_FundPtType37", "xsd:integer"],
            0,
            0,
            {"name": "ToCoord2_FundPt", "type": "xsd:integer"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(
        self,
        From5=None,
        To5=None,
        FromCo1_FundPt=None,
        FromCo2_FundPt=None,
        ToCoord1_FundPt=None,
        ToCoord2_FundPt=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.From5 = From5
        self.From5_nsprefix_ = None
        self.To5 = To5
        self.To5_nsprefix_ = None
        self.FromCo1_FundPt = FromCo1_FundPt
        self.validate_CoordSys_Angle_DMS_90(self.FromCo1_FundPt)
        self.FromCo1_FundPt_nsprefix_ = None
        self.FromCo2_FundPt = FromCo2_FundPt
        self.validate_CoordSys_Angle_DMS_90(self.FromCo2_FundPt)
        self.FromCo2_FundPt_nsprefix_ = None
        self.ToCoord1_FundPt = ToCoord1_FundPt
        self.validate_ToCoord1_FundPtType36(self.ToCoord1_FundPt)
        self.ToCoord1_FundPt_nsprefix_ = None
        self.ToCoord2_FundPt = ToCoord2_FundPt
        self.validate_ToCoord2_FundPtType37(self.ToCoord2_FundPt)
        self.ToCoord2_FundPt_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, CoordSys_CoordsysTopic_Albus)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoordSys_CoordsysTopic_Albus.subclass:
            return CoordSys_CoordsysTopic_Albus.subclass(*args_, **kwargs_)
        else:
            return CoordSys_CoordsysTopic_Albus(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_From5(self):
        return self.From5

    def set_From5(self, From5):
        self.From5 = From5

    def get_To5(self):
        return self.To5

    def set_To5(self, To5):
        self.To5 = To5

    def get_FromCo1_FundPt(self):
        return self.FromCo1_FundPt

    def set_FromCo1_FundPt(self, FromCo1_FundPt):
        self.FromCo1_FundPt = FromCo1_FundPt

    def get_FromCo2_FundPt(self):
        return self.FromCo2_FundPt

    def set_FromCo2_FundPt(self, FromCo2_FundPt):
        self.FromCo2_FundPt = FromCo2_FundPt

    def get_ToCoord1_FundPt(self):
        return self.ToCoord1_FundPt

    def set_ToCoord1_FundPt(self, ToCoord1_FundPt):
        self.ToCoord1_FundPt = ToCoord1_FundPt

    def get_ToCoord2_FundPt(self):
        return self.ToCoord2_FundPt

    def set_ToCoord2_FundPt(self, ToCoord2_FundPt):
        self.ToCoord2_FundPt = ToCoord2_FundPt

    def validate_CoordSys_Angle_DMS_90(self, value):
        result = True
        # Validate type CoordSys.Angle_DMS_90, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            pass
        return result

    def validate_ToCoord1_FundPtType36(self, value):
        result = True
        # Validate type ToCoord1_FundPtType36, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if value < -10000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on ToCoord1_FundPtType36'
                    % {"value": value, "lineno": lineno}
                )
                result = False
            if value > 10000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on ToCoord1_FundPtType36'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_ToCoord2_FundPtType37(self, value):
        result = True
        # Validate type ToCoord2_FundPtType37, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if value < -10000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on ToCoord2_FundPtType37'
                    % {"value": value, "lineno": lineno}
                )
                result = False
            if value > 10000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on ToCoord2_FundPtType37'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def _hasContent(self):
        if (
            self.From5 is not None
            or self.To5 is not None
            or self.FromCo1_FundPt is not None
            or self.FromCo2_FundPt is not None
            or self.ToCoord1_FundPt is not None
            or self.ToCoord2_FundPt is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.Albus",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("CoordSys.CoordsysTopic.Albus")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "CoordSys.CoordsysTopic.Albus":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="CoordSys.CoordsysTopic.Albus",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="CoordSys.CoordsysTopic.Albus",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="CoordSys.CoordsysTopic.Albus",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.Albus",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.From5 is not None:
            namespaceprefix_ = self.From5_nsprefix_ + ":" if (UseCapturedNS_ and self.From5_nsprefix_) else ""
            self.From5.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="From5",
                pretty_print=pretty_print,
            )
        if self.To5 is not None:
            namespaceprefix_ = self.To5_nsprefix_ + ":" if (UseCapturedNS_ and self.To5_nsprefix_) else ""
            self.To5.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="To5",
                pretty_print=pretty_print,
            )
        if self.FromCo1_FundPt is not None:
            namespaceprefix_ = (
                self.FromCo1_FundPt_nsprefix_ + ":"
                if (UseCapturedNS_ and self.FromCo1_FundPt_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sFromCo1_FundPt>%s</%sFromCo1_FundPt>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(quote_xml(self.FromCo1_FundPt), input_name="FromCo1_FundPt")
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.FromCo2_FundPt is not None:
            namespaceprefix_ = (
                self.FromCo2_FundPt_nsprefix_ + ":"
                if (UseCapturedNS_ and self.FromCo2_FundPt_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sFromCo2_FundPt>%s</%sFromCo2_FundPt>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(quote_xml(self.FromCo2_FundPt), input_name="FromCo2_FundPt")
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.ToCoord1_FundPt is not None:
            namespaceprefix_ = (
                self.ToCoord1_FundPt_nsprefix_ + ":"
                if (UseCapturedNS_ and self.ToCoord1_FundPt_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sToCoord1_FundPt>%s</%sToCoord1_FundPt>%s"
                % (
                    namespaceprefix_,
                    self.gds_format_integer(self.ToCoord1_FundPt, input_name="ToCoord1_FundPt"),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.ToCoord2_FundPt is not None:
            namespaceprefix_ = (
                self.ToCoord2_FundPt_nsprefix_ + ":"
                if (UseCapturedNS_ and self.ToCoord2_FundPt_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sToCoord2_FundPt>%s</%sToCoord2_FundPt>%s"
                % (
                    namespaceprefix_,
                    self.gds_format_integer(self.ToCoord2_FundPt, input_name="ToCoord2_FundPt"),
                    namespaceprefix_,
                    eol_,
                )
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "From5":
            obj_ = RoleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.From5 = obj_
            obj_.original_tagname_ = "From5"
        elif nodeName_ == "To5":
            obj_ = RoleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.To5 = obj_
            obj_.original_tagname_ = "To5"
        elif nodeName_ == "FromCo1_FundPt":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "FromCo1_FundPt")
            value_ = self.gds_validate_string(value_, node, "FromCo1_FundPt")
            self.FromCo1_FundPt = value_
            self.FromCo1_FundPt_nsprefix_ = child_.prefix
            # validate type CoordSys.Angle_DMS_90
            self.validate_CoordSys_Angle_DMS_90(self.FromCo1_FundPt)
        elif nodeName_ == "FromCo2_FundPt":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "FromCo2_FundPt")
            value_ = self.gds_validate_string(value_, node, "FromCo2_FundPt")
            self.FromCo2_FundPt = value_
            self.FromCo2_FundPt_nsprefix_ = child_.prefix
            # validate type CoordSys.Angle_DMS_90
            self.validate_CoordSys_Angle_DMS_90(self.FromCo2_FundPt)
        elif nodeName_ == "ToCoord1_FundPt" and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, "ToCoord1_FundPt")
            ival_ = self.gds_validate_integer(ival_, node, "ToCoord1_FundPt")
            self.ToCoord1_FundPt = ival_
            self.ToCoord1_FundPt_nsprefix_ = child_.prefix
            # validate type ToCoord1_FundPtType36
            self.validate_ToCoord1_FundPtType36(self.ToCoord1_FundPt)
        elif nodeName_ == "ToCoord2_FundPt" and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, "ToCoord2_FundPt")
            ival_ = self.gds_validate_integer(ival_, node, "ToCoord2_FundPt")
            self.ToCoord2_FundPt = ival_
            self.ToCoord2_FundPt_nsprefix_ = child_.prefix
            # validate type ToCoord2_FundPtType37
            self.validate_ToCoord2_FundPtType37(self.ToCoord2_FundPt)


# end class CoordSys_CoordsysTopic_Albus


class CoordSys_CoordsysTopic_Azimutal(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "From5": MemberSpec_("From5", "RoleType", 0, 0, {"name": "From5", "type": "RoleType"}, None),
        "To5": MemberSpec_("To5", "RoleType", 0, 0, {"name": "To5", "type": "RoleType"}, None),
        "FromCo1_FundPt": MemberSpec_(
            "FromCo1_FundPt",
            ["CoordSys.Angle_DMS_90", "xsd:normalizedString"],
            0,
            0,
            {"name": "FromCo1_FundPt", "type": "xsd:normalizedString"},
            None,
        ),
        "FromCo2_FundPt": MemberSpec_(
            "FromCo2_FundPt",
            ["CoordSys.Angle_DMS_90", "xsd:normalizedString"],
            0,
            0,
            {"name": "FromCo2_FundPt", "type": "xsd:normalizedString"},
            None,
        ),
        "ToCoord1_FundPt": MemberSpec_(
            "ToCoord1_FundPt",
            ["ToCoord1_FundPtType38", "xsd:integer"],
            0,
            0,
            {"name": "ToCoord1_FundPt", "type": "xsd:integer"},
            None,
        ),
        "ToCoord2_FundPt": MemberSpec_(
            "ToCoord2_FundPt",
            ["ToCoord2_FundPtType39", "xsd:integer"],
            0,
            0,
            {"name": "ToCoord2_FundPt", "type": "xsd:integer"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(
        self,
        From5=None,
        To5=None,
        FromCo1_FundPt=None,
        FromCo2_FundPt=None,
        ToCoord1_FundPt=None,
        ToCoord2_FundPt=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.From5 = From5
        self.From5_nsprefix_ = None
        self.To5 = To5
        self.To5_nsprefix_ = None
        self.FromCo1_FundPt = FromCo1_FundPt
        self.validate_CoordSys_Angle_DMS_90(self.FromCo1_FundPt)
        self.FromCo1_FundPt_nsprefix_ = None
        self.FromCo2_FundPt = FromCo2_FundPt
        self.validate_CoordSys_Angle_DMS_90(self.FromCo2_FundPt)
        self.FromCo2_FundPt_nsprefix_ = None
        self.ToCoord1_FundPt = ToCoord1_FundPt
        self.validate_ToCoord1_FundPtType38(self.ToCoord1_FundPt)
        self.ToCoord1_FundPt_nsprefix_ = None
        self.ToCoord2_FundPt = ToCoord2_FundPt
        self.validate_ToCoord2_FundPtType39(self.ToCoord2_FundPt)
        self.ToCoord2_FundPt_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, CoordSys_CoordsysTopic_Azimutal)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoordSys_CoordsysTopic_Azimutal.subclass:
            return CoordSys_CoordsysTopic_Azimutal.subclass(*args_, **kwargs_)
        else:
            return CoordSys_CoordsysTopic_Azimutal(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_From5(self):
        return self.From5

    def set_From5(self, From5):
        self.From5 = From5

    def get_To5(self):
        return self.To5

    def set_To5(self, To5):
        self.To5 = To5

    def get_FromCo1_FundPt(self):
        return self.FromCo1_FundPt

    def set_FromCo1_FundPt(self, FromCo1_FundPt):
        self.FromCo1_FundPt = FromCo1_FundPt

    def get_FromCo2_FundPt(self):
        return self.FromCo2_FundPt

    def set_FromCo2_FundPt(self, FromCo2_FundPt):
        self.FromCo2_FundPt = FromCo2_FundPt

    def get_ToCoord1_FundPt(self):
        return self.ToCoord1_FundPt

    def set_ToCoord1_FundPt(self, ToCoord1_FundPt):
        self.ToCoord1_FundPt = ToCoord1_FundPt

    def get_ToCoord2_FundPt(self):
        return self.ToCoord2_FundPt

    def set_ToCoord2_FundPt(self, ToCoord2_FundPt):
        self.ToCoord2_FundPt = ToCoord2_FundPt

    def validate_CoordSys_Angle_DMS_90(self, value):
        result = True
        # Validate type CoordSys.Angle_DMS_90, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            pass
        return result

    def validate_ToCoord1_FundPtType38(self, value):
        result = True
        # Validate type ToCoord1_FundPtType38, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if value < -10000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on ToCoord1_FundPtType38'
                    % {"value": value, "lineno": lineno}
                )
                result = False
            if value > 10000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on ToCoord1_FundPtType38'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_ToCoord2_FundPtType39(self, value):
        result = True
        # Validate type ToCoord2_FundPtType39, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if value < -10000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on ToCoord2_FundPtType39'
                    % {"value": value, "lineno": lineno}
                )
                result = False
            if value > 10000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on ToCoord2_FundPtType39'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def _hasContent(self):
        if (
            self.From5 is not None
            or self.To5 is not None
            or self.FromCo1_FundPt is not None
            or self.FromCo2_FundPt is not None
            or self.ToCoord1_FundPt is not None
            or self.ToCoord2_FundPt is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.Azimutal",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("CoordSys.CoordsysTopic.Azimutal")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "CoordSys.CoordsysTopic.Azimutal":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="CoordSys.CoordsysTopic.Azimutal",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="CoordSys.CoordsysTopic.Azimutal",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="CoordSys.CoordsysTopic.Azimutal",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.Azimutal",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.From5 is not None:
            namespaceprefix_ = self.From5_nsprefix_ + ":" if (UseCapturedNS_ and self.From5_nsprefix_) else ""
            self.From5.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="From5",
                pretty_print=pretty_print,
            )
        if self.To5 is not None:
            namespaceprefix_ = self.To5_nsprefix_ + ":" if (UseCapturedNS_ and self.To5_nsprefix_) else ""
            self.To5.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="To5",
                pretty_print=pretty_print,
            )
        if self.FromCo1_FundPt is not None:
            namespaceprefix_ = (
                self.FromCo1_FundPt_nsprefix_ + ":"
                if (UseCapturedNS_ and self.FromCo1_FundPt_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sFromCo1_FundPt>%s</%sFromCo1_FundPt>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(quote_xml(self.FromCo1_FundPt), input_name="FromCo1_FundPt")
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.FromCo2_FundPt is not None:
            namespaceprefix_ = (
                self.FromCo2_FundPt_nsprefix_ + ":"
                if (UseCapturedNS_ and self.FromCo2_FundPt_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sFromCo2_FundPt>%s</%sFromCo2_FundPt>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(quote_xml(self.FromCo2_FundPt), input_name="FromCo2_FundPt")
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.ToCoord1_FundPt is not None:
            namespaceprefix_ = (
                self.ToCoord1_FundPt_nsprefix_ + ":"
                if (UseCapturedNS_ and self.ToCoord1_FundPt_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sToCoord1_FundPt>%s</%sToCoord1_FundPt>%s"
                % (
                    namespaceprefix_,
                    self.gds_format_integer(self.ToCoord1_FundPt, input_name="ToCoord1_FundPt"),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.ToCoord2_FundPt is not None:
            namespaceprefix_ = (
                self.ToCoord2_FundPt_nsprefix_ + ":"
                if (UseCapturedNS_ and self.ToCoord2_FundPt_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sToCoord2_FundPt>%s</%sToCoord2_FundPt>%s"
                % (
                    namespaceprefix_,
                    self.gds_format_integer(self.ToCoord2_FundPt, input_name="ToCoord2_FundPt"),
                    namespaceprefix_,
                    eol_,
                )
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "From5":
            obj_ = RoleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.From5 = obj_
            obj_.original_tagname_ = "From5"
        elif nodeName_ == "To5":
            obj_ = RoleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.To5 = obj_
            obj_.original_tagname_ = "To5"
        elif nodeName_ == "FromCo1_FundPt":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "FromCo1_FundPt")
            value_ = self.gds_validate_string(value_, node, "FromCo1_FundPt")
            self.FromCo1_FundPt = value_
            self.FromCo1_FundPt_nsprefix_ = child_.prefix
            # validate type CoordSys.Angle_DMS_90
            self.validate_CoordSys_Angle_DMS_90(self.FromCo1_FundPt)
        elif nodeName_ == "FromCo2_FundPt":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "FromCo2_FundPt")
            value_ = self.gds_validate_string(value_, node, "FromCo2_FundPt")
            self.FromCo2_FundPt = value_
            self.FromCo2_FundPt_nsprefix_ = child_.prefix
            # validate type CoordSys.Angle_DMS_90
            self.validate_CoordSys_Angle_DMS_90(self.FromCo2_FundPt)
        elif nodeName_ == "ToCoord1_FundPt" and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, "ToCoord1_FundPt")
            ival_ = self.gds_validate_integer(ival_, node, "ToCoord1_FundPt")
            self.ToCoord1_FundPt = ival_
            self.ToCoord1_FundPt_nsprefix_ = child_.prefix
            # validate type ToCoord1_FundPtType38
            self.validate_ToCoord1_FundPtType38(self.ToCoord1_FundPt)
        elif nodeName_ == "ToCoord2_FundPt" and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, "ToCoord2_FundPt")
            ival_ = self.gds_validate_integer(ival_, node, "ToCoord2_FundPt")
            self.ToCoord2_FundPt = ival_
            self.ToCoord2_FundPt_nsprefix_ = child_.prefix
            # validate type ToCoord2_FundPtType39
            self.validate_ToCoord2_FundPtType39(self.ToCoord2_FundPt)


# end class CoordSys_CoordsysTopic_Azimutal


class CoordSys_CoordsysTopic_Stereographic(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "From5": MemberSpec_("From5", "RoleType", 0, 0, {"name": "From5", "type": "RoleType"}, None),
        "To5": MemberSpec_("To5", "RoleType", 0, 0, {"name": "To5", "type": "RoleType"}, None),
        "FromCo1_FundPt": MemberSpec_(
            "FromCo1_FundPt",
            ["CoordSys.Angle_DMS_90", "xsd:normalizedString"],
            0,
            0,
            {"name": "FromCo1_FundPt", "type": "xsd:normalizedString"},
            None,
        ),
        "FromCo2_FundPt": MemberSpec_(
            "FromCo2_FundPt",
            ["CoordSys.Angle_DMS_90", "xsd:normalizedString"],
            0,
            0,
            {"name": "FromCo2_FundPt", "type": "xsd:normalizedString"},
            None,
        ),
        "ToCoord1_FundPt": MemberSpec_(
            "ToCoord1_FundPt",
            ["ToCoord1_FundPtType40", "xsd:integer"],
            0,
            0,
            {"name": "ToCoord1_FundPt", "type": "xsd:integer"},
            None,
        ),
        "ToCoord2_FundPt": MemberSpec_(
            "ToCoord2_FundPt",
            ["ToCoord2_FundPtType41", "xsd:integer"],
            0,
            0,
            {"name": "ToCoord2_FundPt", "type": "xsd:integer"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(
        self,
        From5=None,
        To5=None,
        FromCo1_FundPt=None,
        FromCo2_FundPt=None,
        ToCoord1_FundPt=None,
        ToCoord2_FundPt=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.From5 = From5
        self.From5_nsprefix_ = None
        self.To5 = To5
        self.To5_nsprefix_ = None
        self.FromCo1_FundPt = FromCo1_FundPt
        self.validate_CoordSys_Angle_DMS_90(self.FromCo1_FundPt)
        self.FromCo1_FundPt_nsprefix_ = None
        self.FromCo2_FundPt = FromCo2_FundPt
        self.validate_CoordSys_Angle_DMS_90(self.FromCo2_FundPt)
        self.FromCo2_FundPt_nsprefix_ = None
        self.ToCoord1_FundPt = ToCoord1_FundPt
        self.validate_ToCoord1_FundPtType40(self.ToCoord1_FundPt)
        self.ToCoord1_FundPt_nsprefix_ = None
        self.ToCoord2_FundPt = ToCoord2_FundPt
        self.validate_ToCoord2_FundPtType41(self.ToCoord2_FundPt)
        self.ToCoord2_FundPt_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, CoordSys_CoordsysTopic_Stereographic)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoordSys_CoordsysTopic_Stereographic.subclass:
            return CoordSys_CoordsysTopic_Stereographic.subclass(*args_, **kwargs_)
        else:
            return CoordSys_CoordsysTopic_Stereographic(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_From5(self):
        return self.From5

    def set_From5(self, From5):
        self.From5 = From5

    def get_To5(self):
        return self.To5

    def set_To5(self, To5):
        self.To5 = To5

    def get_FromCo1_FundPt(self):
        return self.FromCo1_FundPt

    def set_FromCo1_FundPt(self, FromCo1_FundPt):
        self.FromCo1_FundPt = FromCo1_FundPt

    def get_FromCo2_FundPt(self):
        return self.FromCo2_FundPt

    def set_FromCo2_FundPt(self, FromCo2_FundPt):
        self.FromCo2_FundPt = FromCo2_FundPt

    def get_ToCoord1_FundPt(self):
        return self.ToCoord1_FundPt

    def set_ToCoord1_FundPt(self, ToCoord1_FundPt):
        self.ToCoord1_FundPt = ToCoord1_FundPt

    def get_ToCoord2_FundPt(self):
        return self.ToCoord2_FundPt

    def set_ToCoord2_FundPt(self, ToCoord2_FundPt):
        self.ToCoord2_FundPt = ToCoord2_FundPt

    def validate_CoordSys_Angle_DMS_90(self, value):
        result = True
        # Validate type CoordSys.Angle_DMS_90, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            pass
        return result

    def validate_ToCoord1_FundPtType40(self, value):
        result = True
        # Validate type ToCoord1_FundPtType40, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if value < -10000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on ToCoord1_FundPtType40'
                    % {"value": value, "lineno": lineno}
                )
                result = False
            if value > 10000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on ToCoord1_FundPtType40'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_ToCoord2_FundPtType41(self, value):
        result = True
        # Validate type ToCoord2_FundPtType41, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if value < -10000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on ToCoord2_FundPtType41'
                    % {"value": value, "lineno": lineno}
                )
                result = False
            if value > 10000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on ToCoord2_FundPtType41'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def _hasContent(self):
        if (
            self.From5 is not None
            or self.To5 is not None
            or self.FromCo1_FundPt is not None
            or self.FromCo2_FundPt is not None
            or self.ToCoord1_FundPt is not None
            or self.ToCoord2_FundPt is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.Stereographic",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("CoordSys.CoordsysTopic.Stereographic")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "CoordSys.CoordsysTopic.Stereographic":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="CoordSys.CoordsysTopic.Stereographic",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="CoordSys.CoordsysTopic.Stereographic",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="CoordSys.CoordsysTopic.Stereographic",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.Stereographic",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.From5 is not None:
            namespaceprefix_ = self.From5_nsprefix_ + ":" if (UseCapturedNS_ and self.From5_nsprefix_) else ""
            self.From5.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="From5",
                pretty_print=pretty_print,
            )
        if self.To5 is not None:
            namespaceprefix_ = self.To5_nsprefix_ + ":" if (UseCapturedNS_ and self.To5_nsprefix_) else ""
            self.To5.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="To5",
                pretty_print=pretty_print,
            )
        if self.FromCo1_FundPt is not None:
            namespaceprefix_ = (
                self.FromCo1_FundPt_nsprefix_ + ":"
                if (UseCapturedNS_ and self.FromCo1_FundPt_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sFromCo1_FundPt>%s</%sFromCo1_FundPt>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(quote_xml(self.FromCo1_FundPt), input_name="FromCo1_FundPt")
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.FromCo2_FundPt is not None:
            namespaceprefix_ = (
                self.FromCo2_FundPt_nsprefix_ + ":"
                if (UseCapturedNS_ and self.FromCo2_FundPt_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sFromCo2_FundPt>%s</%sFromCo2_FundPt>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(quote_xml(self.FromCo2_FundPt), input_name="FromCo2_FundPt")
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.ToCoord1_FundPt is not None:
            namespaceprefix_ = (
                self.ToCoord1_FundPt_nsprefix_ + ":"
                if (UseCapturedNS_ and self.ToCoord1_FundPt_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sToCoord1_FundPt>%s</%sToCoord1_FundPt>%s"
                % (
                    namespaceprefix_,
                    self.gds_format_integer(self.ToCoord1_FundPt, input_name="ToCoord1_FundPt"),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.ToCoord2_FundPt is not None:
            namespaceprefix_ = (
                self.ToCoord2_FundPt_nsprefix_ + ":"
                if (UseCapturedNS_ and self.ToCoord2_FundPt_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sToCoord2_FundPt>%s</%sToCoord2_FundPt>%s"
                % (
                    namespaceprefix_,
                    self.gds_format_integer(self.ToCoord2_FundPt, input_name="ToCoord2_FundPt"),
                    namespaceprefix_,
                    eol_,
                )
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "From5":
            obj_ = RoleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.From5 = obj_
            obj_.original_tagname_ = "From5"
        elif nodeName_ == "To5":
            obj_ = RoleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.To5 = obj_
            obj_.original_tagname_ = "To5"
        elif nodeName_ == "FromCo1_FundPt":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "FromCo1_FundPt")
            value_ = self.gds_validate_string(value_, node, "FromCo1_FundPt")
            self.FromCo1_FundPt = value_
            self.FromCo1_FundPt_nsprefix_ = child_.prefix
            # validate type CoordSys.Angle_DMS_90
            self.validate_CoordSys_Angle_DMS_90(self.FromCo1_FundPt)
        elif nodeName_ == "FromCo2_FundPt":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "FromCo2_FundPt")
            value_ = self.gds_validate_string(value_, node, "FromCo2_FundPt")
            self.FromCo2_FundPt = value_
            self.FromCo2_FundPt_nsprefix_ = child_.prefix
            # validate type CoordSys.Angle_DMS_90
            self.validate_CoordSys_Angle_DMS_90(self.FromCo2_FundPt)
        elif nodeName_ == "ToCoord1_FundPt" and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, "ToCoord1_FundPt")
            ival_ = self.gds_validate_integer(ival_, node, "ToCoord1_FundPt")
            self.ToCoord1_FundPt = ival_
            self.ToCoord1_FundPt_nsprefix_ = child_.prefix
            # validate type ToCoord1_FundPtType40
            self.validate_ToCoord1_FundPtType40(self.ToCoord1_FundPt)
        elif nodeName_ == "ToCoord2_FundPt" and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, "ToCoord2_FundPt")
            ival_ = self.gds_validate_integer(ival_, node, "ToCoord2_FundPt")
            self.ToCoord2_FundPt = ival_
            self.ToCoord2_FundPt_nsprefix_ = child_.prefix
            # validate type ToCoord2_FundPtType41
            self.validate_ToCoord2_FundPtType41(self.ToCoord2_FundPt)


# end class CoordSys_CoordsysTopic_Stereographic


class CoordSys_CoordsysTopic_HeightConversion(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "FromHeight": MemberSpec_(
            "FromHeight",
            "RoleType",
            0,
            0,
            {"name": "FromHeight", "type": "RoleType"},
            None,
        ),
        "ToHeight": MemberSpec_("ToHeight", "RoleType", 0, 0, {"name": "ToHeight", "type": "RoleType"}, None),
        "Definition": MemberSpec_(
            "Definition",
            ["DefinitionType42", "xsd:normalizedString"],
            0,
            1,
            {"minOccurs": "0", "name": "Definition", "type": "xsd:normalizedString"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, FromHeight=None, ToHeight=None, Definition=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.FromHeight = FromHeight
        self.FromHeight_nsprefix_ = None
        self.ToHeight = ToHeight
        self.ToHeight_nsprefix_ = None
        self.Definition = Definition
        self.validate_DefinitionType42(self.Definition)
        self.Definition_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, CoordSys_CoordsysTopic_HeightConversion)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoordSys_CoordsysTopic_HeightConversion.subclass:
            return CoordSys_CoordsysTopic_HeightConversion.subclass(*args_, **kwargs_)
        else:
            return CoordSys_CoordsysTopic_HeightConversion(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_FromHeight(self):
        return self.FromHeight

    def set_FromHeight(self, FromHeight):
        self.FromHeight = FromHeight

    def get_ToHeight(self):
        return self.ToHeight

    def set_ToHeight(self, ToHeight):
        self.ToHeight = ToHeight

    def get_Definition(self):
        return self.Definition

    def set_Definition(self, Definition):
        self.Definition = Definition

    def validate_DefinitionType42(self, value):
        result = True
        # Validate type DefinitionType42, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if len(value) > 70:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on DefinitionType42'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def _hasContent(self):
        if self.FromHeight is not None or self.ToHeight is not None or self.Definition is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.HeightConversion",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("CoordSys.CoordsysTopic.HeightConversion")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "CoordSys.CoordsysTopic.HeightConversion":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="CoordSys.CoordsysTopic.HeightConversion",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="CoordSys.CoordsysTopic.HeightConversion",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="CoordSys.CoordsysTopic.HeightConversion",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic.HeightConversion",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.FromHeight is not None:
            namespaceprefix_ = (
                self.FromHeight_nsprefix_ + ":" if (UseCapturedNS_ and self.FromHeight_nsprefix_) else ""
            )
            self.FromHeight.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="FromHeight",
                pretty_print=pretty_print,
            )
        if self.ToHeight is not None:
            namespaceprefix_ = (
                self.ToHeight_nsprefix_ + ":" if (UseCapturedNS_ and self.ToHeight_nsprefix_) else ""
            )
            self.ToHeight.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="ToHeight",
                pretty_print=pretty_print,
            )
        if self.Definition is not None:
            namespaceprefix_ = (
                self.Definition_nsprefix_ + ":" if (UseCapturedNS_ and self.Definition_nsprefix_) else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sDefinition>%s</%sDefinition>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(quote_xml(self.Definition), input_name="Definition")
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "FromHeight":
            obj_ = RoleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FromHeight = obj_
            obj_.original_tagname_ = "FromHeight"
        elif nodeName_ == "ToHeight":
            obj_ = RoleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ToHeight = obj_
            obj_.original_tagname_ = "ToHeight"
        elif nodeName_ == "Definition":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Definition")
            value_ = self.gds_validate_string(value_, node, "Definition")
            self.Definition = value_
            self.Definition_nsprefix_ = child_.prefix
            # validate type DefinitionType42
            self.validate_DefinitionType42(self.Definition)


# end class CoordSys_CoordsysTopic_HeightConversion


class CoordSys_CoordsysTopic(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "BID": MemberSpec_("BID", "IliID", 0, 0, {"use": "required", "name": "BID"}),
        "CoordSys_CoordsysTopic_Ellipsoid": MemberSpec_(
            "CoordSys_CoordsysTopic_Ellipsoid",
            "CoordSys.CoordsysTopic.Ellipsoid",
            1,
            1,
            {
                "name": "CoordSys.CoordsysTopic.Ellipsoid",
                "type": "CoordSys.CoordsysTopic.Ellipsoid",
            },
            11,
        ),
        "CoordSys_CoordsysTopic_GravityModel": MemberSpec_(
            "CoordSys_CoordsysTopic_GravityModel",
            "CoordSys.CoordsysTopic.GravityModel",
            1,
            1,
            {
                "name": "CoordSys.CoordsysTopic.GravityModel",
                "type": "CoordSys.CoordsysTopic.GravityModel",
            },
            11,
        ),
        "CoordSys_CoordsysTopic_GeoidModel": MemberSpec_(
            "CoordSys_CoordsysTopic_GeoidModel",
            "CoordSys.CoordsysTopic.GeoidModel",
            1,
            1,
            {
                "name": "CoordSys.CoordsysTopic.GeoidModel",
                "type": "CoordSys.CoordsysTopic.GeoidModel",
            },
            11,
        ),
        "CoordSys_CoordsysTopic_GeoCartesian1D": MemberSpec_(
            "CoordSys_CoordsysTopic_GeoCartesian1D",
            "CoordSys.CoordsysTopic.GeoCartesian1D",
            1,
            1,
            {
                "name": "CoordSys.CoordsysTopic.GeoCartesian1D",
                "type": "CoordSys.CoordsysTopic.GeoCartesian1D",
            },
            11,
        ),
        "CoordSys_CoordsysTopic_GeoHeight": MemberSpec_(
            "CoordSys_CoordsysTopic_GeoHeight",
            "CoordSys.CoordsysTopic.GeoHeight",
            1,
            1,
            {
                "name": "CoordSys.CoordsysTopic.GeoHeight",
                "type": "CoordSys.CoordsysTopic.GeoHeight",
            },
            11,
        ),
        "CoordSys_CoordsysTopic_GeoCartesian2D": MemberSpec_(
            "CoordSys_CoordsysTopic_GeoCartesian2D",
            "CoordSys.CoordsysTopic.GeoCartesian2D",
            1,
            1,
            {
                "name": "CoordSys.CoordsysTopic.GeoCartesian2D",
                "type": "CoordSys.CoordsysTopic.GeoCartesian2D",
            },
            11,
        ),
        "CoordSys_CoordsysTopic_GeoCartesian3D": MemberSpec_(
            "CoordSys_CoordsysTopic_GeoCartesian3D",
            "CoordSys.CoordsysTopic.GeoCartesian3D",
            1,
            1,
            {
                "name": "CoordSys.CoordsysTopic.GeoCartesian3D",
                "type": "CoordSys.CoordsysTopic.GeoCartesian3D",
            },
            11,
        ),
        "CoordSys_CoordsysTopic_GeoEllipsoidal": MemberSpec_(
            "CoordSys_CoordsysTopic_GeoEllipsoidal",
            "CoordSys.CoordsysTopic.GeoEllipsoidal",
            1,
            1,
            {
                "name": "CoordSys.CoordsysTopic.GeoEllipsoidal",
                "type": "CoordSys.CoordsysTopic.GeoEllipsoidal",
            },
            11,
        ),
        "CoordSys_CoordsysTopic_ToGeoEllipsoidal": MemberSpec_(
            "CoordSys_CoordsysTopic_ToGeoEllipsoidal",
            "CoordSys.CoordsysTopic.ToGeoEllipsoidal",
            1,
            1,
            {
                "name": "CoordSys.CoordsysTopic.ToGeoEllipsoidal",
                "type": "CoordSys.CoordsysTopic.ToGeoEllipsoidal",
            },
            11,
        ),
        "CoordSys_CoordsysTopic_ToGeoCartesian3D": MemberSpec_(
            "CoordSys_CoordsysTopic_ToGeoCartesian3D",
            "CoordSys.CoordsysTopic.ToGeoCartesian3D",
            1,
            1,
            {
                "name": "CoordSys.CoordsysTopic.ToGeoCartesian3D",
                "type": "CoordSys.CoordsysTopic.ToGeoCartesian3D",
            },
            11,
        ),
        "CoordSys_CoordsysTopic_BidirectGeoCartesian2D": MemberSpec_(
            "CoordSys_CoordsysTopic_BidirectGeoCartesian2D",
            "CoordSys.CoordsysTopic.BidirectGeoCartesian2D",
            1,
            1,
            {
                "name": "CoordSys.CoordsysTopic.BidirectGeoCartesian2D",
                "type": "CoordSys.CoordsysTopic.BidirectGeoCartesian2D",
            },
            11,
        ),
        "CoordSys_CoordsysTopic_BidirectGeoCartesian3D": MemberSpec_(
            "CoordSys_CoordsysTopic_BidirectGeoCartesian3D",
            "CoordSys.CoordsysTopic.BidirectGeoCartesian3D",
            1,
            1,
            {
                "name": "CoordSys.CoordsysTopic.BidirectGeoCartesian3D",
                "type": "CoordSys.CoordsysTopic.BidirectGeoCartesian3D",
            },
            11,
        ),
        "CoordSys_CoordsysTopic_BidirectGeoEllipsoidal": MemberSpec_(
            "CoordSys_CoordsysTopic_BidirectGeoEllipsoidal",
            "CoordSys.CoordsysTopic.BidirectGeoEllipsoidal",
            1,
            1,
            {
                "name": "CoordSys.CoordsysTopic.BidirectGeoEllipsoidal",
                "type": "CoordSys.CoordsysTopic.BidirectGeoEllipsoidal",
            },
            11,
        ),
        "CoordSys_CoordsysTopic_TransverseMercator": MemberSpec_(
            "CoordSys_CoordsysTopic_TransverseMercator",
            "CoordSys.CoordsysTopic.TransverseMercator",
            1,
            1,
            {
                "name": "CoordSys.CoordsysTopic.TransverseMercator",
                "type": "CoordSys.CoordsysTopic.TransverseMercator",
            },
            11,
        ),
        "CoordSys_CoordsysTopic_SwissProjection": MemberSpec_(
            "CoordSys_CoordsysTopic_SwissProjection",
            "CoordSys.CoordsysTopic.SwissProjection",
            1,
            1,
            {
                "name": "CoordSys.CoordsysTopic.SwissProjection",
                "type": "CoordSys.CoordsysTopic.SwissProjection",
            },
            11,
        ),
        "CoordSys_CoordsysTopic_Mercator": MemberSpec_(
            "CoordSys_CoordsysTopic_Mercator",
            "CoordSys.CoordsysTopic.Mercator",
            1,
            1,
            {
                "name": "CoordSys.CoordsysTopic.Mercator",
                "type": "CoordSys.CoordsysTopic.Mercator",
            },
            11,
        ),
        "CoordSys_CoordsysTopic_ObliqueMercator": MemberSpec_(
            "CoordSys_CoordsysTopic_ObliqueMercator",
            "CoordSys.CoordsysTopic.ObliqueMercator",
            1,
            1,
            {
                "name": "CoordSys.CoordsysTopic.ObliqueMercator",
                "type": "CoordSys.CoordsysTopic.ObliqueMercator",
            },
            11,
        ),
        "CoordSys_CoordsysTopic_Lambert": MemberSpec_(
            "CoordSys_CoordsysTopic_Lambert",
            "CoordSys.CoordsysTopic.Lambert",
            1,
            1,
            {
                "name": "CoordSys.CoordsysTopic.Lambert",
                "type": "CoordSys.CoordsysTopic.Lambert",
            },
            11,
        ),
        "CoordSys_CoordsysTopic_Polyconic": MemberSpec_(
            "CoordSys_CoordsysTopic_Polyconic",
            "CoordSys.CoordsysTopic.Polyconic",
            1,
            1,
            {
                "name": "CoordSys.CoordsysTopic.Polyconic",
                "type": "CoordSys.CoordsysTopic.Polyconic",
            },
            11,
        ),
        "CoordSys_CoordsysTopic_Albus": MemberSpec_(
            "CoordSys_CoordsysTopic_Albus",
            "CoordSys.CoordsysTopic.Albus",
            1,
            1,
            {
                "name": "CoordSys.CoordsysTopic.Albus",
                "type": "CoordSys.CoordsysTopic.Albus",
            },
            11,
        ),
        "CoordSys_CoordsysTopic_Azimutal": MemberSpec_(
            "CoordSys_CoordsysTopic_Azimutal",
            "CoordSys.CoordsysTopic.Azimutal",
            1,
            1,
            {
                "name": "CoordSys.CoordsysTopic.Azimutal",
                "type": "CoordSys.CoordsysTopic.Azimutal",
            },
            11,
        ),
        "CoordSys_CoordsysTopic_Stereographic": MemberSpec_(
            "CoordSys_CoordsysTopic_Stereographic",
            "CoordSys.CoordsysTopic.Stereographic",
            1,
            1,
            {
                "name": "CoordSys.CoordsysTopic.Stereographic",
                "type": "CoordSys.CoordsysTopic.Stereographic",
            },
            11,
        ),
        "CoordSys_CoordsysTopic_HeightConversion": MemberSpec_(
            "CoordSys_CoordsysTopic_HeightConversion",
            "CoordSys.CoordsysTopic.HeightConversion",
            1,
            1,
            {
                "name": "CoordSys.CoordsysTopic.HeightConversion",
                "type": "CoordSys.CoordsysTopic.HeightConversion",
            },
            11,
        ),
    }
    subclass = None
    superclass = None

    def __init__(
        self,
        BID=None,
        CoordSys_CoordsysTopic_Ellipsoid=None,
        CoordSys_CoordsysTopic_GravityModel=None,
        CoordSys_CoordsysTopic_GeoidModel=None,
        CoordSys_CoordsysTopic_GeoCartesian1D=None,
        CoordSys_CoordsysTopic_GeoHeight=None,
        CoordSys_CoordsysTopic_GeoCartesian2D=None,
        CoordSys_CoordsysTopic_GeoCartesian3D=None,
        CoordSys_CoordsysTopic_GeoEllipsoidal=None,
        CoordSys_CoordsysTopic_ToGeoEllipsoidal=None,
        CoordSys_CoordsysTopic_ToGeoCartesian3D=None,
        CoordSys_CoordsysTopic_BidirectGeoCartesian2D=None,
        CoordSys_CoordsysTopic_BidirectGeoCartesian3D=None,
        CoordSys_CoordsysTopic_BidirectGeoEllipsoidal=None,
        CoordSys_CoordsysTopic_TransverseMercator=None,
        CoordSys_CoordsysTopic_SwissProjection=None,
        CoordSys_CoordsysTopic_Mercator=None,
        CoordSys_CoordsysTopic_ObliqueMercator=None,
        CoordSys_CoordsysTopic_Lambert=None,
        CoordSys_CoordsysTopic_Polyconic=None,
        CoordSys_CoordsysTopic_Albus=None,
        CoordSys_CoordsysTopic_Azimutal=None,
        CoordSys_CoordsysTopic_Stereographic=None,
        CoordSys_CoordsysTopic_HeightConversion=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.BID = _cast(None, BID)
        self.BID_nsprefix_ = None
        if CoordSys_CoordsysTopic_Ellipsoid is None:
            self.CoordSys_CoordsysTopic_Ellipsoid = []
        else:
            self.CoordSys_CoordsysTopic_Ellipsoid = CoordSys_CoordsysTopic_Ellipsoid
        self.CoordSys_CoordsysTopic_Ellipsoid_nsprefix_ = None
        if CoordSys_CoordsysTopic_GravityModel is None:
            self.CoordSys_CoordsysTopic_GravityModel = []
        else:
            self.CoordSys_CoordsysTopic_GravityModel = CoordSys_CoordsysTopic_GravityModel
        self.CoordSys_CoordsysTopic_GravityModel_nsprefix_ = None
        if CoordSys_CoordsysTopic_GeoidModel is None:
            self.CoordSys_CoordsysTopic_GeoidModel = []
        else:
            self.CoordSys_CoordsysTopic_GeoidModel = CoordSys_CoordsysTopic_GeoidModel
        self.CoordSys_CoordsysTopic_GeoidModel_nsprefix_ = None
        if CoordSys_CoordsysTopic_GeoCartesian1D is None:
            self.CoordSys_CoordsysTopic_GeoCartesian1D = []
        else:
            self.CoordSys_CoordsysTopic_GeoCartesian1D = CoordSys_CoordsysTopic_GeoCartesian1D
        self.CoordSys_CoordsysTopic_GeoCartesian1D_nsprefix_ = None
        if CoordSys_CoordsysTopic_GeoHeight is None:
            self.CoordSys_CoordsysTopic_GeoHeight = []
        else:
            self.CoordSys_CoordsysTopic_GeoHeight = CoordSys_CoordsysTopic_GeoHeight
        self.CoordSys_CoordsysTopic_GeoHeight_nsprefix_ = None
        if CoordSys_CoordsysTopic_GeoCartesian2D is None:
            self.CoordSys_CoordsysTopic_GeoCartesian2D = []
        else:
            self.CoordSys_CoordsysTopic_GeoCartesian2D = CoordSys_CoordsysTopic_GeoCartesian2D
        self.CoordSys_CoordsysTopic_GeoCartesian2D_nsprefix_ = None
        if CoordSys_CoordsysTopic_GeoCartesian3D is None:
            self.CoordSys_CoordsysTopic_GeoCartesian3D = []
        else:
            self.CoordSys_CoordsysTopic_GeoCartesian3D = CoordSys_CoordsysTopic_GeoCartesian3D
        self.CoordSys_CoordsysTopic_GeoCartesian3D_nsprefix_ = None
        if CoordSys_CoordsysTopic_GeoEllipsoidal is None:
            self.CoordSys_CoordsysTopic_GeoEllipsoidal = []
        else:
            self.CoordSys_CoordsysTopic_GeoEllipsoidal = CoordSys_CoordsysTopic_GeoEllipsoidal
        self.CoordSys_CoordsysTopic_GeoEllipsoidal_nsprefix_ = None
        if CoordSys_CoordsysTopic_ToGeoEllipsoidal is None:
            self.CoordSys_CoordsysTopic_ToGeoEllipsoidal = []
        else:
            self.CoordSys_CoordsysTopic_ToGeoEllipsoidal = CoordSys_CoordsysTopic_ToGeoEllipsoidal
        self.CoordSys_CoordsysTopic_ToGeoEllipsoidal_nsprefix_ = None
        if CoordSys_CoordsysTopic_ToGeoCartesian3D is None:
            self.CoordSys_CoordsysTopic_ToGeoCartesian3D = []
        else:
            self.CoordSys_CoordsysTopic_ToGeoCartesian3D = CoordSys_CoordsysTopic_ToGeoCartesian3D
        self.CoordSys_CoordsysTopic_ToGeoCartesian3D_nsprefix_ = None
        if CoordSys_CoordsysTopic_BidirectGeoCartesian2D is None:
            self.CoordSys_CoordsysTopic_BidirectGeoCartesian2D = []
        else:
            self.CoordSys_CoordsysTopic_BidirectGeoCartesian2D = CoordSys_CoordsysTopic_BidirectGeoCartesian2D
        self.CoordSys_CoordsysTopic_BidirectGeoCartesian2D_nsprefix_ = None
        if CoordSys_CoordsysTopic_BidirectGeoCartesian3D is None:
            self.CoordSys_CoordsysTopic_BidirectGeoCartesian3D = []
        else:
            self.CoordSys_CoordsysTopic_BidirectGeoCartesian3D = CoordSys_CoordsysTopic_BidirectGeoCartesian3D
        self.CoordSys_CoordsysTopic_BidirectGeoCartesian3D_nsprefix_ = None
        if CoordSys_CoordsysTopic_BidirectGeoEllipsoidal is None:
            self.CoordSys_CoordsysTopic_BidirectGeoEllipsoidal = []
        else:
            self.CoordSys_CoordsysTopic_BidirectGeoEllipsoidal = CoordSys_CoordsysTopic_BidirectGeoEllipsoidal
        self.CoordSys_CoordsysTopic_BidirectGeoEllipsoidal_nsprefix_ = None
        if CoordSys_CoordsysTopic_TransverseMercator is None:
            self.CoordSys_CoordsysTopic_TransverseMercator = []
        else:
            self.CoordSys_CoordsysTopic_TransverseMercator = CoordSys_CoordsysTopic_TransverseMercator
        self.CoordSys_CoordsysTopic_TransverseMercator_nsprefix_ = None
        if CoordSys_CoordsysTopic_SwissProjection is None:
            self.CoordSys_CoordsysTopic_SwissProjection = []
        else:
            self.CoordSys_CoordsysTopic_SwissProjection = CoordSys_CoordsysTopic_SwissProjection
        self.CoordSys_CoordsysTopic_SwissProjection_nsprefix_ = None
        if CoordSys_CoordsysTopic_Mercator is None:
            self.CoordSys_CoordsysTopic_Mercator = []
        else:
            self.CoordSys_CoordsysTopic_Mercator = CoordSys_CoordsysTopic_Mercator
        self.CoordSys_CoordsysTopic_Mercator_nsprefix_ = None
        if CoordSys_CoordsysTopic_ObliqueMercator is None:
            self.CoordSys_CoordsysTopic_ObliqueMercator = []
        else:
            self.CoordSys_CoordsysTopic_ObliqueMercator = CoordSys_CoordsysTopic_ObliqueMercator
        self.CoordSys_CoordsysTopic_ObliqueMercator_nsprefix_ = None
        if CoordSys_CoordsysTopic_Lambert is None:
            self.CoordSys_CoordsysTopic_Lambert = []
        else:
            self.CoordSys_CoordsysTopic_Lambert = CoordSys_CoordsysTopic_Lambert
        self.CoordSys_CoordsysTopic_Lambert_nsprefix_ = None
        if CoordSys_CoordsysTopic_Polyconic is None:
            self.CoordSys_CoordsysTopic_Polyconic = []
        else:
            self.CoordSys_CoordsysTopic_Polyconic = CoordSys_CoordsysTopic_Polyconic
        self.CoordSys_CoordsysTopic_Polyconic_nsprefix_ = None
        if CoordSys_CoordsysTopic_Albus is None:
            self.CoordSys_CoordsysTopic_Albus = []
        else:
            self.CoordSys_CoordsysTopic_Albus = CoordSys_CoordsysTopic_Albus
        self.CoordSys_CoordsysTopic_Albus_nsprefix_ = None
        if CoordSys_CoordsysTopic_Azimutal is None:
            self.CoordSys_CoordsysTopic_Azimutal = []
        else:
            self.CoordSys_CoordsysTopic_Azimutal = CoordSys_CoordsysTopic_Azimutal
        self.CoordSys_CoordsysTopic_Azimutal_nsprefix_ = None
        if CoordSys_CoordsysTopic_Stereographic is None:
            self.CoordSys_CoordsysTopic_Stereographic = []
        else:
            self.CoordSys_CoordsysTopic_Stereographic = CoordSys_CoordsysTopic_Stereographic
        self.CoordSys_CoordsysTopic_Stereographic_nsprefix_ = None
        if CoordSys_CoordsysTopic_HeightConversion is None:
            self.CoordSys_CoordsysTopic_HeightConversion = []
        else:
            self.CoordSys_CoordsysTopic_HeightConversion = CoordSys_CoordsysTopic_HeightConversion
        self.CoordSys_CoordsysTopic_HeightConversion_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, CoordSys_CoordsysTopic)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoordSys_CoordsysTopic.subclass:
            return CoordSys_CoordsysTopic.subclass(*args_, **kwargs_)
        else:
            return CoordSys_CoordsysTopic(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_CoordSys_CoordsysTopic_Ellipsoid(self):
        return self.CoordSys_CoordsysTopic_Ellipsoid

    def set_CoordSys_CoordsysTopic_Ellipsoid(self, CoordSys_CoordsysTopic_Ellipsoid):
        self.CoordSys_CoordsysTopic_Ellipsoid = CoordSys_CoordsysTopic_Ellipsoid

    def add_CoordSys_CoordsysTopic_Ellipsoid(self, value):
        self.CoordSys_CoordsysTopic_Ellipsoid.append(value)

    def insert_CoordSys_CoordsysTopic_Ellipsoid_at(self, index, value):
        self.CoordSys_CoordsysTopic_Ellipsoid.insert(index, value)

    def replace_CoordSys_CoordsysTopic_Ellipsoid_at(self, index, value):
        self.CoordSys_CoordsysTopic_Ellipsoid[index] = value

    def get_CoordSys_CoordsysTopic_GravityModel(self):
        return self.CoordSys_CoordsysTopic_GravityModel

    def set_CoordSys_CoordsysTopic_GravityModel(self, CoordSys_CoordsysTopic_GravityModel):
        self.CoordSys_CoordsysTopic_GravityModel = CoordSys_CoordsysTopic_GravityModel

    def add_CoordSys_CoordsysTopic_GravityModel(self, value):
        self.CoordSys_CoordsysTopic_GravityModel.append(value)

    def insert_CoordSys_CoordsysTopic_GravityModel_at(self, index, value):
        self.CoordSys_CoordsysTopic_GravityModel.insert(index, value)

    def replace_CoordSys_CoordsysTopic_GravityModel_at(self, index, value):
        self.CoordSys_CoordsysTopic_GravityModel[index] = value

    def get_CoordSys_CoordsysTopic_GeoidModel(self):
        return self.CoordSys_CoordsysTopic_GeoidModel

    def set_CoordSys_CoordsysTopic_GeoidModel(self, CoordSys_CoordsysTopic_GeoidModel):
        self.CoordSys_CoordsysTopic_GeoidModel = CoordSys_CoordsysTopic_GeoidModel

    def add_CoordSys_CoordsysTopic_GeoidModel(self, value):
        self.CoordSys_CoordsysTopic_GeoidModel.append(value)

    def insert_CoordSys_CoordsysTopic_GeoidModel_at(self, index, value):
        self.CoordSys_CoordsysTopic_GeoidModel.insert(index, value)

    def replace_CoordSys_CoordsysTopic_GeoidModel_at(self, index, value):
        self.CoordSys_CoordsysTopic_GeoidModel[index] = value

    def get_CoordSys_CoordsysTopic_GeoCartesian1D(self):
        return self.CoordSys_CoordsysTopic_GeoCartesian1D

    def set_CoordSys_CoordsysTopic_GeoCartesian1D(self, CoordSys_CoordsysTopic_GeoCartesian1D):
        self.CoordSys_CoordsysTopic_GeoCartesian1D = CoordSys_CoordsysTopic_GeoCartesian1D

    def add_CoordSys_CoordsysTopic_GeoCartesian1D(self, value):
        self.CoordSys_CoordsysTopic_GeoCartesian1D.append(value)

    def insert_CoordSys_CoordsysTopic_GeoCartesian1D_at(self, index, value):
        self.CoordSys_CoordsysTopic_GeoCartesian1D.insert(index, value)

    def replace_CoordSys_CoordsysTopic_GeoCartesian1D_at(self, index, value):
        self.CoordSys_CoordsysTopic_GeoCartesian1D[index] = value

    def get_CoordSys_CoordsysTopic_GeoHeight(self):
        return self.CoordSys_CoordsysTopic_GeoHeight

    def set_CoordSys_CoordsysTopic_GeoHeight(self, CoordSys_CoordsysTopic_GeoHeight):
        self.CoordSys_CoordsysTopic_GeoHeight = CoordSys_CoordsysTopic_GeoHeight

    def add_CoordSys_CoordsysTopic_GeoHeight(self, value):
        self.CoordSys_CoordsysTopic_GeoHeight.append(value)

    def insert_CoordSys_CoordsysTopic_GeoHeight_at(self, index, value):
        self.CoordSys_CoordsysTopic_GeoHeight.insert(index, value)

    def replace_CoordSys_CoordsysTopic_GeoHeight_at(self, index, value):
        self.CoordSys_CoordsysTopic_GeoHeight[index] = value

    def get_CoordSys_CoordsysTopic_GeoCartesian2D(self):
        return self.CoordSys_CoordsysTopic_GeoCartesian2D

    def set_CoordSys_CoordsysTopic_GeoCartesian2D(self, CoordSys_CoordsysTopic_GeoCartesian2D):
        self.CoordSys_CoordsysTopic_GeoCartesian2D = CoordSys_CoordsysTopic_GeoCartesian2D

    def add_CoordSys_CoordsysTopic_GeoCartesian2D(self, value):
        self.CoordSys_CoordsysTopic_GeoCartesian2D.append(value)

    def insert_CoordSys_CoordsysTopic_GeoCartesian2D_at(self, index, value):
        self.CoordSys_CoordsysTopic_GeoCartesian2D.insert(index, value)

    def replace_CoordSys_CoordsysTopic_GeoCartesian2D_at(self, index, value):
        self.CoordSys_CoordsysTopic_GeoCartesian2D[index] = value

    def get_CoordSys_CoordsysTopic_GeoCartesian3D(self):
        return self.CoordSys_CoordsysTopic_GeoCartesian3D

    def set_CoordSys_CoordsysTopic_GeoCartesian3D(self, CoordSys_CoordsysTopic_GeoCartesian3D):
        self.CoordSys_CoordsysTopic_GeoCartesian3D = CoordSys_CoordsysTopic_GeoCartesian3D

    def add_CoordSys_CoordsysTopic_GeoCartesian3D(self, value):
        self.CoordSys_CoordsysTopic_GeoCartesian3D.append(value)

    def insert_CoordSys_CoordsysTopic_GeoCartesian3D_at(self, index, value):
        self.CoordSys_CoordsysTopic_GeoCartesian3D.insert(index, value)

    def replace_CoordSys_CoordsysTopic_GeoCartesian3D_at(self, index, value):
        self.CoordSys_CoordsysTopic_GeoCartesian3D[index] = value

    def get_CoordSys_CoordsysTopic_GeoEllipsoidal(self):
        return self.CoordSys_CoordsysTopic_GeoEllipsoidal

    def set_CoordSys_CoordsysTopic_GeoEllipsoidal(self, CoordSys_CoordsysTopic_GeoEllipsoidal):
        self.CoordSys_CoordsysTopic_GeoEllipsoidal = CoordSys_CoordsysTopic_GeoEllipsoidal

    def add_CoordSys_CoordsysTopic_GeoEllipsoidal(self, value):
        self.CoordSys_CoordsysTopic_GeoEllipsoidal.append(value)

    def insert_CoordSys_CoordsysTopic_GeoEllipsoidal_at(self, index, value):
        self.CoordSys_CoordsysTopic_GeoEllipsoidal.insert(index, value)

    def replace_CoordSys_CoordsysTopic_GeoEllipsoidal_at(self, index, value):
        self.CoordSys_CoordsysTopic_GeoEllipsoidal[index] = value

    def get_CoordSys_CoordsysTopic_ToGeoEllipsoidal(self):
        return self.CoordSys_CoordsysTopic_ToGeoEllipsoidal

    def set_CoordSys_CoordsysTopic_ToGeoEllipsoidal(self, CoordSys_CoordsysTopic_ToGeoEllipsoidal):
        self.CoordSys_CoordsysTopic_ToGeoEllipsoidal = CoordSys_CoordsysTopic_ToGeoEllipsoidal

    def add_CoordSys_CoordsysTopic_ToGeoEllipsoidal(self, value):
        self.CoordSys_CoordsysTopic_ToGeoEllipsoidal.append(value)

    def insert_CoordSys_CoordsysTopic_ToGeoEllipsoidal_at(self, index, value):
        self.CoordSys_CoordsysTopic_ToGeoEllipsoidal.insert(index, value)

    def replace_CoordSys_CoordsysTopic_ToGeoEllipsoidal_at(self, index, value):
        self.CoordSys_CoordsysTopic_ToGeoEllipsoidal[index] = value

    def get_CoordSys_CoordsysTopic_ToGeoCartesian3D(self):
        return self.CoordSys_CoordsysTopic_ToGeoCartesian3D

    def set_CoordSys_CoordsysTopic_ToGeoCartesian3D(self, CoordSys_CoordsysTopic_ToGeoCartesian3D):
        self.CoordSys_CoordsysTopic_ToGeoCartesian3D = CoordSys_CoordsysTopic_ToGeoCartesian3D

    def add_CoordSys_CoordsysTopic_ToGeoCartesian3D(self, value):
        self.CoordSys_CoordsysTopic_ToGeoCartesian3D.append(value)

    def insert_CoordSys_CoordsysTopic_ToGeoCartesian3D_at(self, index, value):
        self.CoordSys_CoordsysTopic_ToGeoCartesian3D.insert(index, value)

    def replace_CoordSys_CoordsysTopic_ToGeoCartesian3D_at(self, index, value):
        self.CoordSys_CoordsysTopic_ToGeoCartesian3D[index] = value

    def get_CoordSys_CoordsysTopic_BidirectGeoCartesian2D(self):
        return self.CoordSys_CoordsysTopic_BidirectGeoCartesian2D

    def set_CoordSys_CoordsysTopic_BidirectGeoCartesian2D(
        self, CoordSys_CoordsysTopic_BidirectGeoCartesian2D
    ):
        self.CoordSys_CoordsysTopic_BidirectGeoCartesian2D = CoordSys_CoordsysTopic_BidirectGeoCartesian2D

    def add_CoordSys_CoordsysTopic_BidirectGeoCartesian2D(self, value):
        self.CoordSys_CoordsysTopic_BidirectGeoCartesian2D.append(value)

    def insert_CoordSys_CoordsysTopic_BidirectGeoCartesian2D_at(self, index, value):
        self.CoordSys_CoordsysTopic_BidirectGeoCartesian2D.insert(index, value)

    def replace_CoordSys_CoordsysTopic_BidirectGeoCartesian2D_at(self, index, value):
        self.CoordSys_CoordsysTopic_BidirectGeoCartesian2D[index] = value

    def get_CoordSys_CoordsysTopic_BidirectGeoCartesian3D(self):
        return self.CoordSys_CoordsysTopic_BidirectGeoCartesian3D

    def set_CoordSys_CoordsysTopic_BidirectGeoCartesian3D(
        self, CoordSys_CoordsysTopic_BidirectGeoCartesian3D
    ):
        self.CoordSys_CoordsysTopic_BidirectGeoCartesian3D = CoordSys_CoordsysTopic_BidirectGeoCartesian3D

    def add_CoordSys_CoordsysTopic_BidirectGeoCartesian3D(self, value):
        self.CoordSys_CoordsysTopic_BidirectGeoCartesian3D.append(value)

    def insert_CoordSys_CoordsysTopic_BidirectGeoCartesian3D_at(self, index, value):
        self.CoordSys_CoordsysTopic_BidirectGeoCartesian3D.insert(index, value)

    def replace_CoordSys_CoordsysTopic_BidirectGeoCartesian3D_at(self, index, value):
        self.CoordSys_CoordsysTopic_BidirectGeoCartesian3D[index] = value

    def get_CoordSys_CoordsysTopic_BidirectGeoEllipsoidal(self):
        return self.CoordSys_CoordsysTopic_BidirectGeoEllipsoidal

    def set_CoordSys_CoordsysTopic_BidirectGeoEllipsoidal(
        self, CoordSys_CoordsysTopic_BidirectGeoEllipsoidal
    ):
        self.CoordSys_CoordsysTopic_BidirectGeoEllipsoidal = CoordSys_CoordsysTopic_BidirectGeoEllipsoidal

    def add_CoordSys_CoordsysTopic_BidirectGeoEllipsoidal(self, value):
        self.CoordSys_CoordsysTopic_BidirectGeoEllipsoidal.append(value)

    def insert_CoordSys_CoordsysTopic_BidirectGeoEllipsoidal_at(self, index, value):
        self.CoordSys_CoordsysTopic_BidirectGeoEllipsoidal.insert(index, value)

    def replace_CoordSys_CoordsysTopic_BidirectGeoEllipsoidal_at(self, index, value):
        self.CoordSys_CoordsysTopic_BidirectGeoEllipsoidal[index] = value

    def get_CoordSys_CoordsysTopic_TransverseMercator(self):
        return self.CoordSys_CoordsysTopic_TransverseMercator

    def set_CoordSys_CoordsysTopic_TransverseMercator(self, CoordSys_CoordsysTopic_TransverseMercator):
        self.CoordSys_CoordsysTopic_TransverseMercator = CoordSys_CoordsysTopic_TransverseMercator

    def add_CoordSys_CoordsysTopic_TransverseMercator(self, value):
        self.CoordSys_CoordsysTopic_TransverseMercator.append(value)

    def insert_CoordSys_CoordsysTopic_TransverseMercator_at(self, index, value):
        self.CoordSys_CoordsysTopic_TransverseMercator.insert(index, value)

    def replace_CoordSys_CoordsysTopic_TransverseMercator_at(self, index, value):
        self.CoordSys_CoordsysTopic_TransverseMercator[index] = value

    def get_CoordSys_CoordsysTopic_SwissProjection(self):
        return self.CoordSys_CoordsysTopic_SwissProjection

    def set_CoordSys_CoordsysTopic_SwissProjection(self, CoordSys_CoordsysTopic_SwissProjection):
        self.CoordSys_CoordsysTopic_SwissProjection = CoordSys_CoordsysTopic_SwissProjection

    def add_CoordSys_CoordsysTopic_SwissProjection(self, value):
        self.CoordSys_CoordsysTopic_SwissProjection.append(value)

    def insert_CoordSys_CoordsysTopic_SwissProjection_at(self, index, value):
        self.CoordSys_CoordsysTopic_SwissProjection.insert(index, value)

    def replace_CoordSys_CoordsysTopic_SwissProjection_at(self, index, value):
        self.CoordSys_CoordsysTopic_SwissProjection[index] = value

    def get_CoordSys_CoordsysTopic_Mercator(self):
        return self.CoordSys_CoordsysTopic_Mercator

    def set_CoordSys_CoordsysTopic_Mercator(self, CoordSys_CoordsysTopic_Mercator):
        self.CoordSys_CoordsysTopic_Mercator = CoordSys_CoordsysTopic_Mercator

    def add_CoordSys_CoordsysTopic_Mercator(self, value):
        self.CoordSys_CoordsysTopic_Mercator.append(value)

    def insert_CoordSys_CoordsysTopic_Mercator_at(self, index, value):
        self.CoordSys_CoordsysTopic_Mercator.insert(index, value)

    def replace_CoordSys_CoordsysTopic_Mercator_at(self, index, value):
        self.CoordSys_CoordsysTopic_Mercator[index] = value

    def get_CoordSys_CoordsysTopic_ObliqueMercator(self):
        return self.CoordSys_CoordsysTopic_ObliqueMercator

    def set_CoordSys_CoordsysTopic_ObliqueMercator(self, CoordSys_CoordsysTopic_ObliqueMercator):
        self.CoordSys_CoordsysTopic_ObliqueMercator = CoordSys_CoordsysTopic_ObliqueMercator

    def add_CoordSys_CoordsysTopic_ObliqueMercator(self, value):
        self.CoordSys_CoordsysTopic_ObliqueMercator.append(value)

    def insert_CoordSys_CoordsysTopic_ObliqueMercator_at(self, index, value):
        self.CoordSys_CoordsysTopic_ObliqueMercator.insert(index, value)

    def replace_CoordSys_CoordsysTopic_ObliqueMercator_at(self, index, value):
        self.CoordSys_CoordsysTopic_ObliqueMercator[index] = value

    def get_CoordSys_CoordsysTopic_Lambert(self):
        return self.CoordSys_CoordsysTopic_Lambert

    def set_CoordSys_CoordsysTopic_Lambert(self, CoordSys_CoordsysTopic_Lambert):
        self.CoordSys_CoordsysTopic_Lambert = CoordSys_CoordsysTopic_Lambert

    def add_CoordSys_CoordsysTopic_Lambert(self, value):
        self.CoordSys_CoordsysTopic_Lambert.append(value)

    def insert_CoordSys_CoordsysTopic_Lambert_at(self, index, value):
        self.CoordSys_CoordsysTopic_Lambert.insert(index, value)

    def replace_CoordSys_CoordsysTopic_Lambert_at(self, index, value):
        self.CoordSys_CoordsysTopic_Lambert[index] = value

    def get_CoordSys_CoordsysTopic_Polyconic(self):
        return self.CoordSys_CoordsysTopic_Polyconic

    def set_CoordSys_CoordsysTopic_Polyconic(self, CoordSys_CoordsysTopic_Polyconic):
        self.CoordSys_CoordsysTopic_Polyconic = CoordSys_CoordsysTopic_Polyconic

    def add_CoordSys_CoordsysTopic_Polyconic(self, value):
        self.CoordSys_CoordsysTopic_Polyconic.append(value)

    def insert_CoordSys_CoordsysTopic_Polyconic_at(self, index, value):
        self.CoordSys_CoordsysTopic_Polyconic.insert(index, value)

    def replace_CoordSys_CoordsysTopic_Polyconic_at(self, index, value):
        self.CoordSys_CoordsysTopic_Polyconic[index] = value

    def get_CoordSys_CoordsysTopic_Albus(self):
        return self.CoordSys_CoordsysTopic_Albus

    def set_CoordSys_CoordsysTopic_Albus(self, CoordSys_CoordsysTopic_Albus):
        self.CoordSys_CoordsysTopic_Albus = CoordSys_CoordsysTopic_Albus

    def add_CoordSys_CoordsysTopic_Albus(self, value):
        self.CoordSys_CoordsysTopic_Albus.append(value)

    def insert_CoordSys_CoordsysTopic_Albus_at(self, index, value):
        self.CoordSys_CoordsysTopic_Albus.insert(index, value)

    def replace_CoordSys_CoordsysTopic_Albus_at(self, index, value):
        self.CoordSys_CoordsysTopic_Albus[index] = value

    def get_CoordSys_CoordsysTopic_Azimutal(self):
        return self.CoordSys_CoordsysTopic_Azimutal

    def set_CoordSys_CoordsysTopic_Azimutal(self, CoordSys_CoordsysTopic_Azimutal):
        self.CoordSys_CoordsysTopic_Azimutal = CoordSys_CoordsysTopic_Azimutal

    def add_CoordSys_CoordsysTopic_Azimutal(self, value):
        self.CoordSys_CoordsysTopic_Azimutal.append(value)

    def insert_CoordSys_CoordsysTopic_Azimutal_at(self, index, value):
        self.CoordSys_CoordsysTopic_Azimutal.insert(index, value)

    def replace_CoordSys_CoordsysTopic_Azimutal_at(self, index, value):
        self.CoordSys_CoordsysTopic_Azimutal[index] = value

    def get_CoordSys_CoordsysTopic_Stereographic(self):
        return self.CoordSys_CoordsysTopic_Stereographic

    def set_CoordSys_CoordsysTopic_Stereographic(self, CoordSys_CoordsysTopic_Stereographic):
        self.CoordSys_CoordsysTopic_Stereographic = CoordSys_CoordsysTopic_Stereographic

    def add_CoordSys_CoordsysTopic_Stereographic(self, value):
        self.CoordSys_CoordsysTopic_Stereographic.append(value)

    def insert_CoordSys_CoordsysTopic_Stereographic_at(self, index, value):
        self.CoordSys_CoordsysTopic_Stereographic.insert(index, value)

    def replace_CoordSys_CoordsysTopic_Stereographic_at(self, index, value):
        self.CoordSys_CoordsysTopic_Stereographic[index] = value

    def get_CoordSys_CoordsysTopic_HeightConversion(self):
        return self.CoordSys_CoordsysTopic_HeightConversion

    def set_CoordSys_CoordsysTopic_HeightConversion(self, CoordSys_CoordsysTopic_HeightConversion):
        self.CoordSys_CoordsysTopic_HeightConversion = CoordSys_CoordsysTopic_HeightConversion

    def add_CoordSys_CoordsysTopic_HeightConversion(self, value):
        self.CoordSys_CoordsysTopic_HeightConversion.append(value)

    def insert_CoordSys_CoordsysTopic_HeightConversion_at(self, index, value):
        self.CoordSys_CoordsysTopic_HeightConversion.insert(index, value)

    def replace_CoordSys_CoordsysTopic_HeightConversion_at(self, index, value):
        self.CoordSys_CoordsysTopic_HeightConversion[index] = value

    def get_BID(self):
        return self.BID

    def set_BID(self, BID):
        self.BID = BID

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if (
            self.CoordSys_CoordsysTopic_Ellipsoid
            or self.CoordSys_CoordsysTopic_GravityModel
            or self.CoordSys_CoordsysTopic_GeoidModel
            or self.CoordSys_CoordsysTopic_GeoCartesian1D
            or self.CoordSys_CoordsysTopic_GeoHeight
            or self.CoordSys_CoordsysTopic_GeoCartesian2D
            or self.CoordSys_CoordsysTopic_GeoCartesian3D
            or self.CoordSys_CoordsysTopic_GeoEllipsoidal
            or self.CoordSys_CoordsysTopic_ToGeoEllipsoidal
            or self.CoordSys_CoordsysTopic_ToGeoCartesian3D
            or self.CoordSys_CoordsysTopic_BidirectGeoCartesian2D
            or self.CoordSys_CoordsysTopic_BidirectGeoCartesian3D
            or self.CoordSys_CoordsysTopic_BidirectGeoEllipsoidal
            or self.CoordSys_CoordsysTopic_TransverseMercator
            or self.CoordSys_CoordsysTopic_SwissProjection
            or self.CoordSys_CoordsysTopic_Mercator
            or self.CoordSys_CoordsysTopic_ObliqueMercator
            or self.CoordSys_CoordsysTopic_Lambert
            or self.CoordSys_CoordsysTopic_Polyconic
            or self.CoordSys_CoordsysTopic_Albus
            or self.CoordSys_CoordsysTopic_Azimutal
            or self.CoordSys_CoordsysTopic_Stereographic
            or self.CoordSys_CoordsysTopic_HeightConversion
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("CoordSys.CoordsysTopic")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "CoordSys.CoordsysTopic":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="CoordSys.CoordsysTopic",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="CoordSys.CoordsysTopic",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="CoordSys.CoordsysTopic",
    ):
        if self.BID is not None and "BID" not in already_processed:
            already_processed.add("BID")
            outfile.write(
                " BID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.BID), input_name="BID")),)
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordSys.CoordsysTopic",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for CoordSys_CoordsysTopic_Ellipsoid_ in self.CoordSys_CoordsysTopic_Ellipsoid:
            namespaceprefix_ = (
                self.CoordSys_CoordsysTopic_Ellipsoid_nsprefix_ + ":"
                if (UseCapturedNS_ and self.CoordSys_CoordsysTopic_Ellipsoid_nsprefix_)
                else ""
            )
            CoordSys_CoordsysTopic_Ellipsoid_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="CoordSys.CoordsysTopic.Ellipsoid",
                pretty_print=pretty_print,
            )
        for CoordSys_CoordsysTopic_GravityModel_ in self.CoordSys_CoordsysTopic_GravityModel:
            namespaceprefix_ = (
                self.CoordSys_CoordsysTopic_GravityModel_nsprefix_ + ":"
                if (UseCapturedNS_ and self.CoordSys_CoordsysTopic_GravityModel_nsprefix_)
                else ""
            )
            CoordSys_CoordsysTopic_GravityModel_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="CoordSys.CoordsysTopic.GravityModel",
                pretty_print=pretty_print,
            )
        for CoordSys_CoordsysTopic_GeoidModel_ in self.CoordSys_CoordsysTopic_GeoidModel:
            namespaceprefix_ = (
                self.CoordSys_CoordsysTopic_GeoidModel_nsprefix_ + ":"
                if (UseCapturedNS_ and self.CoordSys_CoordsysTopic_GeoidModel_nsprefix_)
                else ""
            )
            CoordSys_CoordsysTopic_GeoidModel_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="CoordSys.CoordsysTopic.GeoidModel",
                pretty_print=pretty_print,
            )
        for CoordSys_CoordsysTopic_GeoCartesian1D_ in self.CoordSys_CoordsysTopic_GeoCartesian1D:
            namespaceprefix_ = (
                self.CoordSys_CoordsysTopic_GeoCartesian1D_nsprefix_ + ":"
                if (UseCapturedNS_ and self.CoordSys_CoordsysTopic_GeoCartesian1D_nsprefix_)
                else ""
            )
            CoordSys_CoordsysTopic_GeoCartesian1D_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="CoordSys.CoordsysTopic.GeoCartesian1D",
                pretty_print=pretty_print,
            )
        for CoordSys_CoordsysTopic_GeoHeight_ in self.CoordSys_CoordsysTopic_GeoHeight:
            namespaceprefix_ = (
                self.CoordSys_CoordsysTopic_GeoHeight_nsprefix_ + ":"
                if (UseCapturedNS_ and self.CoordSys_CoordsysTopic_GeoHeight_nsprefix_)
                else ""
            )
            CoordSys_CoordsysTopic_GeoHeight_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="CoordSys.CoordsysTopic.GeoHeight",
                pretty_print=pretty_print,
            )
        for CoordSys_CoordsysTopic_GeoCartesian2D_ in self.CoordSys_CoordsysTopic_GeoCartesian2D:
            namespaceprefix_ = (
                self.CoordSys_CoordsysTopic_GeoCartesian2D_nsprefix_ + ":"
                if (UseCapturedNS_ and self.CoordSys_CoordsysTopic_GeoCartesian2D_nsprefix_)
                else ""
            )
            CoordSys_CoordsysTopic_GeoCartesian2D_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="CoordSys.CoordsysTopic.GeoCartesian2D",
                pretty_print=pretty_print,
            )
        for CoordSys_CoordsysTopic_GeoCartesian3D_ in self.CoordSys_CoordsysTopic_GeoCartesian3D:
            namespaceprefix_ = (
                self.CoordSys_CoordsysTopic_GeoCartesian3D_nsprefix_ + ":"
                if (UseCapturedNS_ and self.CoordSys_CoordsysTopic_GeoCartesian3D_nsprefix_)
                else ""
            )
            CoordSys_CoordsysTopic_GeoCartesian3D_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="CoordSys.CoordsysTopic.GeoCartesian3D",
                pretty_print=pretty_print,
            )
        for CoordSys_CoordsysTopic_GeoEllipsoidal_ in self.CoordSys_CoordsysTopic_GeoEllipsoidal:
            namespaceprefix_ = (
                self.CoordSys_CoordsysTopic_GeoEllipsoidal_nsprefix_ + ":"
                if (UseCapturedNS_ and self.CoordSys_CoordsysTopic_GeoEllipsoidal_nsprefix_)
                else ""
            )
            CoordSys_CoordsysTopic_GeoEllipsoidal_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="CoordSys.CoordsysTopic.GeoEllipsoidal",
                pretty_print=pretty_print,
            )
        for CoordSys_CoordsysTopic_ToGeoEllipsoidal_ in self.CoordSys_CoordsysTopic_ToGeoEllipsoidal:
            namespaceprefix_ = (
                self.CoordSys_CoordsysTopic_ToGeoEllipsoidal_nsprefix_ + ":"
                if (UseCapturedNS_ and self.CoordSys_CoordsysTopic_ToGeoEllipsoidal_nsprefix_)
                else ""
            )
            CoordSys_CoordsysTopic_ToGeoEllipsoidal_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="CoordSys.CoordsysTopic.ToGeoEllipsoidal",
                pretty_print=pretty_print,
            )
        for CoordSys_CoordsysTopic_ToGeoCartesian3D_ in self.CoordSys_CoordsysTopic_ToGeoCartesian3D:
            namespaceprefix_ = (
                self.CoordSys_CoordsysTopic_ToGeoCartesian3D_nsprefix_ + ":"
                if (UseCapturedNS_ and self.CoordSys_CoordsysTopic_ToGeoCartesian3D_nsprefix_)
                else ""
            )
            CoordSys_CoordsysTopic_ToGeoCartesian3D_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="CoordSys.CoordsysTopic.ToGeoCartesian3D",
                pretty_print=pretty_print,
            )
        for (
            CoordSys_CoordsysTopic_BidirectGeoCartesian2D_
        ) in self.CoordSys_CoordsysTopic_BidirectGeoCartesian2D:
            namespaceprefix_ = (
                self.CoordSys_CoordsysTopic_BidirectGeoCartesian2D_nsprefix_ + ":"
                if (UseCapturedNS_ and self.CoordSys_CoordsysTopic_BidirectGeoCartesian2D_nsprefix_)
                else ""
            )
            CoordSys_CoordsysTopic_BidirectGeoCartesian2D_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="CoordSys.CoordsysTopic.BidirectGeoCartesian2D",
                pretty_print=pretty_print,
            )
        for (
            CoordSys_CoordsysTopic_BidirectGeoCartesian3D_
        ) in self.CoordSys_CoordsysTopic_BidirectGeoCartesian3D:
            namespaceprefix_ = (
                self.CoordSys_CoordsysTopic_BidirectGeoCartesian3D_nsprefix_ + ":"
                if (UseCapturedNS_ and self.CoordSys_CoordsysTopic_BidirectGeoCartesian3D_nsprefix_)
                else ""
            )
            CoordSys_CoordsysTopic_BidirectGeoCartesian3D_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="CoordSys.CoordsysTopic.BidirectGeoCartesian3D",
                pretty_print=pretty_print,
            )
        for (
            CoordSys_CoordsysTopic_BidirectGeoEllipsoidal_
        ) in self.CoordSys_CoordsysTopic_BidirectGeoEllipsoidal:
            namespaceprefix_ = (
                self.CoordSys_CoordsysTopic_BidirectGeoEllipsoidal_nsprefix_ + ":"
                if (UseCapturedNS_ and self.CoordSys_CoordsysTopic_BidirectGeoEllipsoidal_nsprefix_)
                else ""
            )
            CoordSys_CoordsysTopic_BidirectGeoEllipsoidal_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="CoordSys.CoordsysTopic.BidirectGeoEllipsoidal",
                pretty_print=pretty_print,
            )
        for CoordSys_CoordsysTopic_TransverseMercator_ in self.CoordSys_CoordsysTopic_TransverseMercator:
            namespaceprefix_ = (
                self.CoordSys_CoordsysTopic_TransverseMercator_nsprefix_ + ":"
                if (UseCapturedNS_ and self.CoordSys_CoordsysTopic_TransverseMercator_nsprefix_)
                else ""
            )
            CoordSys_CoordsysTopic_TransverseMercator_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="CoordSys.CoordsysTopic.TransverseMercator",
                pretty_print=pretty_print,
            )
        for CoordSys_CoordsysTopic_SwissProjection_ in self.CoordSys_CoordsysTopic_SwissProjection:
            namespaceprefix_ = (
                self.CoordSys_CoordsysTopic_SwissProjection_nsprefix_ + ":"
                if (UseCapturedNS_ and self.CoordSys_CoordsysTopic_SwissProjection_nsprefix_)
                else ""
            )
            CoordSys_CoordsysTopic_SwissProjection_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="CoordSys.CoordsysTopic.SwissProjection",
                pretty_print=pretty_print,
            )
        for CoordSys_CoordsysTopic_Mercator_ in self.CoordSys_CoordsysTopic_Mercator:
            namespaceprefix_ = (
                self.CoordSys_CoordsysTopic_Mercator_nsprefix_ + ":"
                if (UseCapturedNS_ and self.CoordSys_CoordsysTopic_Mercator_nsprefix_)
                else ""
            )
            CoordSys_CoordsysTopic_Mercator_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="CoordSys.CoordsysTopic.Mercator",
                pretty_print=pretty_print,
            )
        for CoordSys_CoordsysTopic_ObliqueMercator_ in self.CoordSys_CoordsysTopic_ObliqueMercator:
            namespaceprefix_ = (
                self.CoordSys_CoordsysTopic_ObliqueMercator_nsprefix_ + ":"
                if (UseCapturedNS_ and self.CoordSys_CoordsysTopic_ObliqueMercator_nsprefix_)
                else ""
            )
            CoordSys_CoordsysTopic_ObliqueMercator_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="CoordSys.CoordsysTopic.ObliqueMercator",
                pretty_print=pretty_print,
            )
        for CoordSys_CoordsysTopic_Lambert_ in self.CoordSys_CoordsysTopic_Lambert:
            namespaceprefix_ = (
                self.CoordSys_CoordsysTopic_Lambert_nsprefix_ + ":"
                if (UseCapturedNS_ and self.CoordSys_CoordsysTopic_Lambert_nsprefix_)
                else ""
            )
            CoordSys_CoordsysTopic_Lambert_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="CoordSys.CoordsysTopic.Lambert",
                pretty_print=pretty_print,
            )
        for CoordSys_CoordsysTopic_Polyconic_ in self.CoordSys_CoordsysTopic_Polyconic:
            namespaceprefix_ = (
                self.CoordSys_CoordsysTopic_Polyconic_nsprefix_ + ":"
                if (UseCapturedNS_ and self.CoordSys_CoordsysTopic_Polyconic_nsprefix_)
                else ""
            )
            CoordSys_CoordsysTopic_Polyconic_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="CoordSys.CoordsysTopic.Polyconic",
                pretty_print=pretty_print,
            )
        for CoordSys_CoordsysTopic_Albus_ in self.CoordSys_CoordsysTopic_Albus:
            namespaceprefix_ = (
                self.CoordSys_CoordsysTopic_Albus_nsprefix_ + ":"
                if (UseCapturedNS_ and self.CoordSys_CoordsysTopic_Albus_nsprefix_)
                else ""
            )
            CoordSys_CoordsysTopic_Albus_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="CoordSys.CoordsysTopic.Albus",
                pretty_print=pretty_print,
            )
        for CoordSys_CoordsysTopic_Azimutal_ in self.CoordSys_CoordsysTopic_Azimutal:
            namespaceprefix_ = (
                self.CoordSys_CoordsysTopic_Azimutal_nsprefix_ + ":"
                if (UseCapturedNS_ and self.CoordSys_CoordsysTopic_Azimutal_nsprefix_)
                else ""
            )
            CoordSys_CoordsysTopic_Azimutal_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="CoordSys.CoordsysTopic.Azimutal",
                pretty_print=pretty_print,
            )
        for CoordSys_CoordsysTopic_Stereographic_ in self.CoordSys_CoordsysTopic_Stereographic:
            namespaceprefix_ = (
                self.CoordSys_CoordsysTopic_Stereographic_nsprefix_ + ":"
                if (UseCapturedNS_ and self.CoordSys_CoordsysTopic_Stereographic_nsprefix_)
                else ""
            )
            CoordSys_CoordsysTopic_Stereographic_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="CoordSys.CoordsysTopic.Stereographic",
                pretty_print=pretty_print,
            )
        for CoordSys_CoordsysTopic_HeightConversion_ in self.CoordSys_CoordsysTopic_HeightConversion:
            namespaceprefix_ = (
                self.CoordSys_CoordsysTopic_HeightConversion_nsprefix_ + ":"
                if (UseCapturedNS_ and self.CoordSys_CoordsysTopic_HeightConversion_nsprefix_)
                else ""
            )
            CoordSys_CoordsysTopic_HeightConversion_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="CoordSys.CoordsysTopic.HeightConversion",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("BID", node)
        if value is not None and "BID" not in already_processed:
            already_processed.add("BID")
            self.BID = value
            self.validate_IliID(self.BID)  # validate type IliID

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "CoordSys.CoordsysTopic.Ellipsoid":
            obj_ = CoordSys_CoordsysTopic_Ellipsoid.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CoordSys_CoordsysTopic_Ellipsoid.append(obj_)
            obj_.original_tagname_ = "CoordSys.CoordsysTopic.Ellipsoid"
        elif nodeName_ == "CoordSys.CoordsysTopic.GravityModel":
            obj_ = CoordSys_CoordsysTopic_GravityModel.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CoordSys_CoordsysTopic_GravityModel.append(obj_)
            obj_.original_tagname_ = "CoordSys.CoordsysTopic.GravityModel"
        elif nodeName_ == "CoordSys.CoordsysTopic.GeoidModel":
            obj_ = CoordSys_CoordsysTopic_GeoidModel.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CoordSys_CoordsysTopic_GeoidModel.append(obj_)
            obj_.original_tagname_ = "CoordSys.CoordsysTopic.GeoidModel"
        elif nodeName_ == "CoordSys.CoordsysTopic.GeoCartesian1D":
            obj_ = CoordSys_CoordsysTopic_GeoCartesian1D.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CoordSys_CoordsysTopic_GeoCartesian1D.append(obj_)
            obj_.original_tagname_ = "CoordSys.CoordsysTopic.GeoCartesian1D"
        elif nodeName_ == "CoordSys.CoordsysTopic.GeoHeight":
            obj_ = CoordSys_CoordsysTopic_GeoHeight.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CoordSys_CoordsysTopic_GeoHeight.append(obj_)
            obj_.original_tagname_ = "CoordSys.CoordsysTopic.GeoHeight"
        elif nodeName_ == "CoordSys.CoordsysTopic.GeoCartesian2D":
            obj_ = CoordSys_CoordsysTopic_GeoCartesian2D.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CoordSys_CoordsysTopic_GeoCartesian2D.append(obj_)
            obj_.original_tagname_ = "CoordSys.CoordsysTopic.GeoCartesian2D"
        elif nodeName_ == "CoordSys.CoordsysTopic.GeoCartesian3D":
            obj_ = CoordSys_CoordsysTopic_GeoCartesian3D.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CoordSys_CoordsysTopic_GeoCartesian3D.append(obj_)
            obj_.original_tagname_ = "CoordSys.CoordsysTopic.GeoCartesian3D"
        elif nodeName_ == "CoordSys.CoordsysTopic.GeoEllipsoidal":
            obj_ = CoordSys_CoordsysTopic_GeoEllipsoidal.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CoordSys_CoordsysTopic_GeoEllipsoidal.append(obj_)
            obj_.original_tagname_ = "CoordSys.CoordsysTopic.GeoEllipsoidal"
        elif nodeName_ == "CoordSys.CoordsysTopic.ToGeoEllipsoidal":
            obj_ = CoordSys_CoordsysTopic_ToGeoEllipsoidal.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CoordSys_CoordsysTopic_ToGeoEllipsoidal.append(obj_)
            obj_.original_tagname_ = "CoordSys.CoordsysTopic.ToGeoEllipsoidal"
        elif nodeName_ == "CoordSys.CoordsysTopic.ToGeoCartesian3D":
            obj_ = CoordSys_CoordsysTopic_ToGeoCartesian3D.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CoordSys_CoordsysTopic_ToGeoCartesian3D.append(obj_)
            obj_.original_tagname_ = "CoordSys.CoordsysTopic.ToGeoCartesian3D"
        elif nodeName_ == "CoordSys.CoordsysTopic.BidirectGeoCartesian2D":
            obj_ = CoordSys_CoordsysTopic_BidirectGeoCartesian2D.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CoordSys_CoordsysTopic_BidirectGeoCartesian2D.append(obj_)
            obj_.original_tagname_ = "CoordSys.CoordsysTopic.BidirectGeoCartesian2D"
        elif nodeName_ == "CoordSys.CoordsysTopic.BidirectGeoCartesian3D":
            obj_ = CoordSys_CoordsysTopic_BidirectGeoCartesian3D.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CoordSys_CoordsysTopic_BidirectGeoCartesian3D.append(obj_)
            obj_.original_tagname_ = "CoordSys.CoordsysTopic.BidirectGeoCartesian3D"
        elif nodeName_ == "CoordSys.CoordsysTopic.BidirectGeoEllipsoidal":
            obj_ = CoordSys_CoordsysTopic_BidirectGeoEllipsoidal.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CoordSys_CoordsysTopic_BidirectGeoEllipsoidal.append(obj_)
            obj_.original_tagname_ = "CoordSys.CoordsysTopic.BidirectGeoEllipsoidal"
        elif nodeName_ == "CoordSys.CoordsysTopic.TransverseMercator":
            obj_ = CoordSys_CoordsysTopic_TransverseMercator.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CoordSys_CoordsysTopic_TransverseMercator.append(obj_)
            obj_.original_tagname_ = "CoordSys.CoordsysTopic.TransverseMercator"
        elif nodeName_ == "CoordSys.CoordsysTopic.SwissProjection":
            obj_ = CoordSys_CoordsysTopic_SwissProjection.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CoordSys_CoordsysTopic_SwissProjection.append(obj_)
            obj_.original_tagname_ = "CoordSys.CoordsysTopic.SwissProjection"
        elif nodeName_ == "CoordSys.CoordsysTopic.Mercator":
            obj_ = CoordSys_CoordsysTopic_Mercator.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CoordSys_CoordsysTopic_Mercator.append(obj_)
            obj_.original_tagname_ = "CoordSys.CoordsysTopic.Mercator"
        elif nodeName_ == "CoordSys.CoordsysTopic.ObliqueMercator":
            obj_ = CoordSys_CoordsysTopic_ObliqueMercator.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CoordSys_CoordsysTopic_ObliqueMercator.append(obj_)
            obj_.original_tagname_ = "CoordSys.CoordsysTopic.ObliqueMercator"
        elif nodeName_ == "CoordSys.CoordsysTopic.Lambert":
            obj_ = CoordSys_CoordsysTopic_Lambert.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CoordSys_CoordsysTopic_Lambert.append(obj_)
            obj_.original_tagname_ = "CoordSys.CoordsysTopic.Lambert"
        elif nodeName_ == "CoordSys.CoordsysTopic.Polyconic":
            obj_ = CoordSys_CoordsysTopic_Polyconic.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CoordSys_CoordsysTopic_Polyconic.append(obj_)
            obj_.original_tagname_ = "CoordSys.CoordsysTopic.Polyconic"
        elif nodeName_ == "CoordSys.CoordsysTopic.Albus":
            obj_ = CoordSys_CoordsysTopic_Albus.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CoordSys_CoordsysTopic_Albus.append(obj_)
            obj_.original_tagname_ = "CoordSys.CoordsysTopic.Albus"
        elif nodeName_ == "CoordSys.CoordsysTopic.Azimutal":
            obj_ = CoordSys_CoordsysTopic_Azimutal.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CoordSys_CoordsysTopic_Azimutal.append(obj_)
            obj_.original_tagname_ = "CoordSys.CoordsysTopic.Azimutal"
        elif nodeName_ == "CoordSys.CoordsysTopic.Stereographic":
            obj_ = CoordSys_CoordsysTopic_Stereographic.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CoordSys_CoordsysTopic_Stereographic.append(obj_)
            obj_.original_tagname_ = "CoordSys.CoordsysTopic.Stereographic"
        elif nodeName_ == "CoordSys.CoordsysTopic.HeightConversion":
            obj_ = CoordSys_CoordsysTopic_HeightConversion.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CoordSys_CoordsysTopic_HeightConversion.append(obj_)
            obj_.original_tagname_ = "CoordSys.CoordsysTopic.HeightConversion"


# end class CoordSys_CoordsysTopic


class DictionariesCH_V1_Dictionaries_Dictionary(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "TID": MemberSpec_("TID", "IliID", 0, 0, {"use": "required", "name": "TID"}),
        "Language": MemberSpec_(
            "Language",
            ["InternationalCodes_V1.LanguageCode_ISO639_1", "xsd:string"],
            0,
            0,
            {"name": "Language", "type": "xsd:string"},
            None,
        ),
        "Entries": MemberSpec_(
            "Entries",
            "EntriesType43",
            0,
            1,
            {"minOccurs": "0", "name": "Entries", "type": "EntriesType43"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, TID=None, Language=None, Entries=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.TID = _cast(None, TID)
        self.TID_nsprefix_ = None
        self.Language = Language
        self.validate_InternationalCodes_V1_LanguageCode_ISO639_1(self.Language)
        self.Language_nsprefix_ = None
        self.Entries = Entries
        self.Entries_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DictionariesCH_V1_Dictionaries_Dictionary
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DictionariesCH_V1_Dictionaries_Dictionary.subclass:
            return DictionariesCH_V1_Dictionaries_Dictionary.subclass(*args_, **kwargs_)
        else:
            return DictionariesCH_V1_Dictionaries_Dictionary(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Language(self):
        return self.Language

    def set_Language(self, Language):
        self.Language = Language

    def get_Entries(self):
        return self.Entries

    def set_Entries(self, Entries):
        self.Entries = Entries

    def get_TID(self):
        return self.TID

    def set_TID(self, TID):
        self.TID = TID

    def validate_InternationalCodes_V1_LanguageCode_ISO639_1(self, value):
        result = True
        # Validate type InternationalCodes_V1.LanguageCode_ISO639_1, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            value = value
            enumerations = [
                "de",
                "fr",
                "it",
                "rm",
                "en",
                "aa",
                "ab",
                "af",
                "am",
                "ar",
                "as",
                "ay",
                "az",
                "ba",
                "be",
                "bg",
                "bh",
                "bi",
                "bn",
                "bo",
                "br",
                "ca",
                "co",
                "cs",
                "cy",
                "da",
                "dz",
                "el",
                "eo",
                "es",
                "et",
                "eu",
                "fa",
                "fi",
                "fj",
                "fo",
                "fy",
                "ga",
                "gd",
                "gl",
                "gn",
                "gu",
                "ha",
                "he",
                "hi",
                "hr",
                "hu",
                "hy",
                "ia",
                "id",
                "ie",
                "ik",
                "is",
                "iu",
                "ja",
                "jw",
                "ka",
                "kk",
                "kl",
                "km",
                "kn",
                "ko",
                "ks",
                "ku",
                "ky",
                "la",
                "ln",
                "lo",
                "lt",
                "lv",
                "mg",
                "mi",
                "mk",
                "ml",
                "mn",
                "mo",
                "mr",
                "ms",
                "mt",
                "my",
                "na",
                "ne",
                "nl",
                "no",
                "oc",
                "om",
                "or",
                "pa",
                "pl",
                "ps",
                "pt",
                "qu",
                "rn",
                "ro",
                "ru",
                "rw",
                "sa",
                "sd",
                "sg",
                "sh",
                "si",
                "sk",
                "sl",
                "sm",
                "sn",
                "so",
                "sq",
                "sr",
                "ss",
                "st",
                "su",
                "sv",
                "sw",
                "ta",
                "te",
                "tg",
                "th",
                "ti",
                "tk",
                "tl",
                "tn",
                "to",
                "tr",
                "ts",
                "tt",
                "tw",
                "ug",
                "uk",
                "ur",
                "uz",
                "vi",
                "vo",
                "wo",
                "xh",
                "yi",
                "yo",
                "za",
                "zh",
                "zu",
            ]
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on InternationalCodes_V1.LanguageCode_ISO639_1'
                    % {"value": encode_str_2_3(value), "lineno": lineno}
                )
                result = False
        return result

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if self.Language is not None or self.Entries is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="DictionariesCH_V1.Dictionaries.Dictionary",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("DictionariesCH_V1.Dictionaries.Dictionary")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "DictionariesCH_V1.Dictionaries.Dictionary":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="DictionariesCH_V1.Dictionaries.Dictionary",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="DictionariesCH_V1.Dictionaries.Dictionary",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="DictionariesCH_V1.Dictionaries.Dictionary",
    ):
        if self.TID is not None and "TID" not in already_processed:
            already_processed.add("TID")
            outfile.write(
                " TID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.TID), input_name="TID")),)
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="DictionariesCH_V1.Dictionaries.Dictionary",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.Language is not None:
            namespaceprefix_ = (
                self.Language_nsprefix_ + ":" if (UseCapturedNS_ and self.Language_nsprefix_) else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sLanguage>%s</%sLanguage>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(self.gds_format_string(quote_xml(self.Language), input_name="Language")),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.Entries is not None:
            namespaceprefix_ = (
                self.Entries_nsprefix_ + ":" if (UseCapturedNS_ and self.Entries_nsprefix_) else ""
            )
            self.Entries.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Entries",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("TID", node)
        if value is not None and "TID" not in already_processed:
            already_processed.add("TID")
            self.TID = value
            self.validate_IliID(self.TID)  # validate type IliID

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "Language":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Language")
            value_ = self.gds_validate_string(value_, node, "Language")
            self.Language = value_
            self.Language_nsprefix_ = child_.prefix
            # validate type InternationalCodes_V1.LanguageCode_ISO639_1
            self.validate_InternationalCodes_V1_LanguageCode_ISO639_1(self.Language)
        elif nodeName_ == "Entries":
            obj_ = EntriesType43.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Entries = obj_
            obj_.original_tagname_ = "Entries"


# end class DictionariesCH_V1_Dictionaries_Dictionary


class DictionariesCH_V1_Dictionaries(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "BID": MemberSpec_("BID", "IliID", 0, 0, {"use": "required", "name": "BID"}),
        "DictionariesCH_V1_Dictionaries_Dictionary": MemberSpec_(
            "DictionariesCH_V1_Dictionaries_Dictionary",
            "DictionariesCH_V1.Dictionaries.Dictionary",
            1,
            1,
            {
                "name": "DictionariesCH_V1.Dictionaries.Dictionary",
                "type": "DictionariesCH_V1.Dictionaries.Dictionary",
            },
            12,
        ),
    }
    subclass = None
    superclass = None

    def __init__(
        self, BID=None, DictionariesCH_V1_Dictionaries_Dictionary=None, gds_collector_=None, **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.BID = _cast(None, BID)
        self.BID_nsprefix_ = None
        if DictionariesCH_V1_Dictionaries_Dictionary is None:
            self.DictionariesCH_V1_Dictionaries_Dictionary = []
        else:
            self.DictionariesCH_V1_Dictionaries_Dictionary = DictionariesCH_V1_Dictionaries_Dictionary
        self.DictionariesCH_V1_Dictionaries_Dictionary_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, DictionariesCH_V1_Dictionaries)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DictionariesCH_V1_Dictionaries.subclass:
            return DictionariesCH_V1_Dictionaries.subclass(*args_, **kwargs_)
        else:
            return DictionariesCH_V1_Dictionaries(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_DictionariesCH_V1_Dictionaries_Dictionary(self):
        return self.DictionariesCH_V1_Dictionaries_Dictionary

    def set_DictionariesCH_V1_Dictionaries_Dictionary(self, DictionariesCH_V1_Dictionaries_Dictionary):
        self.DictionariesCH_V1_Dictionaries_Dictionary = DictionariesCH_V1_Dictionaries_Dictionary

    def add_DictionariesCH_V1_Dictionaries_Dictionary(self, value):
        self.DictionariesCH_V1_Dictionaries_Dictionary.append(value)

    def insert_DictionariesCH_V1_Dictionaries_Dictionary_at(self, index, value):
        self.DictionariesCH_V1_Dictionaries_Dictionary.insert(index, value)

    def replace_DictionariesCH_V1_Dictionaries_Dictionary_at(self, index, value):
        self.DictionariesCH_V1_Dictionaries_Dictionary[index] = value

    def get_BID(self):
        return self.BID

    def set_BID(self, BID):
        self.BID = BID

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if self.DictionariesCH_V1_Dictionaries_Dictionary:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="DictionariesCH_V1.Dictionaries",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("DictionariesCH_V1.Dictionaries")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "DictionariesCH_V1.Dictionaries":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="DictionariesCH_V1.Dictionaries",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="DictionariesCH_V1.Dictionaries",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="DictionariesCH_V1.Dictionaries",
    ):
        if self.BID is not None and "BID" not in already_processed:
            already_processed.add("BID")
            outfile.write(
                " BID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.BID), input_name="BID")),)
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="DictionariesCH_V1.Dictionaries",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for DictionariesCH_V1_Dictionaries_Dictionary_ in self.DictionariesCH_V1_Dictionaries_Dictionary:
            namespaceprefix_ = (
                self.DictionariesCH_V1_Dictionaries_Dictionary_nsprefix_ + ":"
                if (UseCapturedNS_ and self.DictionariesCH_V1_Dictionaries_Dictionary_nsprefix_)
                else ""
            )
            DictionariesCH_V1_Dictionaries_Dictionary_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="DictionariesCH_V1.Dictionaries.Dictionary",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("BID", node)
        if value is not None and "BID" not in already_processed:
            already_processed.add("BID")
            self.BID = value
            self.validate_IliID(self.BID)  # validate type IliID

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "DictionariesCH_V1.Dictionaries.Dictionary":
            obj_ = DictionariesCH_V1_Dictionaries_Dictionary.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DictionariesCH_V1_Dictionaries_Dictionary.append(obj_)
            obj_.original_tagname_ = "DictionariesCH_V1.Dictionaries.Dictionary"


# end class DictionariesCH_V1_Dictionaries


class Dictionaries_V1_Dictionaries_Entry(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "Text": MemberSpec_(
            "Text",
            ["TextType44", "xsd:normalizedString"],
            0,
            0,
            {"name": "Text", "type": "xsd:normalizedString"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, Text=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.Text = Text
        self.validate_TextType44(self.Text)
        self.Text_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, Dictionaries_V1_Dictionaries_Entry)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Dictionaries_V1_Dictionaries_Entry.subclass:
            return Dictionaries_V1_Dictionaries_Entry.subclass(*args_, **kwargs_)
        else:
            return Dictionaries_V1_Dictionaries_Entry(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Text(self):
        return self.Text

    def set_Text(self, Text):
        self.Text = Text

    def validate_TextType44(self, value):
        result = True
        # Validate type TextType44, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            pass
        return result

    def _hasContent(self):
        if self.Text is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="Dictionaries_V1.Dictionaries.Entry",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("Dictionaries_V1.Dictionaries.Entry")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "Dictionaries_V1.Dictionaries.Entry":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="Dictionaries_V1.Dictionaries.Entry",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="Dictionaries_V1.Dictionaries.Entry",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="Dictionaries_V1.Dictionaries.Entry",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="Dictionaries_V1.Dictionaries.Entry",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.Text is not None:
            namespaceprefix_ = self.Text_nsprefix_ + ":" if (UseCapturedNS_ and self.Text_nsprefix_) else ""
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sText>%s</%sText>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(self.gds_format_string(quote_xml(self.Text), input_name="Text")),
                    namespaceprefix_,
                    eol_,
                )
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "Text":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Text")
            value_ = self.gds_validate_string(value_, node, "Text")
            self.Text = value_
            self.Text_nsprefix_ = child_.prefix
            # validate type TextType44
            self.validate_TextType44(self.Text)


# end class Dictionaries_V1_Dictionaries_Entry


class Dictionaries_V1_Dictionaries_Dictionary(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "TID": MemberSpec_("TID", "IliID", 0, 0, {"use": "required", "name": "TID"}),
        "Language": MemberSpec_(
            "Language",
            ["InternationalCodes_V1.LanguageCode_ISO639_1", "xsd:string"],
            0,
            0,
            {"name": "Language", "type": "xsd:string"},
            None,
        ),
        "Entries": MemberSpec_(
            "Entries",
            "EntriesType45",
            0,
            1,
            {"minOccurs": "0", "name": "Entries", "type": "EntriesType45"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, TID=None, Language=None, Entries=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.TID = _cast(None, TID)
        self.TID_nsprefix_ = None
        self.Language = Language
        self.validate_InternationalCodes_V1_LanguageCode_ISO639_1(self.Language)
        self.Language_nsprefix_ = None
        self.Entries = Entries
        self.Entries_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, Dictionaries_V1_Dictionaries_Dictionary)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Dictionaries_V1_Dictionaries_Dictionary.subclass:
            return Dictionaries_V1_Dictionaries_Dictionary.subclass(*args_, **kwargs_)
        else:
            return Dictionaries_V1_Dictionaries_Dictionary(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Language(self):
        return self.Language

    def set_Language(self, Language):
        self.Language = Language

    def get_Entries(self):
        return self.Entries

    def set_Entries(self, Entries):
        self.Entries = Entries

    def get_TID(self):
        return self.TID

    def set_TID(self, TID):
        self.TID = TID

    def validate_InternationalCodes_V1_LanguageCode_ISO639_1(self, value):
        result = True
        # Validate type InternationalCodes_V1.LanguageCode_ISO639_1, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            value = value
            enumerations = [
                "de",
                "fr",
                "it",
                "rm",
                "en",
                "aa",
                "ab",
                "af",
                "am",
                "ar",
                "as",
                "ay",
                "az",
                "ba",
                "be",
                "bg",
                "bh",
                "bi",
                "bn",
                "bo",
                "br",
                "ca",
                "co",
                "cs",
                "cy",
                "da",
                "dz",
                "el",
                "eo",
                "es",
                "et",
                "eu",
                "fa",
                "fi",
                "fj",
                "fo",
                "fy",
                "ga",
                "gd",
                "gl",
                "gn",
                "gu",
                "ha",
                "he",
                "hi",
                "hr",
                "hu",
                "hy",
                "ia",
                "id",
                "ie",
                "ik",
                "is",
                "iu",
                "ja",
                "jw",
                "ka",
                "kk",
                "kl",
                "km",
                "kn",
                "ko",
                "ks",
                "ku",
                "ky",
                "la",
                "ln",
                "lo",
                "lt",
                "lv",
                "mg",
                "mi",
                "mk",
                "ml",
                "mn",
                "mo",
                "mr",
                "ms",
                "mt",
                "my",
                "na",
                "ne",
                "nl",
                "no",
                "oc",
                "om",
                "or",
                "pa",
                "pl",
                "ps",
                "pt",
                "qu",
                "rn",
                "ro",
                "ru",
                "rw",
                "sa",
                "sd",
                "sg",
                "sh",
                "si",
                "sk",
                "sl",
                "sm",
                "sn",
                "so",
                "sq",
                "sr",
                "ss",
                "st",
                "su",
                "sv",
                "sw",
                "ta",
                "te",
                "tg",
                "th",
                "ti",
                "tk",
                "tl",
                "tn",
                "to",
                "tr",
                "ts",
                "tt",
                "tw",
                "ug",
                "uk",
                "ur",
                "uz",
                "vi",
                "vo",
                "wo",
                "xh",
                "yi",
                "yo",
                "za",
                "zh",
                "zu",
            ]
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on InternationalCodes_V1.LanguageCode_ISO639_1'
                    % {"value": encode_str_2_3(value), "lineno": lineno}
                )
                result = False
        return result

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if self.Language is not None or self.Entries is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="Dictionaries_V1.Dictionaries.Dictionary",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("Dictionaries_V1.Dictionaries.Dictionary")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "Dictionaries_V1.Dictionaries.Dictionary":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="Dictionaries_V1.Dictionaries.Dictionary",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="Dictionaries_V1.Dictionaries.Dictionary",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="Dictionaries_V1.Dictionaries.Dictionary",
    ):
        if self.TID is not None and "TID" not in already_processed:
            already_processed.add("TID")
            outfile.write(
                " TID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.TID), input_name="TID")),)
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="Dictionaries_V1.Dictionaries.Dictionary",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.Language is not None:
            namespaceprefix_ = (
                self.Language_nsprefix_ + ":" if (UseCapturedNS_ and self.Language_nsprefix_) else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sLanguage>%s</%sLanguage>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(self.gds_format_string(quote_xml(self.Language), input_name="Language")),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.Entries is not None:
            namespaceprefix_ = (
                self.Entries_nsprefix_ + ":" if (UseCapturedNS_ and self.Entries_nsprefix_) else ""
            )
            self.Entries.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Entries",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("TID", node)
        if value is not None and "TID" not in already_processed:
            already_processed.add("TID")
            self.TID = value
            self.validate_IliID(self.TID)  # validate type IliID

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "Language":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Language")
            value_ = self.gds_validate_string(value_, node, "Language")
            self.Language = value_
            self.Language_nsprefix_ = child_.prefix
            # validate type InternationalCodes_V1.LanguageCode_ISO639_1
            self.validate_InternationalCodes_V1_LanguageCode_ISO639_1(self.Language)
        elif nodeName_ == "Entries":
            obj_ = EntriesType45.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Entries = obj_
            obj_.original_tagname_ = "Entries"


# end class Dictionaries_V1_Dictionaries_Dictionary


class Dictionaries_V1_Dictionaries(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "BID": MemberSpec_("BID", "IliID", 0, 0, {"use": "required", "name": "BID"}),
        "Dictionaries_V1_Dictionaries_Dictionary": MemberSpec_(
            "Dictionaries_V1_Dictionaries_Dictionary",
            "Dictionaries_V1.Dictionaries.Dictionary",
            1,
            1,
            {
                "name": "Dictionaries_V1.Dictionaries.Dictionary",
                "type": "Dictionaries_V1.Dictionaries.Dictionary",
            },
            13,
        ),
    }
    subclass = None
    superclass = None

    def __init__(
        self, BID=None, Dictionaries_V1_Dictionaries_Dictionary=None, gds_collector_=None, **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.BID = _cast(None, BID)
        self.BID_nsprefix_ = None
        if Dictionaries_V1_Dictionaries_Dictionary is None:
            self.Dictionaries_V1_Dictionaries_Dictionary = []
        else:
            self.Dictionaries_V1_Dictionaries_Dictionary = Dictionaries_V1_Dictionaries_Dictionary
        self.Dictionaries_V1_Dictionaries_Dictionary_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, Dictionaries_V1_Dictionaries)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Dictionaries_V1_Dictionaries.subclass:
            return Dictionaries_V1_Dictionaries.subclass(*args_, **kwargs_)
        else:
            return Dictionaries_V1_Dictionaries(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Dictionaries_V1_Dictionaries_Dictionary(self):
        return self.Dictionaries_V1_Dictionaries_Dictionary

    def set_Dictionaries_V1_Dictionaries_Dictionary(self, Dictionaries_V1_Dictionaries_Dictionary):
        self.Dictionaries_V1_Dictionaries_Dictionary = Dictionaries_V1_Dictionaries_Dictionary

    def add_Dictionaries_V1_Dictionaries_Dictionary(self, value):
        self.Dictionaries_V1_Dictionaries_Dictionary.append(value)

    def insert_Dictionaries_V1_Dictionaries_Dictionary_at(self, index, value):
        self.Dictionaries_V1_Dictionaries_Dictionary.insert(index, value)

    def replace_Dictionaries_V1_Dictionaries_Dictionary_at(self, index, value):
        self.Dictionaries_V1_Dictionaries_Dictionary[index] = value

    def get_BID(self):
        return self.BID

    def set_BID(self, BID):
        self.BID = BID

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if self.Dictionaries_V1_Dictionaries_Dictionary:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="Dictionaries_V1.Dictionaries",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("Dictionaries_V1.Dictionaries")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "Dictionaries_V1.Dictionaries":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="Dictionaries_V1.Dictionaries",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="Dictionaries_V1.Dictionaries",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="Dictionaries_V1.Dictionaries",
    ):
        if self.BID is not None and "BID" not in already_processed:
            already_processed.add("BID")
            outfile.write(
                " BID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.BID), input_name="BID")),)
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="Dictionaries_V1.Dictionaries",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for Dictionaries_V1_Dictionaries_Dictionary_ in self.Dictionaries_V1_Dictionaries_Dictionary:
            namespaceprefix_ = (
                self.Dictionaries_V1_Dictionaries_Dictionary_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Dictionaries_V1_Dictionaries_Dictionary_nsprefix_)
                else ""
            )
            Dictionaries_V1_Dictionaries_Dictionary_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Dictionaries_V1.Dictionaries.Dictionary",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("BID", node)
        if value is not None and "BID" not in already_processed:
            already_processed.add("BID")
            self.BID = value
            self.validate_IliID(self.BID)  # validate type IliID

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "Dictionaries_V1.Dictionaries.Dictionary":
            obj_ = Dictionaries_V1_Dictionaries_Dictionary.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Dictionaries_V1_Dictionaries_Dictionary.append(obj_)
            obj_.original_tagname_ = "Dictionaries_V1.Dictionaries.Dictionary"


# end class Dictionaries_V1_Dictionaries


class GeometryCHLV03_V1_Coord2(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "COORD": MemberSpec_("COORD", "CoordValue", 0, 0, {"name": "COORD", "type": "CoordValue"}, None),
    }
    subclass = None
    superclass = None

    def __init__(self, COORD=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if COORD is None:
            self.COORD = globals()["CoordValue"]()
        else:
            self.COORD = COORD
        self.COORD_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, GeometryCHLV03_V1_Coord2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeometryCHLV03_V1_Coord2.subclass:
            return GeometryCHLV03_V1_Coord2.subclass(*args_, **kwargs_)
        else:
            return GeometryCHLV03_V1_Coord2(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_COORD(self):
        return self.COORD

    def set_COORD(self, COORD):
        self.COORD = COORD

    def _hasContent(self):
        if self.COORD is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV03_V1.Coord2",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("GeometryCHLV03_V1.Coord2")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "GeometryCHLV03_V1.Coord2":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="GeometryCHLV03_V1.Coord2",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="GeometryCHLV03_V1.Coord2",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="GeometryCHLV03_V1.Coord2",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV03_V1.Coord2",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.COORD is not None:
            namespaceprefix_ = self.COORD_nsprefix_ + ":" if (UseCapturedNS_ and self.COORD_nsprefix_) else ""
            self.COORD.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="COORD",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "COORD":
            obj_ = CoordValue.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.COORD = obj_
            obj_.original_tagname_ = "COORD"


# end class GeometryCHLV03_V1_Coord2


class GeometryCHLV03_V1_Coord3(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "COORD": MemberSpec_("COORD", "CoordValue", 0, 0, {"name": "COORD", "type": "CoordValue"}, None),
    }
    subclass = None
    superclass = None

    def __init__(self, COORD=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if COORD is None:
            self.COORD = globals()["CoordValue"]()
        else:
            self.COORD = COORD
        self.COORD_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, GeometryCHLV03_V1_Coord3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeometryCHLV03_V1_Coord3.subclass:
            return GeometryCHLV03_V1_Coord3.subclass(*args_, **kwargs_)
        else:
            return GeometryCHLV03_V1_Coord3(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_COORD(self):
        return self.COORD

    def set_COORD(self, COORD):
        self.COORD = COORD

    def _hasContent(self):
        if self.COORD is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV03_V1.Coord3",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("GeometryCHLV03_V1.Coord3")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "GeometryCHLV03_V1.Coord3":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="GeometryCHLV03_V1.Coord3",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="GeometryCHLV03_V1.Coord3",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="GeometryCHLV03_V1.Coord3",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV03_V1.Coord3",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.COORD is not None:
            namespaceprefix_ = self.COORD_nsprefix_ + ":" if (UseCapturedNS_ and self.COORD_nsprefix_) else ""
            self.COORD.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="COORD",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "COORD":
            obj_ = CoordValue.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.COORD = obj_
            obj_.original_tagname_ = "COORD"


# end class GeometryCHLV03_V1_Coord3


class GeometryCHLV03_V1_Surface(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "SURFACE": MemberSpec_(
            "SURFACE",
            "SURFACEType",
            0,
            0,
            {"name": "SURFACE", "type": "SURFACEType"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, SURFACE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if SURFACE is None:
            self.SURFACE = globals()["SURFACEType"]()
        else:
            self.SURFACE = SURFACE
        self.SURFACE_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, GeometryCHLV03_V1_Surface)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeometryCHLV03_V1_Surface.subclass:
            return GeometryCHLV03_V1_Surface.subclass(*args_, **kwargs_)
        else:
            return GeometryCHLV03_V1_Surface(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_SURFACE(self):
        return self.SURFACE

    def set_SURFACE(self, SURFACE):
        self.SURFACE = SURFACE

    def _hasContent(self):
        if self.SURFACE is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV03_V1.Surface",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("GeometryCHLV03_V1.Surface")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "GeometryCHLV03_V1.Surface":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="GeometryCHLV03_V1.Surface",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="GeometryCHLV03_V1.Surface",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="GeometryCHLV03_V1.Surface",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV03_V1.Surface",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.SURFACE is not None:
            namespaceprefix_ = (
                self.SURFACE_nsprefix_ + ":" if (UseCapturedNS_ and self.SURFACE_nsprefix_) else ""
            )
            self.SURFACE.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="SURFACE",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "SURFACE":
            obj_ = SURFACEType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SURFACE = obj_
            obj_.original_tagname_ = "SURFACE"


# end class GeometryCHLV03_V1_Surface


class GeometryCHLV03_V1_Area(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "SURFACE": MemberSpec_(
            "SURFACE",
            "SURFACEType46",
            0,
            0,
            {"name": "SURFACE", "type": "SURFACEType46"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, SURFACE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if SURFACE is None:
            self.SURFACE = globals()["SURFACEType46"]()
        else:
            self.SURFACE = SURFACE
        self.SURFACE_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, GeometryCHLV03_V1_Area)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeometryCHLV03_V1_Area.subclass:
            return GeometryCHLV03_V1_Area.subclass(*args_, **kwargs_)
        else:
            return GeometryCHLV03_V1_Area(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_SURFACE(self):
        return self.SURFACE

    def set_SURFACE(self, SURFACE):
        self.SURFACE = SURFACE

    def _hasContent(self):
        if self.SURFACE is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV03_V1.Area",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("GeometryCHLV03_V1.Area")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "GeometryCHLV03_V1.Area":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="GeometryCHLV03_V1.Area",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="GeometryCHLV03_V1.Area",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="GeometryCHLV03_V1.Area",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV03_V1.Area",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.SURFACE is not None:
            namespaceprefix_ = (
                self.SURFACE_nsprefix_ + ":" if (UseCapturedNS_ and self.SURFACE_nsprefix_) else ""
            )
            self.SURFACE.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="SURFACE",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "SURFACE":
            obj_ = SURFACEType46.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SURFACE = obj_
            obj_.original_tagname_ = "SURFACE"


# end class GeometryCHLV03_V1_Area


class GeometryCHLV03_V1_Line(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "POLYLINE": MemberSpec_(
            "POLYLINE",
            "POLYLINEType49",
            0,
            0,
            {"name": "POLYLINE", "type": "POLYLINEType49"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, POLYLINE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if POLYLINE is None:
            self.POLYLINE = globals()["POLYLINEType49"]()
        else:
            self.POLYLINE = POLYLINE
        self.POLYLINE_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, GeometryCHLV03_V1_Line)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeometryCHLV03_V1_Line.subclass:
            return GeometryCHLV03_V1_Line.subclass(*args_, **kwargs_)
        else:
            return GeometryCHLV03_V1_Line(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_POLYLINE(self):
        return self.POLYLINE

    def set_POLYLINE(self, POLYLINE):
        self.POLYLINE = POLYLINE

    def _hasContent(self):
        if self.POLYLINE is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV03_V1.Line",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("GeometryCHLV03_V1.Line")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "GeometryCHLV03_V1.Line":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="GeometryCHLV03_V1.Line",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="GeometryCHLV03_V1.Line",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="GeometryCHLV03_V1.Line",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV03_V1.Line",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.POLYLINE is not None:
            namespaceprefix_ = (
                self.POLYLINE_nsprefix_ + ":" if (UseCapturedNS_ and self.POLYLINE_nsprefix_) else ""
            )
            self.POLYLINE.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="POLYLINE",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "POLYLINE":
            obj_ = POLYLINEType49.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.POLYLINE = obj_
            obj_.original_tagname_ = "POLYLINE"


# end class GeometryCHLV03_V1_Line


class GeometryCHLV03_V1_DirectedLine(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "POLYLINE": MemberSpec_(
            "POLYLINE",
            "POLYLINEType50",
            0,
            0,
            {"name": "POLYLINE", "type": "POLYLINEType50"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, POLYLINE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if POLYLINE is None:
            self.POLYLINE = globals()["POLYLINEType50"]()
        else:
            self.POLYLINE = POLYLINE
        self.POLYLINE_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, GeometryCHLV03_V1_DirectedLine)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeometryCHLV03_V1_DirectedLine.subclass:
            return GeometryCHLV03_V1_DirectedLine.subclass(*args_, **kwargs_)
        else:
            return GeometryCHLV03_V1_DirectedLine(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_POLYLINE(self):
        return self.POLYLINE

    def set_POLYLINE(self, POLYLINE):
        self.POLYLINE = POLYLINE

    def _hasContent(self):
        if self.POLYLINE is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV03_V1.DirectedLine",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("GeometryCHLV03_V1.DirectedLine")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "GeometryCHLV03_V1.DirectedLine":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="GeometryCHLV03_V1.DirectedLine",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="GeometryCHLV03_V1.DirectedLine",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="GeometryCHLV03_V1.DirectedLine",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV03_V1.DirectedLine",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.POLYLINE is not None:
            namespaceprefix_ = (
                self.POLYLINE_nsprefix_ + ":" if (UseCapturedNS_ and self.POLYLINE_nsprefix_) else ""
            )
            self.POLYLINE.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="POLYLINE",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "POLYLINE":
            obj_ = POLYLINEType50.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.POLYLINE = obj_
            obj_.original_tagname_ = "POLYLINE"


# end class GeometryCHLV03_V1_DirectedLine


class GeometryCHLV03_V1_LineWithAltitude(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "POLYLINE": MemberSpec_(
            "POLYLINE",
            "POLYLINEType51",
            0,
            0,
            {"name": "POLYLINE", "type": "POLYLINEType51"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, POLYLINE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if POLYLINE is None:
            self.POLYLINE = globals()["POLYLINEType51"]()
        else:
            self.POLYLINE = POLYLINE
        self.POLYLINE_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, GeometryCHLV03_V1_LineWithAltitude)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeometryCHLV03_V1_LineWithAltitude.subclass:
            return GeometryCHLV03_V1_LineWithAltitude.subclass(*args_, **kwargs_)
        else:
            return GeometryCHLV03_V1_LineWithAltitude(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_POLYLINE(self):
        return self.POLYLINE

    def set_POLYLINE(self, POLYLINE):
        self.POLYLINE = POLYLINE

    def _hasContent(self):
        if self.POLYLINE is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV03_V1.LineWithAltitude",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("GeometryCHLV03_V1.LineWithAltitude")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "GeometryCHLV03_V1.LineWithAltitude":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="GeometryCHLV03_V1.LineWithAltitude",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="GeometryCHLV03_V1.LineWithAltitude",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="GeometryCHLV03_V1.LineWithAltitude",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV03_V1.LineWithAltitude",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.POLYLINE is not None:
            namespaceprefix_ = (
                self.POLYLINE_nsprefix_ + ":" if (UseCapturedNS_ and self.POLYLINE_nsprefix_) else ""
            )
            self.POLYLINE.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="POLYLINE",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "POLYLINE":
            obj_ = POLYLINEType51.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.POLYLINE = obj_
            obj_.original_tagname_ = "POLYLINE"


# end class GeometryCHLV03_V1_LineWithAltitude


class GeometryCHLV03_V1_DirectedLineWithAltitude(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "POLYLINE": MemberSpec_(
            "POLYLINE",
            "POLYLINEType52",
            0,
            0,
            {"name": "POLYLINE", "type": "POLYLINEType52"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, POLYLINE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if POLYLINE is None:
            self.POLYLINE = globals()["POLYLINEType52"]()
        else:
            self.POLYLINE = POLYLINE
        self.POLYLINE_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GeometryCHLV03_V1_DirectedLineWithAltitude
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeometryCHLV03_V1_DirectedLineWithAltitude.subclass:
            return GeometryCHLV03_V1_DirectedLineWithAltitude.subclass(*args_, **kwargs_)
        else:
            return GeometryCHLV03_V1_DirectedLineWithAltitude(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_POLYLINE(self):
        return self.POLYLINE

    def set_POLYLINE(self, POLYLINE):
        self.POLYLINE = POLYLINE

    def _hasContent(self):
        if self.POLYLINE is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV03_V1.DirectedLineWithAltitude",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("GeometryCHLV03_V1.DirectedLineWithAltitude")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "GeometryCHLV03_V1.DirectedLineWithAltitude":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="GeometryCHLV03_V1.DirectedLineWithAltitude",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="GeometryCHLV03_V1.DirectedLineWithAltitude",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="GeometryCHLV03_V1.DirectedLineWithAltitude",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV03_V1.DirectedLineWithAltitude",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.POLYLINE is not None:
            namespaceprefix_ = (
                self.POLYLINE_nsprefix_ + ":" if (UseCapturedNS_ and self.POLYLINE_nsprefix_) else ""
            )
            self.POLYLINE.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="POLYLINE",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "POLYLINE":
            obj_ = POLYLINEType52.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.POLYLINE = obj_
            obj_.original_tagname_ = "POLYLINE"


# end class GeometryCHLV03_V1_DirectedLineWithAltitude


class GeometryCHLV03_V1_SurfaceWithOverlaps2mm(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "SURFACE": MemberSpec_(
            "SURFACE",
            "SURFACEType53",
            0,
            0,
            {"name": "SURFACE", "type": "SURFACEType53"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, SURFACE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if SURFACE is None:
            self.SURFACE = globals()["SURFACEType53"]()
        else:
            self.SURFACE = SURFACE
        self.SURFACE_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GeometryCHLV03_V1_SurfaceWithOverlaps2mm
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeometryCHLV03_V1_SurfaceWithOverlaps2mm.subclass:
            return GeometryCHLV03_V1_SurfaceWithOverlaps2mm.subclass(*args_, **kwargs_)
        else:
            return GeometryCHLV03_V1_SurfaceWithOverlaps2mm(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_SURFACE(self):
        return self.SURFACE

    def set_SURFACE(self, SURFACE):
        self.SURFACE = SURFACE

    def _hasContent(self):
        if self.SURFACE is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV03_V1.SurfaceWithOverlaps2mm",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("GeometryCHLV03_V1.SurfaceWithOverlaps2mm")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "GeometryCHLV03_V1.SurfaceWithOverlaps2mm":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="GeometryCHLV03_V1.SurfaceWithOverlaps2mm",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="GeometryCHLV03_V1.SurfaceWithOverlaps2mm",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="GeometryCHLV03_V1.SurfaceWithOverlaps2mm",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV03_V1.SurfaceWithOverlaps2mm",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.SURFACE is not None:
            namespaceprefix_ = (
                self.SURFACE_nsprefix_ + ":" if (UseCapturedNS_ and self.SURFACE_nsprefix_) else ""
            )
            self.SURFACE.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="SURFACE",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "SURFACE":
            obj_ = SURFACEType53.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SURFACE = obj_
            obj_.original_tagname_ = "SURFACE"


# end class GeometryCHLV03_V1_SurfaceWithOverlaps2mm


class GeometryCHLV03_V1_AreaWithOverlaps2mm(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "SURFACE": MemberSpec_(
            "SURFACE",
            "SURFACEType56",
            0,
            0,
            {"name": "SURFACE", "type": "SURFACEType56"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, SURFACE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if SURFACE is None:
            self.SURFACE = globals()["SURFACEType56"]()
        else:
            self.SURFACE = SURFACE
        self.SURFACE_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, GeometryCHLV03_V1_AreaWithOverlaps2mm)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeometryCHLV03_V1_AreaWithOverlaps2mm.subclass:
            return GeometryCHLV03_V1_AreaWithOverlaps2mm.subclass(*args_, **kwargs_)
        else:
            return GeometryCHLV03_V1_AreaWithOverlaps2mm(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_SURFACE(self):
        return self.SURFACE

    def set_SURFACE(self, SURFACE):
        self.SURFACE = SURFACE

    def _hasContent(self):
        if self.SURFACE is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV03_V1.AreaWithOverlaps2mm",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("GeometryCHLV03_V1.AreaWithOverlaps2mm")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "GeometryCHLV03_V1.AreaWithOverlaps2mm":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="GeometryCHLV03_V1.AreaWithOverlaps2mm",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="GeometryCHLV03_V1.AreaWithOverlaps2mm",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="GeometryCHLV03_V1.AreaWithOverlaps2mm",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV03_V1.AreaWithOverlaps2mm",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.SURFACE is not None:
            namespaceprefix_ = (
                self.SURFACE_nsprefix_ + ":" if (UseCapturedNS_ and self.SURFACE_nsprefix_) else ""
            )
            self.SURFACE.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="SURFACE",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "SURFACE":
            obj_ = SURFACEType56.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SURFACE = obj_
            obj_.original_tagname_ = "SURFACE"


# end class GeometryCHLV03_V1_AreaWithOverlaps2mm


class GeometryCHLV03_V1_LineStructure(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "Line": MemberSpec_(
            "Line",
            "GeometryCHLV03_V1.Line",
            0,
            1,
            {"minOccurs": "0", "name": "Line", "type": "GeometryCHLV03_V1.Line"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, Line=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.Line = Line
        self.Line_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, GeometryCHLV03_V1_LineStructure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeometryCHLV03_V1_LineStructure.subclass:
            return GeometryCHLV03_V1_LineStructure.subclass(*args_, **kwargs_)
        else:
            return GeometryCHLV03_V1_LineStructure(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Line(self):
        return self.Line

    def set_Line(self, Line):
        self.Line = Line

    def _hasContent(self):
        if self.Line is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV03_V1.LineStructure",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("GeometryCHLV03_V1.LineStructure")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "GeometryCHLV03_V1.LineStructure":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="GeometryCHLV03_V1.LineStructure",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="GeometryCHLV03_V1.LineStructure",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="GeometryCHLV03_V1.LineStructure",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV03_V1.LineStructure",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.Line is not None:
            namespaceprefix_ = self.Line_nsprefix_ + ":" if (UseCapturedNS_ and self.Line_nsprefix_) else ""
            self.Line.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Line",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "Line":
            obj_ = GeometryCHLV03_V1_Line.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Line = obj_
            obj_.original_tagname_ = "Line"


# end class GeometryCHLV03_V1_LineStructure


class GeometryCHLV03_V1_DirectedLineStructure(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "Line": MemberSpec_(
            "Line",
            "GeometryCHLV03_V1.DirectedLine",
            0,
            1,
            {
                "minOccurs": "0",
                "name": "Line",
                "type": "GeometryCHLV03_V1.DirectedLine",
            },
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, Line=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.Line = Line
        self.Line_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, GeometryCHLV03_V1_DirectedLineStructure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeometryCHLV03_V1_DirectedLineStructure.subclass:
            return GeometryCHLV03_V1_DirectedLineStructure.subclass(*args_, **kwargs_)
        else:
            return GeometryCHLV03_V1_DirectedLineStructure(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Line(self):
        return self.Line

    def set_Line(self, Line):
        self.Line = Line

    def _hasContent(self):
        if self.Line is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV03_V1.DirectedLineStructure",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("GeometryCHLV03_V1.DirectedLineStructure")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "GeometryCHLV03_V1.DirectedLineStructure":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="GeometryCHLV03_V1.DirectedLineStructure",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="GeometryCHLV03_V1.DirectedLineStructure",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="GeometryCHLV03_V1.DirectedLineStructure",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV03_V1.DirectedLineStructure",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.Line is not None:
            namespaceprefix_ = self.Line_nsprefix_ + ":" if (UseCapturedNS_ and self.Line_nsprefix_) else ""
            self.Line.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Line",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "Line":
            obj_ = GeometryCHLV03_V1_DirectedLine.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Line = obj_
            obj_.original_tagname_ = "Line"


# end class GeometryCHLV03_V1_DirectedLineStructure


class GeometryCHLV03_V1_MultiLine(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "Lines": MemberSpec_("Lines", "LinesType", 0, 0, {"name": "Lines", "type": "LinesType"}, None),
    }
    subclass = None
    superclass = None

    def __init__(self, Lines=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if Lines is None:
            self.Lines = globals()["LinesType"]()
        else:
            self.Lines = Lines
        self.Lines_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, GeometryCHLV03_V1_MultiLine)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeometryCHLV03_V1_MultiLine.subclass:
            return GeometryCHLV03_V1_MultiLine.subclass(*args_, **kwargs_)
        else:
            return GeometryCHLV03_V1_MultiLine(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Lines(self):
        return self.Lines

    def set_Lines(self, Lines):
        self.Lines = Lines

    def _hasContent(self):
        if self.Lines is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV03_V1.MultiLine",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("GeometryCHLV03_V1.MultiLine")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "GeometryCHLV03_V1.MultiLine":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="GeometryCHLV03_V1.MultiLine",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="GeometryCHLV03_V1.MultiLine",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="GeometryCHLV03_V1.MultiLine",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV03_V1.MultiLine",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.Lines is not None:
            namespaceprefix_ = self.Lines_nsprefix_ + ":" if (UseCapturedNS_ and self.Lines_nsprefix_) else ""
            self.Lines.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Lines",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "Lines":
            obj_ = LinesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Lines = obj_
            obj_.original_tagname_ = "Lines"


# end class GeometryCHLV03_V1_MultiLine


class GeometryCHLV03_V1_MultiDirectedLine(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "Lines": MemberSpec_("Lines", "LinesType59", 0, 0, {"name": "Lines", "type": "LinesType59"}, None),
    }
    subclass = None
    superclass = None

    def __init__(self, Lines=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if Lines is None:
            self.Lines = globals()["LinesType59"]()
        else:
            self.Lines = Lines
        self.Lines_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, GeometryCHLV03_V1_MultiDirectedLine)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeometryCHLV03_V1_MultiDirectedLine.subclass:
            return GeometryCHLV03_V1_MultiDirectedLine.subclass(*args_, **kwargs_)
        else:
            return GeometryCHLV03_V1_MultiDirectedLine(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Lines(self):
        return self.Lines

    def set_Lines(self, Lines):
        self.Lines = Lines

    def _hasContent(self):
        if self.Lines is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV03_V1.MultiDirectedLine",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("GeometryCHLV03_V1.MultiDirectedLine")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "GeometryCHLV03_V1.MultiDirectedLine":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="GeometryCHLV03_V1.MultiDirectedLine",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="GeometryCHLV03_V1.MultiDirectedLine",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="GeometryCHLV03_V1.MultiDirectedLine",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV03_V1.MultiDirectedLine",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.Lines is not None:
            namespaceprefix_ = self.Lines_nsprefix_ + ":" if (UseCapturedNS_ and self.Lines_nsprefix_) else ""
            self.Lines.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Lines",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "Lines":
            obj_ = LinesType59.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Lines = obj_
            obj_.original_tagname_ = "Lines"


# end class GeometryCHLV03_V1_MultiDirectedLine


class GeometryCHLV03_V1_SurfaceStructure(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "Surface": MemberSpec_(
            "Surface",
            "GeometryCHLV03_V1.Surface",
            0,
            1,
            {"minOccurs": "0", "name": "Surface", "type": "GeometryCHLV03_V1.Surface"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, Surface=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.Surface = Surface
        self.Surface_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, GeometryCHLV03_V1_SurfaceStructure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeometryCHLV03_V1_SurfaceStructure.subclass:
            return GeometryCHLV03_V1_SurfaceStructure.subclass(*args_, **kwargs_)
        else:
            return GeometryCHLV03_V1_SurfaceStructure(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Surface(self):
        return self.Surface

    def set_Surface(self, Surface):
        self.Surface = Surface

    def _hasContent(self):
        if self.Surface is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV03_V1.SurfaceStructure",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("GeometryCHLV03_V1.SurfaceStructure")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "GeometryCHLV03_V1.SurfaceStructure":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="GeometryCHLV03_V1.SurfaceStructure",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="GeometryCHLV03_V1.SurfaceStructure",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="GeometryCHLV03_V1.SurfaceStructure",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV03_V1.SurfaceStructure",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.Surface is not None:
            namespaceprefix_ = (
                self.Surface_nsprefix_ + ":" if (UseCapturedNS_ and self.Surface_nsprefix_) else ""
            )
            self.Surface.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Surface",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "Surface":
            obj_ = GeometryCHLV03_V1_Surface.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Surface = obj_
            obj_.original_tagname_ = "Surface"


# end class GeometryCHLV03_V1_SurfaceStructure


class GeometryCHLV03_V1_MultiSurface(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "Surfaces": MemberSpec_(
            "Surfaces",
            "SurfacesType",
            0,
            0,
            {"name": "Surfaces", "type": "SurfacesType"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, Surfaces=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if Surfaces is None:
            self.Surfaces = globals()["SurfacesType"]()
        else:
            self.Surfaces = Surfaces
        self.Surfaces_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, GeometryCHLV03_V1_MultiSurface)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeometryCHLV03_V1_MultiSurface.subclass:
            return GeometryCHLV03_V1_MultiSurface.subclass(*args_, **kwargs_)
        else:
            return GeometryCHLV03_V1_MultiSurface(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Surfaces(self):
        return self.Surfaces

    def set_Surfaces(self, Surfaces):
        self.Surfaces = Surfaces

    def _hasContent(self):
        if self.Surfaces is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV03_V1.MultiSurface",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("GeometryCHLV03_V1.MultiSurface")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "GeometryCHLV03_V1.MultiSurface":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="GeometryCHLV03_V1.MultiSurface",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="GeometryCHLV03_V1.MultiSurface",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="GeometryCHLV03_V1.MultiSurface",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV03_V1.MultiSurface",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.Surfaces is not None:
            namespaceprefix_ = (
                self.Surfaces_nsprefix_ + ":" if (UseCapturedNS_ and self.Surfaces_nsprefix_) else ""
            )
            self.Surfaces.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Surfaces",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "Surfaces":
            obj_ = SurfacesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Surfaces = obj_
            obj_.original_tagname_ = "Surfaces"


# end class GeometryCHLV03_V1_MultiSurface


class GeometryCHLV95_V1_Coord2(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "COORD": MemberSpec_("COORD", "CoordValue", 0, 0, {"name": "COORD", "type": "CoordValue"}, None),
    }
    subclass = None
    superclass = None

    def __init__(self, COORD=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if COORD is None:
            self.COORD = globals()["CoordValue"]()
        else:
            self.COORD = COORD
        self.COORD_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, GeometryCHLV95_V1_Coord2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeometryCHLV95_V1_Coord2.subclass:
            return GeometryCHLV95_V1_Coord2.subclass(*args_, **kwargs_)
        else:
            return GeometryCHLV95_V1_Coord2(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_COORD(self):
        return self.COORD

    def set_COORD(self, COORD):
        self.COORD = COORD

    def _hasContent(self):
        if self.COORD is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV95_V1.Coord2",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("GeometryCHLV95_V1.Coord2")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "GeometryCHLV95_V1.Coord2":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="GeometryCHLV95_V1.Coord2",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="GeometryCHLV95_V1.Coord2",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="GeometryCHLV95_V1.Coord2",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV95_V1.Coord2",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.COORD is not None:
            namespaceprefix_ = self.COORD_nsprefix_ + ":" if (UseCapturedNS_ and self.COORD_nsprefix_) else ""
            self.COORD.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="COORD",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "COORD":
            obj_ = CoordValue.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.COORD = obj_
            obj_.original_tagname_ = "COORD"


# end class GeometryCHLV95_V1_Coord2


class GeometryCHLV95_V1_Coord3(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "COORD": MemberSpec_("COORD", "CoordValue", 0, 0, {"name": "COORD", "type": "CoordValue"}, None),
    }
    subclass = None
    superclass = None

    def __init__(self, COORD=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if COORD is None:
            self.COORD = globals()["CoordValue"]()
        else:
            self.COORD = COORD
        self.COORD_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, GeometryCHLV95_V1_Coord3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeometryCHLV95_V1_Coord3.subclass:
            return GeometryCHLV95_V1_Coord3.subclass(*args_, **kwargs_)
        else:
            return GeometryCHLV95_V1_Coord3(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_COORD(self):
        return self.COORD

    def set_COORD(self, COORD):
        self.COORD = COORD

    def _hasContent(self):
        if self.COORD is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV95_V1.Coord3",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("GeometryCHLV95_V1.Coord3")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "GeometryCHLV95_V1.Coord3":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="GeometryCHLV95_V1.Coord3",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="GeometryCHLV95_V1.Coord3",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="GeometryCHLV95_V1.Coord3",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV95_V1.Coord3",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.COORD is not None:
            namespaceprefix_ = self.COORD_nsprefix_ + ":" if (UseCapturedNS_ and self.COORD_nsprefix_) else ""
            self.COORD.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="COORD",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "COORD":
            obj_ = CoordValue.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.COORD = obj_
            obj_.original_tagname_ = "COORD"


# end class GeometryCHLV95_V1_Coord3


class GeometryCHLV95_V1_Surface(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "SURFACE": MemberSpec_(
            "SURFACE",
            "SURFACEType60",
            0,
            0,
            {"name": "SURFACE", "type": "SURFACEType60"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, SURFACE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if SURFACE is None:
            self.SURFACE = globals()["SURFACEType60"]()
        else:
            self.SURFACE = SURFACE
        self.SURFACE_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, GeometryCHLV95_V1_Surface)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeometryCHLV95_V1_Surface.subclass:
            return GeometryCHLV95_V1_Surface.subclass(*args_, **kwargs_)
        else:
            return GeometryCHLV95_V1_Surface(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_SURFACE(self):
        return self.SURFACE

    def set_SURFACE(self, SURFACE):
        self.SURFACE = SURFACE

    def _hasContent(self):
        if self.SURFACE is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV95_V1.Surface",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("GeometryCHLV95_V1.Surface")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "GeometryCHLV95_V1.Surface":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="GeometryCHLV95_V1.Surface",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="GeometryCHLV95_V1.Surface",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="GeometryCHLV95_V1.Surface",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV95_V1.Surface",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.SURFACE is not None:
            namespaceprefix_ = (
                self.SURFACE_nsprefix_ + ":" if (UseCapturedNS_ and self.SURFACE_nsprefix_) else ""
            )
            self.SURFACE.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="SURFACE",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "SURFACE":
            obj_ = SURFACEType60.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SURFACE = obj_
            obj_.original_tagname_ = "SURFACE"


# end class GeometryCHLV95_V1_Surface


class GeometryCHLV95_V1_Area(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "SURFACE": MemberSpec_(
            "SURFACE",
            "SURFACEType63",
            0,
            0,
            {"name": "SURFACE", "type": "SURFACEType63"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, SURFACE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if SURFACE is None:
            self.SURFACE = globals()["SURFACEType63"]()
        else:
            self.SURFACE = SURFACE
        self.SURFACE_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, GeometryCHLV95_V1_Area)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeometryCHLV95_V1_Area.subclass:
            return GeometryCHLV95_V1_Area.subclass(*args_, **kwargs_)
        else:
            return GeometryCHLV95_V1_Area(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_SURFACE(self):
        return self.SURFACE

    def set_SURFACE(self, SURFACE):
        self.SURFACE = SURFACE

    def _hasContent(self):
        if self.SURFACE is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV95_V1.Area",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("GeometryCHLV95_V1.Area")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "GeometryCHLV95_V1.Area":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="GeometryCHLV95_V1.Area",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="GeometryCHLV95_V1.Area",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="GeometryCHLV95_V1.Area",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV95_V1.Area",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.SURFACE is not None:
            namespaceprefix_ = (
                self.SURFACE_nsprefix_ + ":" if (UseCapturedNS_ and self.SURFACE_nsprefix_) else ""
            )
            self.SURFACE.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="SURFACE",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "SURFACE":
            obj_ = SURFACEType63.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SURFACE = obj_
            obj_.original_tagname_ = "SURFACE"


# end class GeometryCHLV95_V1_Area


class GeometryCHLV95_V1_Line(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "POLYLINE": MemberSpec_(
            "POLYLINE",
            "POLYLINEType66",
            0,
            0,
            {"name": "POLYLINE", "type": "POLYLINEType66"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, POLYLINE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if POLYLINE is None:
            self.POLYLINE = globals()["POLYLINEType66"]()
        else:
            self.POLYLINE = POLYLINE
        self.POLYLINE_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, GeometryCHLV95_V1_Line)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeometryCHLV95_V1_Line.subclass:
            return GeometryCHLV95_V1_Line.subclass(*args_, **kwargs_)
        else:
            return GeometryCHLV95_V1_Line(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_POLYLINE(self):
        return self.POLYLINE

    def set_POLYLINE(self, POLYLINE):
        self.POLYLINE = POLYLINE

    def _hasContent(self):
        if self.POLYLINE is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV95_V1.Line",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("GeometryCHLV95_V1.Line")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "GeometryCHLV95_V1.Line":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="GeometryCHLV95_V1.Line",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="GeometryCHLV95_V1.Line",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="GeometryCHLV95_V1.Line",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV95_V1.Line",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.POLYLINE is not None:
            namespaceprefix_ = (
                self.POLYLINE_nsprefix_ + ":" if (UseCapturedNS_ and self.POLYLINE_nsprefix_) else ""
            )
            self.POLYLINE.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="POLYLINE",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "POLYLINE":
            obj_ = POLYLINEType66.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.POLYLINE = obj_
            obj_.original_tagname_ = "POLYLINE"


# end class GeometryCHLV95_V1_Line


class GeometryCHLV95_V1_DirectedLine(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "POLYLINE": MemberSpec_(
            "POLYLINE",
            "POLYLINEType67",
            0,
            0,
            {"name": "POLYLINE", "type": "POLYLINEType67"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, POLYLINE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if POLYLINE is None:
            self.POLYLINE = globals()["POLYLINEType67"]()
        else:
            self.POLYLINE = POLYLINE
        self.POLYLINE_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, GeometryCHLV95_V1_DirectedLine)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeometryCHLV95_V1_DirectedLine.subclass:
            return GeometryCHLV95_V1_DirectedLine.subclass(*args_, **kwargs_)
        else:
            return GeometryCHLV95_V1_DirectedLine(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_POLYLINE(self):
        return self.POLYLINE

    def set_POLYLINE(self, POLYLINE):
        self.POLYLINE = POLYLINE

    def _hasContent(self):
        if self.POLYLINE is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV95_V1.DirectedLine",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("GeometryCHLV95_V1.DirectedLine")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "GeometryCHLV95_V1.DirectedLine":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="GeometryCHLV95_V1.DirectedLine",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="GeometryCHLV95_V1.DirectedLine",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="GeometryCHLV95_V1.DirectedLine",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV95_V1.DirectedLine",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.POLYLINE is not None:
            namespaceprefix_ = (
                self.POLYLINE_nsprefix_ + ":" if (UseCapturedNS_ and self.POLYLINE_nsprefix_) else ""
            )
            self.POLYLINE.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="POLYLINE",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "POLYLINE":
            obj_ = POLYLINEType67.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.POLYLINE = obj_
            obj_.original_tagname_ = "POLYLINE"


# end class GeometryCHLV95_V1_DirectedLine


class GeometryCHLV95_V1_LineWithAltitude(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "POLYLINE": MemberSpec_(
            "POLYLINE",
            "POLYLINEType68",
            0,
            0,
            {"name": "POLYLINE", "type": "POLYLINEType68"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, POLYLINE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if POLYLINE is None:
            self.POLYLINE = globals()["POLYLINEType68"]()
        else:
            self.POLYLINE = POLYLINE
        self.POLYLINE_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, GeometryCHLV95_V1_LineWithAltitude)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeometryCHLV95_V1_LineWithAltitude.subclass:
            return GeometryCHLV95_V1_LineWithAltitude.subclass(*args_, **kwargs_)
        else:
            return GeometryCHLV95_V1_LineWithAltitude(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_POLYLINE(self):
        return self.POLYLINE

    def set_POLYLINE(self, POLYLINE):
        self.POLYLINE = POLYLINE

    def _hasContent(self):
        if self.POLYLINE is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV95_V1.LineWithAltitude",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("GeometryCHLV95_V1.LineWithAltitude")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "GeometryCHLV95_V1.LineWithAltitude":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="GeometryCHLV95_V1.LineWithAltitude",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="GeometryCHLV95_V1.LineWithAltitude",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="GeometryCHLV95_V1.LineWithAltitude",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV95_V1.LineWithAltitude",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.POLYLINE is not None:
            namespaceprefix_ = (
                self.POLYLINE_nsprefix_ + ":" if (UseCapturedNS_ and self.POLYLINE_nsprefix_) else ""
            )
            self.POLYLINE.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="POLYLINE",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "POLYLINE":
            obj_ = POLYLINEType68.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.POLYLINE = obj_
            obj_.original_tagname_ = "POLYLINE"


# end class GeometryCHLV95_V1_LineWithAltitude


class GeometryCHLV95_V1_DirectedLineWithAltitude(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "POLYLINE": MemberSpec_(
            "POLYLINE",
            "POLYLINEType69",
            0,
            0,
            {"name": "POLYLINE", "type": "POLYLINEType69"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, POLYLINE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if POLYLINE is None:
            self.POLYLINE = globals()["POLYLINEType69"]()
        else:
            self.POLYLINE = POLYLINE
        self.POLYLINE_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GeometryCHLV95_V1_DirectedLineWithAltitude
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeometryCHLV95_V1_DirectedLineWithAltitude.subclass:
            return GeometryCHLV95_V1_DirectedLineWithAltitude.subclass(*args_, **kwargs_)
        else:
            return GeometryCHLV95_V1_DirectedLineWithAltitude(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_POLYLINE(self):
        return self.POLYLINE

    def set_POLYLINE(self, POLYLINE):
        self.POLYLINE = POLYLINE

    def _hasContent(self):
        if self.POLYLINE is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV95_V1.DirectedLineWithAltitude",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("GeometryCHLV95_V1.DirectedLineWithAltitude")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "GeometryCHLV95_V1.DirectedLineWithAltitude":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="GeometryCHLV95_V1.DirectedLineWithAltitude",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="GeometryCHLV95_V1.DirectedLineWithAltitude",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="GeometryCHLV95_V1.DirectedLineWithAltitude",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV95_V1.DirectedLineWithAltitude",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.POLYLINE is not None:
            namespaceprefix_ = (
                self.POLYLINE_nsprefix_ + ":" if (UseCapturedNS_ and self.POLYLINE_nsprefix_) else ""
            )
            self.POLYLINE.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="POLYLINE",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "POLYLINE":
            obj_ = POLYLINEType69.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.POLYLINE = obj_
            obj_.original_tagname_ = "POLYLINE"


# end class GeometryCHLV95_V1_DirectedLineWithAltitude


class GeometryCHLV95_V1_SurfaceWithOverlaps2mm(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "SURFACE": MemberSpec_(
            "SURFACE",
            "SURFACEType70",
            0,
            0,
            {"name": "SURFACE", "type": "SURFACEType70"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, SURFACE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if SURFACE is None:
            self.SURFACE = globals()["SURFACEType70"]()
        else:
            self.SURFACE = SURFACE
        self.SURFACE_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GeometryCHLV95_V1_SurfaceWithOverlaps2mm
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeometryCHLV95_V1_SurfaceWithOverlaps2mm.subclass:
            return GeometryCHLV95_V1_SurfaceWithOverlaps2mm.subclass(*args_, **kwargs_)
        else:
            return GeometryCHLV95_V1_SurfaceWithOverlaps2mm(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_SURFACE(self):
        return self.SURFACE

    def set_SURFACE(self, SURFACE):
        self.SURFACE = SURFACE

    def _hasContent(self):
        if self.SURFACE is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV95_V1.SurfaceWithOverlaps2mm",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("GeometryCHLV95_V1.SurfaceWithOverlaps2mm")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "GeometryCHLV95_V1.SurfaceWithOverlaps2mm":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="GeometryCHLV95_V1.SurfaceWithOverlaps2mm",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="GeometryCHLV95_V1.SurfaceWithOverlaps2mm",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="GeometryCHLV95_V1.SurfaceWithOverlaps2mm",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV95_V1.SurfaceWithOverlaps2mm",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.SURFACE is not None:
            namespaceprefix_ = (
                self.SURFACE_nsprefix_ + ":" if (UseCapturedNS_ and self.SURFACE_nsprefix_) else ""
            )
            self.SURFACE.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="SURFACE",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "SURFACE":
            obj_ = SURFACEType70.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SURFACE = obj_
            obj_.original_tagname_ = "SURFACE"


# end class GeometryCHLV95_V1_SurfaceWithOverlaps2mm


class GeometryCHLV95_V1_AreaWithOverlaps2mm(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "SURFACE": MemberSpec_(
            "SURFACE",
            "SURFACEType73",
            0,
            0,
            {"name": "SURFACE", "type": "SURFACEType73"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, SURFACE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if SURFACE is None:
            self.SURFACE = globals()["SURFACEType73"]()
        else:
            self.SURFACE = SURFACE
        self.SURFACE_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, GeometryCHLV95_V1_AreaWithOverlaps2mm)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeometryCHLV95_V1_AreaWithOverlaps2mm.subclass:
            return GeometryCHLV95_V1_AreaWithOverlaps2mm.subclass(*args_, **kwargs_)
        else:
            return GeometryCHLV95_V1_AreaWithOverlaps2mm(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_SURFACE(self):
        return self.SURFACE

    def set_SURFACE(self, SURFACE):
        self.SURFACE = SURFACE

    def _hasContent(self):
        if self.SURFACE is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV95_V1.AreaWithOverlaps2mm",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("GeometryCHLV95_V1.AreaWithOverlaps2mm")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "GeometryCHLV95_V1.AreaWithOverlaps2mm":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="GeometryCHLV95_V1.AreaWithOverlaps2mm",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="GeometryCHLV95_V1.AreaWithOverlaps2mm",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="GeometryCHLV95_V1.AreaWithOverlaps2mm",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV95_V1.AreaWithOverlaps2mm",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.SURFACE is not None:
            namespaceprefix_ = (
                self.SURFACE_nsprefix_ + ":" if (UseCapturedNS_ and self.SURFACE_nsprefix_) else ""
            )
            self.SURFACE.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="SURFACE",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "SURFACE":
            obj_ = SURFACEType73.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SURFACE = obj_
            obj_.original_tagname_ = "SURFACE"


# end class GeometryCHLV95_V1_AreaWithOverlaps2mm


class GeometryCHLV95_V1_LineStructure(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "Line": MemberSpec_(
            "Line",
            "GeometryCHLV95_V1.Line",
            0,
            1,
            {"minOccurs": "0", "name": "Line", "type": "GeometryCHLV95_V1.Line"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, Line=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.Line = Line
        self.Line_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, GeometryCHLV95_V1_LineStructure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeometryCHLV95_V1_LineStructure.subclass:
            return GeometryCHLV95_V1_LineStructure.subclass(*args_, **kwargs_)
        else:
            return GeometryCHLV95_V1_LineStructure(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Line(self):
        return self.Line

    def set_Line(self, Line):
        self.Line = Line

    def _hasContent(self):
        if self.Line is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV95_V1.LineStructure",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("GeometryCHLV95_V1.LineStructure")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "GeometryCHLV95_V1.LineStructure":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="GeometryCHLV95_V1.LineStructure",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="GeometryCHLV95_V1.LineStructure",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="GeometryCHLV95_V1.LineStructure",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV95_V1.LineStructure",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.Line is not None:
            namespaceprefix_ = self.Line_nsprefix_ + ":" if (UseCapturedNS_ and self.Line_nsprefix_) else ""
            self.Line.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Line",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "Line":
            obj_ = GeometryCHLV95_V1_Line.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Line = obj_
            obj_.original_tagname_ = "Line"


# end class GeometryCHLV95_V1_LineStructure


class GeometryCHLV95_V1_DirectedLineStructure(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "Line": MemberSpec_(
            "Line",
            "GeometryCHLV95_V1.DirectedLine",
            0,
            1,
            {
                "minOccurs": "0",
                "name": "Line",
                "type": "GeometryCHLV95_V1.DirectedLine",
            },
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, Line=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.Line = Line
        self.Line_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, GeometryCHLV95_V1_DirectedLineStructure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeometryCHLV95_V1_DirectedLineStructure.subclass:
            return GeometryCHLV95_V1_DirectedLineStructure.subclass(*args_, **kwargs_)
        else:
            return GeometryCHLV95_V1_DirectedLineStructure(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Line(self):
        return self.Line

    def set_Line(self, Line):
        self.Line = Line

    def _hasContent(self):
        if self.Line is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV95_V1.DirectedLineStructure",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("GeometryCHLV95_V1.DirectedLineStructure")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "GeometryCHLV95_V1.DirectedLineStructure":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="GeometryCHLV95_V1.DirectedLineStructure",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="GeometryCHLV95_V1.DirectedLineStructure",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="GeometryCHLV95_V1.DirectedLineStructure",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV95_V1.DirectedLineStructure",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.Line is not None:
            namespaceprefix_ = self.Line_nsprefix_ + ":" if (UseCapturedNS_ and self.Line_nsprefix_) else ""
            self.Line.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Line",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "Line":
            obj_ = GeometryCHLV95_V1_DirectedLine.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Line = obj_
            obj_.original_tagname_ = "Line"


# end class GeometryCHLV95_V1_DirectedLineStructure


class GeometryCHLV95_V1_MultiLine(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "Lines": MemberSpec_("Lines", "LinesType76", 0, 0, {"name": "Lines", "type": "LinesType76"}, None),
    }
    subclass = None
    superclass = None

    def __init__(self, Lines=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if Lines is None:
            self.Lines = globals()["LinesType76"]()
        else:
            self.Lines = Lines
        self.Lines_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, GeometryCHLV95_V1_MultiLine)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeometryCHLV95_V1_MultiLine.subclass:
            return GeometryCHLV95_V1_MultiLine.subclass(*args_, **kwargs_)
        else:
            return GeometryCHLV95_V1_MultiLine(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Lines(self):
        return self.Lines

    def set_Lines(self, Lines):
        self.Lines = Lines

    def _hasContent(self):
        if self.Lines is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV95_V1.MultiLine",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("GeometryCHLV95_V1.MultiLine")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "GeometryCHLV95_V1.MultiLine":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="GeometryCHLV95_V1.MultiLine",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="GeometryCHLV95_V1.MultiLine",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="GeometryCHLV95_V1.MultiLine",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV95_V1.MultiLine",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.Lines is not None:
            namespaceprefix_ = self.Lines_nsprefix_ + ":" if (UseCapturedNS_ and self.Lines_nsprefix_) else ""
            self.Lines.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Lines",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "Lines":
            obj_ = LinesType76.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Lines = obj_
            obj_.original_tagname_ = "Lines"


# end class GeometryCHLV95_V1_MultiLine


class GeometryCHLV95_V1_MultiDirectedLine(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "Lines": MemberSpec_("Lines", "LinesType77", 0, 0, {"name": "Lines", "type": "LinesType77"}, None),
    }
    subclass = None
    superclass = None

    def __init__(self, Lines=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if Lines is None:
            self.Lines = globals()["LinesType77"]()
        else:
            self.Lines = Lines
        self.Lines_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, GeometryCHLV95_V1_MultiDirectedLine)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeometryCHLV95_V1_MultiDirectedLine.subclass:
            return GeometryCHLV95_V1_MultiDirectedLine.subclass(*args_, **kwargs_)
        else:
            return GeometryCHLV95_V1_MultiDirectedLine(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Lines(self):
        return self.Lines

    def set_Lines(self, Lines):
        self.Lines = Lines

    def _hasContent(self):
        if self.Lines is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV95_V1.MultiDirectedLine",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("GeometryCHLV95_V1.MultiDirectedLine")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "GeometryCHLV95_V1.MultiDirectedLine":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="GeometryCHLV95_V1.MultiDirectedLine",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="GeometryCHLV95_V1.MultiDirectedLine",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="GeometryCHLV95_V1.MultiDirectedLine",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV95_V1.MultiDirectedLine",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.Lines is not None:
            namespaceprefix_ = self.Lines_nsprefix_ + ":" if (UseCapturedNS_ and self.Lines_nsprefix_) else ""
            self.Lines.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Lines",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "Lines":
            obj_ = LinesType77.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Lines = obj_
            obj_.original_tagname_ = "Lines"


# end class GeometryCHLV95_V1_MultiDirectedLine


class GeometryCHLV95_V1_SurfaceStructure(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "Surface": MemberSpec_(
            "Surface",
            "GeometryCHLV95_V1.Surface",
            0,
            1,
            {"minOccurs": "0", "name": "Surface", "type": "GeometryCHLV95_V1.Surface"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, Surface=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.Surface = Surface
        self.Surface_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, GeometryCHLV95_V1_SurfaceStructure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeometryCHLV95_V1_SurfaceStructure.subclass:
            return GeometryCHLV95_V1_SurfaceStructure.subclass(*args_, **kwargs_)
        else:
            return GeometryCHLV95_V1_SurfaceStructure(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Surface(self):
        return self.Surface

    def set_Surface(self, Surface):
        self.Surface = Surface

    def _hasContent(self):
        if self.Surface is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV95_V1.SurfaceStructure",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("GeometryCHLV95_V1.SurfaceStructure")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "GeometryCHLV95_V1.SurfaceStructure":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="GeometryCHLV95_V1.SurfaceStructure",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="GeometryCHLV95_V1.SurfaceStructure",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="GeometryCHLV95_V1.SurfaceStructure",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV95_V1.SurfaceStructure",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.Surface is not None:
            namespaceprefix_ = (
                self.Surface_nsprefix_ + ":" if (UseCapturedNS_ and self.Surface_nsprefix_) else ""
            )
            self.Surface.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Surface",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "Surface":
            obj_ = GeometryCHLV95_V1_Surface.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Surface = obj_
            obj_.original_tagname_ = "Surface"


# end class GeometryCHLV95_V1_SurfaceStructure


class GeometryCHLV95_V1_MultiSurface(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "Surfaces": MemberSpec_(
            "Surfaces",
            "SurfacesType78",
            0,
            0,
            {"name": "Surfaces", "type": "SurfacesType78"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, Surfaces=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if Surfaces is None:
            self.Surfaces = globals()["SurfacesType78"]()
        else:
            self.Surfaces = Surfaces
        self.Surfaces_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, GeometryCHLV95_V1_MultiSurface)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeometryCHLV95_V1_MultiSurface.subclass:
            return GeometryCHLV95_V1_MultiSurface.subclass(*args_, **kwargs_)
        else:
            return GeometryCHLV95_V1_MultiSurface(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Surfaces(self):
        return self.Surfaces

    def set_Surfaces(self, Surfaces):
        self.Surfaces = Surfaces

    def _hasContent(self):
        if self.Surfaces is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV95_V1.MultiSurface",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("GeometryCHLV95_V1.MultiSurface")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "GeometryCHLV95_V1.MultiSurface":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="GeometryCHLV95_V1.MultiSurface",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="GeometryCHLV95_V1.MultiSurface",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="GeometryCHLV95_V1.MultiSurface",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="GeometryCHLV95_V1.MultiSurface",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.Surfaces is not None:
            namespaceprefix_ = (
                self.Surfaces_nsprefix_ + ":" if (UseCapturedNS_ and self.Surfaces_nsprefix_) else ""
            )
            self.Surfaces.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Surfaces",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "Surfaces":
            obj_ = SurfacesType78.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Surfaces = obj_
            obj_.original_tagname_ = "Surfaces"


# end class GeometryCHLV95_V1_MultiSurface


class LocalisationCH_V1_LocalisedText(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "Language": MemberSpec_(
            "Language",
            ["InternationalCodes_V1.LanguageCode_ISO639_1", "xsd:string"],
            0,
            1,
            {"minOccurs": "0", "name": "Language", "type": "xsd:string"},
            None,
        ),
        "Text": MemberSpec_(
            "Text",
            ["TextType79", "xsd:normalizedString"],
            0,
            0,
            {"name": "Text", "type": "xsd:normalizedString"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, Language=None, Text=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.Language = Language
        self.validate_InternationalCodes_V1_LanguageCode_ISO639_1(self.Language)
        self.Language_nsprefix_ = None
        self.Text = Text
        self.validate_TextType79(self.Text)
        self.Text_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, LocalisationCH_V1_LocalisedText)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LocalisationCH_V1_LocalisedText.subclass:
            return LocalisationCH_V1_LocalisedText.subclass(*args_, **kwargs_)
        else:
            return LocalisationCH_V1_LocalisedText(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Language(self):
        return self.Language

    def set_Language(self, Language):
        self.Language = Language

    def get_Text(self):
        return self.Text

    def set_Text(self, Text):
        self.Text = Text

    def validate_InternationalCodes_V1_LanguageCode_ISO639_1(self, value):
        result = True
        # Validate type InternationalCodes_V1.LanguageCode_ISO639_1, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            value = value
            enumerations = [
                "de",
                "fr",
                "it",
                "rm",
                "en",
                "aa",
                "ab",
                "af",
                "am",
                "ar",
                "as",
                "ay",
                "az",
                "ba",
                "be",
                "bg",
                "bh",
                "bi",
                "bn",
                "bo",
                "br",
                "ca",
                "co",
                "cs",
                "cy",
                "da",
                "dz",
                "el",
                "eo",
                "es",
                "et",
                "eu",
                "fa",
                "fi",
                "fj",
                "fo",
                "fy",
                "ga",
                "gd",
                "gl",
                "gn",
                "gu",
                "ha",
                "he",
                "hi",
                "hr",
                "hu",
                "hy",
                "ia",
                "id",
                "ie",
                "ik",
                "is",
                "iu",
                "ja",
                "jw",
                "ka",
                "kk",
                "kl",
                "km",
                "kn",
                "ko",
                "ks",
                "ku",
                "ky",
                "la",
                "ln",
                "lo",
                "lt",
                "lv",
                "mg",
                "mi",
                "mk",
                "ml",
                "mn",
                "mo",
                "mr",
                "ms",
                "mt",
                "my",
                "na",
                "ne",
                "nl",
                "no",
                "oc",
                "om",
                "or",
                "pa",
                "pl",
                "ps",
                "pt",
                "qu",
                "rn",
                "ro",
                "ru",
                "rw",
                "sa",
                "sd",
                "sg",
                "sh",
                "si",
                "sk",
                "sl",
                "sm",
                "sn",
                "so",
                "sq",
                "sr",
                "ss",
                "st",
                "su",
                "sv",
                "sw",
                "ta",
                "te",
                "tg",
                "th",
                "ti",
                "tk",
                "tl",
                "tn",
                "to",
                "tr",
                "ts",
                "tt",
                "tw",
                "ug",
                "uk",
                "ur",
                "uz",
                "vi",
                "vo",
                "wo",
                "xh",
                "yi",
                "yo",
                "za",
                "zh",
                "zu",
            ]
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on InternationalCodes_V1.LanguageCode_ISO639_1'
                    % {"value": encode_str_2_3(value), "lineno": lineno}
                )
                result = False
        return result

    def validate_TextType79(self, value):
        result = True
        # Validate type TextType79, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            pass
        return result

    def _hasContent(self):
        if self.Language is not None or self.Text is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="LocalisationCH_V1.LocalisedText",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("LocalisationCH_V1.LocalisedText")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "LocalisationCH_V1.LocalisedText":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="LocalisationCH_V1.LocalisedText",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="LocalisationCH_V1.LocalisedText",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="LocalisationCH_V1.LocalisedText",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="LocalisationCH_V1.LocalisedText",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.Language is not None:
            namespaceprefix_ = (
                self.Language_nsprefix_ + ":" if (UseCapturedNS_ and self.Language_nsprefix_) else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sLanguage>%s</%sLanguage>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(self.gds_format_string(quote_xml(self.Language), input_name="Language")),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.Text is not None:
            namespaceprefix_ = self.Text_nsprefix_ + ":" if (UseCapturedNS_ and self.Text_nsprefix_) else ""
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sText>%s</%sText>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(self.gds_format_string(quote_xml(self.Text), input_name="Text")),
                    namespaceprefix_,
                    eol_,
                )
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "Language":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Language")
            value_ = self.gds_validate_string(value_, node, "Language")
            self.Language = value_
            self.Language_nsprefix_ = child_.prefix
            # validate type InternationalCodes_V1.LanguageCode_ISO639_1
            self.validate_InternationalCodes_V1_LanguageCode_ISO639_1(self.Language)
        elif nodeName_ == "Text":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Text")
            value_ = self.gds_validate_string(value_, node, "Text")
            self.Text = value_
            self.Text_nsprefix_ = child_.prefix
            # validate type TextType79
            self.validate_TextType79(self.Text)


# end class LocalisationCH_V1_LocalisedText


class LocalisationCH_V1_LocalisedMText(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "Language": MemberSpec_(
            "Language",
            ["InternationalCodes_V1.LanguageCode_ISO639_1", "xsd:string"],
            0,
            1,
            {"minOccurs": "0", "name": "Language", "type": "xsd:string"},
            None,
        ),
        "Text": MemberSpec_(
            "Text",
            ["TextType80", "xsd:string"],
            0,
            0,
            {"name": "Text", "type": "xsd:string"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, Language=None, Text=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.Language = Language
        self.validate_InternationalCodes_V1_LanguageCode_ISO639_1(self.Language)
        self.Language_nsprefix_ = None
        self.Text = Text
        self.validate_TextType80(self.Text)
        self.Text_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, LocalisationCH_V1_LocalisedMText)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LocalisationCH_V1_LocalisedMText.subclass:
            return LocalisationCH_V1_LocalisedMText.subclass(*args_, **kwargs_)
        else:
            return LocalisationCH_V1_LocalisedMText(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Language(self):
        return self.Language

    def set_Language(self, Language):
        self.Language = Language

    def get_Text(self):
        return self.Text

    def set_Text(self, Text):
        self.Text = Text

    def validate_InternationalCodes_V1_LanguageCode_ISO639_1(self, value):
        result = True
        # Validate type InternationalCodes_V1.LanguageCode_ISO639_1, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            value = value
            enumerations = [
                "de",
                "fr",
                "it",
                "rm",
                "en",
                "aa",
                "ab",
                "af",
                "am",
                "ar",
                "as",
                "ay",
                "az",
                "ba",
                "be",
                "bg",
                "bh",
                "bi",
                "bn",
                "bo",
                "br",
                "ca",
                "co",
                "cs",
                "cy",
                "da",
                "dz",
                "el",
                "eo",
                "es",
                "et",
                "eu",
                "fa",
                "fi",
                "fj",
                "fo",
                "fy",
                "ga",
                "gd",
                "gl",
                "gn",
                "gu",
                "ha",
                "he",
                "hi",
                "hr",
                "hu",
                "hy",
                "ia",
                "id",
                "ie",
                "ik",
                "is",
                "iu",
                "ja",
                "jw",
                "ka",
                "kk",
                "kl",
                "km",
                "kn",
                "ko",
                "ks",
                "ku",
                "ky",
                "la",
                "ln",
                "lo",
                "lt",
                "lv",
                "mg",
                "mi",
                "mk",
                "ml",
                "mn",
                "mo",
                "mr",
                "ms",
                "mt",
                "my",
                "na",
                "ne",
                "nl",
                "no",
                "oc",
                "om",
                "or",
                "pa",
                "pl",
                "ps",
                "pt",
                "qu",
                "rn",
                "ro",
                "ru",
                "rw",
                "sa",
                "sd",
                "sg",
                "sh",
                "si",
                "sk",
                "sl",
                "sm",
                "sn",
                "so",
                "sq",
                "sr",
                "ss",
                "st",
                "su",
                "sv",
                "sw",
                "ta",
                "te",
                "tg",
                "th",
                "ti",
                "tk",
                "tl",
                "tn",
                "to",
                "tr",
                "ts",
                "tt",
                "tw",
                "ug",
                "uk",
                "ur",
                "uz",
                "vi",
                "vo",
                "wo",
                "xh",
                "yi",
                "yo",
                "za",
                "zh",
                "zu",
            ]
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on InternationalCodes_V1.LanguageCode_ISO639_1'
                    % {"value": encode_str_2_3(value), "lineno": lineno}
                )
                result = False
        return result

    def validate_TextType80(self, value):
        result = True
        # Validate type TextType80, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            pass
        return result

    def _hasContent(self):
        if self.Language is not None or self.Text is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="LocalisationCH_V1.LocalisedMText",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("LocalisationCH_V1.LocalisedMText")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "LocalisationCH_V1.LocalisedMText":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="LocalisationCH_V1.LocalisedMText",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="LocalisationCH_V1.LocalisedMText",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="LocalisationCH_V1.LocalisedMText",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="LocalisationCH_V1.LocalisedMText",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.Language is not None:
            namespaceprefix_ = (
                self.Language_nsprefix_ + ":" if (UseCapturedNS_ and self.Language_nsprefix_) else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sLanguage>%s</%sLanguage>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(self.gds_format_string(quote_xml(self.Language), input_name="Language")),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.Text is not None:
            namespaceprefix_ = self.Text_nsprefix_ + ":" if (UseCapturedNS_ and self.Text_nsprefix_) else ""
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sText>%s</%sText>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(self.gds_format_string(quote_xml(self.Text), input_name="Text")),
                    namespaceprefix_,
                    eol_,
                )
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "Language":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Language")
            value_ = self.gds_validate_string(value_, node, "Language")
            self.Language = value_
            self.Language_nsprefix_ = child_.prefix
            # validate type InternationalCodes_V1.LanguageCode_ISO639_1
            self.validate_InternationalCodes_V1_LanguageCode_ISO639_1(self.Language)
        elif nodeName_ == "Text":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Text")
            value_ = self.gds_validate_string(value_, node, "Text")
            self.Text = value_
            self.Text_nsprefix_ = child_.prefix
            # validate type TextType80
            self.validate_TextType80(self.Text)


# end class LocalisationCH_V1_LocalisedMText


class LocalisationCH_V1_MultilingualText(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "LocalisedText": MemberSpec_(
            "LocalisedText",
            "LocalisedTextType",
            0,
            0,
            {"name": "LocalisedText", "type": "LocalisedTextType"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, LocalisedText=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if LocalisedText is None:
            self.LocalisedText = globals()["LocalisedTextType"]()
        else:
            self.LocalisedText = LocalisedText
        self.LocalisedText_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, LocalisationCH_V1_MultilingualText)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LocalisationCH_V1_MultilingualText.subclass:
            return LocalisationCH_V1_MultilingualText.subclass(*args_, **kwargs_)
        else:
            return LocalisationCH_V1_MultilingualText(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_LocalisedText(self):
        return self.LocalisedText

    def set_LocalisedText(self, LocalisedText):
        self.LocalisedText = LocalisedText

    def _hasContent(self):
        if self.LocalisedText is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="LocalisationCH_V1.MultilingualText",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("LocalisationCH_V1.MultilingualText")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "LocalisationCH_V1.MultilingualText":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="LocalisationCH_V1.MultilingualText",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="LocalisationCH_V1.MultilingualText",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="LocalisationCH_V1.MultilingualText",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="LocalisationCH_V1.MultilingualText",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.LocalisedText is not None:
            namespaceprefix_ = (
                self.LocalisedText_nsprefix_ + ":"
                if (UseCapturedNS_ and self.LocalisedText_nsprefix_)
                else ""
            )
            self.LocalisedText.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="LocalisedText",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "LocalisedText":
            obj_ = LocalisedTextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LocalisedText = obj_
            obj_.original_tagname_ = "LocalisedText"


# end class LocalisationCH_V1_MultilingualText


class LocalisationCH_V1_MultilingualMText(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "LocalisedText": MemberSpec_(
            "LocalisedText",
            "LocalisedTextType81",
            0,
            0,
            {"name": "LocalisedText", "type": "LocalisedTextType81"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, LocalisedText=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if LocalisedText is None:
            self.LocalisedText = globals()["LocalisedTextType81"]()
        else:
            self.LocalisedText = LocalisedText
        self.LocalisedText_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, LocalisationCH_V1_MultilingualMText)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LocalisationCH_V1_MultilingualMText.subclass:
            return LocalisationCH_V1_MultilingualMText.subclass(*args_, **kwargs_)
        else:
            return LocalisationCH_V1_MultilingualMText(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_LocalisedText(self):
        return self.LocalisedText

    def set_LocalisedText(self, LocalisedText):
        self.LocalisedText = LocalisedText

    def _hasContent(self):
        if self.LocalisedText is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="LocalisationCH_V1.MultilingualMText",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("LocalisationCH_V1.MultilingualMText")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "LocalisationCH_V1.MultilingualMText":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="LocalisationCH_V1.MultilingualMText",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="LocalisationCH_V1.MultilingualMText",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="LocalisationCH_V1.MultilingualMText",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="LocalisationCH_V1.MultilingualMText",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.LocalisedText is not None:
            namespaceprefix_ = (
                self.LocalisedText_nsprefix_ + ":"
                if (UseCapturedNS_ and self.LocalisedText_nsprefix_)
                else ""
            )
            self.LocalisedText.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="LocalisedText",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "LocalisedText":
            obj_ = LocalisedTextType81.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LocalisedText = obj_
            obj_.original_tagname_ = "LocalisedText"


# end class LocalisationCH_V1_MultilingualMText


class Localisation_V1_LocalisedText(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "Language": MemberSpec_(
            "Language",
            ["InternationalCodes_V1.LanguageCode_ISO639_1", "xsd:string"],
            0,
            1,
            {"minOccurs": "0", "name": "Language", "type": "xsd:string"},
            None,
        ),
        "Text": MemberSpec_(
            "Text",
            ["TextType82", "xsd:normalizedString"],
            0,
            0,
            {"name": "Text", "type": "xsd:normalizedString"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, Language=None, Text=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.Language = Language
        self.validate_InternationalCodes_V1_LanguageCode_ISO639_1(self.Language)
        self.Language_nsprefix_ = None
        self.Text = Text
        self.validate_TextType82(self.Text)
        self.Text_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, Localisation_V1_LocalisedText)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Localisation_V1_LocalisedText.subclass:
            return Localisation_V1_LocalisedText.subclass(*args_, **kwargs_)
        else:
            return Localisation_V1_LocalisedText(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Language(self):
        return self.Language

    def set_Language(self, Language):
        self.Language = Language

    def get_Text(self):
        return self.Text

    def set_Text(self, Text):
        self.Text = Text

    def validate_InternationalCodes_V1_LanguageCode_ISO639_1(self, value):
        result = True
        # Validate type InternationalCodes_V1.LanguageCode_ISO639_1, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            value = value
            enumerations = [
                "de",
                "fr",
                "it",
                "rm",
                "en",
                "aa",
                "ab",
                "af",
                "am",
                "ar",
                "as",
                "ay",
                "az",
                "ba",
                "be",
                "bg",
                "bh",
                "bi",
                "bn",
                "bo",
                "br",
                "ca",
                "co",
                "cs",
                "cy",
                "da",
                "dz",
                "el",
                "eo",
                "es",
                "et",
                "eu",
                "fa",
                "fi",
                "fj",
                "fo",
                "fy",
                "ga",
                "gd",
                "gl",
                "gn",
                "gu",
                "ha",
                "he",
                "hi",
                "hr",
                "hu",
                "hy",
                "ia",
                "id",
                "ie",
                "ik",
                "is",
                "iu",
                "ja",
                "jw",
                "ka",
                "kk",
                "kl",
                "km",
                "kn",
                "ko",
                "ks",
                "ku",
                "ky",
                "la",
                "ln",
                "lo",
                "lt",
                "lv",
                "mg",
                "mi",
                "mk",
                "ml",
                "mn",
                "mo",
                "mr",
                "ms",
                "mt",
                "my",
                "na",
                "ne",
                "nl",
                "no",
                "oc",
                "om",
                "or",
                "pa",
                "pl",
                "ps",
                "pt",
                "qu",
                "rn",
                "ro",
                "ru",
                "rw",
                "sa",
                "sd",
                "sg",
                "sh",
                "si",
                "sk",
                "sl",
                "sm",
                "sn",
                "so",
                "sq",
                "sr",
                "ss",
                "st",
                "su",
                "sv",
                "sw",
                "ta",
                "te",
                "tg",
                "th",
                "ti",
                "tk",
                "tl",
                "tn",
                "to",
                "tr",
                "ts",
                "tt",
                "tw",
                "ug",
                "uk",
                "ur",
                "uz",
                "vi",
                "vo",
                "wo",
                "xh",
                "yi",
                "yo",
                "za",
                "zh",
                "zu",
            ]
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on InternationalCodes_V1.LanguageCode_ISO639_1'
                    % {"value": encode_str_2_3(value), "lineno": lineno}
                )
                result = False
        return result

    def validate_TextType82(self, value):
        result = True
        # Validate type TextType82, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            pass
        return result

    def _hasContent(self):
        if self.Language is not None or self.Text is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="Localisation_V1.LocalisedText",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("Localisation_V1.LocalisedText")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "Localisation_V1.LocalisedText":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="Localisation_V1.LocalisedText",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="Localisation_V1.LocalisedText",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="Localisation_V1.LocalisedText",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="Localisation_V1.LocalisedText",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.Language is not None:
            namespaceprefix_ = (
                self.Language_nsprefix_ + ":" if (UseCapturedNS_ and self.Language_nsprefix_) else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sLanguage>%s</%sLanguage>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(self.gds_format_string(quote_xml(self.Language), input_name="Language")),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.Text is not None:
            namespaceprefix_ = self.Text_nsprefix_ + ":" if (UseCapturedNS_ and self.Text_nsprefix_) else ""
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sText>%s</%sText>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(self.gds_format_string(quote_xml(self.Text), input_name="Text")),
                    namespaceprefix_,
                    eol_,
                )
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "Language":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Language")
            value_ = self.gds_validate_string(value_, node, "Language")
            self.Language = value_
            self.Language_nsprefix_ = child_.prefix
            # validate type InternationalCodes_V1.LanguageCode_ISO639_1
            self.validate_InternationalCodes_V1_LanguageCode_ISO639_1(self.Language)
        elif nodeName_ == "Text":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Text")
            value_ = self.gds_validate_string(value_, node, "Text")
            self.Text = value_
            self.Text_nsprefix_ = child_.prefix
            # validate type TextType82
            self.validate_TextType82(self.Text)


# end class Localisation_V1_LocalisedText


class Localisation_V1_LocalisedMText(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "Language": MemberSpec_(
            "Language",
            ["InternationalCodes_V1.LanguageCode_ISO639_1", "xsd:string"],
            0,
            1,
            {"minOccurs": "0", "name": "Language", "type": "xsd:string"},
            None,
        ),
        "Text": MemberSpec_(
            "Text",
            ["TextType83", "xsd:string"],
            0,
            0,
            {"name": "Text", "type": "xsd:string"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, Language=None, Text=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.Language = Language
        self.validate_InternationalCodes_V1_LanguageCode_ISO639_1(self.Language)
        self.Language_nsprefix_ = None
        self.Text = Text
        self.validate_TextType83(self.Text)
        self.Text_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, Localisation_V1_LocalisedMText)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Localisation_V1_LocalisedMText.subclass:
            return Localisation_V1_LocalisedMText.subclass(*args_, **kwargs_)
        else:
            return Localisation_V1_LocalisedMText(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Language(self):
        return self.Language

    def set_Language(self, Language):
        self.Language = Language

    def get_Text(self):
        return self.Text

    def set_Text(self, Text):
        self.Text = Text

    def validate_InternationalCodes_V1_LanguageCode_ISO639_1(self, value):
        result = True
        # Validate type InternationalCodes_V1.LanguageCode_ISO639_1, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            value = value
            enumerations = [
                "de",
                "fr",
                "it",
                "rm",
                "en",
                "aa",
                "ab",
                "af",
                "am",
                "ar",
                "as",
                "ay",
                "az",
                "ba",
                "be",
                "bg",
                "bh",
                "bi",
                "bn",
                "bo",
                "br",
                "ca",
                "co",
                "cs",
                "cy",
                "da",
                "dz",
                "el",
                "eo",
                "es",
                "et",
                "eu",
                "fa",
                "fi",
                "fj",
                "fo",
                "fy",
                "ga",
                "gd",
                "gl",
                "gn",
                "gu",
                "ha",
                "he",
                "hi",
                "hr",
                "hu",
                "hy",
                "ia",
                "id",
                "ie",
                "ik",
                "is",
                "iu",
                "ja",
                "jw",
                "ka",
                "kk",
                "kl",
                "km",
                "kn",
                "ko",
                "ks",
                "ku",
                "ky",
                "la",
                "ln",
                "lo",
                "lt",
                "lv",
                "mg",
                "mi",
                "mk",
                "ml",
                "mn",
                "mo",
                "mr",
                "ms",
                "mt",
                "my",
                "na",
                "ne",
                "nl",
                "no",
                "oc",
                "om",
                "or",
                "pa",
                "pl",
                "ps",
                "pt",
                "qu",
                "rn",
                "ro",
                "ru",
                "rw",
                "sa",
                "sd",
                "sg",
                "sh",
                "si",
                "sk",
                "sl",
                "sm",
                "sn",
                "so",
                "sq",
                "sr",
                "ss",
                "st",
                "su",
                "sv",
                "sw",
                "ta",
                "te",
                "tg",
                "th",
                "ti",
                "tk",
                "tl",
                "tn",
                "to",
                "tr",
                "ts",
                "tt",
                "tw",
                "ug",
                "uk",
                "ur",
                "uz",
                "vi",
                "vo",
                "wo",
                "xh",
                "yi",
                "yo",
                "za",
                "zh",
                "zu",
            ]
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on InternationalCodes_V1.LanguageCode_ISO639_1'
                    % {"value": encode_str_2_3(value), "lineno": lineno}
                )
                result = False
        return result

    def validate_TextType83(self, value):
        result = True
        # Validate type TextType83, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            pass
        return result

    def _hasContent(self):
        if self.Language is not None or self.Text is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="Localisation_V1.LocalisedMText",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("Localisation_V1.LocalisedMText")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "Localisation_V1.LocalisedMText":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="Localisation_V1.LocalisedMText",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="Localisation_V1.LocalisedMText",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="Localisation_V1.LocalisedMText",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="Localisation_V1.LocalisedMText",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.Language is not None:
            namespaceprefix_ = (
                self.Language_nsprefix_ + ":" if (UseCapturedNS_ and self.Language_nsprefix_) else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sLanguage>%s</%sLanguage>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(self.gds_format_string(quote_xml(self.Language), input_name="Language")),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.Text is not None:
            namespaceprefix_ = self.Text_nsprefix_ + ":" if (UseCapturedNS_ and self.Text_nsprefix_) else ""
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sText>%s</%sText>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(self.gds_format_string(quote_xml(self.Text), input_name="Text")),
                    namespaceprefix_,
                    eol_,
                )
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "Language":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Language")
            value_ = self.gds_validate_string(value_, node, "Language")
            self.Language = value_
            self.Language_nsprefix_ = child_.prefix
            # validate type InternationalCodes_V1.LanguageCode_ISO639_1
            self.validate_InternationalCodes_V1_LanguageCode_ISO639_1(self.Language)
        elif nodeName_ == "Text":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Text")
            value_ = self.gds_validate_string(value_, node, "Text")
            self.Text = value_
            self.Text_nsprefix_ = child_.prefix
            # validate type TextType83
            self.validate_TextType83(self.Text)


# end class Localisation_V1_LocalisedMText


class Localisation_V1_MultilingualText(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "LocalisedText": MemberSpec_(
            "LocalisedText",
            "LocalisedTextType84",
            0,
            0,
            {"name": "LocalisedText", "type": "LocalisedTextType84"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, LocalisedText=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if LocalisedText is None:
            self.LocalisedText = globals()["LocalisedTextType84"]()
        else:
            self.LocalisedText = LocalisedText
        self.LocalisedText_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, Localisation_V1_MultilingualText)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Localisation_V1_MultilingualText.subclass:
            return Localisation_V1_MultilingualText.subclass(*args_, **kwargs_)
        else:
            return Localisation_V1_MultilingualText(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_LocalisedText(self):
        return self.LocalisedText

    def set_LocalisedText(self, LocalisedText):
        self.LocalisedText = LocalisedText

    def _hasContent(self):
        if self.LocalisedText is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="Localisation_V1.MultilingualText",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("Localisation_V1.MultilingualText")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "Localisation_V1.MultilingualText":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="Localisation_V1.MultilingualText",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="Localisation_V1.MultilingualText",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="Localisation_V1.MultilingualText",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="Localisation_V1.MultilingualText",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.LocalisedText is not None:
            namespaceprefix_ = (
                self.LocalisedText_nsprefix_ + ":"
                if (UseCapturedNS_ and self.LocalisedText_nsprefix_)
                else ""
            )
            self.LocalisedText.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="LocalisedText",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "LocalisedText":
            obj_ = LocalisedTextType84.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LocalisedText = obj_
            obj_.original_tagname_ = "LocalisedText"


# end class Localisation_V1_MultilingualText


class Localisation_V1_MultilingualMText(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "LocalisedText": MemberSpec_(
            "LocalisedText",
            "LocalisedTextType85",
            0,
            0,
            {"name": "LocalisedText", "type": "LocalisedTextType85"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, LocalisedText=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if LocalisedText is None:
            self.LocalisedText = globals()["LocalisedTextType85"]()
        else:
            self.LocalisedText = LocalisedText
        self.LocalisedText_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, Localisation_V1_MultilingualMText)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Localisation_V1_MultilingualMText.subclass:
            return Localisation_V1_MultilingualMText.subclass(*args_, **kwargs_)
        else:
            return Localisation_V1_MultilingualMText(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_LocalisedText(self):
        return self.LocalisedText

    def set_LocalisedText(self, LocalisedText):
        self.LocalisedText = LocalisedText

    def _hasContent(self):
        if self.LocalisedText is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="Localisation_V1.MultilingualMText",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("Localisation_V1.MultilingualMText")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "Localisation_V1.MultilingualMText":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="Localisation_V1.MultilingualMText",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="Localisation_V1.MultilingualMText",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="Localisation_V1.MultilingualMText",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="Localisation_V1.MultilingualMText",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.LocalisedText is not None:
            namespaceprefix_ = (
                self.LocalisedText_nsprefix_ + ":"
                if (UseCapturedNS_ and self.LocalisedText_nsprefix_)
                else ""
            )
            self.LocalisedText.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="LocalisedText",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "LocalisedText":
            obj_ = LocalisedTextType85.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LocalisedText = obj_
            obj_.original_tagname_ = "LocalisedText"


# end class Localisation_V1_MultilingualMText


class OeREBKRM_V2_0_OEREBOID(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "OID": MemberSpec_("OID", "IliID", 0, 0, {"use": "required", "name": "OID"}),
    }
    subclass = None
    superclass = None

    def __init__(self, OID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.OID = _cast(None, OID)
        self.OID_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, OeREBKRM_V2_0_OEREBOID)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OeREBKRM_V2_0_OEREBOID.subclass:
            return OeREBKRM_V2_0_OEREBOID.subclass(*args_, **kwargs_)
        else:
            return OeREBKRM_V2_0_OEREBOID(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_OID(self):
        return self.OID

    def set_OID(self, OID):
        self.OID = OID

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if ():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="OeREBKRM_V2_0.OEREBOID",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("OeREBKRM_V2_0.OEREBOID")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "OeREBKRM_V2_0.OEREBOID":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="OeREBKRM_V2_0.OEREBOID",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="OeREBKRM_V2_0.OEREBOID",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="OeREBKRM_V2_0.OEREBOID",
    ):
        if self.OID is not None and "OID" not in already_processed:
            already_processed.add("OID")
            outfile.write(
                " OID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.OID), input_name="OID")),)
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="OeREBKRM_V2_0.OEREBOID",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("OID", node)
        if value is not None and "OID" not in already_processed:
            already_processed.add("OID")
            self.OID = value
            self.validate_IliID(self.OID)  # validate type IliID

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class OeREBKRM_V2_0_OEREBOID


class OeREBKRM_V2_0_ArtikelNummer_(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "value": MemberSpec_(
            "value",
            ["OeREBKRM_V2_0.ArtikelNummer", "xsd:normalizedString"],
            0,
            0,
            {"name": "value", "type": "xsd:normalizedString"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        self.validate_OeREBKRM_V2_0_ArtikelNummer(self.value)
        self.value_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, OeREBKRM_V2_0_ArtikelNummer_)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OeREBKRM_V2_0_ArtikelNummer_.subclass:
            return OeREBKRM_V2_0_ArtikelNummer_.subclass(*args_, **kwargs_)
        else:
            return OeREBKRM_V2_0_ArtikelNummer_(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def validate_OeREBKRM_V2_0_ArtikelNummer(self, value):
        result = True
        # Validate type OeREBKRM_V2_0.ArtikelNummer, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on OeREBKRM_V2_0.ArtikelNummer'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def _hasContent(self):
        if self.value is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="OeREBKRM_V2_0.ArtikelNummer_",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("OeREBKRM_V2_0.ArtikelNummer_")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "OeREBKRM_V2_0.ArtikelNummer_":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="OeREBKRM_V2_0.ArtikelNummer_",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="OeREBKRM_V2_0.ArtikelNummer_",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="OeREBKRM_V2_0.ArtikelNummer_",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="OeREBKRM_V2_0.ArtikelNummer_",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.value is not None:
            namespaceprefix_ = self.value_nsprefix_ + ":" if (UseCapturedNS_ and self.value_nsprefix_) else ""
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%svalue>%s</%svalue>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(self.gds_format_string(quote_xml(self.value), input_name="value")),
                    namespaceprefix_,
                    eol_,
                )
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "value":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "value")
            value_ = self.gds_validate_string(value_, node, "value")
            self.value = value_
            self.value_nsprefix_ = child_.prefix
            # validate type OeREBKRM_V2_0.ArtikelNummer
            self.validate_OeREBKRM_V2_0_ArtikelNummer(self.value)


# end class OeREBKRM_V2_0_ArtikelNummer_


class OeREBKRM_V2_0_Datum_(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "value": MemberSpec_(
            "value",
            ["OeREBKRM_V2_0.Datum", "xsd:date"],
            0,
            0,
            {"name": "value", "type": "xsd:date"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if isinstance(value, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(value, "%Y-%m-%d").date()
        else:
            initvalue_ = value
        self.value = initvalue_
        self.value_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, OeREBKRM_V2_0_Datum_)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OeREBKRM_V2_0_Datum_.subclass:
            return OeREBKRM_V2_0_Datum_.subclass(*args_, **kwargs_)
        else:
            return OeREBKRM_V2_0_Datum_(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def validate_OeREBKRM_V2_0_Datum(self, value):
        result = True
        # Validate type OeREBKRM_V2_0.Datum, a restriction on xsd:date.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.date):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.date)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if value < self.gds_parse_date("1848-01-01"):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on OeREBKRM_V2_0.Datum'
                    % {"value": value, "lineno": lineno}
                )
                result = False
            if value > self.gds_parse_date("2100-12-31"):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on OeREBKRM_V2_0.Datum'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def _hasContent(self):
        if self.value is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="OeREBKRM_V2_0.Datum_",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("OeREBKRM_V2_0.Datum_")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "OeREBKRM_V2_0.Datum_":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="OeREBKRM_V2_0.Datum_",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="OeREBKRM_V2_0.Datum_",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="OeREBKRM_V2_0.Datum_",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="OeREBKRM_V2_0.Datum_",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.value is not None:
            namespaceprefix_ = self.value_nsprefix_ + ":" if (UseCapturedNS_ and self.value_nsprefix_) else ""
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%svalue>%s</%svalue>%s"
                % (
                    namespaceprefix_,
                    self.gds_format_date(self.value, input_name="value"),
                    namespaceprefix_,
                    eol_,
                )
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "value":
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.value = dval_
            self.value_nsprefix_ = child_.prefix
            # validate type OeREBKRM_V2_0.Datum
            self.validate_OeREBKRM_V2_0_Datum(self.value)


# end class OeREBKRM_V2_0_Datum_


class OeREBKRM_V2_0_Thema_(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "value": MemberSpec_(
            "value",
            ["OeREBKRM_V2_0.Thema", "xsd:normalizedString"],
            0,
            0,
            {"name": "value", "type": "xsd:normalizedString"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.value = value
        self.validate_OeREBKRM_V2_0_Thema(self.value)
        self.value_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, OeREBKRM_V2_0_Thema_)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OeREBKRM_V2_0_Thema_.subclass:
            return OeREBKRM_V2_0_Thema_.subclass(*args_, **kwargs_)
        else:
            return OeREBKRM_V2_0_Thema_(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def validate_OeREBKRM_V2_0_Thema(self, value):
        result = True
        # Validate type OeREBKRM_V2_0.Thema, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if len(value) > 120:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on OeREBKRM_V2_0.Thema'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def _hasContent(self):
        if self.value is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="OeREBKRM_V2_0.Thema_",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("OeREBKRM_V2_0.Thema_")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "OeREBKRM_V2_0.Thema_":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="OeREBKRM_V2_0.Thema_",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="OeREBKRM_V2_0.Thema_",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="OeREBKRM_V2_0.Thema_",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="OeREBKRM_V2_0.Thema_",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.value is not None:
            namespaceprefix_ = self.value_nsprefix_ + ":" if (UseCapturedNS_ and self.value_nsprefix_) else ""
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%svalue>%s</%svalue>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(self.gds_format_string(quote_xml(self.value), input_name="value")),
                    namespaceprefix_,
                    eol_,
                )
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "value":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "value")
            value_ = self.gds_validate_string(value_, node, "value")
            self.value = value_
            self.value_nsprefix_ = child_.prefix
            # validate type OeREBKRM_V2_0.Thema
            self.validate_OeREBKRM_V2_0_Thema(self.value)


# end class OeREBKRM_V2_0_Thema_


class OeREBKRM_V2_0_LocalisedBlob(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "Language": MemberSpec_(
            "Language",
            ["InternationalCodes_V1.LanguageCode_ISO639_1", "xsd:string"],
            0,
            1,
            {"minOccurs": "0", "name": "Language", "type": "xsd:string"},
            None,
        ),
        "Blob": MemberSpec_("Blob", "BlobType", 0, 0, {"name": "Blob", "type": "BlobType"}, None),
    }
    subclass = None
    superclass = None

    def __init__(self, Language=None, Blob=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.Language = Language
        self.validate_InternationalCodes_V1_LanguageCode_ISO639_1(self.Language)
        self.Language_nsprefix_ = None
        if Blob is None:
            self.Blob = globals()["BlobType"]()
        else:
            self.Blob = Blob
        self.Blob_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, OeREBKRM_V2_0_LocalisedBlob)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OeREBKRM_V2_0_LocalisedBlob.subclass:
            return OeREBKRM_V2_0_LocalisedBlob.subclass(*args_, **kwargs_)
        else:
            return OeREBKRM_V2_0_LocalisedBlob(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Language(self):
        return self.Language

    def set_Language(self, Language):
        self.Language = Language

    def get_Blob(self):
        return self.Blob

    def set_Blob(self, Blob):
        self.Blob = Blob

    def validate_InternationalCodes_V1_LanguageCode_ISO639_1(self, value):
        result = True
        # Validate type InternationalCodes_V1.LanguageCode_ISO639_1, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            value = value
            enumerations = [
                "de",
                "fr",
                "it",
                "rm",
                "en",
                "aa",
                "ab",
                "af",
                "am",
                "ar",
                "as",
                "ay",
                "az",
                "ba",
                "be",
                "bg",
                "bh",
                "bi",
                "bn",
                "bo",
                "br",
                "ca",
                "co",
                "cs",
                "cy",
                "da",
                "dz",
                "el",
                "eo",
                "es",
                "et",
                "eu",
                "fa",
                "fi",
                "fj",
                "fo",
                "fy",
                "ga",
                "gd",
                "gl",
                "gn",
                "gu",
                "ha",
                "he",
                "hi",
                "hr",
                "hu",
                "hy",
                "ia",
                "id",
                "ie",
                "ik",
                "is",
                "iu",
                "ja",
                "jw",
                "ka",
                "kk",
                "kl",
                "km",
                "kn",
                "ko",
                "ks",
                "ku",
                "ky",
                "la",
                "ln",
                "lo",
                "lt",
                "lv",
                "mg",
                "mi",
                "mk",
                "ml",
                "mn",
                "mo",
                "mr",
                "ms",
                "mt",
                "my",
                "na",
                "ne",
                "nl",
                "no",
                "oc",
                "om",
                "or",
                "pa",
                "pl",
                "ps",
                "pt",
                "qu",
                "rn",
                "ro",
                "ru",
                "rw",
                "sa",
                "sd",
                "sg",
                "sh",
                "si",
                "sk",
                "sl",
                "sm",
                "sn",
                "so",
                "sq",
                "sr",
                "ss",
                "st",
                "su",
                "sv",
                "sw",
                "ta",
                "te",
                "tg",
                "th",
                "ti",
                "tk",
                "tl",
                "tn",
                "to",
                "tr",
                "ts",
                "tt",
                "tw",
                "ug",
                "uk",
                "ur",
                "uz",
                "vi",
                "vo",
                "wo",
                "xh",
                "yi",
                "yo",
                "za",
                "zh",
                "zu",
            ]
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on InternationalCodes_V1.LanguageCode_ISO639_1'
                    % {"value": encode_str_2_3(value), "lineno": lineno}
                )
                result = False
        return result

    def _hasContent(self):
        if self.Language is not None or self.Blob is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="OeREBKRM_V2_0.LocalisedBlob",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("OeREBKRM_V2_0.LocalisedBlob")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "OeREBKRM_V2_0.LocalisedBlob":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="OeREBKRM_V2_0.LocalisedBlob",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="OeREBKRM_V2_0.LocalisedBlob",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="OeREBKRM_V2_0.LocalisedBlob",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="OeREBKRM_V2_0.LocalisedBlob",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.Language is not None:
            namespaceprefix_ = (
                self.Language_nsprefix_ + ":" if (UseCapturedNS_ and self.Language_nsprefix_) else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sLanguage>%s</%sLanguage>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(self.gds_format_string(quote_xml(self.Language), input_name="Language")),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.Blob is not None:
            namespaceprefix_ = self.Blob_nsprefix_ + ":" if (UseCapturedNS_ and self.Blob_nsprefix_) else ""
            self.Blob.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Blob",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "Language":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Language")
            value_ = self.gds_validate_string(value_, node, "Language")
            self.Language = value_
            self.Language_nsprefix_ = child_.prefix
            # validate type InternationalCodes_V1.LanguageCode_ISO639_1
            self.validate_InternationalCodes_V1_LanguageCode_ISO639_1(self.Language)
        elif nodeName_ == "Blob":
            obj_ = BlobType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Blob = obj_
            obj_.original_tagname_ = "Blob"


# end class OeREBKRM_V2_0_LocalisedBlob


class OeREBKRM_V2_0_LocalisedUri(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "Language": MemberSpec_(
            "Language",
            ["InternationalCodes_V1.LanguageCode_ISO639_1", "xsd:string"],
            0,
            1,
            {"minOccurs": "0", "name": "Language", "type": "xsd:string"},
            None,
        ),
        "Text": MemberSpec_(
            "Text",
            ["INTERLIS.URI", "xsd:normalizedString"],
            0,
            0,
            {"name": "Text", "type": "xsd:normalizedString"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, Language=None, Text=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.Language = Language
        self.validate_InternationalCodes_V1_LanguageCode_ISO639_1(self.Language)
        self.Language_nsprefix_ = None
        self.Text = Text
        self.validate_INTERLIS_URI(self.Text)
        self.Text_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, OeREBKRM_V2_0_LocalisedUri)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OeREBKRM_V2_0_LocalisedUri.subclass:
            return OeREBKRM_V2_0_LocalisedUri.subclass(*args_, **kwargs_)
        else:
            return OeREBKRM_V2_0_LocalisedUri(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Language(self):
        return self.Language

    def set_Language(self, Language):
        self.Language = Language

    def get_Text(self):
        return self.Text

    def set_Text(self, Text):
        self.Text = Text

    def validate_InternationalCodes_V1_LanguageCode_ISO639_1(self, value):
        result = True
        # Validate type InternationalCodes_V1.LanguageCode_ISO639_1, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            value = value
            enumerations = [
                "de",
                "fr",
                "it",
                "rm",
                "en",
                "aa",
                "ab",
                "af",
                "am",
                "ar",
                "as",
                "ay",
                "az",
                "ba",
                "be",
                "bg",
                "bh",
                "bi",
                "bn",
                "bo",
                "br",
                "ca",
                "co",
                "cs",
                "cy",
                "da",
                "dz",
                "el",
                "eo",
                "es",
                "et",
                "eu",
                "fa",
                "fi",
                "fj",
                "fo",
                "fy",
                "ga",
                "gd",
                "gl",
                "gn",
                "gu",
                "ha",
                "he",
                "hi",
                "hr",
                "hu",
                "hy",
                "ia",
                "id",
                "ie",
                "ik",
                "is",
                "iu",
                "ja",
                "jw",
                "ka",
                "kk",
                "kl",
                "km",
                "kn",
                "ko",
                "ks",
                "ku",
                "ky",
                "la",
                "ln",
                "lo",
                "lt",
                "lv",
                "mg",
                "mi",
                "mk",
                "ml",
                "mn",
                "mo",
                "mr",
                "ms",
                "mt",
                "my",
                "na",
                "ne",
                "nl",
                "no",
                "oc",
                "om",
                "or",
                "pa",
                "pl",
                "ps",
                "pt",
                "qu",
                "rn",
                "ro",
                "ru",
                "rw",
                "sa",
                "sd",
                "sg",
                "sh",
                "si",
                "sk",
                "sl",
                "sm",
                "sn",
                "so",
                "sq",
                "sr",
                "ss",
                "st",
                "su",
                "sv",
                "sw",
                "ta",
                "te",
                "tg",
                "th",
                "ti",
                "tk",
                "tl",
                "tn",
                "to",
                "tr",
                "ts",
                "tt",
                "tw",
                "ug",
                "uk",
                "ur",
                "uz",
                "vi",
                "vo",
                "wo",
                "xh",
                "yi",
                "yo",
                "za",
                "zh",
                "zu",
            ]
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on InternationalCodes_V1.LanguageCode_ISO639_1'
                    % {"value": encode_str_2_3(value), "lineno": lineno}
                )
                result = False
        return result

    def validate_INTERLIS_URI(self, value):
        result = True
        # Validate type INTERLIS.URI, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if len(value) > 1023:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on INTERLIS.URI'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def _hasContent(self):
        if self.Language is not None or self.Text is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="OeREBKRM_V2_0.LocalisedUri",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("OeREBKRM_V2_0.LocalisedUri")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "OeREBKRM_V2_0.LocalisedUri":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="OeREBKRM_V2_0.LocalisedUri",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="OeREBKRM_V2_0.LocalisedUri",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="OeREBKRM_V2_0.LocalisedUri",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="OeREBKRM_V2_0.LocalisedUri",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.Language is not None:
            namespaceprefix_ = (
                self.Language_nsprefix_ + ":" if (UseCapturedNS_ and self.Language_nsprefix_) else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sLanguage>%s</%sLanguage>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(self.gds_format_string(quote_xml(self.Language), input_name="Language")),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.Text is not None:
            namespaceprefix_ = self.Text_nsprefix_ + ":" if (UseCapturedNS_ and self.Text_nsprefix_) else ""
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sText>%s</%sText>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(self.gds_format_string(quote_xml(self.Text), input_name="Text")),
                    namespaceprefix_,
                    eol_,
                )
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "Language":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Language")
            value_ = self.gds_validate_string(value_, node, "Language")
            self.Language = value_
            self.Language_nsprefix_ = child_.prefix
            # validate type InternationalCodes_V1.LanguageCode_ISO639_1
            self.validate_InternationalCodes_V1_LanguageCode_ISO639_1(self.Language)
        elif nodeName_ == "Text":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Text")
            value_ = self.gds_validate_string(value_, node, "Text")
            self.Text = value_
            self.Text_nsprefix_ = child_.prefix
            # validate type INTERLIS.URI
            self.validate_INTERLIS_URI(self.Text)


# end class OeREBKRM_V2_0_LocalisedUri


class OeREBKRM_V2_0_MultilingualBlob(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "LocalisedBlob": MemberSpec_(
            "LocalisedBlob",
            "LocalisedBlobType",
            0,
            0,
            {"name": "LocalisedBlob", "type": "LocalisedBlobType"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, LocalisedBlob=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if LocalisedBlob is None:
            self.LocalisedBlob = globals()["LocalisedBlobType"]()
        else:
            self.LocalisedBlob = LocalisedBlob
        self.LocalisedBlob_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, OeREBKRM_V2_0_MultilingualBlob)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OeREBKRM_V2_0_MultilingualBlob.subclass:
            return OeREBKRM_V2_0_MultilingualBlob.subclass(*args_, **kwargs_)
        else:
            return OeREBKRM_V2_0_MultilingualBlob(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_LocalisedBlob(self):
        return self.LocalisedBlob

    def set_LocalisedBlob(self, LocalisedBlob):
        self.LocalisedBlob = LocalisedBlob

    def _hasContent(self):
        if self.LocalisedBlob is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="OeREBKRM_V2_0.MultilingualBlob",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("OeREBKRM_V2_0.MultilingualBlob")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "OeREBKRM_V2_0.MultilingualBlob":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="OeREBKRM_V2_0.MultilingualBlob",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="OeREBKRM_V2_0.MultilingualBlob",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="OeREBKRM_V2_0.MultilingualBlob",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="OeREBKRM_V2_0.MultilingualBlob",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.LocalisedBlob is not None:
            namespaceprefix_ = (
                self.LocalisedBlob_nsprefix_ + ":"
                if (UseCapturedNS_ and self.LocalisedBlob_nsprefix_)
                else ""
            )
            self.LocalisedBlob.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="LocalisedBlob",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "LocalisedBlob":
            obj_ = LocalisedBlobType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LocalisedBlob = obj_
            obj_.original_tagname_ = "LocalisedBlob"


# end class OeREBKRM_V2_0_MultilingualBlob


class OeREBKRM_V2_0_MultilingualUri(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "LocalisedText": MemberSpec_(
            "LocalisedText",
            "LocalisedTextType86",
            0,
            0,
            {"name": "LocalisedText", "type": "LocalisedTextType86"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, LocalisedText=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if LocalisedText is None:
            self.LocalisedText = globals()["LocalisedTextType86"]()
        else:
            self.LocalisedText = LocalisedText
        self.LocalisedText_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, OeREBKRM_V2_0_MultilingualUri)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OeREBKRM_V2_0_MultilingualUri.subclass:
            return OeREBKRM_V2_0_MultilingualUri.subclass(*args_, **kwargs_)
        else:
            return OeREBKRM_V2_0_MultilingualUri(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_LocalisedText(self):
        return self.LocalisedText

    def set_LocalisedText(self, LocalisedText):
        self.LocalisedText = LocalisedText

    def _hasContent(self):
        if self.LocalisedText is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="OeREBKRM_V2_0.MultilingualUri",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("OeREBKRM_V2_0.MultilingualUri")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "OeREBKRM_V2_0.MultilingualUri":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="OeREBKRM_V2_0.MultilingualUri",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="OeREBKRM_V2_0.MultilingualUri",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="OeREBKRM_V2_0.MultilingualUri",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="OeREBKRM_V2_0.MultilingualUri",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.LocalisedText is not None:
            namespaceprefix_ = (
                self.LocalisedText_nsprefix_ + ":"
                if (UseCapturedNS_ and self.LocalisedText_nsprefix_)
                else ""
            )
            self.LocalisedText.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="LocalisedText",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "LocalisedText":
            obj_ = LocalisedTextType86.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LocalisedText = obj_
            obj_.original_tagname_ = "LocalisedText"


# end class OeREBKRM_V2_0_MultilingualUri


class OeREBKRM_V2_0_ThemaRef(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "Thema": MemberSpec_(
            "Thema",
            ["OeREBKRM_V2_0.Thema", "xsd:normalizedString"],
            0,
            0,
            {"name": "Thema", "type": "xsd:normalizedString"},
            None,
        ),
        "SubThema": MemberSpec_(
            "SubThema",
            ["OeREBKRM_V2_0.Thema", "xsd:normalizedString"],
            0,
            1,
            {"minOccurs": "0", "name": "SubThema", "type": "xsd:normalizedString"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, Thema=None, SubThema=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.Thema = Thema
        self.validate_OeREBKRM_V2_0_Thema(self.Thema)
        self.Thema_nsprefix_ = None
        self.SubThema = SubThema
        self.validate_OeREBKRM_V2_0_Thema(self.SubThema)
        self.SubThema_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, OeREBKRM_V2_0_ThemaRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OeREBKRM_V2_0_ThemaRef.subclass:
            return OeREBKRM_V2_0_ThemaRef.subclass(*args_, **kwargs_)
        else:
            return OeREBKRM_V2_0_ThemaRef(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Thema(self):
        return self.Thema

    def set_Thema(self, Thema):
        self.Thema = Thema

    def get_SubThema(self):
        return self.SubThema

    def set_SubThema(self, SubThema):
        self.SubThema = SubThema

    def validate_OeREBKRM_V2_0_Thema(self, value):
        result = True
        # Validate type OeREBKRM_V2_0.Thema, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if len(value) > 120:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on OeREBKRM_V2_0.Thema'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def _hasContent(self):
        if self.Thema is not None or self.SubThema is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="OeREBKRM_V2_0.ThemaRef",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("OeREBKRM_V2_0.ThemaRef")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "OeREBKRM_V2_0.ThemaRef":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="OeREBKRM_V2_0.ThemaRef",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="OeREBKRM_V2_0.ThemaRef",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="OeREBKRM_V2_0.ThemaRef",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="OeREBKRM_V2_0.ThemaRef",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.Thema is not None:
            namespaceprefix_ = self.Thema_nsprefix_ + ":" if (UseCapturedNS_ and self.Thema_nsprefix_) else ""
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sThema>%s</%sThema>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(self.gds_format_string(quote_xml(self.Thema), input_name="Thema")),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.SubThema is not None:
            namespaceprefix_ = (
                self.SubThema_nsprefix_ + ":" if (UseCapturedNS_ and self.SubThema_nsprefix_) else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sSubThema>%s</%sSubThema>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(self.gds_format_string(quote_xml(self.SubThema), input_name="SubThema")),
                    namespaceprefix_,
                    eol_,
                )
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "Thema":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Thema")
            value_ = self.gds_validate_string(value_, node, "Thema")
            self.Thema = value_
            self.Thema_nsprefix_ = child_.prefix
            # validate type OeREBKRM_V2_0.Thema
            self.validate_OeREBKRM_V2_0_Thema(self.Thema)
        elif nodeName_ == "SubThema":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "SubThema")
            value_ = self.gds_validate_string(value_, node, "SubThema")
            self.SubThema = value_
            self.SubThema_nsprefix_ = child_.prefix
            # validate type OeREBKRM_V2_0.Thema
            self.validate_OeREBKRM_V2_0_Thema(self.SubThema)


# end class OeREBKRM_V2_0_ThemaRef


class OeREBKRM_V2_0_Amt_Amt(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "TID": MemberSpec_("TID", "IliID", 0, 0, {"use": "required", "name": "TID"}),
        "Name": MemberSpec_("Name", "NameType87", 0, 0, {"name": "Name", "type": "NameType87"}, None),
        "AmtImWeb": MemberSpec_(
            "AmtImWeb",
            "AmtImWebType",
            0,
            1,
            {"minOccurs": "0", "name": "AmtImWeb", "type": "AmtImWebType"},
            None,
        ),
        "UID": MemberSpec_(
            "UID",
            ["OeREBKRM_V2_0.UID", "xsd:normalizedString"],
            0,
            1,
            {"minOccurs": "0", "name": "UID", "type": "xsd:normalizedString"},
            None,
        ),
        "Zeile1": MemberSpec_(
            "Zeile1",
            ["Zeile1Type", "xsd:normalizedString"],
            0,
            1,
            {"minOccurs": "0", "name": "Zeile1", "type": "xsd:normalizedString"},
            None,
        ),
        "Zeile2": MemberSpec_(
            "Zeile2",
            ["Zeile2Type", "xsd:normalizedString"],
            0,
            1,
            {"minOccurs": "0", "name": "Zeile2", "type": "xsd:normalizedString"},
            None,
        ),
        "Strasse": MemberSpec_(
            "Strasse",
            ["StrasseType", "xsd:normalizedString"],
            0,
            1,
            {"minOccurs": "0", "name": "Strasse", "type": "xsd:normalizedString"},
            None,
        ),
        "Hausnr": MemberSpec_(
            "Hausnr",
            ["HausnrType", "xsd:normalizedString"],
            0,
            1,
            {"minOccurs": "0", "name": "Hausnr", "type": "xsd:normalizedString"},
            None,
        ),
        "PLZ": MemberSpec_(
            "PLZ",
            ["PLZType", "xsd:normalizedString"],
            0,
            1,
            {"minOccurs": "0", "name": "PLZ", "type": "xsd:normalizedString"},
            None,
        ),
        "Ort": MemberSpec_(
            "Ort",
            ["OrtType", "xsd:normalizedString"],
            0,
            1,
            {"minOccurs": "0", "name": "Ort", "type": "xsd:normalizedString"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(
        self,
        TID=None,
        Name=None,
        AmtImWeb=None,
        UID=None,
        Zeile1=None,
        Zeile2=None,
        Strasse=None,
        Hausnr=None,
        PLZ=None,
        Ort=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.TID = _cast(None, TID)
        self.TID_nsprefix_ = None
        if Name is None:
            self.Name = globals()["NameType87"]()
        else:
            self.Name = Name
        self.Name_nsprefix_ = None
        self.AmtImWeb = AmtImWeb
        self.AmtImWeb_nsprefix_ = None
        self.UID = UID
        self.validate_OeREBKRM_V2_0_UID(self.UID)
        self.UID_nsprefix_ = None
        self.Zeile1 = Zeile1
        self.validate_Zeile1Type(self.Zeile1)
        self.Zeile1_nsprefix_ = None
        self.Zeile2 = Zeile2
        self.validate_Zeile2Type(self.Zeile2)
        self.Zeile2_nsprefix_ = None
        self.Strasse = Strasse
        self.validate_StrasseType(self.Strasse)
        self.Strasse_nsprefix_ = None
        self.Hausnr = Hausnr
        self.validate_HausnrType(self.Hausnr)
        self.Hausnr_nsprefix_ = None
        self.PLZ = PLZ
        self.validate_PLZType(self.PLZ)
        self.PLZ_nsprefix_ = None
        self.Ort = Ort
        self.validate_OrtType(self.Ort)
        self.Ort_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, OeREBKRM_V2_0_Amt_Amt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OeREBKRM_V2_0_Amt_Amt.subclass:
            return OeREBKRM_V2_0_Amt_Amt.subclass(*args_, **kwargs_)
        else:
            return OeREBKRM_V2_0_Amt_Amt(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Name(self):
        return self.Name

    def set_Name(self, Name):
        self.Name = Name

    def get_AmtImWeb(self):
        return self.AmtImWeb

    def set_AmtImWeb(self, AmtImWeb):
        self.AmtImWeb = AmtImWeb

    def get_UID(self):
        return self.UID

    def set_UID(self, UID):
        self.UID = UID

    def get_Zeile1(self):
        return self.Zeile1

    def set_Zeile1(self, Zeile1):
        self.Zeile1 = Zeile1

    def get_Zeile2(self):
        return self.Zeile2

    def set_Zeile2(self, Zeile2):
        self.Zeile2 = Zeile2

    def get_Strasse(self):
        return self.Strasse

    def set_Strasse(self, Strasse):
        self.Strasse = Strasse

    def get_Hausnr(self):
        return self.Hausnr

    def set_Hausnr(self, Hausnr):
        self.Hausnr = Hausnr

    def get_PLZ(self):
        return self.PLZ

    def set_PLZ(self, PLZ):
        self.PLZ = PLZ

    def get_Ort(self):
        return self.Ort

    def set_Ort(self, Ort):
        self.Ort = Ort

    def get_TID(self):
        return self.TID

    def set_TID(self, TID):
        self.TID = TID

    def validate_OeREBKRM_V2_0_UID(self, value):
        result = True
        # Validate type OeREBKRM_V2_0.UID, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if len(value) > 12:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on OeREBKRM_V2_0.UID'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_Zeile1Type(self, value):
        result = True
        # Validate type Zeile1Type, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if len(value) > 80:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Zeile1Type'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_Zeile2Type(self, value):
        result = True
        # Validate type Zeile2Type, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if len(value) > 80:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on Zeile2Type'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_StrasseType(self, value):
        result = True
        # Validate type StrasseType, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if len(value) > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on StrasseType'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_HausnrType(self, value):
        result = True
        # Validate type HausnrType, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if len(value) > 7:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on HausnrType'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_PLZType(self, value):
        result = True
        # Validate type PLZType, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if len(value) > 4:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on PLZType'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_OrtType(self, value):
        result = True
        # Validate type OrtType, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if len(value) > 40:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on OrtType'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if (
            self.Name is not None
            or self.AmtImWeb is not None
            or self.UID is not None
            or self.Zeile1 is not None
            or self.Zeile2 is not None
            or self.Strasse is not None
            or self.Hausnr is not None
            or self.PLZ is not None
            or self.Ort is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="OeREBKRM_V2_0.Amt.Amt",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("OeREBKRM_V2_0.Amt.Amt")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "OeREBKRM_V2_0.Amt.Amt":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="OeREBKRM_V2_0.Amt.Amt",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="OeREBKRM_V2_0.Amt.Amt",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="OeREBKRM_V2_0.Amt.Amt",
    ):
        if self.TID is not None and "TID" not in already_processed:
            already_processed.add("TID")
            outfile.write(
                " TID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.TID), input_name="TID")),)
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="OeREBKRM_V2_0.Amt.Amt",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.Name is not None:
            namespaceprefix_ = self.Name_nsprefix_ + ":" if (UseCapturedNS_ and self.Name_nsprefix_) else ""
            self.Name.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Name",
                pretty_print=pretty_print,
            )
        if self.AmtImWeb is not None:
            namespaceprefix_ = (
                self.AmtImWeb_nsprefix_ + ":" if (UseCapturedNS_ and self.AmtImWeb_nsprefix_) else ""
            )
            self.AmtImWeb.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="AmtImWeb",
                pretty_print=pretty_print,
            )
        if self.UID is not None:
            namespaceprefix_ = self.UID_nsprefix_ + ":" if (UseCapturedNS_ and self.UID_nsprefix_) else ""
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sUID>%s</%sUID>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(self.gds_format_string(quote_xml(self.UID), input_name="UID")),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.Zeile1 is not None:
            namespaceprefix_ = (
                self.Zeile1_nsprefix_ + ":" if (UseCapturedNS_ and self.Zeile1_nsprefix_) else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sZeile1>%s</%sZeile1>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(self.gds_format_string(quote_xml(self.Zeile1), input_name="Zeile1")),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.Zeile2 is not None:
            namespaceprefix_ = (
                self.Zeile2_nsprefix_ + ":" if (UseCapturedNS_ and self.Zeile2_nsprefix_) else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sZeile2>%s</%sZeile2>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(self.gds_format_string(quote_xml(self.Zeile2), input_name="Zeile2")),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.Strasse is not None:
            namespaceprefix_ = (
                self.Strasse_nsprefix_ + ":" if (UseCapturedNS_ and self.Strasse_nsprefix_) else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sStrasse>%s</%sStrasse>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(self.gds_format_string(quote_xml(self.Strasse), input_name="Strasse")),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.Hausnr is not None:
            namespaceprefix_ = (
                self.Hausnr_nsprefix_ + ":" if (UseCapturedNS_ and self.Hausnr_nsprefix_) else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sHausnr>%s</%sHausnr>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(self.gds_format_string(quote_xml(self.Hausnr), input_name="Hausnr")),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.PLZ is not None:
            namespaceprefix_ = self.PLZ_nsprefix_ + ":" if (UseCapturedNS_ and self.PLZ_nsprefix_) else ""
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sPLZ>%s</%sPLZ>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(self.gds_format_string(quote_xml(self.PLZ), input_name="PLZ")),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.Ort is not None:
            namespaceprefix_ = self.Ort_nsprefix_ + ":" if (UseCapturedNS_ and self.Ort_nsprefix_) else ""
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sOrt>%s</%sOrt>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(self.gds_format_string(quote_xml(self.Ort), input_name="Ort")),
                    namespaceprefix_,
                    eol_,
                )
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("TID", node)
        if value is not None and "TID" not in already_processed:
            already_processed.add("TID")
            self.TID = value
            self.validate_IliID(self.TID)  # validate type IliID

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "Name":
            obj_ = NameType87.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Name = obj_
            obj_.original_tagname_ = "Name"
        elif nodeName_ == "AmtImWeb":
            obj_ = AmtImWebType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AmtImWeb = obj_
            obj_.original_tagname_ = "AmtImWeb"
        elif nodeName_ == "UID":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "UID")
            value_ = self.gds_validate_string(value_, node, "UID")
            self.UID = value_
            self.UID_nsprefix_ = child_.prefix
            # validate type OeREBKRM_V2_0.UID
            self.validate_OeREBKRM_V2_0_UID(self.UID)
        elif nodeName_ == "Zeile1":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Zeile1")
            value_ = self.gds_validate_string(value_, node, "Zeile1")
            self.Zeile1 = value_
            self.Zeile1_nsprefix_ = child_.prefix
            # validate type Zeile1Type
            self.validate_Zeile1Type(self.Zeile1)
        elif nodeName_ == "Zeile2":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Zeile2")
            value_ = self.gds_validate_string(value_, node, "Zeile2")
            self.Zeile2 = value_
            self.Zeile2_nsprefix_ = child_.prefix
            # validate type Zeile2Type
            self.validate_Zeile2Type(self.Zeile2)
        elif nodeName_ == "Strasse":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Strasse")
            value_ = self.gds_validate_string(value_, node, "Strasse")
            self.Strasse = value_
            self.Strasse_nsprefix_ = child_.prefix
            # validate type StrasseType
            self.validate_StrasseType(self.Strasse)
        elif nodeName_ == "Hausnr":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Hausnr")
            value_ = self.gds_validate_string(value_, node, "Hausnr")
            self.Hausnr = value_
            self.Hausnr_nsprefix_ = child_.prefix
            # validate type HausnrType
            self.validate_HausnrType(self.Hausnr)
        elif nodeName_ == "PLZ":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "PLZ")
            value_ = self.gds_validate_string(value_, node, "PLZ")
            self.PLZ = value_
            self.PLZ_nsprefix_ = child_.prefix
            # validate type PLZType
            self.validate_PLZType(self.PLZ)
        elif nodeName_ == "Ort":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Ort")
            value_ = self.gds_validate_string(value_, node, "Ort")
            self.Ort = value_
            self.Ort_nsprefix_ = child_.prefix
            # validate type OrtType
            self.validate_OrtType(self.Ort)


# end class OeREBKRM_V2_0_Amt_Amt


class OeREBKRM_V2_0_Amt(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "BID": MemberSpec_("BID", "IliID", 0, 0, {"use": "required", "name": "BID"}),
        "OeREBKRM_V2_0_Amt_Amt": MemberSpec_(
            "OeREBKRM_V2_0_Amt_Amt",
            "OeREBKRM_V2_0.Amt.Amt",
            1,
            1,
            {"name": "OeREBKRM_V2_0.Amt.Amt", "type": "OeREBKRM_V2_0.Amt.Amt"},
            14,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, BID=None, OeREBKRM_V2_0_Amt_Amt=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.BID = _cast(None, BID)
        self.BID_nsprefix_ = None
        if OeREBKRM_V2_0_Amt_Amt is None:
            self.OeREBKRM_V2_0_Amt_Amt = []
        else:
            self.OeREBKRM_V2_0_Amt_Amt = OeREBKRM_V2_0_Amt_Amt
        self.OeREBKRM_V2_0_Amt_Amt_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, OeREBKRM_V2_0_Amt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OeREBKRM_V2_0_Amt.subclass:
            return OeREBKRM_V2_0_Amt.subclass(*args_, **kwargs_)
        else:
            return OeREBKRM_V2_0_Amt(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_OeREBKRM_V2_0_Amt_Amt(self):
        return self.OeREBKRM_V2_0_Amt_Amt

    def set_OeREBKRM_V2_0_Amt_Amt(self, OeREBKRM_V2_0_Amt_Amt):
        self.OeREBKRM_V2_0_Amt_Amt = OeREBKRM_V2_0_Amt_Amt

    def add_OeREBKRM_V2_0_Amt_Amt(self, value):
        self.OeREBKRM_V2_0_Amt_Amt.append(value)

    def insert_OeREBKRM_V2_0_Amt_Amt_at(self, index, value):
        self.OeREBKRM_V2_0_Amt_Amt.insert(index, value)

    def replace_OeREBKRM_V2_0_Amt_Amt_at(self, index, value):
        self.OeREBKRM_V2_0_Amt_Amt[index] = value

    def get_BID(self):
        return self.BID

    def set_BID(self, BID):
        self.BID = BID

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if self.OeREBKRM_V2_0_Amt_Amt:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="OeREBKRM_V2_0.Amt",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("OeREBKRM_V2_0.Amt")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "OeREBKRM_V2_0.Amt":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="OeREBKRM_V2_0.Amt",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="OeREBKRM_V2_0.Amt",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="OeREBKRM_V2_0.Amt",
    ):
        if self.BID is not None and "BID" not in already_processed:
            already_processed.add("BID")
            outfile.write(
                " BID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.BID), input_name="BID")),)
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="OeREBKRM_V2_0.Amt",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for OeREBKRM_V2_0_Amt_Amt_ in self.OeREBKRM_V2_0_Amt_Amt:
            namespaceprefix_ = (
                self.OeREBKRM_V2_0_Amt_Amt_nsprefix_ + ":"
                if (UseCapturedNS_ and self.OeREBKRM_V2_0_Amt_Amt_nsprefix_)
                else ""
            )
            OeREBKRM_V2_0_Amt_Amt_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="OeREBKRM_V2_0.Amt.Amt",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("BID", node)
        if value is not None and "BID" not in already_processed:
            already_processed.add("BID")
            self.BID = value
            self.validate_IliID(self.BID)  # validate type IliID

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "OeREBKRM_V2_0.Amt.Amt":
            obj_ = OeREBKRM_V2_0_Amt_Amt.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OeREBKRM_V2_0_Amt_Amt.append(obj_)
            obj_.original_tagname_ = "OeREBKRM_V2_0.Amt.Amt"


# end class OeREBKRM_V2_0_Amt


class OeREBKRM_V2_0_Dokumente_Dokument(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "TID": MemberSpec_("TID", "IliID", 0, 0, {"use": "required", "name": "TID"}),
        "Typ": MemberSpec_(
            "Typ",
            ["OeREBKRM_V2_0.DokumentTyp", "xsd:string"],
            0,
            0,
            {"name": "Typ", "type": "xsd:string"},
            None,
        ),
        "Titel": MemberSpec_("Titel", "TitelType", 0, 0, {"name": "Titel", "type": "TitelType"}, None),
        "Abkuerzung": MemberSpec_(
            "Abkuerzung",
            "AbkuerzungType",
            0,
            1,
            {"minOccurs": "0", "name": "Abkuerzung", "type": "AbkuerzungType"},
            None,
        ),
        "OffizielleNr": MemberSpec_(
            "OffizielleNr",
            "OffizielleNrType",
            0,
            1,
            {"minOccurs": "0", "name": "OffizielleNr", "type": "OffizielleNrType"},
            None,
        ),
        "NurInGemeinde": MemberSpec_(
            "NurInGemeinde",
            ["CHAdminCodes_V1.CHMunicipalityCode", "xsd:integer"],
            0,
            1,
            {"minOccurs": "0", "name": "NurInGemeinde", "type": "xsd:integer"},
            None,
        ),
        "TextImWeb": MemberSpec_(
            "TextImWeb",
            "TextImWebType",
            0,
            1,
            {"minOccurs": "0", "name": "TextImWeb", "type": "TextImWebType"},
            None,
        ),
        "Dokument": MemberSpec_(
            "Dokument",
            "DokumentType",
            0,
            1,
            {"minOccurs": "0", "name": "Dokument", "type": "DokumentType"},
            None,
        ),
        "AuszugIndex": MemberSpec_(
            "AuszugIndex",
            ["AuszugIndexType", "xsd:integer"],
            0,
            0,
            {"name": "AuszugIndex", "type": "xsd:integer"},
            None,
        ),
        "Rechtsstatus": MemberSpec_(
            "Rechtsstatus",
            ["OeREBKRM_V2_0.RechtsStatus", "xsd:string"],
            0,
            0,
            {"name": "Rechtsstatus", "type": "xsd:string"},
            None,
        ),
        "publiziertAb": MemberSpec_(
            "publiziertAb",
            ["OeREBKRM_V2_0.Datum", "xsd:date"],
            0,
            0,
            {"name": "publiziertAb", "type": "xsd:date"},
            None,
        ),
        "publiziertBis": MemberSpec_(
            "publiziertBis",
            ["OeREBKRM_V2_0.Datum", "xsd:date"],
            0,
            1,
            {"minOccurs": "0", "name": "publiziertBis", "type": "xsd:date"},
            None,
        ),
        "ZustaendigeStelle": MemberSpec_(
            "ZustaendigeStelle",
            "ZustaendigeStelleType",
            0,
            0,
            {"name": "ZustaendigeStelle", "type": "ZustaendigeStelleType"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(
        self,
        TID=None,
        Typ=None,
        Titel=None,
        Abkuerzung=None,
        OffizielleNr=None,
        NurInGemeinde=None,
        TextImWeb=None,
        Dokument=None,
        AuszugIndex=None,
        Rechtsstatus=None,
        publiziertAb=None,
        publiziertBis=None,
        ZustaendigeStelle=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.TID = _cast(None, TID)
        self.TID_nsprefix_ = None
        self.Typ = Typ
        self.validate_OeREBKRM_V2_0_DokumentTyp(self.Typ)
        self.Typ_nsprefix_ = None
        if Titel is None:
            self.Titel = globals()["TitelType"]()
        else:
            self.Titel = Titel
        self.Titel_nsprefix_ = None
        self.Abkuerzung = Abkuerzung
        self.Abkuerzung_nsprefix_ = None
        self.OffizielleNr = OffizielleNr
        self.OffizielleNr_nsprefix_ = None
        self.NurInGemeinde = NurInGemeinde
        self.validate_CHAdminCodes_V1_CHMunicipalityCode(self.NurInGemeinde)
        self.NurInGemeinde_nsprefix_ = None
        self.TextImWeb = TextImWeb
        self.TextImWeb_nsprefix_ = None
        self.Dokument = Dokument
        self.Dokument_nsprefix_ = None
        self.AuszugIndex = AuszugIndex
        self.validate_AuszugIndexType(self.AuszugIndex)
        self.AuszugIndex_nsprefix_ = None
        self.Rechtsstatus = Rechtsstatus
        self.validate_OeREBKRM_V2_0_RechtsStatus(self.Rechtsstatus)
        self.Rechtsstatus_nsprefix_ = None
        if isinstance(publiziertAb, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(publiziertAb, "%Y-%m-%d").date()
        else:
            initvalue_ = publiziertAb
        self.publiziertAb = initvalue_
        self.publiziertAb_nsprefix_ = None
        if isinstance(publiziertBis, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(publiziertBis, "%Y-%m-%d").date()
        else:
            initvalue_ = publiziertBis
        self.publiziertBis = initvalue_
        self.publiziertBis_nsprefix_ = None
        if ZustaendigeStelle is None:
            self.ZustaendigeStelle = globals()["ZustaendigeStelleType"]()
        else:
            self.ZustaendigeStelle = ZustaendigeStelle
        self.ZustaendigeStelle_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, OeREBKRM_V2_0_Dokumente_Dokument)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OeREBKRM_V2_0_Dokumente_Dokument.subclass:
            return OeREBKRM_V2_0_Dokumente_Dokument.subclass(*args_, **kwargs_)
        else:
            return OeREBKRM_V2_0_Dokumente_Dokument(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Typ(self):
        return self.Typ

    def set_Typ(self, Typ):
        self.Typ = Typ

    def get_Titel(self):
        return self.Titel

    def set_Titel(self, Titel):
        self.Titel = Titel

    def get_Abkuerzung(self):
        return self.Abkuerzung

    def set_Abkuerzung(self, Abkuerzung):
        self.Abkuerzung = Abkuerzung

    def get_OffizielleNr(self):
        return self.OffizielleNr

    def set_OffizielleNr(self, OffizielleNr):
        self.OffizielleNr = OffizielleNr

    def get_NurInGemeinde(self):
        return self.NurInGemeinde

    def set_NurInGemeinde(self, NurInGemeinde):
        self.NurInGemeinde = NurInGemeinde

    def get_TextImWeb(self):
        return self.TextImWeb

    def set_TextImWeb(self, TextImWeb):
        self.TextImWeb = TextImWeb

    def get_Dokument(self):
        return self.Dokument

    def set_Dokument(self, Dokument):
        self.Dokument = Dokument

    def get_AuszugIndex(self):
        return self.AuszugIndex

    def set_AuszugIndex(self, AuszugIndex):
        self.AuszugIndex = AuszugIndex

    def get_Rechtsstatus(self):
        return self.Rechtsstatus

    def set_Rechtsstatus(self, Rechtsstatus):
        self.Rechtsstatus = Rechtsstatus

    def get_publiziertAb(self):
        return self.publiziertAb

    def set_publiziertAb(self, publiziertAb):
        self.publiziertAb = publiziertAb

    def get_publiziertBis(self):
        return self.publiziertBis

    def set_publiziertBis(self, publiziertBis):
        self.publiziertBis = publiziertBis

    def get_ZustaendigeStelle(self):
        return self.ZustaendigeStelle

    def set_ZustaendigeStelle(self, ZustaendigeStelle):
        self.ZustaendigeStelle = ZustaendigeStelle

    def get_TID(self):
        return self.TID

    def set_TID(self, TID):
        self.TID = TID

    def validate_OeREBKRM_V2_0_DokumentTyp(self, value):
        result = True
        # Validate type OeREBKRM_V2_0.DokumentTyp, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            value = value
            enumerations = ["Rechtsvorschrift", "GesetzlicheGrundlage", "Hinweis"]
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on OeREBKRM_V2_0.DokumentTyp'
                    % {"value": encode_str_2_3(value), "lineno": lineno}
                )
                result = False
        return result

    def validate_CHAdminCodes_V1_CHMunicipalityCode(self, value):
        result = True
        # Validate type CHAdminCodes_V1.CHMunicipalityCode, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on CHAdminCodes_V1.CHMunicipalityCode'
                    % {"value": value, "lineno": lineno}
                )
                result = False
            if value > 9999:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on CHAdminCodes_V1.CHMunicipalityCode'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_AuszugIndexType(self, value):
        result = True
        # Validate type AuszugIndexType, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if value < -1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on AuszugIndexType'
                    % {"value": value, "lineno": lineno}
                )
                result = False
            if value > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on AuszugIndexType'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_OeREBKRM_V2_0_RechtsStatus(self, value):
        result = True
        # Validate type OeREBKRM_V2_0.RechtsStatus, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            value = value
            enumerations = [
                "inKraft",
                "AenderungMitVorwirkung",
                "AenderungOhneVorwirkung",
            ]
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on OeREBKRM_V2_0.RechtsStatus'
                    % {"value": encode_str_2_3(value), "lineno": lineno}
                )
                result = False
        return result

    def validate_OeREBKRM_V2_0_Datum(self, value):
        result = True
        # Validate type OeREBKRM_V2_0.Datum, a restriction on xsd:date.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.date):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.date)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if value < self.gds_parse_date("1848-01-01"):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on OeREBKRM_V2_0.Datum'
                    % {"value": value, "lineno": lineno}
                )
                result = False
            if value > self.gds_parse_date("2100-12-31"):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on OeREBKRM_V2_0.Datum'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if (
            self.Typ is not None
            or self.Titel is not None
            or self.Abkuerzung is not None
            or self.OffizielleNr is not None
            or self.NurInGemeinde is not None
            or self.TextImWeb is not None
            or self.Dokument is not None
            or self.AuszugIndex is not None
            or self.Rechtsstatus is not None
            or self.publiziertAb is not None
            or self.publiziertBis is not None
            or self.ZustaendigeStelle is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="OeREBKRM_V2_0.Dokumente.Dokument",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("OeREBKRM_V2_0.Dokumente.Dokument")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "OeREBKRM_V2_0.Dokumente.Dokument":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="OeREBKRM_V2_0.Dokumente.Dokument",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="OeREBKRM_V2_0.Dokumente.Dokument",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="OeREBKRM_V2_0.Dokumente.Dokument",
    ):
        if self.TID is not None and "TID" not in already_processed:
            already_processed.add("TID")
            outfile.write(
                " TID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.TID), input_name="TID")),)
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="OeREBKRM_V2_0.Dokumente.Dokument",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.Typ is not None:
            namespaceprefix_ = self.Typ_nsprefix_ + ":" if (UseCapturedNS_ and self.Typ_nsprefix_) else ""
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sTyp>%s</%sTyp>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(self.gds_format_string(quote_xml(self.Typ), input_name="Typ")),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.Titel is not None:
            namespaceprefix_ = self.Titel_nsprefix_ + ":" if (UseCapturedNS_ and self.Titel_nsprefix_) else ""
            self.Titel.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Titel",
                pretty_print=pretty_print,
            )
        if self.Abkuerzung is not None:
            namespaceprefix_ = (
                self.Abkuerzung_nsprefix_ + ":" if (UseCapturedNS_ and self.Abkuerzung_nsprefix_) else ""
            )
            self.Abkuerzung.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Abkuerzung",
                pretty_print=pretty_print,
            )
        if self.OffizielleNr is not None:
            namespaceprefix_ = (
                self.OffizielleNr_nsprefix_ + ":" if (UseCapturedNS_ and self.OffizielleNr_nsprefix_) else ""
            )
            self.OffizielleNr.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="OffizielleNr",
                pretty_print=pretty_print,
            )
        if self.NurInGemeinde is not None:
            namespaceprefix_ = (
                self.NurInGemeinde_nsprefix_ + ":"
                if (UseCapturedNS_ and self.NurInGemeinde_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sNurInGemeinde>%s</%sNurInGemeinde>%s"
                % (
                    namespaceprefix_,
                    self.gds_format_integer(self.NurInGemeinde, input_name="NurInGemeinde"),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.TextImWeb is not None:
            namespaceprefix_ = (
                self.TextImWeb_nsprefix_ + ":" if (UseCapturedNS_ and self.TextImWeb_nsprefix_) else ""
            )
            self.TextImWeb.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="TextImWeb",
                pretty_print=pretty_print,
            )
        if self.Dokument is not None:
            namespaceprefix_ = (
                self.Dokument_nsprefix_ + ":" if (UseCapturedNS_ and self.Dokument_nsprefix_) else ""
            )
            self.Dokument.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Dokument",
                pretty_print=pretty_print,
            )
        if self.AuszugIndex is not None:
            namespaceprefix_ = (
                self.AuszugIndex_nsprefix_ + ":" if (UseCapturedNS_ and self.AuszugIndex_nsprefix_) else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sAuszugIndex>%s</%sAuszugIndex>%s"
                % (
                    namespaceprefix_,
                    self.gds_format_integer(self.AuszugIndex, input_name="AuszugIndex"),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.Rechtsstatus is not None:
            namespaceprefix_ = (
                self.Rechtsstatus_nsprefix_ + ":" if (UseCapturedNS_ and self.Rechtsstatus_nsprefix_) else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sRechtsstatus>%s</%sRechtsstatus>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(quote_xml(self.Rechtsstatus), input_name="Rechtsstatus")
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.publiziertAb is not None:
            namespaceprefix_ = (
                self.publiziertAb_nsprefix_ + ":" if (UseCapturedNS_ and self.publiziertAb_nsprefix_) else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%spubliziertAb>%s</%spubliziertAb>%s"
                % (
                    namespaceprefix_,
                    self.gds_format_date(self.publiziertAb, input_name="publiziertAb"),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.publiziertBis is not None:
            namespaceprefix_ = (
                self.publiziertBis_nsprefix_ + ":"
                if (UseCapturedNS_ and self.publiziertBis_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%spubliziertBis>%s</%spubliziertBis>%s"
                % (
                    namespaceprefix_,
                    self.gds_format_date(self.publiziertBis, input_name="publiziertBis"),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.ZustaendigeStelle is not None:
            namespaceprefix_ = (
                self.ZustaendigeStelle_nsprefix_ + ":"
                if (UseCapturedNS_ and self.ZustaendigeStelle_nsprefix_)
                else ""
            )
            self.ZustaendigeStelle.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="ZustaendigeStelle",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("TID", node)
        if value is not None and "TID" not in already_processed:
            already_processed.add("TID")
            self.TID = value
            self.validate_IliID(self.TID)  # validate type IliID

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "Typ":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Typ")
            value_ = self.gds_validate_string(value_, node, "Typ")
            self.Typ = value_
            self.Typ_nsprefix_ = child_.prefix
            # validate type OeREBKRM_V2_0.DokumentTyp
            self.validate_OeREBKRM_V2_0_DokumentTyp(self.Typ)
        elif nodeName_ == "Titel":
            obj_ = TitelType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Titel = obj_
            obj_.original_tagname_ = "Titel"
        elif nodeName_ == "Abkuerzung":
            obj_ = AbkuerzungType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Abkuerzung = obj_
            obj_.original_tagname_ = "Abkuerzung"
        elif nodeName_ == "OffizielleNr":
            obj_ = OffizielleNrType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OffizielleNr = obj_
            obj_.original_tagname_ = "OffizielleNr"
        elif nodeName_ == "NurInGemeinde" and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, "NurInGemeinde")
            ival_ = self.gds_validate_integer(ival_, node, "NurInGemeinde")
            self.NurInGemeinde = ival_
            self.NurInGemeinde_nsprefix_ = child_.prefix
            # validate type CHAdminCodes_V1.CHMunicipalityCode
            self.validate_CHAdminCodes_V1_CHMunicipalityCode(self.NurInGemeinde)
        elif nodeName_ == "TextImWeb":
            obj_ = TextImWebType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TextImWeb = obj_
            obj_.original_tagname_ = "TextImWeb"
        elif nodeName_ == "Dokument":
            obj_ = DokumentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Dokument = obj_
            obj_.original_tagname_ = "Dokument"
        elif nodeName_ == "AuszugIndex" and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, "AuszugIndex")
            ival_ = self.gds_validate_integer(ival_, node, "AuszugIndex")
            self.AuszugIndex = ival_
            self.AuszugIndex_nsprefix_ = child_.prefix
            # validate type AuszugIndexType
            self.validate_AuszugIndexType(self.AuszugIndex)
        elif nodeName_ == "Rechtsstatus":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Rechtsstatus")
            value_ = self.gds_validate_string(value_, node, "Rechtsstatus")
            self.Rechtsstatus = value_
            self.Rechtsstatus_nsprefix_ = child_.prefix
            # validate type OeREBKRM_V2_0.RechtsStatus
            self.validate_OeREBKRM_V2_0_RechtsStatus(self.Rechtsstatus)
        elif nodeName_ == "publiziertAb":
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.publiziertAb = dval_
            self.publiziertAb_nsprefix_ = child_.prefix
            # validate type OeREBKRM_V2_0.Datum
            self.validate_OeREBKRM_V2_0_Datum(self.publiziertAb)
        elif nodeName_ == "publiziertBis":
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.publiziertBis = dval_
            self.publiziertBis_nsprefix_ = child_.prefix
            # validate type OeREBKRM_V2_0.Datum
            self.validate_OeREBKRM_V2_0_Datum(self.publiziertBis)
        elif nodeName_ == "ZustaendigeStelle":
            obj_ = ZustaendigeStelleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ZustaendigeStelle = obj_
            obj_.original_tagname_ = "ZustaendigeStelle"


# end class OeREBKRM_V2_0_Dokumente_Dokument


class OeREBKRM_V2_0_Dokumente(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "BID": MemberSpec_("BID", "IliID", 0, 0, {"use": "required", "name": "BID"}),
        "OeREBKRM_V2_0_Amt_Amt": MemberSpec_(
            "OeREBKRM_V2_0_Amt_Amt",
            "OeREBKRM_V2_0.Amt.Amt",
            1,
            1,
            {"name": "OeREBKRM_V2_0.Amt.Amt", "type": "OeREBKRM_V2_0.Amt.Amt"},
            15,
        ),
        "OeREBKRM_V2_0_Dokumente_Dokument": MemberSpec_(
            "OeREBKRM_V2_0_Dokumente_Dokument",
            "OeREBKRM_V2_0.Dokumente.Dokument",
            1,
            1,
            {
                "name": "OeREBKRM_V2_0.Dokumente.Dokument",
                "type": "OeREBKRM_V2_0.Dokumente.Dokument",
            },
            15,
        ),
    }
    subclass = None
    superclass = None

    def __init__(
        self,
        BID=None,
        OeREBKRM_V2_0_Amt_Amt=None,
        OeREBKRM_V2_0_Dokumente_Dokument=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.BID = _cast(None, BID)
        self.BID_nsprefix_ = None
        if OeREBKRM_V2_0_Amt_Amt is None:
            self.OeREBKRM_V2_0_Amt_Amt = []
        else:
            self.OeREBKRM_V2_0_Amt_Amt = OeREBKRM_V2_0_Amt_Amt
        self.OeREBKRM_V2_0_Amt_Amt_nsprefix_ = None
        if OeREBKRM_V2_0_Dokumente_Dokument is None:
            self.OeREBKRM_V2_0_Dokumente_Dokument = []
        else:
            self.OeREBKRM_V2_0_Dokumente_Dokument = OeREBKRM_V2_0_Dokumente_Dokument
        self.OeREBKRM_V2_0_Dokumente_Dokument_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, OeREBKRM_V2_0_Dokumente)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OeREBKRM_V2_0_Dokumente.subclass:
            return OeREBKRM_V2_0_Dokumente.subclass(*args_, **kwargs_)
        else:
            return OeREBKRM_V2_0_Dokumente(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_OeREBKRM_V2_0_Amt_Amt(self):
        return self.OeREBKRM_V2_0_Amt_Amt

    def set_OeREBKRM_V2_0_Amt_Amt(self, OeREBKRM_V2_0_Amt_Amt):
        self.OeREBKRM_V2_0_Amt_Amt = OeREBKRM_V2_0_Amt_Amt

    def add_OeREBKRM_V2_0_Amt_Amt(self, value):
        self.OeREBKRM_V2_0_Amt_Amt.append(value)

    def insert_OeREBKRM_V2_0_Amt_Amt_at(self, index, value):
        self.OeREBKRM_V2_0_Amt_Amt.insert(index, value)

    def replace_OeREBKRM_V2_0_Amt_Amt_at(self, index, value):
        self.OeREBKRM_V2_0_Amt_Amt[index] = value

    def get_OeREBKRM_V2_0_Dokumente_Dokument(self):
        return self.OeREBKRM_V2_0_Dokumente_Dokument

    def set_OeREBKRM_V2_0_Dokumente_Dokument(self, OeREBKRM_V2_0_Dokumente_Dokument):
        self.OeREBKRM_V2_0_Dokumente_Dokument = OeREBKRM_V2_0_Dokumente_Dokument

    def add_OeREBKRM_V2_0_Dokumente_Dokument(self, value):
        self.OeREBKRM_V2_0_Dokumente_Dokument.append(value)

    def insert_OeREBKRM_V2_0_Dokumente_Dokument_at(self, index, value):
        self.OeREBKRM_V2_0_Dokumente_Dokument.insert(index, value)

    def replace_OeREBKRM_V2_0_Dokumente_Dokument_at(self, index, value):
        self.OeREBKRM_V2_0_Dokumente_Dokument[index] = value

    def get_BID(self):
        return self.BID

    def set_BID(self, BID):
        self.BID = BID

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if self.OeREBKRM_V2_0_Amt_Amt or self.OeREBKRM_V2_0_Dokumente_Dokument:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="OeREBKRM_V2_0.Dokumente",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("OeREBKRM_V2_0.Dokumente")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "OeREBKRM_V2_0.Dokumente":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="OeREBKRM_V2_0.Dokumente",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="OeREBKRM_V2_0.Dokumente",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="OeREBKRM_V2_0.Dokumente",
    ):
        if self.BID is not None and "BID" not in already_processed:
            already_processed.add("BID")
            outfile.write(
                " BID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.BID), input_name="BID")),)
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="OeREBKRM_V2_0.Dokumente",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for OeREBKRM_V2_0_Amt_Amt_ in self.OeREBKRM_V2_0_Amt_Amt:
            namespaceprefix_ = (
                self.OeREBKRM_V2_0_Amt_Amt_nsprefix_ + ":"
                if (UseCapturedNS_ and self.OeREBKRM_V2_0_Amt_Amt_nsprefix_)
                else ""
            )
            OeREBKRM_V2_0_Amt_Amt_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="OeREBKRM_V2_0.Amt.Amt",
                pretty_print=pretty_print,
            )
        for OeREBKRM_V2_0_Dokumente_Dokument_ in self.OeREBKRM_V2_0_Dokumente_Dokument:
            namespaceprefix_ = (
                self.OeREBKRM_V2_0_Dokumente_Dokument_nsprefix_ + ":"
                if (UseCapturedNS_ and self.OeREBKRM_V2_0_Dokumente_Dokument_nsprefix_)
                else ""
            )
            OeREBKRM_V2_0_Dokumente_Dokument_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="OeREBKRM_V2_0.Dokumente.Dokument",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("BID", node)
        if value is not None and "BID" not in already_processed:
            already_processed.add("BID")
            self.BID = value
            self.validate_IliID(self.BID)  # validate type IliID

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "OeREBKRM_V2_0.Amt.Amt":
            obj_ = OeREBKRM_V2_0_Amt_Amt.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OeREBKRM_V2_0_Amt_Amt.append(obj_)
            obj_.original_tagname_ = "OeREBKRM_V2_0.Amt.Amt"
        elif nodeName_ == "OeREBKRM_V2_0.Dokumente.Dokument":
            obj_ = OeREBKRM_V2_0_Dokumente_Dokument.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OeREBKRM_V2_0_Dokumente_Dokument.append(obj_)
            obj_.original_tagname_ = "OeREBKRM_V2_0.Dokumente.Dokument"


# end class OeREBKRM_V2_0_Dokumente


class OeREBKRMtrsfr_V2_0_Transferstruktur_DarstellungsDienst(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "TID": MemberSpec_("TID", "IliID", 0, 0, {"use": "required", "name": "TID"}),
        "VerweisWMS": MemberSpec_(
            "VerweisWMS",
            "VerweisWMSType",
            0,
            0,
            {"name": "VerweisWMS", "type": "VerweisWMSType"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, TID=None, VerweisWMS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.TID = _cast(None, TID)
        self.TID_nsprefix_ = None
        if VerweisWMS is None:
            self.VerweisWMS = globals()["VerweisWMSType"]()
        else:
            self.VerweisWMS = VerweisWMS
        self.VerweisWMS_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_,
                OeREBKRMtrsfr_V2_0_Transferstruktur_DarstellungsDienst,
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OeREBKRMtrsfr_V2_0_Transferstruktur_DarstellungsDienst.subclass:
            return OeREBKRMtrsfr_V2_0_Transferstruktur_DarstellungsDienst.subclass(*args_, **kwargs_)
        else:
            return OeREBKRMtrsfr_V2_0_Transferstruktur_DarstellungsDienst(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_VerweisWMS(self):
        return self.VerweisWMS

    def set_VerweisWMS(self, VerweisWMS):
        self.VerweisWMS = VerweisWMS

    def get_TID(self):
        return self.TID

    def set_TID(self, TID):
        self.TID = TID

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if self.VerweisWMS is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="OeREBKRMtrsfr_V2_0.Transferstruktur.DarstellungsDienst",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get(
            "OeREBKRMtrsfr_V2_0.Transferstruktur.DarstellungsDienst"
        )
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if (
            self.original_tagname_ is not None
            and name_ == "OeREBKRMtrsfr_V2_0.Transferstruktur.DarstellungsDienst"
        ):
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="OeREBKRMtrsfr_V2_0.Transferstruktur.DarstellungsDienst",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="OeREBKRMtrsfr_V2_0.Transferstruktur.DarstellungsDienst",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="OeREBKRMtrsfr_V2_0.Transferstruktur.DarstellungsDienst",
    ):
        if self.TID is not None and "TID" not in already_processed:
            already_processed.add("TID")
            outfile.write(
                " TID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.TID), input_name="TID")),)
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="OeREBKRMtrsfr_V2_0.Transferstruktur.DarstellungsDienst",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.VerweisWMS is not None:
            namespaceprefix_ = (
                self.VerweisWMS_nsprefix_ + ":" if (UseCapturedNS_ and self.VerweisWMS_nsprefix_) else ""
            )
            self.VerweisWMS.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="VerweisWMS",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("TID", node)
        if value is not None and "TID" not in already_processed:
            already_processed.add("TID")
            self.TID = value
            self.validate_IliID(self.TID)  # validate type IliID

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "VerweisWMS":
            obj_ = VerweisWMSType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VerweisWMS = obj_
            obj_.original_tagname_ = "VerweisWMS"


# end class OeREBKRMtrsfr_V2_0_Transferstruktur_DarstellungsDienst


class OeREBKRMtrsfr_V2_0_Transferstruktur_Eigentumsbeschraenkung(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "TID": MemberSpec_("TID", "IliID", 0, 0, {"use": "required", "name": "TID"}),
        "Rechtsstatus": MemberSpec_(
            "Rechtsstatus",
            ["OeREBKRM_V2_0.RechtsStatus", "xsd:string"],
            0,
            0,
            {"name": "Rechtsstatus", "type": "xsd:string"},
            None,
        ),
        "publiziertAb": MemberSpec_(
            "publiziertAb",
            ["OeREBKRM_V2_0.Datum", "xsd:date"],
            0,
            0,
            {"name": "publiziertAb", "type": "xsd:date"},
            None,
        ),
        "publiziertBis": MemberSpec_(
            "publiziertBis",
            ["OeREBKRM_V2_0.Datum", "xsd:date"],
            0,
            1,
            {"minOccurs": "0", "name": "publiziertBis", "type": "xsd:date"},
            None,
        ),
        "DarstellungsDienst": MemberSpec_(
            "DarstellungsDienst",
            "DarstellungsDienstType",
            0,
            0,
            {"name": "DarstellungsDienst", "type": "DarstellungsDienstType"},
            None,
        ),
        "Legende": MemberSpec_(
            "Legende",
            "LegendeType",
            0,
            0,
            {"name": "Legende", "type": "LegendeType"},
            None,
        ),
        "ZustaendigeStelle": MemberSpec_(
            "ZustaendigeStelle",
            "ZustaendigeStelleType88",
            0,
            0,
            {"name": "ZustaendigeStelle", "type": "ZustaendigeStelleType88"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(
        self,
        TID=None,
        Rechtsstatus=None,
        publiziertAb=None,
        publiziertBis=None,
        DarstellungsDienst=None,
        Legende=None,
        ZustaendigeStelle=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.TID = _cast(None, TID)
        self.TID_nsprefix_ = None
        self.Rechtsstatus = Rechtsstatus
        self.validate_OeREBKRM_V2_0_RechtsStatus(self.Rechtsstatus)
        self.Rechtsstatus_nsprefix_ = None
        if isinstance(publiziertAb, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(publiziertAb, "%Y-%m-%d").date()
        else:
            initvalue_ = publiziertAb
        self.publiziertAb = initvalue_
        self.publiziertAb_nsprefix_ = None
        if isinstance(publiziertBis, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(publiziertBis, "%Y-%m-%d").date()
        else:
            initvalue_ = publiziertBis
        self.publiziertBis = initvalue_
        self.publiziertBis_nsprefix_ = None
        if DarstellungsDienst is None:
            self.DarstellungsDienst = globals()["DarstellungsDienstType"]()
        else:
            self.DarstellungsDienst = DarstellungsDienst
        self.DarstellungsDienst_nsprefix_ = None
        if Legende is None:
            self.Legende = globals()["LegendeType"]()
        else:
            self.Legende = Legende
        self.Legende_nsprefix_ = None
        if ZustaendigeStelle is None:
            self.ZustaendigeStelle = globals()["ZustaendigeStelleType88"]()
        else:
            self.ZustaendigeStelle = ZustaendigeStelle
        self.ZustaendigeStelle_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_,
                OeREBKRMtrsfr_V2_0_Transferstruktur_Eigentumsbeschraenkung,
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OeREBKRMtrsfr_V2_0_Transferstruktur_Eigentumsbeschraenkung.subclass:
            return OeREBKRMtrsfr_V2_0_Transferstruktur_Eigentumsbeschraenkung.subclass(*args_, **kwargs_)
        else:
            return OeREBKRMtrsfr_V2_0_Transferstruktur_Eigentumsbeschraenkung(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Rechtsstatus(self):
        return self.Rechtsstatus

    def set_Rechtsstatus(self, Rechtsstatus):
        self.Rechtsstatus = Rechtsstatus

    def get_publiziertAb(self):
        return self.publiziertAb

    def set_publiziertAb(self, publiziertAb):
        self.publiziertAb = publiziertAb

    def get_publiziertBis(self):
        return self.publiziertBis

    def set_publiziertBis(self, publiziertBis):
        self.publiziertBis = publiziertBis

    def get_DarstellungsDienst(self):
        return self.DarstellungsDienst

    def set_DarstellungsDienst(self, DarstellungsDienst):
        self.DarstellungsDienst = DarstellungsDienst

    def get_Legende(self):
        return self.Legende

    def set_Legende(self, Legende):
        self.Legende = Legende

    def get_ZustaendigeStelle(self):
        return self.ZustaendigeStelle

    def set_ZustaendigeStelle(self, ZustaendigeStelle):
        self.ZustaendigeStelle = ZustaendigeStelle

    def get_TID(self):
        return self.TID

    def set_TID(self, TID):
        self.TID = TID

    def validate_OeREBKRM_V2_0_RechtsStatus(self, value):
        result = True
        # Validate type OeREBKRM_V2_0.RechtsStatus, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            value = value
            enumerations = [
                "inKraft",
                "AenderungMitVorwirkung",
                "AenderungOhneVorwirkung",
            ]
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on OeREBKRM_V2_0.RechtsStatus'
                    % {"value": encode_str_2_3(value), "lineno": lineno}
                )
                result = False
        return result

    def validate_OeREBKRM_V2_0_Datum(self, value):
        result = True
        # Validate type OeREBKRM_V2_0.Datum, a restriction on xsd:date.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.date):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.date)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if value < self.gds_parse_date("1848-01-01"):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on OeREBKRM_V2_0.Datum'
                    % {"value": value, "lineno": lineno}
                )
                result = False
            if value > self.gds_parse_date("2100-12-31"):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on OeREBKRM_V2_0.Datum'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if (
            self.Rechtsstatus is not None
            or self.publiziertAb is not None
            or self.publiziertBis is not None
            or self.DarstellungsDienst is not None
            or self.Legende is not None
            or self.ZustaendigeStelle is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="OeREBKRMtrsfr_V2_0.Transferstruktur.Eigentumsbeschraenkung",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get(
            "OeREBKRMtrsfr_V2_0.Transferstruktur.Eigentumsbeschraenkung"
        )
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if (
            self.original_tagname_ is not None
            and name_ == "OeREBKRMtrsfr_V2_0.Transferstruktur.Eigentumsbeschraenkung"
        ):
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="OeREBKRMtrsfr_V2_0.Transferstruktur.Eigentumsbeschraenkung",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="OeREBKRMtrsfr_V2_0.Transferstruktur.Eigentumsbeschraenkung",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="OeREBKRMtrsfr_V2_0.Transferstruktur.Eigentumsbeschraenkung",
    ):
        if self.TID is not None and "TID" not in already_processed:
            already_processed.add("TID")
            outfile.write(
                " TID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.TID), input_name="TID")),)
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="OeREBKRMtrsfr_V2_0.Transferstruktur.Eigentumsbeschraenkung",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.Rechtsstatus is not None:
            namespaceprefix_ = (
                self.Rechtsstatus_nsprefix_ + ":" if (UseCapturedNS_ and self.Rechtsstatus_nsprefix_) else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sRechtsstatus>%s</%sRechtsstatus>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(quote_xml(self.Rechtsstatus), input_name="Rechtsstatus")
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.publiziertAb is not None:
            namespaceprefix_ = (
                self.publiziertAb_nsprefix_ + ":" if (UseCapturedNS_ and self.publiziertAb_nsprefix_) else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%spubliziertAb>%s</%spubliziertAb>%s"
                % (
                    namespaceprefix_,
                    self.gds_format_date(self.publiziertAb, input_name="publiziertAb"),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.publiziertBis is not None:
            namespaceprefix_ = (
                self.publiziertBis_nsprefix_ + ":"
                if (UseCapturedNS_ and self.publiziertBis_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%spubliziertBis>%s</%spubliziertBis>%s"
                % (
                    namespaceprefix_,
                    self.gds_format_date(self.publiziertBis, input_name="publiziertBis"),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.DarstellungsDienst is not None:
            namespaceprefix_ = (
                self.DarstellungsDienst_nsprefix_ + ":"
                if (UseCapturedNS_ and self.DarstellungsDienst_nsprefix_)
                else ""
            )
            self.DarstellungsDienst.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="DarstellungsDienst",
                pretty_print=pretty_print,
            )
        if self.Legende is not None:
            namespaceprefix_ = (
                self.Legende_nsprefix_ + ":" if (UseCapturedNS_ and self.Legende_nsprefix_) else ""
            )
            self.Legende.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Legende",
                pretty_print=pretty_print,
            )
        if self.ZustaendigeStelle is not None:
            namespaceprefix_ = (
                self.ZustaendigeStelle_nsprefix_ + ":"
                if (UseCapturedNS_ and self.ZustaendigeStelle_nsprefix_)
                else ""
            )
            self.ZustaendigeStelle.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="ZustaendigeStelle",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("TID", node)
        if value is not None and "TID" not in already_processed:
            already_processed.add("TID")
            self.TID = value
            self.validate_IliID(self.TID)  # validate type IliID

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "Rechtsstatus":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Rechtsstatus")
            value_ = self.gds_validate_string(value_, node, "Rechtsstatus")
            self.Rechtsstatus = value_
            self.Rechtsstatus_nsprefix_ = child_.prefix
            # validate type OeREBKRM_V2_0.RechtsStatus
            self.validate_OeREBKRM_V2_0_RechtsStatus(self.Rechtsstatus)
        elif nodeName_ == "publiziertAb":
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.publiziertAb = dval_
            self.publiziertAb_nsprefix_ = child_.prefix
            # validate type OeREBKRM_V2_0.Datum
            self.validate_OeREBKRM_V2_0_Datum(self.publiziertAb)
        elif nodeName_ == "publiziertBis":
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.publiziertBis = dval_
            self.publiziertBis_nsprefix_ = child_.prefix
            # validate type OeREBKRM_V2_0.Datum
            self.validate_OeREBKRM_V2_0_Datum(self.publiziertBis)
        elif nodeName_ == "DarstellungsDienst":
            obj_ = DarstellungsDienstType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DarstellungsDienst = obj_
            obj_.original_tagname_ = "DarstellungsDienst"
        elif nodeName_ == "Legende":
            obj_ = LegendeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Legende = obj_
            obj_.original_tagname_ = "Legende"
        elif nodeName_ == "ZustaendigeStelle":
            obj_ = ZustaendigeStelleType88.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ZustaendigeStelle = obj_
            obj_.original_tagname_ = "ZustaendigeStelle"


# end class OeREBKRMtrsfr_V2_0_Transferstruktur_Eigentumsbeschraenkung


class OeREBKRMtrsfr_V2_0_Transferstruktur_Geometrie(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "TID": MemberSpec_("TID", "IliID", 0, 0, {"use": "required", "name": "TID"}),
        "Punkt": MemberSpec_(
            "Punkt",
            "GeometryCHLV95_V1.Coord2",
            0,
            1,
            {"minOccurs": "0", "name": "Punkt", "type": "GeometryCHLV95_V1.Coord2"},
            None,
        ),
        "Linie": MemberSpec_(
            "Linie",
            "GeometryCHLV95_V1.Line",
            0,
            1,
            {"minOccurs": "0", "name": "Linie", "type": "GeometryCHLV95_V1.Line"},
            None,
        ),
        "Flaeche": MemberSpec_(
            "Flaeche",
            "GeometryCHLV95_V1.Surface",
            0,
            1,
            {"minOccurs": "0", "name": "Flaeche", "type": "GeometryCHLV95_V1.Surface"},
            None,
        ),
        "Rechtsstatus": MemberSpec_(
            "Rechtsstatus",
            ["OeREBKRM_V2_0.RechtsStatus", "xsd:string"],
            0,
            0,
            {"name": "Rechtsstatus", "type": "xsd:string"},
            None,
        ),
        "publiziertAb": MemberSpec_(
            "publiziertAb",
            ["OeREBKRM_V2_0.Datum", "xsd:date"],
            0,
            0,
            {"name": "publiziertAb", "type": "xsd:date"},
            None,
        ),
        "publiziertBis": MemberSpec_(
            "publiziertBis",
            ["OeREBKRM_V2_0.Datum", "xsd:date"],
            0,
            1,
            {"minOccurs": "0", "name": "publiziertBis", "type": "xsd:date"},
            None,
        ),
        "MetadatenGeobasisdaten": MemberSpec_(
            "MetadatenGeobasisdaten",
            ["INTERLIS.URI", "xsd:normalizedString"],
            0,
            1,
            {
                "minOccurs": "0",
                "name": "MetadatenGeobasisdaten",
                "type": "xsd:normalizedString",
            },
            None,
        ),
        "Eigentumsbeschraenkung": MemberSpec_(
            "Eigentumsbeschraenkung",
            "EigentumsbeschraenkungType",
            0,
            0,
            {"name": "Eigentumsbeschraenkung", "type": "EigentumsbeschraenkungType"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(
        self,
        TID=None,
        Punkt=None,
        Linie=None,
        Flaeche=None,
        Rechtsstatus=None,
        publiziertAb=None,
        publiziertBis=None,
        MetadatenGeobasisdaten=None,
        Eigentumsbeschraenkung=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.TID = _cast(None, TID)
        self.TID_nsprefix_ = None
        self.Punkt = Punkt
        self.Punkt_nsprefix_ = None
        self.Linie = Linie
        self.Linie_nsprefix_ = None
        self.Flaeche = Flaeche
        self.Flaeche_nsprefix_ = None
        self.Rechtsstatus = Rechtsstatus
        self.validate_OeREBKRM_V2_0_RechtsStatus(self.Rechtsstatus)
        self.Rechtsstatus_nsprefix_ = None
        if isinstance(publiziertAb, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(publiziertAb, "%Y-%m-%d").date()
        else:
            initvalue_ = publiziertAb
        self.publiziertAb = initvalue_
        self.publiziertAb_nsprefix_ = None
        if isinstance(publiziertBis, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(publiziertBis, "%Y-%m-%d").date()
        else:
            initvalue_ = publiziertBis
        self.publiziertBis = initvalue_
        self.publiziertBis_nsprefix_ = None
        self.MetadatenGeobasisdaten = MetadatenGeobasisdaten
        self.validate_INTERLIS_URI(self.MetadatenGeobasisdaten)
        self.MetadatenGeobasisdaten_nsprefix_ = None
        if Eigentumsbeschraenkung is None:
            self.Eigentumsbeschraenkung = globals()["EigentumsbeschraenkungType"]()
        else:
            self.Eigentumsbeschraenkung = Eigentumsbeschraenkung
        self.Eigentumsbeschraenkung_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OeREBKRMtrsfr_V2_0_Transferstruktur_Geometrie
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OeREBKRMtrsfr_V2_0_Transferstruktur_Geometrie.subclass:
            return OeREBKRMtrsfr_V2_0_Transferstruktur_Geometrie.subclass(*args_, **kwargs_)
        else:
            return OeREBKRMtrsfr_V2_0_Transferstruktur_Geometrie(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Punkt(self):
        return self.Punkt

    def set_Punkt(self, Punkt):
        self.Punkt = Punkt

    def get_Linie(self):
        return self.Linie

    def set_Linie(self, Linie):
        self.Linie = Linie

    def get_Flaeche(self):
        return self.Flaeche

    def set_Flaeche(self, Flaeche):
        self.Flaeche = Flaeche

    def get_Rechtsstatus(self):
        return self.Rechtsstatus

    def set_Rechtsstatus(self, Rechtsstatus):
        self.Rechtsstatus = Rechtsstatus

    def get_publiziertAb(self):
        return self.publiziertAb

    def set_publiziertAb(self, publiziertAb):
        self.publiziertAb = publiziertAb

    def get_publiziertBis(self):
        return self.publiziertBis

    def set_publiziertBis(self, publiziertBis):
        self.publiziertBis = publiziertBis

    def get_MetadatenGeobasisdaten(self):
        return self.MetadatenGeobasisdaten

    def set_MetadatenGeobasisdaten(self, MetadatenGeobasisdaten):
        self.MetadatenGeobasisdaten = MetadatenGeobasisdaten

    def get_Eigentumsbeschraenkung(self):
        return self.Eigentumsbeschraenkung

    def set_Eigentumsbeschraenkung(self, Eigentumsbeschraenkung):
        self.Eigentumsbeschraenkung = Eigentumsbeschraenkung

    def get_TID(self):
        return self.TID

    def set_TID(self, TID):
        self.TID = TID

    def validate_OeREBKRM_V2_0_RechtsStatus(self, value):
        result = True
        # Validate type OeREBKRM_V2_0.RechtsStatus, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            value = value
            enumerations = [
                "inKraft",
                "AenderungMitVorwirkung",
                "AenderungOhneVorwirkung",
            ]
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on OeREBKRM_V2_0.RechtsStatus'
                    % {"value": encode_str_2_3(value), "lineno": lineno}
                )
                result = False
        return result

    def validate_OeREBKRM_V2_0_Datum(self, value):
        result = True
        # Validate type OeREBKRM_V2_0.Datum, a restriction on xsd:date.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.date):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.date)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if value < self.gds_parse_date("1848-01-01"):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on OeREBKRM_V2_0.Datum'
                    % {"value": value, "lineno": lineno}
                )
                result = False
            if value > self.gds_parse_date("2100-12-31"):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on OeREBKRM_V2_0.Datum'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_INTERLIS_URI(self, value):
        result = True
        # Validate type INTERLIS.URI, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if len(value) > 1023:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on INTERLIS.URI'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if (
            self.Punkt is not None
            or self.Linie is not None
            or self.Flaeche is not None
            or self.Rechtsstatus is not None
            or self.publiziertAb is not None
            or self.publiziertBis is not None
            or self.MetadatenGeobasisdaten is not None
            or self.Eigentumsbeschraenkung is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="OeREBKRMtrsfr_V2_0.Transferstruktur.Geometrie",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("OeREBKRMtrsfr_V2_0.Transferstruktur.Geometrie")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "OeREBKRMtrsfr_V2_0.Transferstruktur.Geometrie":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="OeREBKRMtrsfr_V2_0.Transferstruktur.Geometrie",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="OeREBKRMtrsfr_V2_0.Transferstruktur.Geometrie",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="OeREBKRMtrsfr_V2_0.Transferstruktur.Geometrie",
    ):
        if self.TID is not None and "TID" not in already_processed:
            already_processed.add("TID")
            outfile.write(
                " TID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.TID), input_name="TID")),)
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="OeREBKRMtrsfr_V2_0.Transferstruktur.Geometrie",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.Punkt is not None:
            namespaceprefix_ = self.Punkt_nsprefix_ + ":" if (UseCapturedNS_ and self.Punkt_nsprefix_) else ""
            self.Punkt.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Punkt",
                pretty_print=pretty_print,
            )
        if self.Linie is not None:
            namespaceprefix_ = self.Linie_nsprefix_ + ":" if (UseCapturedNS_ and self.Linie_nsprefix_) else ""
            self.Linie.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Linie",
                pretty_print=pretty_print,
            )
        if self.Flaeche is not None:
            namespaceprefix_ = (
                self.Flaeche_nsprefix_ + ":" if (UseCapturedNS_ and self.Flaeche_nsprefix_) else ""
            )
            self.Flaeche.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Flaeche",
                pretty_print=pretty_print,
            )
        if self.Rechtsstatus is not None:
            namespaceprefix_ = (
                self.Rechtsstatus_nsprefix_ + ":" if (UseCapturedNS_ and self.Rechtsstatus_nsprefix_) else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sRechtsstatus>%s</%sRechtsstatus>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(quote_xml(self.Rechtsstatus), input_name="Rechtsstatus")
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.publiziertAb is not None:
            namespaceprefix_ = (
                self.publiziertAb_nsprefix_ + ":" if (UseCapturedNS_ and self.publiziertAb_nsprefix_) else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%spubliziertAb>%s</%spubliziertAb>%s"
                % (
                    namespaceprefix_,
                    self.gds_format_date(self.publiziertAb, input_name="publiziertAb"),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.publiziertBis is not None:
            namespaceprefix_ = (
                self.publiziertBis_nsprefix_ + ":"
                if (UseCapturedNS_ and self.publiziertBis_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%spubliziertBis>%s</%spubliziertBis>%s"
                % (
                    namespaceprefix_,
                    self.gds_format_date(self.publiziertBis, input_name="publiziertBis"),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.MetadatenGeobasisdaten is not None:
            namespaceprefix_ = (
                self.MetadatenGeobasisdaten_nsprefix_ + ":"
                if (UseCapturedNS_ and self.MetadatenGeobasisdaten_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sMetadatenGeobasisdaten>%s</%sMetadatenGeobasisdaten>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(
                            quote_xml(self.MetadatenGeobasisdaten),
                            input_name="MetadatenGeobasisdaten",
                        )
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.Eigentumsbeschraenkung is not None:
            namespaceprefix_ = (
                self.Eigentumsbeschraenkung_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Eigentumsbeschraenkung_nsprefix_)
                else ""
            )
            self.Eigentumsbeschraenkung.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Eigentumsbeschraenkung",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("TID", node)
        if value is not None and "TID" not in already_processed:
            already_processed.add("TID")
            self.TID = value
            self.validate_IliID(self.TID)  # validate type IliID

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "Punkt":
            obj_ = GeometryCHLV95_V1_Coord2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Punkt = obj_
            obj_.original_tagname_ = "Punkt"
        elif nodeName_ == "Linie":
            obj_ = GeometryCHLV95_V1_Line.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Linie = obj_
            obj_.original_tagname_ = "Linie"
        elif nodeName_ == "Flaeche":
            obj_ = GeometryCHLV95_V1_Surface.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Flaeche = obj_
            obj_.original_tagname_ = "Flaeche"
        elif nodeName_ == "Rechtsstatus":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Rechtsstatus")
            value_ = self.gds_validate_string(value_, node, "Rechtsstatus")
            self.Rechtsstatus = value_
            self.Rechtsstatus_nsprefix_ = child_.prefix
            # validate type OeREBKRM_V2_0.RechtsStatus
            self.validate_OeREBKRM_V2_0_RechtsStatus(self.Rechtsstatus)
        elif nodeName_ == "publiziertAb":
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.publiziertAb = dval_
            self.publiziertAb_nsprefix_ = child_.prefix
            # validate type OeREBKRM_V2_0.Datum
            self.validate_OeREBKRM_V2_0_Datum(self.publiziertAb)
        elif nodeName_ == "publiziertBis":
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.publiziertBis = dval_
            self.publiziertBis_nsprefix_ = child_.prefix
            # validate type OeREBKRM_V2_0.Datum
            self.validate_OeREBKRM_V2_0_Datum(self.publiziertBis)
        elif nodeName_ == "MetadatenGeobasisdaten":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "MetadatenGeobasisdaten")
            value_ = self.gds_validate_string(value_, node, "MetadatenGeobasisdaten")
            self.MetadatenGeobasisdaten = value_
            self.MetadatenGeobasisdaten_nsprefix_ = child_.prefix
            # validate type INTERLIS.URI
            self.validate_INTERLIS_URI(self.MetadatenGeobasisdaten)
        elif nodeName_ == "Eigentumsbeschraenkung":
            obj_ = EigentumsbeschraenkungType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Eigentumsbeschraenkung = obj_
            obj_.original_tagname_ = "Eigentumsbeschraenkung"


# end class OeREBKRMtrsfr_V2_0_Transferstruktur_Geometrie


class OeREBKRMtrsfr_V2_0_Transferstruktur_LegendeEintrag(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "TID": MemberSpec_("TID", "IliID", 0, 0, {"use": "required", "name": "TID"}),
        "Symbol": MemberSpec_("Symbol", "SymbolType", 0, 0, {"name": "Symbol", "type": "SymbolType"}, None),
        "LegendeText": MemberSpec_(
            "LegendeText",
            "LegendeTextType",
            0,
            0,
            {"name": "LegendeText", "type": "LegendeTextType"},
            None,
        ),
        "ArtCode": MemberSpec_(
            "ArtCode",
            ["OeREBKRM_V2_0.ArtEigentumsbeschraenkung", "xsd:normalizedString"],
            0,
            0,
            {"name": "ArtCode", "type": "xsd:normalizedString"},
            None,
        ),
        "ArtCodeliste": MemberSpec_(
            "ArtCodeliste",
            ["INTERLIS.URI", "xsd:normalizedString"],
            0,
            0,
            {"name": "ArtCodeliste", "type": "xsd:normalizedString"},
            None,
        ),
        "Thema": MemberSpec_(
            "Thema",
            ["OeREBKRM_V2_0.Thema", "xsd:normalizedString"],
            0,
            0,
            {"name": "Thema", "type": "xsd:normalizedString"},
            None,
        ),
        "SubThema": MemberSpec_(
            "SubThema",
            ["OeREBKRM_V2_0.Thema", "xsd:normalizedString"],
            0,
            1,
            {"minOccurs": "0", "name": "SubThema", "type": "xsd:normalizedString"},
            None,
        ),
        "DarstellungsDienst": MemberSpec_(
            "DarstellungsDienst",
            "DarstellungsDienstType90",
            0,
            0,
            {"name": "DarstellungsDienst", "type": "DarstellungsDienstType90"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(
        self,
        TID=None,
        Symbol=None,
        LegendeText=None,
        ArtCode=None,
        ArtCodeliste=None,
        Thema=None,
        SubThema=None,
        DarstellungsDienst=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.TID = _cast(None, TID)
        self.TID_nsprefix_ = None
        if Symbol is None:
            self.Symbol = globals()["SymbolType"]()
        else:
            self.Symbol = Symbol
        self.Symbol_nsprefix_ = None
        if LegendeText is None:
            self.LegendeText = globals()["LegendeTextType"]()
        else:
            self.LegendeText = LegendeText
        self.LegendeText_nsprefix_ = None
        self.ArtCode = ArtCode
        self.validate_OeREBKRM_V2_0_ArtEigentumsbeschraenkung(self.ArtCode)
        self.ArtCode_nsprefix_ = None
        self.ArtCodeliste = ArtCodeliste
        self.validate_INTERLIS_URI(self.ArtCodeliste)
        self.ArtCodeliste_nsprefix_ = None
        self.Thema = Thema
        self.validate_OeREBKRM_V2_0_Thema(self.Thema)
        self.Thema_nsprefix_ = None
        self.SubThema = SubThema
        self.validate_OeREBKRM_V2_0_Thema(self.SubThema)
        self.SubThema_nsprefix_ = None
        if DarstellungsDienst is None:
            self.DarstellungsDienst = globals()["DarstellungsDienstType90"]()
        else:
            self.DarstellungsDienst = DarstellungsDienst
        self.DarstellungsDienst_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_,
                OeREBKRMtrsfr_V2_0_Transferstruktur_LegendeEintrag,
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OeREBKRMtrsfr_V2_0_Transferstruktur_LegendeEintrag.subclass:
            return OeREBKRMtrsfr_V2_0_Transferstruktur_LegendeEintrag.subclass(*args_, **kwargs_)
        else:
            return OeREBKRMtrsfr_V2_0_Transferstruktur_LegendeEintrag(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Symbol(self):
        return self.Symbol

    def set_Symbol(self, Symbol):
        self.Symbol = Symbol

    def get_LegendeText(self):
        return self.LegendeText

    def set_LegendeText(self, LegendeText):
        self.LegendeText = LegendeText

    def get_ArtCode(self):
        return self.ArtCode

    def set_ArtCode(self, ArtCode):
        self.ArtCode = ArtCode

    def get_ArtCodeliste(self):
        return self.ArtCodeliste

    def set_ArtCodeliste(self, ArtCodeliste):
        self.ArtCodeliste = ArtCodeliste

    def get_Thema(self):
        return self.Thema

    def set_Thema(self, Thema):
        self.Thema = Thema

    def get_SubThema(self):
        return self.SubThema

    def set_SubThema(self, SubThema):
        self.SubThema = SubThema

    def get_DarstellungsDienst(self):
        return self.DarstellungsDienst

    def set_DarstellungsDienst(self, DarstellungsDienst):
        self.DarstellungsDienst = DarstellungsDienst

    def get_TID(self):
        return self.TID

    def set_TID(self, TID):
        self.TID = TID

    def validate_OeREBKRM_V2_0_ArtEigentumsbeschraenkung(self, value):
        result = True
        # Validate type OeREBKRM_V2_0.ArtEigentumsbeschraenkung, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if len(value) > 40:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on OeREBKRM_V2_0.ArtEigentumsbeschraenkung'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_INTERLIS_URI(self, value):
        result = True
        # Validate type INTERLIS.URI, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if len(value) > 1023:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on INTERLIS.URI'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_OeREBKRM_V2_0_Thema(self, value):
        result = True
        # Validate type OeREBKRM_V2_0.Thema, a restriction on xsd:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if len(value) > 120:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on OeREBKRM_V2_0.Thema'
                    % {"value": value, "lineno": lineno}
                )
                result = False
        return result

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if (
            self.Symbol is not None
            or self.LegendeText is not None
            or self.ArtCode is not None
            or self.ArtCodeliste is not None
            or self.Thema is not None
            or self.SubThema is not None
            or self.DarstellungsDienst is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="OeREBKRMtrsfr_V2_0.Transferstruktur.LegendeEintrag",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("OeREBKRMtrsfr_V2_0.Transferstruktur.LegendeEintrag")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if (
            self.original_tagname_ is not None
            and name_ == "OeREBKRMtrsfr_V2_0.Transferstruktur.LegendeEintrag"
        ):
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="OeREBKRMtrsfr_V2_0.Transferstruktur.LegendeEintrag",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="OeREBKRMtrsfr_V2_0.Transferstruktur.LegendeEintrag",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="OeREBKRMtrsfr_V2_0.Transferstruktur.LegendeEintrag",
    ):
        if self.TID is not None and "TID" not in already_processed:
            already_processed.add("TID")
            outfile.write(
                " TID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.TID), input_name="TID")),)
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="OeREBKRMtrsfr_V2_0.Transferstruktur.LegendeEintrag",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.Symbol is not None:
            namespaceprefix_ = (
                self.Symbol_nsprefix_ + ":" if (UseCapturedNS_ and self.Symbol_nsprefix_) else ""
            )
            self.Symbol.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Symbol",
                pretty_print=pretty_print,
            )
        if self.LegendeText is not None:
            namespaceprefix_ = (
                self.LegendeText_nsprefix_ + ":" if (UseCapturedNS_ and self.LegendeText_nsprefix_) else ""
            )
            self.LegendeText.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="LegendeText",
                pretty_print=pretty_print,
            )
        if self.ArtCode is not None:
            namespaceprefix_ = (
                self.ArtCode_nsprefix_ + ":" if (UseCapturedNS_ and self.ArtCode_nsprefix_) else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sArtCode>%s</%sArtCode>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(self.gds_format_string(quote_xml(self.ArtCode), input_name="ArtCode")),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.ArtCodeliste is not None:
            namespaceprefix_ = (
                self.ArtCodeliste_nsprefix_ + ":" if (UseCapturedNS_ and self.ArtCodeliste_nsprefix_) else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sArtCodeliste>%s</%sArtCodeliste>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(quote_xml(self.ArtCodeliste), input_name="ArtCodeliste")
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.Thema is not None:
            namespaceprefix_ = self.Thema_nsprefix_ + ":" if (UseCapturedNS_ and self.Thema_nsprefix_) else ""
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sThema>%s</%sThema>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(self.gds_format_string(quote_xml(self.Thema), input_name="Thema")),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.SubThema is not None:
            namespaceprefix_ = (
                self.SubThema_nsprefix_ + ":" if (UseCapturedNS_ and self.SubThema_nsprefix_) else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sSubThema>%s</%sSubThema>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(self.gds_format_string(quote_xml(self.SubThema), input_name="SubThema")),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.DarstellungsDienst is not None:
            namespaceprefix_ = (
                self.DarstellungsDienst_nsprefix_ + ":"
                if (UseCapturedNS_ and self.DarstellungsDienst_nsprefix_)
                else ""
            )
            self.DarstellungsDienst.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="DarstellungsDienst",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("TID", node)
        if value is not None and "TID" not in already_processed:
            already_processed.add("TID")
            self.TID = value
            self.validate_IliID(self.TID)  # validate type IliID

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "Symbol":
            obj_ = SymbolType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Symbol = obj_
            obj_.original_tagname_ = "Symbol"
        elif nodeName_ == "LegendeText":
            obj_ = LegendeTextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LegendeText = obj_
            obj_.original_tagname_ = "LegendeText"
        elif nodeName_ == "ArtCode":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "ArtCode")
            value_ = self.gds_validate_string(value_, node, "ArtCode")
            self.ArtCode = value_
            self.ArtCode_nsprefix_ = child_.prefix
            # validate type OeREBKRM_V2_0.ArtEigentumsbeschraenkung
            self.validate_OeREBKRM_V2_0_ArtEigentumsbeschraenkung(self.ArtCode)
        elif nodeName_ == "ArtCodeliste":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "ArtCodeliste")
            value_ = self.gds_validate_string(value_, node, "ArtCodeliste")
            self.ArtCodeliste = value_
            self.ArtCodeliste_nsprefix_ = child_.prefix
            # validate type INTERLIS.URI
            self.validate_INTERLIS_URI(self.ArtCodeliste)
        elif nodeName_ == "Thema":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "Thema")
            value_ = self.gds_validate_string(value_, node, "Thema")
            self.Thema = value_
            self.Thema_nsprefix_ = child_.prefix
            # validate type OeREBKRM_V2_0.Thema
            self.validate_OeREBKRM_V2_0_Thema(self.Thema)
        elif nodeName_ == "SubThema":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "SubThema")
            value_ = self.gds_validate_string(value_, node, "SubThema")
            self.SubThema = value_
            self.SubThema_nsprefix_ = child_.prefix
            # validate type OeREBKRM_V2_0.Thema
            self.validate_OeREBKRM_V2_0_Thema(self.SubThema)
        elif nodeName_ == "DarstellungsDienst":
            obj_ = DarstellungsDienstType90.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DarstellungsDienst = obj_
            obj_.original_tagname_ = "DarstellungsDienst"


# end class OeREBKRMtrsfr_V2_0_Transferstruktur_LegendeEintrag


class OeREBKRMtrsfr_V2_0_Transferstruktur_HinweisVorschrift(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "Eigentumsbeschraenkung": MemberSpec_(
            "Eigentumsbeschraenkung",
            "RoleType",
            0,
            0,
            {"name": "Eigentumsbeschraenkung", "type": "RoleType"},
            None,
        ),
        "Vorschrift": MemberSpec_(
            "Vorschrift",
            "RoleType",
            0,
            0,
            {"name": "Vorschrift", "type": "RoleType"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, Eigentumsbeschraenkung=None, Vorschrift=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.Eigentumsbeschraenkung = Eigentumsbeschraenkung
        self.Eigentumsbeschraenkung_nsprefix_ = None
        self.Vorschrift = Vorschrift
        self.Vorschrift_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_,
                OeREBKRMtrsfr_V2_0_Transferstruktur_HinweisVorschrift,
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OeREBKRMtrsfr_V2_0_Transferstruktur_HinweisVorschrift.subclass:
            return OeREBKRMtrsfr_V2_0_Transferstruktur_HinweisVorschrift.subclass(*args_, **kwargs_)
        else:
            return OeREBKRMtrsfr_V2_0_Transferstruktur_HinweisVorschrift(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Eigentumsbeschraenkung(self):
        return self.Eigentumsbeschraenkung

    def set_Eigentumsbeschraenkung(self, Eigentumsbeschraenkung):
        self.Eigentumsbeschraenkung = Eigentumsbeschraenkung

    def get_Vorschrift(self):
        return self.Vorschrift

    def set_Vorschrift(self, Vorschrift):
        self.Vorschrift = Vorschrift

    def _hasContent(self):
        if self.Eigentumsbeschraenkung is not None or self.Vorschrift is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="OeREBKRMtrsfr_V2_0.Transferstruktur.HinweisVorschrift",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get(
            "OeREBKRMtrsfr_V2_0.Transferstruktur.HinweisVorschrift"
        )
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if (
            self.original_tagname_ is not None
            and name_ == "OeREBKRMtrsfr_V2_0.Transferstruktur.HinweisVorschrift"
        ):
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="OeREBKRMtrsfr_V2_0.Transferstruktur.HinweisVorschrift",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="OeREBKRMtrsfr_V2_0.Transferstruktur.HinweisVorschrift",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="OeREBKRMtrsfr_V2_0.Transferstruktur.HinweisVorschrift",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="OeREBKRMtrsfr_V2_0.Transferstruktur.HinweisVorschrift",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.Eigentumsbeschraenkung is not None:
            namespaceprefix_ = (
                self.Eigentumsbeschraenkung_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Eigentumsbeschraenkung_nsprefix_)
                else ""
            )
            self.Eigentumsbeschraenkung.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Eigentumsbeschraenkung",
                pretty_print=pretty_print,
            )
        if self.Vorschrift is not None:
            namespaceprefix_ = (
                self.Vorschrift_nsprefix_ + ":" if (UseCapturedNS_ and self.Vorschrift_nsprefix_) else ""
            )
            self.Vorschrift.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Vorschrift",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "Eigentumsbeschraenkung":
            obj_ = RoleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Eigentumsbeschraenkung = obj_
            obj_.original_tagname_ = "Eigentumsbeschraenkung"
        elif nodeName_ == "Vorschrift":
            obj_ = RoleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Vorschrift = obj_
            obj_.original_tagname_ = "Vorschrift"


# end class OeREBKRMtrsfr_V2_0_Transferstruktur_HinweisVorschrift


class OeREBKRMtrsfr_V2_0_Transferstruktur(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "BID": MemberSpec_("BID", "IliID", 0, 0, {"use": "required", "name": "BID"}),
        "OeREBKRM_V2_0_Amt_Amt": MemberSpec_(
            "OeREBKRM_V2_0_Amt_Amt",
            "OeREBKRM_V2_0.Amt.Amt",
            1,
            1,
            {"name": "OeREBKRM_V2_0.Amt.Amt", "type": "OeREBKRM_V2_0.Amt.Amt"},
            16,
        ),
        "OeREBKRM_V2_0_Dokumente_Dokument": MemberSpec_(
            "OeREBKRM_V2_0_Dokumente_Dokument",
            "OeREBKRM_V2_0.Dokumente.Dokument",
            1,
            1,
            {
                "name": "OeREBKRM_V2_0.Dokumente.Dokument",
                "type": "OeREBKRM_V2_0.Dokumente.Dokument",
            },
            16,
        ),
        "OeREBKRMtrsfr_V2_0_Transferstruktur_DarstellungsDienst": MemberSpec_(
            "OeREBKRMtrsfr_V2_0_Transferstruktur_DarstellungsDienst",
            "OeREBKRMtrsfr_V2_0.Transferstruktur.DarstellungsDienst",
            1,
            1,
            {
                "name": "OeREBKRMtrsfr_V2_0.Transferstruktur.DarstellungsDienst",
                "type": "OeREBKRMtrsfr_V2_0.Transferstruktur.DarstellungsDienst",
            },
            16,
        ),
        "OeREBKRMtrsfr_V2_0_Transferstruktur_Eigentumsbeschraenkung": MemberSpec_(
            "OeREBKRMtrsfr_V2_0_Transferstruktur_Eigentumsbeschraenkung",
            "OeREBKRMtrsfr_V2_0.Transferstruktur.Eigentumsbeschraenkung",
            1,
            1,
            {
                "name": "OeREBKRMtrsfr_V2_0.Transferstruktur.Eigentumsbeschraenkung",
                "type": "OeREBKRMtrsfr_V2_0.Transferstruktur.Eigentumsbeschraenkung",
            },
            16,
        ),
        "OeREBKRMtrsfr_V2_0_Transferstruktur_Geometrie": MemberSpec_(
            "OeREBKRMtrsfr_V2_0_Transferstruktur_Geometrie",
            "OeREBKRMtrsfr_V2_0.Transferstruktur.Geometrie",
            1,
            1,
            {
                "name": "OeREBKRMtrsfr_V2_0.Transferstruktur.Geometrie",
                "type": "OeREBKRMtrsfr_V2_0.Transferstruktur.Geometrie",
            },
            16,
        ),
        "OeREBKRMtrsfr_V2_0_Transferstruktur_LegendeEintrag": MemberSpec_(
            "OeREBKRMtrsfr_V2_0_Transferstruktur_LegendeEintrag",
            "OeREBKRMtrsfr_V2_0.Transferstruktur.LegendeEintrag",
            1,
            1,
            {
                "name": "OeREBKRMtrsfr_V2_0.Transferstruktur.LegendeEintrag",
                "type": "OeREBKRMtrsfr_V2_0.Transferstruktur.LegendeEintrag",
            },
            16,
        ),
        "OeREBKRMtrsfr_V2_0_Transferstruktur_HinweisVorschrift": MemberSpec_(
            "OeREBKRMtrsfr_V2_0_Transferstruktur_HinweisVorschrift",
            "OeREBKRMtrsfr_V2_0.Transferstruktur.HinweisVorschrift",
            1,
            1,
            {
                "name": "OeREBKRMtrsfr_V2_0.Transferstruktur.HinweisVorschrift",
                "type": "OeREBKRMtrsfr_V2_0.Transferstruktur.HinweisVorschrift",
            },
            16,
        ),
    }
    subclass = None
    superclass = None

    def __init__(
        self,
        BID=None,
        OeREBKRM_V2_0_Amt_Amt=None,
        OeREBKRM_V2_0_Dokumente_Dokument=None,
        OeREBKRMtrsfr_V2_0_Transferstruktur_DarstellungsDienst=None,
        OeREBKRMtrsfr_V2_0_Transferstruktur_Eigentumsbeschraenkung=None,
        OeREBKRMtrsfr_V2_0_Transferstruktur_Geometrie=None,
        OeREBKRMtrsfr_V2_0_Transferstruktur_LegendeEintrag=None,
        OeREBKRMtrsfr_V2_0_Transferstruktur_HinweisVorschrift=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.BID = _cast(None, BID)
        self.BID_nsprefix_ = None
        if OeREBKRM_V2_0_Amt_Amt is None:
            self.OeREBKRM_V2_0_Amt_Amt = []
        else:
            self.OeREBKRM_V2_0_Amt_Amt = OeREBKRM_V2_0_Amt_Amt
        self.OeREBKRM_V2_0_Amt_Amt_nsprefix_ = None
        if OeREBKRM_V2_0_Dokumente_Dokument is None:
            self.OeREBKRM_V2_0_Dokumente_Dokument = []
        else:
            self.OeREBKRM_V2_0_Dokumente_Dokument = OeREBKRM_V2_0_Dokumente_Dokument
        self.OeREBKRM_V2_0_Dokumente_Dokument_nsprefix_ = None
        if OeREBKRMtrsfr_V2_0_Transferstruktur_DarstellungsDienst is None:
            self.OeREBKRMtrsfr_V2_0_Transferstruktur_DarstellungsDienst = []
        else:
            self.OeREBKRMtrsfr_V2_0_Transferstruktur_DarstellungsDienst = (
                OeREBKRMtrsfr_V2_0_Transferstruktur_DarstellungsDienst
            )
        self.OeREBKRMtrsfr_V2_0_Transferstruktur_DarstellungsDienst_nsprefix_ = None
        if OeREBKRMtrsfr_V2_0_Transferstruktur_Eigentumsbeschraenkung is None:
            self.OeREBKRMtrsfr_V2_0_Transferstruktur_Eigentumsbeschraenkung = []
        else:
            self.OeREBKRMtrsfr_V2_0_Transferstruktur_Eigentumsbeschraenkung = (
                OeREBKRMtrsfr_V2_0_Transferstruktur_Eigentumsbeschraenkung
            )
        self.OeREBKRMtrsfr_V2_0_Transferstruktur_Eigentumsbeschraenkung_nsprefix_ = None
        if OeREBKRMtrsfr_V2_0_Transferstruktur_Geometrie is None:
            self.OeREBKRMtrsfr_V2_0_Transferstruktur_Geometrie = []
        else:
            self.OeREBKRMtrsfr_V2_0_Transferstruktur_Geometrie = OeREBKRMtrsfr_V2_0_Transferstruktur_Geometrie
        self.OeREBKRMtrsfr_V2_0_Transferstruktur_Geometrie_nsprefix_ = None
        if OeREBKRMtrsfr_V2_0_Transferstruktur_LegendeEintrag is None:
            self.OeREBKRMtrsfr_V2_0_Transferstruktur_LegendeEintrag = []
        else:
            self.OeREBKRMtrsfr_V2_0_Transferstruktur_LegendeEintrag = (
                OeREBKRMtrsfr_V2_0_Transferstruktur_LegendeEintrag
            )
        self.OeREBKRMtrsfr_V2_0_Transferstruktur_LegendeEintrag_nsprefix_ = None
        if OeREBKRMtrsfr_V2_0_Transferstruktur_HinweisVorschrift is None:
            self.OeREBKRMtrsfr_V2_0_Transferstruktur_HinweisVorschrift = []
        else:
            self.OeREBKRMtrsfr_V2_0_Transferstruktur_HinweisVorschrift = (
                OeREBKRMtrsfr_V2_0_Transferstruktur_HinweisVorschrift
            )
        self.OeREBKRMtrsfr_V2_0_Transferstruktur_HinweisVorschrift_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, OeREBKRMtrsfr_V2_0_Transferstruktur)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OeREBKRMtrsfr_V2_0_Transferstruktur.subclass:
            return OeREBKRMtrsfr_V2_0_Transferstruktur.subclass(*args_, **kwargs_)
        else:
            return OeREBKRMtrsfr_V2_0_Transferstruktur(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_OeREBKRM_V2_0_Amt_Amt(self):
        return self.OeREBKRM_V2_0_Amt_Amt

    def set_OeREBKRM_V2_0_Amt_Amt(self, OeREBKRM_V2_0_Amt_Amt):
        self.OeREBKRM_V2_0_Amt_Amt = OeREBKRM_V2_0_Amt_Amt

    def add_OeREBKRM_V2_0_Amt_Amt(self, value):
        self.OeREBKRM_V2_0_Amt_Amt.append(value)

    def insert_OeREBKRM_V2_0_Amt_Amt_at(self, index, value):
        self.OeREBKRM_V2_0_Amt_Amt.insert(index, value)

    def replace_OeREBKRM_V2_0_Amt_Amt_at(self, index, value):
        self.OeREBKRM_V2_0_Amt_Amt[index] = value

    def get_OeREBKRM_V2_0_Dokumente_Dokument(self):
        return self.OeREBKRM_V2_0_Dokumente_Dokument

    def set_OeREBKRM_V2_0_Dokumente_Dokument(self, OeREBKRM_V2_0_Dokumente_Dokument):
        self.OeREBKRM_V2_0_Dokumente_Dokument = OeREBKRM_V2_0_Dokumente_Dokument

    def add_OeREBKRM_V2_0_Dokumente_Dokument(self, value):
        self.OeREBKRM_V2_0_Dokumente_Dokument.append(value)

    def insert_OeREBKRM_V2_0_Dokumente_Dokument_at(self, index, value):
        self.OeREBKRM_V2_0_Dokumente_Dokument.insert(index, value)

    def replace_OeREBKRM_V2_0_Dokumente_Dokument_at(self, index, value):
        self.OeREBKRM_V2_0_Dokumente_Dokument[index] = value

    def get_OeREBKRMtrsfr_V2_0_Transferstruktur_DarstellungsDienst(self):
        return self.OeREBKRMtrsfr_V2_0_Transferstruktur_DarstellungsDienst

    def set_OeREBKRMtrsfr_V2_0_Transferstruktur_DarstellungsDienst(
        self, OeREBKRMtrsfr_V2_0_Transferstruktur_DarstellungsDienst
    ):
        self.OeREBKRMtrsfr_V2_0_Transferstruktur_DarstellungsDienst = (
            OeREBKRMtrsfr_V2_0_Transferstruktur_DarstellungsDienst
        )

    def add_OeREBKRMtrsfr_V2_0_Transferstruktur_DarstellungsDienst(self, value):
        self.OeREBKRMtrsfr_V2_0_Transferstruktur_DarstellungsDienst.append(value)

    def insert_OeREBKRMtrsfr_V2_0_Transferstruktur_DarstellungsDienst_at(self, index, value):
        self.OeREBKRMtrsfr_V2_0_Transferstruktur_DarstellungsDienst.insert(index, value)

    def replace_OeREBKRMtrsfr_V2_0_Transferstruktur_DarstellungsDienst_at(self, index, value):
        self.OeREBKRMtrsfr_V2_0_Transferstruktur_DarstellungsDienst[index] = value

    def get_OeREBKRMtrsfr_V2_0_Transferstruktur_Eigentumsbeschraenkung(self):
        return self.OeREBKRMtrsfr_V2_0_Transferstruktur_Eigentumsbeschraenkung

    def set_OeREBKRMtrsfr_V2_0_Transferstruktur_Eigentumsbeschraenkung(
        self, OeREBKRMtrsfr_V2_0_Transferstruktur_Eigentumsbeschraenkung
    ):
        self.OeREBKRMtrsfr_V2_0_Transferstruktur_Eigentumsbeschraenkung = (
            OeREBKRMtrsfr_V2_0_Transferstruktur_Eigentumsbeschraenkung
        )

    def add_OeREBKRMtrsfr_V2_0_Transferstruktur_Eigentumsbeschraenkung(self, value):
        self.OeREBKRMtrsfr_V2_0_Transferstruktur_Eigentumsbeschraenkung.append(value)

    def insert_OeREBKRMtrsfr_V2_0_Transferstruktur_Eigentumsbeschraenkung_at(self, index, value):
        self.OeREBKRMtrsfr_V2_0_Transferstruktur_Eigentumsbeschraenkung.insert(index, value)

    def replace_OeREBKRMtrsfr_V2_0_Transferstruktur_Eigentumsbeschraenkung_at(self, index, value):
        self.OeREBKRMtrsfr_V2_0_Transferstruktur_Eigentumsbeschraenkung[index] = value

    def get_OeREBKRMtrsfr_V2_0_Transferstruktur_Geometrie(self):
        return self.OeREBKRMtrsfr_V2_0_Transferstruktur_Geometrie

    def set_OeREBKRMtrsfr_V2_0_Transferstruktur_Geometrie(
        self, OeREBKRMtrsfr_V2_0_Transferstruktur_Geometrie
    ):
        self.OeREBKRMtrsfr_V2_0_Transferstruktur_Geometrie = OeREBKRMtrsfr_V2_0_Transferstruktur_Geometrie

    def add_OeREBKRMtrsfr_V2_0_Transferstruktur_Geometrie(self, value):
        self.OeREBKRMtrsfr_V2_0_Transferstruktur_Geometrie.append(value)

    def insert_OeREBKRMtrsfr_V2_0_Transferstruktur_Geometrie_at(self, index, value):
        self.OeREBKRMtrsfr_V2_0_Transferstruktur_Geometrie.insert(index, value)

    def replace_OeREBKRMtrsfr_V2_0_Transferstruktur_Geometrie_at(self, index, value):
        self.OeREBKRMtrsfr_V2_0_Transferstruktur_Geometrie[index] = value

    def get_OeREBKRMtrsfr_V2_0_Transferstruktur_LegendeEintrag(self):
        return self.OeREBKRMtrsfr_V2_0_Transferstruktur_LegendeEintrag

    def set_OeREBKRMtrsfr_V2_0_Transferstruktur_LegendeEintrag(
        self, OeREBKRMtrsfr_V2_0_Transferstruktur_LegendeEintrag
    ):
        self.OeREBKRMtrsfr_V2_0_Transferstruktur_LegendeEintrag = (
            OeREBKRMtrsfr_V2_0_Transferstruktur_LegendeEintrag
        )

    def add_OeREBKRMtrsfr_V2_0_Transferstruktur_LegendeEintrag(self, value):
        self.OeREBKRMtrsfr_V2_0_Transferstruktur_LegendeEintrag.append(value)

    def insert_OeREBKRMtrsfr_V2_0_Transferstruktur_LegendeEintrag_at(self, index, value):
        self.OeREBKRMtrsfr_V2_0_Transferstruktur_LegendeEintrag.insert(index, value)

    def replace_OeREBKRMtrsfr_V2_0_Transferstruktur_LegendeEintrag_at(self, index, value):
        self.OeREBKRMtrsfr_V2_0_Transferstruktur_LegendeEintrag[index] = value

    def get_OeREBKRMtrsfr_V2_0_Transferstruktur_HinweisVorschrift(self):
        return self.OeREBKRMtrsfr_V2_0_Transferstruktur_HinweisVorschrift

    def set_OeREBKRMtrsfr_V2_0_Transferstruktur_HinweisVorschrift(
        self, OeREBKRMtrsfr_V2_0_Transferstruktur_HinweisVorschrift
    ):
        self.OeREBKRMtrsfr_V2_0_Transferstruktur_HinweisVorschrift = (
            OeREBKRMtrsfr_V2_0_Transferstruktur_HinweisVorschrift
        )

    def add_OeREBKRMtrsfr_V2_0_Transferstruktur_HinweisVorschrift(self, value):
        self.OeREBKRMtrsfr_V2_0_Transferstruktur_HinweisVorschrift.append(value)

    def insert_OeREBKRMtrsfr_V2_0_Transferstruktur_HinweisVorschrift_at(self, index, value):
        self.OeREBKRMtrsfr_V2_0_Transferstruktur_HinweisVorschrift.insert(index, value)

    def replace_OeREBKRMtrsfr_V2_0_Transferstruktur_HinweisVorschrift_at(self, index, value):
        self.OeREBKRMtrsfr_V2_0_Transferstruktur_HinweisVorschrift[index] = value

    def get_BID(self):
        return self.BID

    def set_BID(self, BID):
        self.BID = BID

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if (
            self.OeREBKRM_V2_0_Amt_Amt
            or self.OeREBKRM_V2_0_Dokumente_Dokument
            or self.OeREBKRMtrsfr_V2_0_Transferstruktur_DarstellungsDienst
            or self.OeREBKRMtrsfr_V2_0_Transferstruktur_Eigentumsbeschraenkung
            or self.OeREBKRMtrsfr_V2_0_Transferstruktur_Geometrie
            or self.OeREBKRMtrsfr_V2_0_Transferstruktur_LegendeEintrag
            or self.OeREBKRMtrsfr_V2_0_Transferstruktur_HinweisVorschrift
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="OeREBKRMtrsfr_V2_0.Transferstruktur",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("OeREBKRMtrsfr_V2_0.Transferstruktur")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "OeREBKRMtrsfr_V2_0.Transferstruktur":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="OeREBKRMtrsfr_V2_0.Transferstruktur",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="OeREBKRMtrsfr_V2_0.Transferstruktur",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="OeREBKRMtrsfr_V2_0.Transferstruktur",
    ):
        if self.BID is not None and "BID" not in already_processed:
            already_processed.add("BID")
            outfile.write(
                " BID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.BID), input_name="BID")),)
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="OeREBKRMtrsfr_V2_0.Transferstruktur",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for OeREBKRM_V2_0_Amt_Amt_ in self.OeREBKRM_V2_0_Amt_Amt:
            namespaceprefix_ = (
                self.OeREBKRM_V2_0_Amt_Amt_nsprefix_ + ":"
                if (UseCapturedNS_ and self.OeREBKRM_V2_0_Amt_Amt_nsprefix_)
                else ""
            )
            OeREBKRM_V2_0_Amt_Amt_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="OeREBKRM_V2_0.Amt.Amt",
                pretty_print=pretty_print,
            )
        for OeREBKRM_V2_0_Dokumente_Dokument_ in self.OeREBKRM_V2_0_Dokumente_Dokument:
            namespaceprefix_ = (
                self.OeREBKRM_V2_0_Dokumente_Dokument_nsprefix_ + ":"
                if (UseCapturedNS_ and self.OeREBKRM_V2_0_Dokumente_Dokument_nsprefix_)
                else ""
            )
            OeREBKRM_V2_0_Dokumente_Dokument_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="OeREBKRM_V2_0.Dokumente.Dokument",
                pretty_print=pretty_print,
            )
        for (
            OeREBKRMtrsfr_V2_0_Transferstruktur_DarstellungsDienst_
        ) in self.OeREBKRMtrsfr_V2_0_Transferstruktur_DarstellungsDienst:
            namespaceprefix_ = (
                self.OeREBKRMtrsfr_V2_0_Transferstruktur_DarstellungsDienst_nsprefix_ + ":"
                if (UseCapturedNS_ and self.OeREBKRMtrsfr_V2_0_Transferstruktur_DarstellungsDienst_nsprefix_)
                else ""
            )
            OeREBKRMtrsfr_V2_0_Transferstruktur_DarstellungsDienst_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="OeREBKRMtrsfr_V2_0.Transferstruktur.DarstellungsDienst",
                pretty_print=pretty_print,
            )
        for (
            OeREBKRMtrsfr_V2_0_Transferstruktur_Eigentumsbeschraenkung_
        ) in self.OeREBKRMtrsfr_V2_0_Transferstruktur_Eigentumsbeschraenkung:
            namespaceprefix_ = (
                self.OeREBKRMtrsfr_V2_0_Transferstruktur_Eigentumsbeschraenkung_nsprefix_ + ":"
                if (
                    UseCapturedNS_
                    and self.OeREBKRMtrsfr_V2_0_Transferstruktur_Eigentumsbeschraenkung_nsprefix_
                )
                else ""
            )
            OeREBKRMtrsfr_V2_0_Transferstruktur_Eigentumsbeschraenkung_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="OeREBKRMtrsfr_V2_0.Transferstruktur.Eigentumsbeschraenkung",
                pretty_print=pretty_print,
            )
        for (
            OeREBKRMtrsfr_V2_0_Transferstruktur_Geometrie_
        ) in self.OeREBKRMtrsfr_V2_0_Transferstruktur_Geometrie:
            namespaceprefix_ = (
                self.OeREBKRMtrsfr_V2_0_Transferstruktur_Geometrie_nsprefix_ + ":"
                if (UseCapturedNS_ and self.OeREBKRMtrsfr_V2_0_Transferstruktur_Geometrie_nsprefix_)
                else ""
            )
            OeREBKRMtrsfr_V2_0_Transferstruktur_Geometrie_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="OeREBKRMtrsfr_V2_0.Transferstruktur.Geometrie",
                pretty_print=pretty_print,
            )
        for (
            OeREBKRMtrsfr_V2_0_Transferstruktur_LegendeEintrag_
        ) in self.OeREBKRMtrsfr_V2_0_Transferstruktur_LegendeEintrag:
            namespaceprefix_ = (
                self.OeREBKRMtrsfr_V2_0_Transferstruktur_LegendeEintrag_nsprefix_ + ":"
                if (UseCapturedNS_ and self.OeREBKRMtrsfr_V2_0_Transferstruktur_LegendeEintrag_nsprefix_)
                else ""
            )
            OeREBKRMtrsfr_V2_0_Transferstruktur_LegendeEintrag_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="OeREBKRMtrsfr_V2_0.Transferstruktur.LegendeEintrag",
                pretty_print=pretty_print,
            )
        for (
            OeREBKRMtrsfr_V2_0_Transferstruktur_HinweisVorschrift_
        ) in self.OeREBKRMtrsfr_V2_0_Transferstruktur_HinweisVorschrift:
            namespaceprefix_ = (
                self.OeREBKRMtrsfr_V2_0_Transferstruktur_HinweisVorschrift_nsprefix_ + ":"
                if (UseCapturedNS_ and self.OeREBKRMtrsfr_V2_0_Transferstruktur_HinweisVorschrift_nsprefix_)
                else ""
            )
            OeREBKRMtrsfr_V2_0_Transferstruktur_HinweisVorschrift_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="OeREBKRMtrsfr_V2_0.Transferstruktur.HinweisVorschrift",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("BID", node)
        if value is not None and "BID" not in already_processed:
            already_processed.add("BID")
            self.BID = value
            self.validate_IliID(self.BID)  # validate type IliID

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "OeREBKRM_V2_0.Amt.Amt":
            obj_ = OeREBKRM_V2_0_Amt_Amt.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OeREBKRM_V2_0_Amt_Amt.append(obj_)
            obj_.original_tagname_ = "OeREBKRM_V2_0.Amt.Amt"
        elif nodeName_ == "OeREBKRM_V2_0.Dokumente.Dokument":
            obj_ = OeREBKRM_V2_0_Dokumente_Dokument.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OeREBKRM_V2_0_Dokumente_Dokument.append(obj_)
            obj_.original_tagname_ = "OeREBKRM_V2_0.Dokumente.Dokument"
        elif nodeName_ == "OeREBKRMtrsfr_V2_0.Transferstruktur.DarstellungsDienst":
            obj_ = OeREBKRMtrsfr_V2_0_Transferstruktur_DarstellungsDienst.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OeREBKRMtrsfr_V2_0_Transferstruktur_DarstellungsDienst.append(obj_)
            obj_.original_tagname_ = "OeREBKRMtrsfr_V2_0.Transferstruktur.DarstellungsDienst"
        elif nodeName_ == "OeREBKRMtrsfr_V2_0.Transferstruktur.Eigentumsbeschraenkung":
            obj_ = OeREBKRMtrsfr_V2_0_Transferstruktur_Eigentumsbeschraenkung.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OeREBKRMtrsfr_V2_0_Transferstruktur_Eigentumsbeschraenkung.append(obj_)
            obj_.original_tagname_ = "OeREBKRMtrsfr_V2_0.Transferstruktur.Eigentumsbeschraenkung"
        elif nodeName_ == "OeREBKRMtrsfr_V2_0.Transferstruktur.Geometrie":
            obj_ = OeREBKRMtrsfr_V2_0_Transferstruktur_Geometrie.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OeREBKRMtrsfr_V2_0_Transferstruktur_Geometrie.append(obj_)
            obj_.original_tagname_ = "OeREBKRMtrsfr_V2_0.Transferstruktur.Geometrie"
        elif nodeName_ == "OeREBKRMtrsfr_V2_0.Transferstruktur.LegendeEintrag":
            obj_ = OeREBKRMtrsfr_V2_0_Transferstruktur_LegendeEintrag.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OeREBKRMtrsfr_V2_0_Transferstruktur_LegendeEintrag.append(obj_)
            obj_.original_tagname_ = "OeREBKRMtrsfr_V2_0.Transferstruktur.LegendeEintrag"
        elif nodeName_ == "OeREBKRMtrsfr_V2_0.Transferstruktur.HinweisVorschrift":
            obj_ = OeREBKRMtrsfr_V2_0_Transferstruktur_HinweisVorschrift.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OeREBKRMtrsfr_V2_0_Transferstruktur_HinweisVorschrift.append(obj_)
            obj_.original_tagname_ = "OeREBKRMtrsfr_V2_0.Transferstruktur.HinweisVorschrift"


# end class OeREBKRMtrsfr_V2_0_Transferstruktur


class CoordValue(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "C1": MemberSpec_("C1", "xsd:double", 0, 0, {"name": "C1", "type": "xsd:double"}, None),
        "C2": MemberSpec_(
            "C2",
            "xsd:double",
            0,
            1,
            {"minOccurs": "0", "name": "C2", "type": "xsd:double"},
            None,
        ),
        "C3": MemberSpec_(
            "C3",
            "xsd:double",
            0,
            1,
            {"minOccurs": "0", "name": "C3", "type": "xsd:double"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, C1=None, C2=None, C3=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.C1 = C1
        self.C1_nsprefix_ = None
        self.C2 = C2
        self.C2_nsprefix_ = None
        self.C3 = C3
        self.C3_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, CoordValue)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoordValue.subclass:
            return CoordValue.subclass(*args_, **kwargs_)
        else:
            return CoordValue(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_C1(self):
        return self.C1

    def set_C1(self, C1):
        self.C1 = C1

    def get_C2(self):
        return self.C2

    def set_C2(self, C2):
        self.C2 = C2

    def get_C3(self):
        return self.C3

    def set_C3(self, C3):
        self.C3 = C3

    def _hasContent(self):
        if self.C1 is not None or self.C2 is not None or self.C3 is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordValue",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("CoordValue")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "CoordValue":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="CoordValue")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="CoordValue",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_="", name_="CoordValue"):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="CoordValue",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.C1 is not None:
            namespaceprefix_ = self.C1_nsprefix_ + ":" if (UseCapturedNS_ and self.C1_nsprefix_) else ""
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sC1>%s</%sC1>%s"
                % (
                    namespaceprefix_,
                    self.gds_format_double(self.C1, input_name="C1"),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.C2 is not None:
            namespaceprefix_ = self.C2_nsprefix_ + ":" if (UseCapturedNS_ and self.C2_nsprefix_) else ""
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sC2>%s</%sC2>%s"
                % (
                    namespaceprefix_,
                    self.gds_format_double(self.C2, input_name="C2"),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.C3 is not None:
            namespaceprefix_ = self.C3_nsprefix_ + ":" if (UseCapturedNS_ and self.C3_nsprefix_) else ""
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sC3>%s</%sC3>%s"
                % (
                    namespaceprefix_,
                    self.gds_format_double(self.C3, input_name="C3"),
                    namespaceprefix_,
                    eol_,
                )
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "C1" and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, "C1")
            fval_ = self.gds_validate_double(fval_, node, "C1")
            self.C1 = fval_
            self.C1_nsprefix_ = child_.prefix
        elif nodeName_ == "C2" and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, "C2")
            fval_ = self.gds_validate_double(fval_, node, "C2")
            self.C2 = fval_
            self.C2_nsprefix_ = child_.prefix
        elif nodeName_ == "C3" and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, "C3")
            fval_ = self.gds_validate_double(fval_, node, "C3")
            self.C3 = fval_
            self.C3_nsprefix_ = child_.prefix


# end class CoordValue


class ArcPoint(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "C1": MemberSpec_("C1", "xsd:double", 0, 0, {"name": "C1", "type": "xsd:double"}, None),
        "C2": MemberSpec_("C2", "xsd:double", 0, 0, {"name": "C2", "type": "xsd:double"}, None),
        "C3": MemberSpec_(
            "C3",
            "xsd:double",
            0,
            1,
            {"minOccurs": "0", "name": "C3", "type": "xsd:double"},
            None,
        ),
        "A1": MemberSpec_("A1", "xsd:double", 0, 0, {"name": "A1", "type": "xsd:double"}, None),
        "A2": MemberSpec_("A2", "xsd:double", 0, 0, {"name": "A2", "type": "xsd:double"}, None),
        "R": MemberSpec_(
            "R",
            "xsd:double",
            0,
            1,
            {"minOccurs": "0", "name": "R", "type": "xsd:double"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, C1=None, C2=None, C3=None, A1=None, A2=None, R=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.C1 = C1
        self.C1_nsprefix_ = None
        self.C2 = C2
        self.C2_nsprefix_ = None
        self.C3 = C3
        self.C3_nsprefix_ = None
        self.A1 = A1
        self.A1_nsprefix_ = None
        self.A2 = A2
        self.A2_nsprefix_ = None
        self.R = R
        self.R_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, ArcPoint)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArcPoint.subclass:
            return ArcPoint.subclass(*args_, **kwargs_)
        else:
            return ArcPoint(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_C1(self):
        return self.C1

    def set_C1(self, C1):
        self.C1 = C1

    def get_C2(self):
        return self.C2

    def set_C2(self, C2):
        self.C2 = C2

    def get_C3(self):
        return self.C3

    def set_C3(self, C3):
        self.C3 = C3

    def get_A1(self):
        return self.A1

    def set_A1(self, A1):
        self.A1 = A1

    def get_A2(self):
        return self.A2

    def set_A2(self, A2):
        self.A2 = A2

    def get_R(self):
        return self.R

    def set_R(self, R):
        self.R = R

    def _hasContent(self):
        if (
            self.C1 is not None
            or self.C2 is not None
            or self.C3 is not None
            or self.A1 is not None
            or self.A2 is not None
            or self.R is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="ArcPoint",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("ArcPoint")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "ArcPoint":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="ArcPoint")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="ArcPoint",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_="", name_="ArcPoint"):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="ArcPoint",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.C1 is not None:
            namespaceprefix_ = self.C1_nsprefix_ + ":" if (UseCapturedNS_ and self.C1_nsprefix_) else ""
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sC1>%s</%sC1>%s"
                % (
                    namespaceprefix_,
                    self.gds_format_double(self.C1, input_name="C1"),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.C2 is not None:
            namespaceprefix_ = self.C2_nsprefix_ + ":" if (UseCapturedNS_ and self.C2_nsprefix_) else ""
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sC2>%s</%sC2>%s"
                % (
                    namespaceprefix_,
                    self.gds_format_double(self.C2, input_name="C2"),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.C3 is not None:
            namespaceprefix_ = self.C3_nsprefix_ + ":" if (UseCapturedNS_ and self.C3_nsprefix_) else ""
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sC3>%s</%sC3>%s"
                % (
                    namespaceprefix_,
                    self.gds_format_double(self.C3, input_name="C3"),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.A1 is not None:
            namespaceprefix_ = self.A1_nsprefix_ + ":" if (UseCapturedNS_ and self.A1_nsprefix_) else ""
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sA1>%s</%sA1>%s"
                % (
                    namespaceprefix_,
                    self.gds_format_double(self.A1, input_name="A1"),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.A2 is not None:
            namespaceprefix_ = self.A2_nsprefix_ + ":" if (UseCapturedNS_ and self.A2_nsprefix_) else ""
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sA2>%s</%sA2>%s"
                % (
                    namespaceprefix_,
                    self.gds_format_double(self.A2, input_name="A2"),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.R is not None:
            namespaceprefix_ = self.R_nsprefix_ + ":" if (UseCapturedNS_ and self.R_nsprefix_) else ""
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sR>%s</%sR>%s"
                % (
                    namespaceprefix_,
                    self.gds_format_double(self.R, input_name="R"),
                    namespaceprefix_,
                    eol_,
                )
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "C1" and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, "C1")
            fval_ = self.gds_validate_double(fval_, node, "C1")
            self.C1 = fval_
            self.C1_nsprefix_ = child_.prefix
        elif nodeName_ == "C2" and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, "C2")
            fval_ = self.gds_validate_double(fval_, node, "C2")
            self.C2 = fval_
            self.C2_nsprefix_ = child_.prefix
        elif nodeName_ == "C3" and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, "C3")
            fval_ = self.gds_validate_double(fval_, node, "C3")
            self.C3 = fval_
            self.C3_nsprefix_ = child_.prefix
        elif nodeName_ == "A1" and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, "A1")
            fval_ = self.gds_validate_double(fval_, node, "A1")
            self.A1 = fval_
            self.A1_nsprefix_ = child_.prefix
        elif nodeName_ == "A2" and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, "A2")
            fval_ = self.gds_validate_double(fval_, node, "A2")
            self.A2 = fval_
            self.A2_nsprefix_ = child_.prefix
        elif nodeName_ == "R" and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, "R")
            fval_ = self.gds_validate_double(fval_, node, "R")
            self.R = fval_
            self.R_nsprefix_ = child_.prefix


# end class ArcPoint


class HeaderSection(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "VERSION": MemberSpec_("VERSION", "xsd:decimal", 0, 0, {"use": "required", "name": "VERSION"}),
        "SENDER": MemberSpec_("SENDER", "xsd:string", 0, 0, {"use": "required", "name": "SENDER"}),
        "MODELS": MemberSpec_("MODELS", "Models", 0, 0, {"name": "MODELS", "type": "Models"}, None),
        "OIDSPACES": MemberSpec_(
            "OIDSPACES",
            "OidSpaces",
            0,
            1,
            {"minOccurs": "0", "name": "OIDSPACES", "type": "OidSpaces"},
            None,
        ),
        "COMMENT": MemberSpec_(
            "COMMENT",
            "xsd:string",
            0,
            1,
            {"minOccurs": "0", "name": "COMMENT", "type": "xsd:string"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(
        self,
        VERSION=2.3,
        SENDER=None,
        MODELS=None,
        OIDSPACES=None,
        COMMENT=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.VERSION = _cast(float, VERSION)
        self.VERSION_nsprefix_ = None
        self.SENDER = _cast(None, SENDER)
        self.SENDER_nsprefix_ = None
        if MODELS is None:
            self.MODELS = globals()["Models"]()
        else:
            self.MODELS = MODELS
        self.MODELS_nsprefix_ = None
        self.OIDSPACES = OIDSPACES
        self.OIDSPACES_nsprefix_ = None
        self.COMMENT = COMMENT
        self.COMMENT_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, HeaderSection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HeaderSection.subclass:
            return HeaderSection.subclass(*args_, **kwargs_)
        else:
            return HeaderSection(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_MODELS(self):
        return self.MODELS

    def set_MODELS(self, MODELS):
        self.MODELS = MODELS

    def get_OIDSPACES(self):
        return self.OIDSPACES

    def set_OIDSPACES(self, OIDSPACES):
        self.OIDSPACES = OIDSPACES

    def get_COMMENT(self):
        return self.COMMENT

    def set_COMMENT(self, COMMENT):
        self.COMMENT = COMMENT

    def get_VERSION(self):
        return self.VERSION

    def set_VERSION(self, VERSION):
        self.VERSION = VERSION

    def get_SENDER(self):
        return self.SENDER

    def set_SENDER(self, SENDER):
        self.SENDER = SENDER

    def _hasContent(self):
        if self.MODELS is not None or self.OIDSPACES is not None or self.COMMENT is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="HeaderSection",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("HeaderSection")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "HeaderSection":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="HeaderSection")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="HeaderSection",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="HeaderSection",
    ):
        if self.VERSION is not None and "VERSION" not in already_processed:
            already_processed.add("VERSION")
            outfile.write(' VERSION="%s"' % self.gds_format_decimal(self.VERSION, input_name="VERSION"))
        if self.SENDER is not None and "SENDER" not in already_processed:
            already_processed.add("SENDER")
            outfile.write(
                " SENDER=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.SENDER), input_name="SENDER")),)
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="HeaderSection",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.MODELS is not None:
            namespaceprefix_ = (
                self.MODELS_nsprefix_ + ":" if (UseCapturedNS_ and self.MODELS_nsprefix_) else ""
            )
            self.MODELS.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="MODELS",
                pretty_print=pretty_print,
            )
        if self.OIDSPACES is not None:
            namespaceprefix_ = (
                self.OIDSPACES_nsprefix_ + ":" if (UseCapturedNS_ and self.OIDSPACES_nsprefix_) else ""
            )
            self.OIDSPACES.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="OIDSPACES",
                pretty_print=pretty_print,
            )
        if self.COMMENT is not None:
            namespaceprefix_ = (
                self.COMMENT_nsprefix_ + ":" if (UseCapturedNS_ and self.COMMENT_nsprefix_) else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sCOMMENT>%s</%sCOMMENT>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(self.gds_format_string(quote_xml(self.COMMENT), input_name="COMMENT")),
                    namespaceprefix_,
                    eol_,
                )
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("VERSION", node)
        if value is not None and "VERSION" not in already_processed:
            already_processed.add("VERSION")
            value = self.gds_parse_decimal(value, node, "VERSION")
            self.VERSION = value
        value = find_attr_value_("SENDER", node)
        if value is not None and "SENDER" not in already_processed:
            already_processed.add("SENDER")
            self.SENDER = value

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "MODELS":
            obj_ = Models.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MODELS = obj_
            obj_.original_tagname_ = "MODELS"
        elif nodeName_ == "OIDSPACES":
            obj_ = OidSpaces.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OIDSPACES = obj_
            obj_.original_tagname_ = "OIDSPACES"
        elif nodeName_ == "COMMENT":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "COMMENT")
            value_ = self.gds_validate_string(value_, node, "COMMENT")
            self.COMMENT = value_
            self.COMMENT_nsprefix_ = child_.prefix


# end class HeaderSection


class OidSpaces(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "OIDSPACE": MemberSpec_(
            "OIDSPACE",
            "OidSpace",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "OIDSPACE",
                "type": "OidSpace",
            },
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, OIDSPACE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if OIDSPACE is None:
            self.OIDSPACE = []
        else:
            self.OIDSPACE = OIDSPACE
        self.OIDSPACE_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, OidSpaces)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OidSpaces.subclass:
            return OidSpaces.subclass(*args_, **kwargs_)
        else:
            return OidSpaces(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_OIDSPACE(self):
        return self.OIDSPACE

    def set_OIDSPACE(self, OIDSPACE):
        self.OIDSPACE = OIDSPACE

    def add_OIDSPACE(self, value):
        self.OIDSPACE.append(value)

    def insert_OIDSPACE_at(self, index, value):
        self.OIDSPACE.insert(index, value)

    def replace_OIDSPACE_at(self, index, value):
        self.OIDSPACE[index] = value

    def _hasContent(self):
        if self.OIDSPACE:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="OidSpaces",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("OidSpaces")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "OidSpaces":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="OidSpaces")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="OidSpaces",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_="", name_="OidSpaces"):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="OidSpaces",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for OIDSPACE_ in self.OIDSPACE:
            namespaceprefix_ = (
                self.OIDSPACE_nsprefix_ + ":" if (UseCapturedNS_ and self.OIDSPACE_nsprefix_) else ""
            )
            OIDSPACE_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="OIDSPACE",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "OIDSPACE":
            obj_ = OidSpace.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OIDSPACE.append(obj_)
            obj_.original_tagname_ = "OIDSPACE"


# end class OidSpaces


class OidSpace(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "NAME": MemberSpec_("NAME", "xsd:string", 0, 0, {"use": "required", "name": "NAME"}),
        "OIDDOMAIN": MemberSpec_("OIDDOMAIN", "xsd:string", 0, 0, {"use": "required", "name": "OIDDOMAIN"}),
    }
    subclass = None
    superclass = None

    def __init__(self, NAME=None, OIDDOMAIN=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.NAME = _cast(None, NAME)
        self.NAME_nsprefix_ = None
        self.OIDDOMAIN = _cast(None, OIDDOMAIN)
        self.OIDDOMAIN_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, OidSpace)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OidSpace.subclass:
            return OidSpace.subclass(*args_, **kwargs_)
        else:
            return OidSpace(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_NAME(self):
        return self.NAME

    def set_NAME(self, NAME):
        self.NAME = NAME

    def get_OIDDOMAIN(self):
        return self.OIDDOMAIN

    def set_OIDDOMAIN(self, OIDDOMAIN):
        self.OIDDOMAIN = OIDDOMAIN

    def _hasContent(self):
        if ():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="OidSpace",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("OidSpace")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "OidSpace":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="OidSpace")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="OidSpace",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_="", name_="OidSpace"):
        if self.NAME is not None and "NAME" not in already_processed:
            already_processed.add("NAME")
            outfile.write(
                " NAME=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.NAME), input_name="NAME")),)
            )
        if self.OIDDOMAIN is not None and "OIDDOMAIN" not in already_processed:
            already_processed.add("OIDDOMAIN")
            outfile.write(
                " OIDDOMAIN=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.OIDDOMAIN), input_name="OIDDOMAIN")
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="OidSpace",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("NAME", node)
        if value is not None and "NAME" not in already_processed:
            already_processed.add("NAME")
            self.NAME = value
        value = find_attr_value_("OIDDOMAIN", node)
        if value is not None and "OIDDOMAIN" not in already_processed:
            already_processed.add("OIDDOMAIN")
            self.OIDDOMAIN = value

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class OidSpace


class UpperLevelUnitType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "REF": MemberSpec_("REF", "IliID", 0, 0, {"use": "required", "name": "REF"}),
        "BID": MemberSpec_("BID", "IliID", 0, 1, {"use": "optional", "name": "BID"}),
        "ORDER_POS": MemberSpec_(
            "ORDER_POS",
            "xsd:positiveInteger",
            0,
            1,
            {"use": "optional", "name": "ORDER_POS"},
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, REF=None, BID=None, ORDER_POS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.REF = _cast(None, REF)
        self.REF_nsprefix_ = None
        self.BID = _cast(None, BID)
        self.BID_nsprefix_ = None
        self.ORDER_POS = _cast(int, ORDER_POS)
        self.ORDER_POS_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, UpperLevelUnitType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UpperLevelUnitType.subclass:
            return UpperLevelUnitType.subclass(*args_, **kwargs_)
        else:
            return UpperLevelUnitType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_REF(self):
        return self.REF

    def set_REF(self, REF):
        self.REF = REF

    def get_BID(self):
        return self.BID

    def set_BID(self, BID):
        self.BID = BID

    def get_ORDER_POS(self):
        return self.ORDER_POS

    def set_ORDER_POS(self, ORDER_POS):
        self.ORDER_POS = ORDER_POS

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if ():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="UpperLevelUnitType",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("UpperLevelUnitType")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "UpperLevelUnitType":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="UpperLevelUnitType",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="UpperLevelUnitType",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="UpperLevelUnitType",
    ):
        if self.REF is not None and "REF" not in already_processed:
            already_processed.add("REF")
            outfile.write(
                " REF=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.REF), input_name="REF")),)
            )
        if self.BID is not None and "BID" not in already_processed:
            already_processed.add("BID")
            outfile.write(
                " BID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.BID), input_name="BID")),)
            )
        if self.ORDER_POS is not None and "ORDER_POS" not in already_processed:
            already_processed.add("ORDER_POS")
            outfile.write(' ORDER_POS="%s"' % self.gds_format_integer(self.ORDER_POS, input_name="ORDER_POS"))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="UpperLevelUnitType",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("REF", node)
        if value is not None and "REF" not in already_processed:
            already_processed.add("REF")
            self.REF = value
            self.validate_IliID(self.REF)  # validate type IliID
        value = find_attr_value_("BID", node)
        if value is not None and "BID" not in already_processed:
            already_processed.add("BID")
            self.BID = value
            self.validate_IliID(self.BID)  # validate type IliID
        value = find_attr_value_("ORDER_POS", node)
        if value is not None and "ORDER_POS" not in already_processed:
            already_processed.add("ORDER_POS")
            self.ORDER_POS = self.gds_parse_integer(value, node, "ORDER_POS")
            if self.ORDER_POS <= 0:
                raise_parse_error(node, "Invalid PositiveInteger")

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class UpperLevelUnitType


class NameType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "LocalisationCH_V1_MultilingualText": MemberSpec_(
            "LocalisationCH_V1_MultilingualText",
            "LocalisationCH_V1.MultilingualText",
            0,
            0,
            {
                "name": "LocalisationCH_V1.MultilingualText",
                "type": "LocalisationCH_V1.MultilingualText",
            },
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, LocalisationCH_V1_MultilingualText=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if LocalisationCH_V1_MultilingualText is None:
            self.LocalisationCH_V1_MultilingualText = globals()["LocalisationCH_V1_MultilingualText"]()
        else:
            self.LocalisationCH_V1_MultilingualText = LocalisationCH_V1_MultilingualText
        self.LocalisationCH_V1_MultilingualText_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, NameType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NameType.subclass:
            return NameType.subclass(*args_, **kwargs_)
        else:
            return NameType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_LocalisationCH_V1_MultilingualText(self):
        return self.LocalisationCH_V1_MultilingualText

    def set_LocalisationCH_V1_MultilingualText(self, LocalisationCH_V1_MultilingualText):
        self.LocalisationCH_V1_MultilingualText = LocalisationCH_V1_MultilingualText

    def _hasContent(self):
        if self.LocalisationCH_V1_MultilingualText is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="NameType",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("NameType")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "NameType":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="NameType")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="NameType",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_="", name_="NameType"):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="NameType",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.LocalisationCH_V1_MultilingualText is not None:
            namespaceprefix_ = (
                self.LocalisationCH_V1_MultilingualText_nsprefix_ + ":"
                if (UseCapturedNS_ and self.LocalisationCH_V1_MultilingualText_nsprefix_)
                else ""
            )
            self.LocalisationCH_V1_MultilingualText.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="LocalisationCH_V1.MultilingualText",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "LocalisationCH_V1.MultilingualText":
            obj_ = LocalisationCH_V1_MultilingualText.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LocalisationCH_V1_MultilingualText = obj_
            obj_.original_tagname_ = "LocalisationCH_V1.MultilingualText"


# end class NameType


class UpperLevelUnitType1(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "REF": MemberSpec_("REF", "IliID", 0, 0, {"use": "required", "name": "REF"}),
        "BID": MemberSpec_("BID", "IliID", 0, 1, {"use": "optional", "name": "BID"}),
        "ORDER_POS": MemberSpec_(
            "ORDER_POS",
            "xsd:positiveInteger",
            0,
            1,
            {"use": "optional", "name": "ORDER_POS"},
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, REF=None, BID=None, ORDER_POS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.REF = _cast(None, REF)
        self.REF_nsprefix_ = None
        self.BID = _cast(None, BID)
        self.BID_nsprefix_ = None
        self.ORDER_POS = _cast(int, ORDER_POS)
        self.ORDER_POS_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, UpperLevelUnitType1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UpperLevelUnitType1.subclass:
            return UpperLevelUnitType1.subclass(*args_, **kwargs_)
        else:
            return UpperLevelUnitType1(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_REF(self):
        return self.REF

    def set_REF(self, REF):
        self.REF = REF

    def get_BID(self):
        return self.BID

    def set_BID(self, BID):
        self.BID = BID

    def get_ORDER_POS(self):
        return self.ORDER_POS

    def set_ORDER_POS(self, ORDER_POS):
        self.ORDER_POS = ORDER_POS

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if ():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="UpperLevelUnitType1",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("UpperLevelUnitType1")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "UpperLevelUnitType1":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="UpperLevelUnitType1",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="UpperLevelUnitType1",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="UpperLevelUnitType1",
    ):
        if self.REF is not None and "REF" not in already_processed:
            already_processed.add("REF")
            outfile.write(
                " REF=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.REF), input_name="REF")),)
            )
        if self.BID is not None and "BID" not in already_processed:
            already_processed.add("BID")
            outfile.write(
                " BID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.BID), input_name="BID")),)
            )
        if self.ORDER_POS is not None and "ORDER_POS" not in already_processed:
            already_processed.add("ORDER_POS")
            outfile.write(' ORDER_POS="%s"' % self.gds_format_integer(self.ORDER_POS, input_name="ORDER_POS"))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="UpperLevelUnitType1",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("REF", node)
        if value is not None and "REF" not in already_processed:
            already_processed.add("REF")
            self.REF = value
            self.validate_IliID(self.REF)  # validate type IliID
        value = find_attr_value_("BID", node)
        if value is not None and "BID" not in already_processed:
            already_processed.add("BID")
            self.BID = value
            self.validate_IliID(self.BID)  # validate type IliID
        value = find_attr_value_("ORDER_POS", node)
        if value is not None and "ORDER_POS" not in already_processed:
            already_processed.add("ORDER_POS")
            self.ORDER_POS = self.gds_parse_integer(value, node, "ORDER_POS")
            if self.ORDER_POS <= 0:
                raise_parse_error(node, "Invalid PositiveInteger")

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class UpperLevelUnitType1


class NameType2(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "LocalisationCH_V1_MultilingualText": MemberSpec_(
            "LocalisationCH_V1_MultilingualText",
            "LocalisationCH_V1.MultilingualText",
            0,
            0,
            {
                "name": "LocalisationCH_V1.MultilingualText",
                "type": "LocalisationCH_V1.MultilingualText",
            },
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, LocalisationCH_V1_MultilingualText=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if LocalisationCH_V1_MultilingualText is None:
            self.LocalisationCH_V1_MultilingualText = globals()["LocalisationCH_V1_MultilingualText"]()
        else:
            self.LocalisationCH_V1_MultilingualText = LocalisationCH_V1_MultilingualText
        self.LocalisationCH_V1_MultilingualText_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, NameType2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NameType2.subclass:
            return NameType2.subclass(*args_, **kwargs_)
        else:
            return NameType2(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_LocalisationCH_V1_MultilingualText(self):
        return self.LocalisationCH_V1_MultilingualText

    def set_LocalisationCH_V1_MultilingualText(self, LocalisationCH_V1_MultilingualText):
        self.LocalisationCH_V1_MultilingualText = LocalisationCH_V1_MultilingualText

    def _hasContent(self):
        if self.LocalisationCH_V1_MultilingualText is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="NameType2",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("NameType2")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "NameType2":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="NameType2")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="NameType2",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_="", name_="NameType2"):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="NameType2",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.LocalisationCH_V1_MultilingualText is not None:
            namespaceprefix_ = (
                self.LocalisationCH_V1_MultilingualText_nsprefix_ + ":"
                if (UseCapturedNS_ and self.LocalisationCH_V1_MultilingualText_nsprefix_)
                else ""
            )
            self.LocalisationCH_V1_MultilingualText.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="LocalisationCH_V1.MultilingualText",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "LocalisationCH_V1.MultilingualText":
            obj_ = LocalisationCH_V1_MultilingualText.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LocalisationCH_V1_MultilingualText = obj_
            obj_.original_tagname_ = "LocalisationCH_V1.MultilingualText"


# end class NameType2


class UpperLevelUnitType3(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "REF": MemberSpec_("REF", "IliID", 0, 0, {"use": "required", "name": "REF"}),
        "BID": MemberSpec_("BID", "IliID", 0, 1, {"use": "optional", "name": "BID"}),
        "ORDER_POS": MemberSpec_(
            "ORDER_POS",
            "xsd:positiveInteger",
            0,
            1,
            {"use": "optional", "name": "ORDER_POS"},
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, REF=None, BID=None, ORDER_POS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.REF = _cast(None, REF)
        self.REF_nsprefix_ = None
        self.BID = _cast(None, BID)
        self.BID_nsprefix_ = None
        self.ORDER_POS = _cast(int, ORDER_POS)
        self.ORDER_POS_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, UpperLevelUnitType3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UpperLevelUnitType3.subclass:
            return UpperLevelUnitType3.subclass(*args_, **kwargs_)
        else:
            return UpperLevelUnitType3(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_REF(self):
        return self.REF

    def set_REF(self, REF):
        self.REF = REF

    def get_BID(self):
        return self.BID

    def set_BID(self, BID):
        self.BID = BID

    def get_ORDER_POS(self):
        return self.ORDER_POS

    def set_ORDER_POS(self, ORDER_POS):
        self.ORDER_POS = ORDER_POS

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if ():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="UpperLevelUnitType3",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("UpperLevelUnitType3")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "UpperLevelUnitType3":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="UpperLevelUnitType3",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="UpperLevelUnitType3",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="UpperLevelUnitType3",
    ):
        if self.REF is not None and "REF" not in already_processed:
            already_processed.add("REF")
            outfile.write(
                " REF=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.REF), input_name="REF")),)
            )
        if self.BID is not None and "BID" not in already_processed:
            already_processed.add("BID")
            outfile.write(
                " BID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.BID), input_name="BID")),)
            )
        if self.ORDER_POS is not None and "ORDER_POS" not in already_processed:
            already_processed.add("ORDER_POS")
            outfile.write(' ORDER_POS="%s"' % self.gds_format_integer(self.ORDER_POS, input_name="ORDER_POS"))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="UpperLevelUnitType3",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("REF", node)
        if value is not None and "REF" not in already_processed:
            already_processed.add("REF")
            self.REF = value
            self.validate_IliID(self.REF)  # validate type IliID
        value = find_attr_value_("BID", node)
        if value is not None and "BID" not in already_processed:
            already_processed.add("BID")
            self.BID = value
            self.validate_IliID(self.BID)  # validate type IliID
        value = find_attr_value_("ORDER_POS", node)
        if value is not None and "ORDER_POS" not in already_processed:
            already_processed.add("ORDER_POS")
            self.ORDER_POS = self.gds_parse_integer(value, node, "ORDER_POS")
            if self.ORDER_POS <= 0:
                raise_parse_error(node, "Invalid PositiveInteger")

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class UpperLevelUnitType3


class NameType4(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "LocalisationCH_V1_MultilingualText": MemberSpec_(
            "LocalisationCH_V1_MultilingualText",
            "LocalisationCH_V1.MultilingualText",
            0,
            0,
            {
                "name": "LocalisationCH_V1.MultilingualText",
                "type": "LocalisationCH_V1.MultilingualText",
            },
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, LocalisationCH_V1_MultilingualText=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if LocalisationCH_V1_MultilingualText is None:
            self.LocalisationCH_V1_MultilingualText = globals()["LocalisationCH_V1_MultilingualText"]()
        else:
            self.LocalisationCH_V1_MultilingualText = LocalisationCH_V1_MultilingualText
        self.LocalisationCH_V1_MultilingualText_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, NameType4)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NameType4.subclass:
            return NameType4.subclass(*args_, **kwargs_)
        else:
            return NameType4(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_LocalisationCH_V1_MultilingualText(self):
        return self.LocalisationCH_V1_MultilingualText

    def set_LocalisationCH_V1_MultilingualText(self, LocalisationCH_V1_MultilingualText):
        self.LocalisationCH_V1_MultilingualText = LocalisationCH_V1_MultilingualText

    def _hasContent(self):
        if self.LocalisationCH_V1_MultilingualText is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="NameType4",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("NameType4")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "NameType4":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="NameType4")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="NameType4",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_="", name_="NameType4"):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="NameType4",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.LocalisationCH_V1_MultilingualText is not None:
            namespaceprefix_ = (
                self.LocalisationCH_V1_MultilingualText_nsprefix_ + ":"
                if (UseCapturedNS_ and self.LocalisationCH_V1_MultilingualText_nsprefix_)
                else ""
            )
            self.LocalisationCH_V1_MultilingualText.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="LocalisationCH_V1.MultilingualText",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "LocalisationCH_V1.MultilingualText":
            obj_ = LocalisationCH_V1_MultilingualText.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LocalisationCH_V1_MultilingualText = obj_
            obj_.original_tagname_ = "LocalisationCH_V1.MultilingualText"


# end class NameType4


class NameType5(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "LocalisationCH_V1_MultilingualText": MemberSpec_(
            "LocalisationCH_V1_MultilingualText",
            "LocalisationCH_V1.MultilingualText",
            0,
            0,
            {
                "name": "LocalisationCH_V1.MultilingualText",
                "type": "LocalisationCH_V1.MultilingualText",
            },
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, LocalisationCH_V1_MultilingualText=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if LocalisationCH_V1_MultilingualText is None:
            self.LocalisationCH_V1_MultilingualText = globals()["LocalisationCH_V1_MultilingualText"]()
        else:
            self.LocalisationCH_V1_MultilingualText = LocalisationCH_V1_MultilingualText
        self.LocalisationCH_V1_MultilingualText_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, NameType5)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NameType5.subclass:
            return NameType5.subclass(*args_, **kwargs_)
        else:
            return NameType5(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_LocalisationCH_V1_MultilingualText(self):
        return self.LocalisationCH_V1_MultilingualText

    def set_LocalisationCH_V1_MultilingualText(self, LocalisationCH_V1_MultilingualText):
        self.LocalisationCH_V1_MultilingualText = LocalisationCH_V1_MultilingualText

    def _hasContent(self):
        if self.LocalisationCH_V1_MultilingualText is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="NameType5",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("NameType5")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "NameType5":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="NameType5")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="NameType5",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_="", name_="NameType5"):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="NameType5",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.LocalisationCH_V1_MultilingualText is not None:
            namespaceprefix_ = (
                self.LocalisationCH_V1_MultilingualText_nsprefix_ + ":"
                if (UseCapturedNS_ and self.LocalisationCH_V1_MultilingualText_nsprefix_)
                else ""
            )
            self.LocalisationCH_V1_MultilingualText.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="LocalisationCH_V1.MultilingualText",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "LocalisationCH_V1.MultilingualText":
            obj_ = LocalisationCH_V1_MultilingualText.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LocalisationCH_V1_MultilingualText = obj_
            obj_.original_tagname_ = "LocalisationCH_V1.MultilingualText"


# end class NameType5


class DescriptionType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "LocalisationCH_V1_MultilingualMText": MemberSpec_(
            "LocalisationCH_V1_MultilingualMText",
            "LocalisationCH_V1.MultilingualMText",
            0,
            0,
            {
                "name": "LocalisationCH_V1.MultilingualMText",
                "type": "LocalisationCH_V1.MultilingualMText",
            },
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, LocalisationCH_V1_MultilingualMText=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if LocalisationCH_V1_MultilingualMText is None:
            self.LocalisationCH_V1_MultilingualMText = globals()["LocalisationCH_V1_MultilingualMText"]()
        else:
            self.LocalisationCH_V1_MultilingualMText = LocalisationCH_V1_MultilingualMText
        self.LocalisationCH_V1_MultilingualMText_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, DescriptionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DescriptionType.subclass:
            return DescriptionType.subclass(*args_, **kwargs_)
        else:
            return DescriptionType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_LocalisationCH_V1_MultilingualMText(self):
        return self.LocalisationCH_V1_MultilingualMText

    def set_LocalisationCH_V1_MultilingualMText(self, LocalisationCH_V1_MultilingualMText):
        self.LocalisationCH_V1_MultilingualMText = LocalisationCH_V1_MultilingualMText

    def _hasContent(self):
        if self.LocalisationCH_V1_MultilingualMText is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="DescriptionType",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("DescriptionType")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "DescriptionType":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="DescriptionType")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="DescriptionType",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="DescriptionType",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="DescriptionType",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.LocalisationCH_V1_MultilingualMText is not None:
            namespaceprefix_ = (
                self.LocalisationCH_V1_MultilingualMText_nsprefix_ + ":"
                if (UseCapturedNS_ and self.LocalisationCH_V1_MultilingualMText_nsprefix_)
                else ""
            )
            self.LocalisationCH_V1_MultilingualMText.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="LocalisationCH_V1.MultilingualMText",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "LocalisationCH_V1.MultilingualMText":
            obj_ = LocalisationCH_V1_MultilingualMText.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LocalisationCH_V1_MultilingualMText = obj_
            obj_.original_tagname_ = "LocalisationCH_V1.MultilingualMText"


# end class DescriptionType


class SupervisorType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "REF": MemberSpec_("REF", "IliID", 0, 0, {"use": "required", "name": "REF"}),
        "BID": MemberSpec_("BID", "IliID", 0, 1, {"use": "optional", "name": "BID"}),
        "ORDER_POS": MemberSpec_(
            "ORDER_POS",
            "xsd:positiveInteger",
            0,
            1,
            {"use": "optional", "name": "ORDER_POS"},
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, REF=None, BID=None, ORDER_POS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.REF = _cast(None, REF)
        self.REF_nsprefix_ = None
        self.BID = _cast(None, BID)
        self.BID_nsprefix_ = None
        self.ORDER_POS = _cast(int, ORDER_POS)
        self.ORDER_POS_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, SupervisorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SupervisorType.subclass:
            return SupervisorType.subclass(*args_, **kwargs_)
        else:
            return SupervisorType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_REF(self):
        return self.REF

    def set_REF(self, REF):
        self.REF = REF

    def get_BID(self):
        return self.BID

    def set_BID(self, BID):
        self.BID = BID

    def get_ORDER_POS(self):
        return self.ORDER_POS

    def set_ORDER_POS(self, ORDER_POS):
        self.ORDER_POS = ORDER_POS

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if ():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="SupervisorType",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("SupervisorType")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "SupervisorType":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="SupervisorType")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="SupervisorType",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="SupervisorType",
    ):
        if self.REF is not None and "REF" not in already_processed:
            already_processed.add("REF")
            outfile.write(
                " REF=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.REF), input_name="REF")),)
            )
        if self.BID is not None and "BID" not in already_processed:
            already_processed.add("BID")
            outfile.write(
                " BID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.BID), input_name="BID")),)
            )
        if self.ORDER_POS is not None and "ORDER_POS" not in already_processed:
            already_processed.add("ORDER_POS")
            outfile.write(' ORDER_POS="%s"' % self.gds_format_integer(self.ORDER_POS, input_name="ORDER_POS"))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="SupervisorType",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("REF", node)
        if value is not None and "REF" not in already_processed:
            already_processed.add("REF")
            self.REF = value
            self.validate_IliID(self.REF)  # validate type IliID
        value = find_attr_value_("BID", node)
        if value is not None and "BID" not in already_processed:
            already_processed.add("BID")
            self.BID = value
            self.validate_IliID(self.BID)  # validate type IliID
        value = find_attr_value_("ORDER_POS", node)
        if value is not None and "ORDER_POS" not in already_processed:
            already_processed.add("ORDER_POS")
            self.ORDER_POS = self.gds_parse_integer(value, node, "ORDER_POS")
            if self.ORDER_POS <= 0:
                raise_parse_error(node, "Invalid PositiveInteger")

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class SupervisorType


class NameType6(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "LocalisationCH_V1_MultilingualText": MemberSpec_(
            "LocalisationCH_V1_MultilingualText",
            "LocalisationCH_V1.MultilingualText",
            0,
            0,
            {
                "name": "LocalisationCH_V1.MultilingualText",
                "type": "LocalisationCH_V1.MultilingualText",
            },
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, LocalisationCH_V1_MultilingualText=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if LocalisationCH_V1_MultilingualText is None:
            self.LocalisationCH_V1_MultilingualText = globals()["LocalisationCH_V1_MultilingualText"]()
        else:
            self.LocalisationCH_V1_MultilingualText = LocalisationCH_V1_MultilingualText
        self.LocalisationCH_V1_MultilingualText_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, NameType6)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NameType6.subclass:
            return NameType6.subclass(*args_, **kwargs_)
        else:
            return NameType6(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_LocalisationCH_V1_MultilingualText(self):
        return self.LocalisationCH_V1_MultilingualText

    def set_LocalisationCH_V1_MultilingualText(self, LocalisationCH_V1_MultilingualText):
        self.LocalisationCH_V1_MultilingualText = LocalisationCH_V1_MultilingualText

    def _hasContent(self):
        if self.LocalisationCH_V1_MultilingualText is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="NameType6",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("NameType6")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "NameType6":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="NameType6")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="NameType6",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_="", name_="NameType6"):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="NameType6",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.LocalisationCH_V1_MultilingualText is not None:
            namespaceprefix_ = (
                self.LocalisationCH_V1_MultilingualText_nsprefix_ + ":"
                if (UseCapturedNS_ and self.LocalisationCH_V1_MultilingualText_nsprefix_)
                else ""
            )
            self.LocalisationCH_V1_MultilingualText.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="LocalisationCH_V1.MultilingualText",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "LocalisationCH_V1.MultilingualText":
            obj_ = LocalisationCH_V1_MultilingualText.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LocalisationCH_V1_MultilingualText = obj_
            obj_.original_tagname_ = "LocalisationCH_V1.MultilingualText"


# end class NameType6


class DescriptionType7(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "LocalisationCH_V1_MultilingualMText": MemberSpec_(
            "LocalisationCH_V1_MultilingualMText",
            "LocalisationCH_V1.MultilingualMText",
            0,
            0,
            {
                "name": "LocalisationCH_V1.MultilingualMText",
                "type": "LocalisationCH_V1.MultilingualMText",
            },
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, LocalisationCH_V1_MultilingualMText=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if LocalisationCH_V1_MultilingualMText is None:
            self.LocalisationCH_V1_MultilingualMText = globals()["LocalisationCH_V1_MultilingualMText"]()
        else:
            self.LocalisationCH_V1_MultilingualMText = LocalisationCH_V1_MultilingualMText
        self.LocalisationCH_V1_MultilingualMText_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, DescriptionType7)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DescriptionType7.subclass:
            return DescriptionType7.subclass(*args_, **kwargs_)
        else:
            return DescriptionType7(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_LocalisationCH_V1_MultilingualMText(self):
        return self.LocalisationCH_V1_MultilingualMText

    def set_LocalisationCH_V1_MultilingualMText(self, LocalisationCH_V1_MultilingualMText):
        self.LocalisationCH_V1_MultilingualMText = LocalisationCH_V1_MultilingualMText

    def _hasContent(self):
        if self.LocalisationCH_V1_MultilingualMText is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="DescriptionType7",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("DescriptionType7")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "DescriptionType7":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="DescriptionType7",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="DescriptionType7",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="DescriptionType7",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="DescriptionType7",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.LocalisationCH_V1_MultilingualMText is not None:
            namespaceprefix_ = (
                self.LocalisationCH_V1_MultilingualMText_nsprefix_ + ":"
                if (UseCapturedNS_ and self.LocalisationCH_V1_MultilingualMText_nsprefix_)
                else ""
            )
            self.LocalisationCH_V1_MultilingualMText.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="LocalisationCH_V1.MultilingualMText",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "LocalisationCH_V1.MultilingualMText":
            obj_ = LocalisationCH_V1_MultilingualMText.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LocalisationCH_V1_MultilingualMText = obj_
            obj_.original_tagname_ = "LocalisationCH_V1.MultilingualMText"


# end class DescriptionType7


class UpperLevelUnitType8(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "REF": MemberSpec_("REF", "IliID", 0, 0, {"use": "required", "name": "REF"}),
        "BID": MemberSpec_("BID", "IliID", 0, 1, {"use": "optional", "name": "BID"}),
        "ORDER_POS": MemberSpec_(
            "ORDER_POS",
            "xsd:positiveInteger",
            0,
            1,
            {"use": "optional", "name": "ORDER_POS"},
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, REF=None, BID=None, ORDER_POS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.REF = _cast(None, REF)
        self.REF_nsprefix_ = None
        self.BID = _cast(None, BID)
        self.BID_nsprefix_ = None
        self.ORDER_POS = _cast(int, ORDER_POS)
        self.ORDER_POS_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, UpperLevelUnitType8)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UpperLevelUnitType8.subclass:
            return UpperLevelUnitType8.subclass(*args_, **kwargs_)
        else:
            return UpperLevelUnitType8(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_REF(self):
        return self.REF

    def set_REF(self, REF):
        self.REF = REF

    def get_BID(self):
        return self.BID

    def set_BID(self, BID):
        self.BID = BID

    def get_ORDER_POS(self):
        return self.ORDER_POS

    def set_ORDER_POS(self, ORDER_POS):
        self.ORDER_POS = ORDER_POS

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if ():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="UpperLevelUnitType8",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("UpperLevelUnitType8")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "UpperLevelUnitType8":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="UpperLevelUnitType8",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="UpperLevelUnitType8",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="UpperLevelUnitType8",
    ):
        if self.REF is not None and "REF" not in already_processed:
            already_processed.add("REF")
            outfile.write(
                " REF=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.REF), input_name="REF")),)
            )
        if self.BID is not None and "BID" not in already_processed:
            already_processed.add("BID")
            outfile.write(
                " BID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.BID), input_name="BID")),)
            )
        if self.ORDER_POS is not None and "ORDER_POS" not in already_processed:
            already_processed.add("ORDER_POS")
            outfile.write(' ORDER_POS="%s"' % self.gds_format_integer(self.ORDER_POS, input_name="ORDER_POS"))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="UpperLevelUnitType8",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("REF", node)
        if value is not None and "REF" not in already_processed:
            already_processed.add("REF")
            self.REF = value
            self.validate_IliID(self.REF)  # validate type IliID
        value = find_attr_value_("BID", node)
        if value is not None and "BID" not in already_processed:
            already_processed.add("BID")
            self.BID = value
            self.validate_IliID(self.BID)  # validate type IliID
        value = find_attr_value_("ORDER_POS", node)
        if value is not None and "ORDER_POS" not in already_processed:
            already_processed.add("ORDER_POS")
            self.ORDER_POS = self.gds_parse_integer(value, node, "ORDER_POS")
            if self.ORDER_POS <= 0:
                raise_parse_error(node, "Invalid PositiveInteger")

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class UpperLevelUnitType8


class UpperLevelUnitType9(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "REF": MemberSpec_("REF", "IliID", 0, 0, {"use": "required", "name": "REF"}),
        "BID": MemberSpec_("BID", "IliID", 0, 1, {"use": "optional", "name": "BID"}),
        "ORDER_POS": MemberSpec_(
            "ORDER_POS",
            "xsd:positiveInteger",
            0,
            1,
            {"use": "optional", "name": "ORDER_POS"},
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, REF=None, BID=None, ORDER_POS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.REF = _cast(None, REF)
        self.REF_nsprefix_ = None
        self.BID = _cast(None, BID)
        self.BID_nsprefix_ = None
        self.ORDER_POS = _cast(int, ORDER_POS)
        self.ORDER_POS_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, UpperLevelUnitType9)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UpperLevelUnitType9.subclass:
            return UpperLevelUnitType9.subclass(*args_, **kwargs_)
        else:
            return UpperLevelUnitType9(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_REF(self):
        return self.REF

    def set_REF(self, REF):
        self.REF = REF

    def get_BID(self):
        return self.BID

    def set_BID(self, BID):
        self.BID = BID

    def get_ORDER_POS(self):
        return self.ORDER_POS

    def set_ORDER_POS(self, ORDER_POS):
        self.ORDER_POS = ORDER_POS

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if ():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="UpperLevelUnitType9",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("UpperLevelUnitType9")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "UpperLevelUnitType9":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="UpperLevelUnitType9",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="UpperLevelUnitType9",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="UpperLevelUnitType9",
    ):
        if self.REF is not None and "REF" not in already_processed:
            already_processed.add("REF")
            outfile.write(
                " REF=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.REF), input_name="REF")),)
            )
        if self.BID is not None and "BID" not in already_processed:
            already_processed.add("BID")
            outfile.write(
                " BID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.BID), input_name="BID")),)
            )
        if self.ORDER_POS is not None and "ORDER_POS" not in already_processed:
            already_processed.add("ORDER_POS")
            outfile.write(' ORDER_POS="%s"' % self.gds_format_integer(self.ORDER_POS, input_name="ORDER_POS"))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="UpperLevelUnitType9",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("REF", node)
        if value is not None and "REF" not in already_processed:
            already_processed.add("REF")
            self.REF = value
            self.validate_IliID(self.REF)  # validate type IliID
        value = find_attr_value_("BID", node)
        if value is not None and "BID" not in already_processed:
            already_processed.add("BID")
            self.BID = value
            self.validate_IliID(self.BID)  # validate type IliID
        value = find_attr_value_("ORDER_POS", node)
        if value is not None and "ORDER_POS" not in already_processed:
            already_processed.add("ORDER_POS")
            self.ORDER_POS = self.gds_parse_integer(value, node, "ORDER_POS")
            if self.ORDER_POS <= 0:
                raise_parse_error(node, "Invalid PositiveInteger")

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class UpperLevelUnitType9


class EntriesType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "AdministrativeUnits_V1_CountryNames_CountryName": MemberSpec_(
            "AdministrativeUnits_V1_CountryNames_CountryName",
            "AdministrativeUnits_V1.CountryNames.CountryName",
            1,
            0,
            {
                "maxOccurs": "unbounded",
                "name": "AdministrativeUnits_V1.CountryNames.CountryName",
                "type": "AdministrativeUnits_V1.CountryNames.CountryName",
            },
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, AdministrativeUnits_V1_CountryNames_CountryName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if AdministrativeUnits_V1_CountryNames_CountryName is None:
            self.AdministrativeUnits_V1_CountryNames_CountryName = []
        else:
            self.AdministrativeUnits_V1_CountryNames_CountryName = (
                AdministrativeUnits_V1_CountryNames_CountryName
            )
        self.AdministrativeUnits_V1_CountryNames_CountryName_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, EntriesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntriesType.subclass:
            return EntriesType.subclass(*args_, **kwargs_)
        else:
            return EntriesType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_AdministrativeUnits_V1_CountryNames_CountryName(self):
        return self.AdministrativeUnits_V1_CountryNames_CountryName

    def set_AdministrativeUnits_V1_CountryNames_CountryName(
        self, AdministrativeUnits_V1_CountryNames_CountryName
    ):
        self.AdministrativeUnits_V1_CountryNames_CountryName = AdministrativeUnits_V1_CountryNames_CountryName

    def add_AdministrativeUnits_V1_CountryNames_CountryName(self, value):
        self.AdministrativeUnits_V1_CountryNames_CountryName.append(value)

    def insert_AdministrativeUnits_V1_CountryNames_CountryName_at(self, index, value):
        self.AdministrativeUnits_V1_CountryNames_CountryName.insert(index, value)

    def replace_AdministrativeUnits_V1_CountryNames_CountryName_at(self, index, value):
        self.AdministrativeUnits_V1_CountryNames_CountryName[index] = value

    def _hasContent(self):
        if self.AdministrativeUnits_V1_CountryNames_CountryName:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="EntriesType",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("EntriesType")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "EntriesType":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="EntriesType")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="EntriesType",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="EntriesType",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="EntriesType",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for (
            AdministrativeUnits_V1_CountryNames_CountryName_
        ) in self.AdministrativeUnits_V1_CountryNames_CountryName:
            namespaceprefix_ = (
                self.AdministrativeUnits_V1_CountryNames_CountryName_nsprefix_ + ":"
                if (UseCapturedNS_ and self.AdministrativeUnits_V1_CountryNames_CountryName_nsprefix_)
                else ""
            )
            AdministrativeUnits_V1_CountryNames_CountryName_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="AdministrativeUnits_V1.CountryNames.CountryName",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "AdministrativeUnits_V1.CountryNames.CountryName":
            obj_ = AdministrativeUnits_V1_CountryNames_CountryName.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AdministrativeUnits_V1_CountryNames_CountryName.append(obj_)
            obj_.original_tagname_ = "AdministrativeUnits_V1.CountryNames.CountryName"


# end class EntriesType


class SupervisorType10(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "REF": MemberSpec_("REF", "IliID", 0, 0, {"use": "required", "name": "REF"}),
        "BID": MemberSpec_("BID", "IliID", 0, 1, {"use": "optional", "name": "BID"}),
        "ORDER_POS": MemberSpec_(
            "ORDER_POS",
            "xsd:positiveInteger",
            0,
            1,
            {"use": "optional", "name": "ORDER_POS"},
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, REF=None, BID=None, ORDER_POS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.REF = _cast(None, REF)
        self.REF_nsprefix_ = None
        self.BID = _cast(None, BID)
        self.BID_nsprefix_ = None
        self.ORDER_POS = _cast(int, ORDER_POS)
        self.ORDER_POS_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, SupervisorType10)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SupervisorType10.subclass:
            return SupervisorType10.subclass(*args_, **kwargs_)
        else:
            return SupervisorType10(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_REF(self):
        return self.REF

    def set_REF(self, REF):
        self.REF = REF

    def get_BID(self):
        return self.BID

    def set_BID(self, BID):
        self.BID = BID

    def get_ORDER_POS(self):
        return self.ORDER_POS

    def set_ORDER_POS(self, ORDER_POS):
        self.ORDER_POS = ORDER_POS

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if ():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="SupervisorType10",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("SupervisorType10")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "SupervisorType10":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="SupervisorType10",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="SupervisorType10",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="SupervisorType10",
    ):
        if self.REF is not None and "REF" not in already_processed:
            already_processed.add("REF")
            outfile.write(
                " REF=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.REF), input_name="REF")),)
            )
        if self.BID is not None and "BID" not in already_processed:
            already_processed.add("BID")
            outfile.write(
                " BID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.BID), input_name="BID")),)
            )
        if self.ORDER_POS is not None and "ORDER_POS" not in already_processed:
            already_processed.add("ORDER_POS")
            outfile.write(' ORDER_POS="%s"' % self.gds_format_integer(self.ORDER_POS, input_name="ORDER_POS"))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="SupervisorType10",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("REF", node)
        if value is not None and "REF" not in already_processed:
            already_processed.add("REF")
            self.REF = value
            self.validate_IliID(self.REF)  # validate type IliID
        value = find_attr_value_("BID", node)
        if value is not None and "BID" not in already_processed:
            already_processed.add("BID")
            self.BID = value
            self.validate_IliID(self.BID)  # validate type IliID
        value = find_attr_value_("ORDER_POS", node)
        if value is not None and "ORDER_POS" not in already_processed:
            already_processed.add("ORDER_POS")
            self.ORDER_POS = self.gds_parse_integer(value, node, "ORDER_POS")
            if self.ORDER_POS <= 0:
                raise_parse_error(node, "Invalid PositiveInteger")

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class SupervisorType10


class AxisType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "CoordSys_CoordsysTopic_LengthAXIS": MemberSpec_(
            "CoordSys_CoordsysTopic_LengthAXIS",
            "CoordSys.CoordsysTopic.LengthAXIS",
            0,
            0,
            {
                "name": "CoordSys.CoordsysTopic.LengthAXIS",
                "type": "CoordSys.CoordsysTopic.LengthAXIS",
            },
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, CoordSys_CoordsysTopic_LengthAXIS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if CoordSys_CoordsysTopic_LengthAXIS is None:
            self.CoordSys_CoordsysTopic_LengthAXIS = globals()["CoordSys_CoordsysTopic_LengthAXIS"]()
        else:
            self.CoordSys_CoordsysTopic_LengthAXIS = CoordSys_CoordsysTopic_LengthAXIS
        self.CoordSys_CoordsysTopic_LengthAXIS_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, AxisType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AxisType.subclass:
            return AxisType.subclass(*args_, **kwargs_)
        else:
            return AxisType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_CoordSys_CoordsysTopic_LengthAXIS(self):
        return self.CoordSys_CoordsysTopic_LengthAXIS

    def set_CoordSys_CoordsysTopic_LengthAXIS(self, CoordSys_CoordsysTopic_LengthAXIS):
        self.CoordSys_CoordsysTopic_LengthAXIS = CoordSys_CoordsysTopic_LengthAXIS

    def _hasContent(self):
        if self.CoordSys_CoordsysTopic_LengthAXIS is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AxisType",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("AxisType")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "AxisType":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="AxisType")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="AxisType",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_="", name_="AxisType"):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AxisType",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.CoordSys_CoordsysTopic_LengthAXIS is not None:
            namespaceprefix_ = (
                self.CoordSys_CoordsysTopic_LengthAXIS_nsprefix_ + ":"
                if (UseCapturedNS_ and self.CoordSys_CoordsysTopic_LengthAXIS_nsprefix_)
                else ""
            )
            self.CoordSys_CoordsysTopic_LengthAXIS.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="CoordSys.CoordsysTopic.LengthAXIS",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "CoordSys.CoordsysTopic.LengthAXIS":
            obj_ = CoordSys_CoordsysTopic_LengthAXIS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CoordSys_CoordsysTopic_LengthAXIS = obj_
            obj_.original_tagname_ = "CoordSys.CoordsysTopic.LengthAXIS"


# end class AxisType


class AxisType16(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "CoordSys_CoordsysTopic_LengthAXIS": MemberSpec_(
            "CoordSys_CoordsysTopic_LengthAXIS",
            "CoordSys.CoordsysTopic.LengthAXIS",
            0,
            0,
            {
                "name": "CoordSys.CoordsysTopic.LengthAXIS",
                "type": "CoordSys.CoordsysTopic.LengthAXIS",
            },
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, CoordSys_CoordsysTopic_LengthAXIS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if CoordSys_CoordsysTopic_LengthAXIS is None:
            self.CoordSys_CoordsysTopic_LengthAXIS = globals()["CoordSys_CoordsysTopic_LengthAXIS"]()
        else:
            self.CoordSys_CoordsysTopic_LengthAXIS = CoordSys_CoordsysTopic_LengthAXIS
        self.CoordSys_CoordsysTopic_LengthAXIS_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, AxisType16)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AxisType16.subclass:
            return AxisType16.subclass(*args_, **kwargs_)
        else:
            return AxisType16(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_CoordSys_CoordsysTopic_LengthAXIS(self):
        return self.CoordSys_CoordsysTopic_LengthAXIS

    def set_CoordSys_CoordsysTopic_LengthAXIS(self, CoordSys_CoordsysTopic_LengthAXIS):
        self.CoordSys_CoordsysTopic_LengthAXIS = CoordSys_CoordsysTopic_LengthAXIS

    def _hasContent(self):
        if self.CoordSys_CoordsysTopic_LengthAXIS is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AxisType16",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("AxisType16")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "AxisType16":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="AxisType16")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="AxisType16",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_="", name_="AxisType16"):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AxisType16",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.CoordSys_CoordsysTopic_LengthAXIS is not None:
            namespaceprefix_ = (
                self.CoordSys_CoordsysTopic_LengthAXIS_nsprefix_ + ":"
                if (UseCapturedNS_ and self.CoordSys_CoordsysTopic_LengthAXIS_nsprefix_)
                else ""
            )
            self.CoordSys_CoordsysTopic_LengthAXIS.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="CoordSys.CoordsysTopic.LengthAXIS",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "CoordSys.CoordsysTopic.LengthAXIS":
            obj_ = CoordSys_CoordsysTopic_LengthAXIS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CoordSys_CoordsysTopic_LengthAXIS = obj_
            obj_.original_tagname_ = "CoordSys.CoordsysTopic.LengthAXIS"


# end class AxisType16


class EllipsoidRefType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "REF": MemberSpec_("REF", "IliID", 0, 0, {"use": "required", "name": "REF"}),
        "BID": MemberSpec_("BID", "IliID", 0, 1, {"use": "optional", "name": "BID"}),
        "ORDER_POS": MemberSpec_(
            "ORDER_POS",
            "xsd:positiveInteger",
            0,
            1,
            {"use": "optional", "name": "ORDER_POS"},
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, REF=None, BID=None, ORDER_POS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.REF = _cast(None, REF)
        self.REF_nsprefix_ = None
        self.BID = _cast(None, BID)
        self.BID_nsprefix_ = None
        self.ORDER_POS = _cast(int, ORDER_POS)
        self.ORDER_POS_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, EllipsoidRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EllipsoidRefType.subclass:
            return EllipsoidRefType.subclass(*args_, **kwargs_)
        else:
            return EllipsoidRefType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_REF(self):
        return self.REF

    def set_REF(self, REF):
        self.REF = REF

    def get_BID(self):
        return self.BID

    def set_BID(self, BID):
        self.BID = BID

    def get_ORDER_POS(self):
        return self.ORDER_POS

    def set_ORDER_POS(self, ORDER_POS):
        self.ORDER_POS = ORDER_POS

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if ():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="EllipsoidRefType",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("EllipsoidRefType")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "EllipsoidRefType":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="EllipsoidRefType",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="EllipsoidRefType",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="EllipsoidRefType",
    ):
        if self.REF is not None and "REF" not in already_processed:
            already_processed.add("REF")
            outfile.write(
                " REF=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.REF), input_name="REF")),)
            )
        if self.BID is not None and "BID" not in already_processed:
            already_processed.add("BID")
            outfile.write(
                " BID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.BID), input_name="BID")),)
            )
        if self.ORDER_POS is not None and "ORDER_POS" not in already_processed:
            already_processed.add("ORDER_POS")
            outfile.write(' ORDER_POS="%s"' % self.gds_format_integer(self.ORDER_POS, input_name="ORDER_POS"))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="EllipsoidRefType",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("REF", node)
        if value is not None and "REF" not in already_processed:
            already_processed.add("REF")
            self.REF = value
            self.validate_IliID(self.REF)  # validate type IliID
        value = find_attr_value_("BID", node)
        if value is not None and "BID" not in already_processed:
            already_processed.add("BID")
            self.BID = value
            self.validate_IliID(self.BID)  # validate type IliID
        value = find_attr_value_("ORDER_POS", node)
        if value is not None and "ORDER_POS" not in already_processed:
            already_processed.add("ORDER_POS")
            self.ORDER_POS = self.gds_parse_integer(value, node, "ORDER_POS")
            if self.ORDER_POS <= 0:
                raise_parse_error(node, "Invalid PositiveInteger")

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class EllipsoidRefType


class GeoidRefType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "REF": MemberSpec_("REF", "IliID", 0, 0, {"use": "required", "name": "REF"}),
        "BID": MemberSpec_("BID", "IliID", 0, 1, {"use": "optional", "name": "BID"}),
        "ORDER_POS": MemberSpec_(
            "ORDER_POS",
            "xsd:positiveInteger",
            0,
            1,
            {"use": "optional", "name": "ORDER_POS"},
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, REF=None, BID=None, ORDER_POS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.REF = _cast(None, REF)
        self.REF_nsprefix_ = None
        self.BID = _cast(None, BID)
        self.BID_nsprefix_ = None
        self.ORDER_POS = _cast(int, ORDER_POS)
        self.ORDER_POS_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, GeoidRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeoidRefType.subclass:
            return GeoidRefType.subclass(*args_, **kwargs_)
        else:
            return GeoidRefType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_REF(self):
        return self.REF

    def set_REF(self, REF):
        self.REF = REF

    def get_BID(self):
        return self.BID

    def set_BID(self, BID):
        self.BID = BID

    def get_ORDER_POS(self):
        return self.ORDER_POS

    def set_ORDER_POS(self, ORDER_POS):
        self.ORDER_POS = ORDER_POS

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if ():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="GeoidRefType",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("GeoidRefType")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "GeoidRefType":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="GeoidRefType")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="GeoidRefType",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="GeoidRefType",
    ):
        if self.REF is not None and "REF" not in already_processed:
            already_processed.add("REF")
            outfile.write(
                " REF=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.REF), input_name="REF")),)
            )
        if self.BID is not None and "BID" not in already_processed:
            already_processed.add("BID")
            outfile.write(
                " BID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.BID), input_name="BID")),)
            )
        if self.ORDER_POS is not None and "ORDER_POS" not in already_processed:
            already_processed.add("ORDER_POS")
            outfile.write(' ORDER_POS="%s"' % self.gds_format_integer(self.ORDER_POS, input_name="ORDER_POS"))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="GeoidRefType",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("REF", node)
        if value is not None and "REF" not in already_processed:
            already_processed.add("REF")
            self.REF = value
            self.validate_IliID(self.REF)  # validate type IliID
        value = find_attr_value_("BID", node)
        if value is not None and "BID" not in already_processed:
            already_processed.add("BID")
            self.BID = value
            self.validate_IliID(self.BID)  # validate type IliID
        value = find_attr_value_("ORDER_POS", node)
        if value is not None and "ORDER_POS" not in already_processed:
            already_processed.add("ORDER_POS")
            self.ORDER_POS = self.gds_parse_integer(value, node, "ORDER_POS")
            if self.ORDER_POS <= 0:
                raise_parse_error(node, "Invalid PositiveInteger")

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class GeoidRefType


class GravityRefType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "REF": MemberSpec_("REF", "IliID", 0, 0, {"use": "required", "name": "REF"}),
        "BID": MemberSpec_("BID", "IliID", 0, 1, {"use": "optional", "name": "BID"}),
        "ORDER_POS": MemberSpec_(
            "ORDER_POS",
            "xsd:positiveInteger",
            0,
            1,
            {"use": "optional", "name": "ORDER_POS"},
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, REF=None, BID=None, ORDER_POS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.REF = _cast(None, REF)
        self.REF_nsprefix_ = None
        self.BID = _cast(None, BID)
        self.BID_nsprefix_ = None
        self.ORDER_POS = _cast(int, ORDER_POS)
        self.ORDER_POS_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, GravityRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GravityRefType.subclass:
            return GravityRefType.subclass(*args_, **kwargs_)
        else:
            return GravityRefType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_REF(self):
        return self.REF

    def set_REF(self, REF):
        self.REF = REF

    def get_BID(self):
        return self.BID

    def set_BID(self, BID):
        self.BID = BID

    def get_ORDER_POS(self):
        return self.ORDER_POS

    def set_ORDER_POS(self, ORDER_POS):
        self.ORDER_POS = ORDER_POS

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if ():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="GravityRefType",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("GravityRefType")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "GravityRefType":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="GravityRefType")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="GravityRefType",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="GravityRefType",
    ):
        if self.REF is not None and "REF" not in already_processed:
            already_processed.add("REF")
            outfile.write(
                " REF=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.REF), input_name="REF")),)
            )
        if self.BID is not None and "BID" not in already_processed:
            already_processed.add("BID")
            outfile.write(
                " BID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.BID), input_name="BID")),)
            )
        if self.ORDER_POS is not None and "ORDER_POS" not in already_processed:
            already_processed.add("ORDER_POS")
            outfile.write(' ORDER_POS="%s"' % self.gds_format_integer(self.ORDER_POS, input_name="ORDER_POS"))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="GravityRefType",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("REF", node)
        if value is not None and "REF" not in already_processed:
            already_processed.add("REF")
            self.REF = value
            self.validate_IliID(self.REF)  # validate type IliID
        value = find_attr_value_("BID", node)
        if value is not None and "BID" not in already_processed:
            already_processed.add("BID")
            self.BID = value
            self.validate_IliID(self.BID)  # validate type IliID
        value = find_attr_value_("ORDER_POS", node)
        if value is not None and "ORDER_POS" not in already_processed:
            already_processed.add("ORDER_POS")
            self.ORDER_POS = self.gds_parse_integer(value, node, "ORDER_POS")
            if self.ORDER_POS <= 0:
                raise_parse_error(node, "Invalid PositiveInteger")

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class GravityRefType


class AxisType17(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "CoordSys_CoordsysTopic_LengthAXIS": MemberSpec_(
            "CoordSys_CoordsysTopic_LengthAXIS",
            "CoordSys.CoordsysTopic.LengthAXIS",
            1,
            0,
            {
                "maxOccurs": "2",
                "minOccurs": "2",
                "name": "CoordSys.CoordsysTopic.LengthAXIS",
                "type": "CoordSys.CoordsysTopic.LengthAXIS",
            },
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, CoordSys_CoordsysTopic_LengthAXIS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if CoordSys_CoordsysTopic_LengthAXIS is None:
            self.CoordSys_CoordsysTopic_LengthAXIS = []
        else:
            self.CoordSys_CoordsysTopic_LengthAXIS = CoordSys_CoordsysTopic_LengthAXIS
        self.CoordSys_CoordsysTopic_LengthAXIS_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, AxisType17)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AxisType17.subclass:
            return AxisType17.subclass(*args_, **kwargs_)
        else:
            return AxisType17(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_CoordSys_CoordsysTopic_LengthAXIS(self):
        return self.CoordSys_CoordsysTopic_LengthAXIS

    def set_CoordSys_CoordsysTopic_LengthAXIS(self, CoordSys_CoordsysTopic_LengthAXIS):
        self.CoordSys_CoordsysTopic_LengthAXIS = CoordSys_CoordsysTopic_LengthAXIS

    def add_CoordSys_CoordsysTopic_LengthAXIS(self, value):
        self.CoordSys_CoordsysTopic_LengthAXIS.append(value)

    def insert_CoordSys_CoordsysTopic_LengthAXIS_at(self, index, value):
        self.CoordSys_CoordsysTopic_LengthAXIS.insert(index, value)

    def replace_CoordSys_CoordsysTopic_LengthAXIS_at(self, index, value):
        self.CoordSys_CoordsysTopic_LengthAXIS[index] = value

    def _hasContent(self):
        if self.CoordSys_CoordsysTopic_LengthAXIS:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AxisType17",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("AxisType17")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "AxisType17":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="AxisType17")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="AxisType17",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_="", name_="AxisType17"):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AxisType17",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for CoordSys_CoordsysTopic_LengthAXIS_ in self.CoordSys_CoordsysTopic_LengthAXIS:
            namespaceprefix_ = (
                self.CoordSys_CoordsysTopic_LengthAXIS_nsprefix_ + ":"
                if (UseCapturedNS_ and self.CoordSys_CoordsysTopic_LengthAXIS_nsprefix_)
                else ""
            )
            CoordSys_CoordsysTopic_LengthAXIS_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="CoordSys.CoordsysTopic.LengthAXIS",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "CoordSys.CoordsysTopic.LengthAXIS":
            obj_ = CoordSys_CoordsysTopic_LengthAXIS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CoordSys_CoordsysTopic_LengthAXIS.append(obj_)
            obj_.original_tagname_ = "CoordSys.CoordsysTopic.LengthAXIS"


# end class AxisType17


class AxisType19(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "CoordSys_CoordsysTopic_LengthAXIS": MemberSpec_(
            "CoordSys_CoordsysTopic_LengthAXIS",
            "CoordSys.CoordsysTopic.LengthAXIS",
            1,
            0,
            {
                "maxOccurs": "3",
                "minOccurs": "3",
                "name": "CoordSys.CoordsysTopic.LengthAXIS",
                "type": "CoordSys.CoordsysTopic.LengthAXIS",
            },
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, CoordSys_CoordsysTopic_LengthAXIS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if CoordSys_CoordsysTopic_LengthAXIS is None:
            self.CoordSys_CoordsysTopic_LengthAXIS = []
        else:
            self.CoordSys_CoordsysTopic_LengthAXIS = CoordSys_CoordsysTopic_LengthAXIS
        self.CoordSys_CoordsysTopic_LengthAXIS_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, AxisType19)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AxisType19.subclass:
            return AxisType19.subclass(*args_, **kwargs_)
        else:
            return AxisType19(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_CoordSys_CoordsysTopic_LengthAXIS(self):
        return self.CoordSys_CoordsysTopic_LengthAXIS

    def set_CoordSys_CoordsysTopic_LengthAXIS(self, CoordSys_CoordsysTopic_LengthAXIS):
        self.CoordSys_CoordsysTopic_LengthAXIS = CoordSys_CoordsysTopic_LengthAXIS

    def add_CoordSys_CoordsysTopic_LengthAXIS(self, value):
        self.CoordSys_CoordsysTopic_LengthAXIS.append(value)

    def insert_CoordSys_CoordsysTopic_LengthAXIS_at(self, index, value):
        self.CoordSys_CoordsysTopic_LengthAXIS.insert(index, value)

    def replace_CoordSys_CoordsysTopic_LengthAXIS_at(self, index, value):
        self.CoordSys_CoordsysTopic_LengthAXIS[index] = value

    def _hasContent(self):
        if self.CoordSys_CoordsysTopic_LengthAXIS:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AxisType19",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("AxisType19")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "AxisType19":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="AxisType19")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="AxisType19",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_="", name_="AxisType19"):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AxisType19",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for CoordSys_CoordsysTopic_LengthAXIS_ in self.CoordSys_CoordsysTopic_LengthAXIS:
            namespaceprefix_ = (
                self.CoordSys_CoordsysTopic_LengthAXIS_nsprefix_ + ":"
                if (UseCapturedNS_ and self.CoordSys_CoordsysTopic_LengthAXIS_nsprefix_)
                else ""
            )
            CoordSys_CoordsysTopic_LengthAXIS_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="CoordSys.CoordsysTopic.LengthAXIS",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "CoordSys.CoordsysTopic.LengthAXIS":
            obj_ = CoordSys_CoordsysTopic_LengthAXIS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CoordSys_CoordsysTopic_LengthAXIS.append(obj_)
            obj_.original_tagname_ = "CoordSys.CoordsysTopic.LengthAXIS"


# end class AxisType19


class AxisType21(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "CoordSys_CoordsysTopic_AngleAXIS": MemberSpec_(
            "CoordSys_CoordsysTopic_AngleAXIS",
            "CoordSys.CoordsysTopic.AngleAXIS",
            1,
            0,
            {
                "maxOccurs": "2",
                "minOccurs": "2",
                "name": "CoordSys.CoordsysTopic.AngleAXIS",
                "type": "CoordSys.CoordsysTopic.AngleAXIS",
            },
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, CoordSys_CoordsysTopic_AngleAXIS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if CoordSys_CoordsysTopic_AngleAXIS is None:
            self.CoordSys_CoordsysTopic_AngleAXIS = []
        else:
            self.CoordSys_CoordsysTopic_AngleAXIS = CoordSys_CoordsysTopic_AngleAXIS
        self.CoordSys_CoordsysTopic_AngleAXIS_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, AxisType21)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AxisType21.subclass:
            return AxisType21.subclass(*args_, **kwargs_)
        else:
            return AxisType21(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_CoordSys_CoordsysTopic_AngleAXIS(self):
        return self.CoordSys_CoordsysTopic_AngleAXIS

    def set_CoordSys_CoordsysTopic_AngleAXIS(self, CoordSys_CoordsysTopic_AngleAXIS):
        self.CoordSys_CoordsysTopic_AngleAXIS = CoordSys_CoordsysTopic_AngleAXIS

    def add_CoordSys_CoordsysTopic_AngleAXIS(self, value):
        self.CoordSys_CoordsysTopic_AngleAXIS.append(value)

    def insert_CoordSys_CoordsysTopic_AngleAXIS_at(self, index, value):
        self.CoordSys_CoordsysTopic_AngleAXIS.insert(index, value)

    def replace_CoordSys_CoordsysTopic_AngleAXIS_at(self, index, value):
        self.CoordSys_CoordsysTopic_AngleAXIS[index] = value

    def _hasContent(self):
        if self.CoordSys_CoordsysTopic_AngleAXIS:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AxisType21",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("AxisType21")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "AxisType21":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="AxisType21")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="AxisType21",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_="", name_="AxisType21"):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AxisType21",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for CoordSys_CoordsysTopic_AngleAXIS_ in self.CoordSys_CoordsysTopic_AngleAXIS:
            namespaceprefix_ = (
                self.CoordSys_CoordsysTopic_AngleAXIS_nsprefix_ + ":"
                if (UseCapturedNS_ and self.CoordSys_CoordsysTopic_AngleAXIS_nsprefix_)
                else ""
            )
            CoordSys_CoordsysTopic_AngleAXIS_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="CoordSys.CoordsysTopic.AngleAXIS",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "CoordSys.CoordsysTopic.AngleAXIS":
            obj_ = CoordSys_CoordsysTopic_AngleAXIS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CoordSys_CoordsysTopic_AngleAXIS.append(obj_)
            obj_.original_tagname_ = "CoordSys.CoordsysTopic.AngleAXIS"


# end class AxisType21


class EllipsoidRefType23(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "REF": MemberSpec_("REF", "IliID", 0, 0, {"use": "required", "name": "REF"}),
        "BID": MemberSpec_("BID", "IliID", 0, 1, {"use": "optional", "name": "BID"}),
        "ORDER_POS": MemberSpec_(
            "ORDER_POS",
            "xsd:positiveInteger",
            0,
            1,
            {"use": "optional", "name": "ORDER_POS"},
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, REF=None, BID=None, ORDER_POS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.REF = _cast(None, REF)
        self.REF_nsprefix_ = None
        self.BID = _cast(None, BID)
        self.BID_nsprefix_ = None
        self.ORDER_POS = _cast(int, ORDER_POS)
        self.ORDER_POS_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, EllipsoidRefType23)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EllipsoidRefType23.subclass:
            return EllipsoidRefType23.subclass(*args_, **kwargs_)
        else:
            return EllipsoidRefType23(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_REF(self):
        return self.REF

    def set_REF(self, REF):
        self.REF = REF

    def get_BID(self):
        return self.BID

    def set_BID(self, BID):
        self.BID = BID

    def get_ORDER_POS(self):
        return self.ORDER_POS

    def set_ORDER_POS(self, ORDER_POS):
        self.ORDER_POS = ORDER_POS

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if ():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="EllipsoidRefType23",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("EllipsoidRefType23")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "EllipsoidRefType23":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="EllipsoidRefType23",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="EllipsoidRefType23",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="EllipsoidRefType23",
    ):
        if self.REF is not None and "REF" not in already_processed:
            already_processed.add("REF")
            outfile.write(
                " REF=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.REF), input_name="REF")),)
            )
        if self.BID is not None and "BID" not in already_processed:
            already_processed.add("BID")
            outfile.write(
                " BID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.BID), input_name="BID")),)
            )
        if self.ORDER_POS is not None and "ORDER_POS" not in already_processed:
            already_processed.add("ORDER_POS")
            outfile.write(' ORDER_POS="%s"' % self.gds_format_integer(self.ORDER_POS, input_name="ORDER_POS"))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="EllipsoidRefType23",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("REF", node)
        if value is not None and "REF" not in already_processed:
            already_processed.add("REF")
            self.REF = value
            self.validate_IliID(self.REF)  # validate type IliID
        value = find_attr_value_("BID", node)
        if value is not None and "BID" not in already_processed:
            already_processed.add("BID")
            self.BID = value
            self.validate_IliID(self.BID)  # validate type IliID
        value = find_attr_value_("ORDER_POS", node)
        if value is not None and "ORDER_POS" not in already_processed:
            already_processed.add("ORDER_POS")
            self.ORDER_POS = self.gds_parse_integer(value, node, "ORDER_POS")
            if self.ORDER_POS <= 0:
                raise_parse_error(node, "Invalid PositiveInteger")

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class EllipsoidRefType23


class EntriesType43(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "AdministrativeUnits_V1_CountryNames_CountryName": MemberSpec_(
            "AdministrativeUnits_V1_CountryNames_CountryName",
            "AdministrativeUnits_V1.CountryNames.CountryName",
            1,
            0,
            {
                "name": "AdministrativeUnits_V1.CountryNames.CountryName",
                "type": "AdministrativeUnits_V1.CountryNames.CountryName",
            },
            17,
        ),
        "Dictionaries_V1_Dictionaries_Entry": MemberSpec_(
            "Dictionaries_V1_Dictionaries_Entry",
            "Dictionaries_V1.Dictionaries.Entry",
            1,
            0,
            {
                "name": "Dictionaries_V1.Dictionaries.Entry",
                "type": "Dictionaries_V1.Dictionaries.Entry",
            },
            17,
        ),
    }
    subclass = None
    superclass = None

    def __init__(
        self,
        AdministrativeUnits_V1_CountryNames_CountryName=None,
        Dictionaries_V1_Dictionaries_Entry=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if AdministrativeUnits_V1_CountryNames_CountryName is None:
            self.AdministrativeUnits_V1_CountryNames_CountryName = []
        else:
            self.AdministrativeUnits_V1_CountryNames_CountryName = (
                AdministrativeUnits_V1_CountryNames_CountryName
            )
        self.AdministrativeUnits_V1_CountryNames_CountryName_nsprefix_ = None
        if Dictionaries_V1_Dictionaries_Entry is None:
            self.Dictionaries_V1_Dictionaries_Entry = []
        else:
            self.Dictionaries_V1_Dictionaries_Entry = Dictionaries_V1_Dictionaries_Entry
        self.Dictionaries_V1_Dictionaries_Entry_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, EntriesType43)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntriesType43.subclass:
            return EntriesType43.subclass(*args_, **kwargs_)
        else:
            return EntriesType43(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_AdministrativeUnits_V1_CountryNames_CountryName(self):
        return self.AdministrativeUnits_V1_CountryNames_CountryName

    def set_AdministrativeUnits_V1_CountryNames_CountryName(
        self, AdministrativeUnits_V1_CountryNames_CountryName
    ):
        self.AdministrativeUnits_V1_CountryNames_CountryName = AdministrativeUnits_V1_CountryNames_CountryName

    def add_AdministrativeUnits_V1_CountryNames_CountryName(self, value):
        self.AdministrativeUnits_V1_CountryNames_CountryName.append(value)

    def insert_AdministrativeUnits_V1_CountryNames_CountryName_at(self, index, value):
        self.AdministrativeUnits_V1_CountryNames_CountryName.insert(index, value)

    def replace_AdministrativeUnits_V1_CountryNames_CountryName_at(self, index, value):
        self.AdministrativeUnits_V1_CountryNames_CountryName[index] = value

    def get_Dictionaries_V1_Dictionaries_Entry(self):
        return self.Dictionaries_V1_Dictionaries_Entry

    def set_Dictionaries_V1_Dictionaries_Entry(self, Dictionaries_V1_Dictionaries_Entry):
        self.Dictionaries_V1_Dictionaries_Entry = Dictionaries_V1_Dictionaries_Entry

    def add_Dictionaries_V1_Dictionaries_Entry(self, value):
        self.Dictionaries_V1_Dictionaries_Entry.append(value)

    def insert_Dictionaries_V1_Dictionaries_Entry_at(self, index, value):
        self.Dictionaries_V1_Dictionaries_Entry.insert(index, value)

    def replace_Dictionaries_V1_Dictionaries_Entry_at(self, index, value):
        self.Dictionaries_V1_Dictionaries_Entry[index] = value

    def _hasContent(self):
        if self.AdministrativeUnits_V1_CountryNames_CountryName or self.Dictionaries_V1_Dictionaries_Entry:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="EntriesType43",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("EntriesType43")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "EntriesType43":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="EntriesType43")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="EntriesType43",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="EntriesType43",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="EntriesType43",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for (
            AdministrativeUnits_V1_CountryNames_CountryName_
        ) in self.AdministrativeUnits_V1_CountryNames_CountryName:
            namespaceprefix_ = (
                self.AdministrativeUnits_V1_CountryNames_CountryName_nsprefix_ + ":"
                if (UseCapturedNS_ and self.AdministrativeUnits_V1_CountryNames_CountryName_nsprefix_)
                else ""
            )
            AdministrativeUnits_V1_CountryNames_CountryName_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="AdministrativeUnits_V1.CountryNames.CountryName",
                pretty_print=pretty_print,
            )
        for Dictionaries_V1_Dictionaries_Entry_ in self.Dictionaries_V1_Dictionaries_Entry:
            namespaceprefix_ = (
                self.Dictionaries_V1_Dictionaries_Entry_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Dictionaries_V1_Dictionaries_Entry_nsprefix_)
                else ""
            )
            Dictionaries_V1_Dictionaries_Entry_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Dictionaries_V1.Dictionaries.Entry",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "AdministrativeUnits_V1.CountryNames.CountryName":
            obj_ = AdministrativeUnits_V1_CountryNames_CountryName.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AdministrativeUnits_V1_CountryNames_CountryName.append(obj_)
            obj_.original_tagname_ = "AdministrativeUnits_V1.CountryNames.CountryName"
        elif nodeName_ == "Dictionaries_V1.Dictionaries.Entry":
            obj_ = Dictionaries_V1_Dictionaries_Entry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Dictionaries_V1_Dictionaries_Entry.append(obj_)
            obj_.original_tagname_ = "Dictionaries_V1.Dictionaries.Entry"


# end class EntriesType43


class EntriesType45(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "AdministrativeUnits_V1_CountryNames_CountryName": MemberSpec_(
            "AdministrativeUnits_V1_CountryNames_CountryName",
            "AdministrativeUnits_V1.CountryNames.CountryName",
            1,
            0,
            {
                "name": "AdministrativeUnits_V1.CountryNames.CountryName",
                "type": "AdministrativeUnits_V1.CountryNames.CountryName",
            },
            18,
        ),
        "Dictionaries_V1_Dictionaries_Entry": MemberSpec_(
            "Dictionaries_V1_Dictionaries_Entry",
            "Dictionaries_V1.Dictionaries.Entry",
            1,
            0,
            {
                "name": "Dictionaries_V1.Dictionaries.Entry",
                "type": "Dictionaries_V1.Dictionaries.Entry",
            },
            18,
        ),
    }
    subclass = None
    superclass = None

    def __init__(
        self,
        AdministrativeUnits_V1_CountryNames_CountryName=None,
        Dictionaries_V1_Dictionaries_Entry=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if AdministrativeUnits_V1_CountryNames_CountryName is None:
            self.AdministrativeUnits_V1_CountryNames_CountryName = []
        else:
            self.AdministrativeUnits_V1_CountryNames_CountryName = (
                AdministrativeUnits_V1_CountryNames_CountryName
            )
        self.AdministrativeUnits_V1_CountryNames_CountryName_nsprefix_ = None
        if Dictionaries_V1_Dictionaries_Entry is None:
            self.Dictionaries_V1_Dictionaries_Entry = []
        else:
            self.Dictionaries_V1_Dictionaries_Entry = Dictionaries_V1_Dictionaries_Entry
        self.Dictionaries_V1_Dictionaries_Entry_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, EntriesType45)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntriesType45.subclass:
            return EntriesType45.subclass(*args_, **kwargs_)
        else:
            return EntriesType45(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_AdministrativeUnits_V1_CountryNames_CountryName(self):
        return self.AdministrativeUnits_V1_CountryNames_CountryName

    def set_AdministrativeUnits_V1_CountryNames_CountryName(
        self, AdministrativeUnits_V1_CountryNames_CountryName
    ):
        self.AdministrativeUnits_V1_CountryNames_CountryName = AdministrativeUnits_V1_CountryNames_CountryName

    def add_AdministrativeUnits_V1_CountryNames_CountryName(self, value):
        self.AdministrativeUnits_V1_CountryNames_CountryName.append(value)

    def insert_AdministrativeUnits_V1_CountryNames_CountryName_at(self, index, value):
        self.AdministrativeUnits_V1_CountryNames_CountryName.insert(index, value)

    def replace_AdministrativeUnits_V1_CountryNames_CountryName_at(self, index, value):
        self.AdministrativeUnits_V1_CountryNames_CountryName[index] = value

    def get_Dictionaries_V1_Dictionaries_Entry(self):
        return self.Dictionaries_V1_Dictionaries_Entry

    def set_Dictionaries_V1_Dictionaries_Entry(self, Dictionaries_V1_Dictionaries_Entry):
        self.Dictionaries_V1_Dictionaries_Entry = Dictionaries_V1_Dictionaries_Entry

    def add_Dictionaries_V1_Dictionaries_Entry(self, value):
        self.Dictionaries_V1_Dictionaries_Entry.append(value)

    def insert_Dictionaries_V1_Dictionaries_Entry_at(self, index, value):
        self.Dictionaries_V1_Dictionaries_Entry.insert(index, value)

    def replace_Dictionaries_V1_Dictionaries_Entry_at(self, index, value):
        self.Dictionaries_V1_Dictionaries_Entry[index] = value

    def _hasContent(self):
        if self.AdministrativeUnits_V1_CountryNames_CountryName or self.Dictionaries_V1_Dictionaries_Entry:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="EntriesType45",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("EntriesType45")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "EntriesType45":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="EntriesType45")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="EntriesType45",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="EntriesType45",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="EntriesType45",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for (
            AdministrativeUnits_V1_CountryNames_CountryName_
        ) in self.AdministrativeUnits_V1_CountryNames_CountryName:
            namespaceprefix_ = (
                self.AdministrativeUnits_V1_CountryNames_CountryName_nsprefix_ + ":"
                if (UseCapturedNS_ and self.AdministrativeUnits_V1_CountryNames_CountryName_nsprefix_)
                else ""
            )
            AdministrativeUnits_V1_CountryNames_CountryName_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="AdministrativeUnits_V1.CountryNames.CountryName",
                pretty_print=pretty_print,
            )
        for Dictionaries_V1_Dictionaries_Entry_ in self.Dictionaries_V1_Dictionaries_Entry:
            namespaceprefix_ = (
                self.Dictionaries_V1_Dictionaries_Entry_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Dictionaries_V1_Dictionaries_Entry_nsprefix_)
                else ""
            )
            Dictionaries_V1_Dictionaries_Entry_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Dictionaries_V1.Dictionaries.Entry",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "AdministrativeUnits_V1.CountryNames.CountryName":
            obj_ = AdministrativeUnits_V1_CountryNames_CountryName.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AdministrativeUnits_V1_CountryNames_CountryName.append(obj_)
            obj_.original_tagname_ = "AdministrativeUnits_V1.CountryNames.CountryName"
        elif nodeName_ == "Dictionaries_V1.Dictionaries.Entry":
            obj_ = Dictionaries_V1_Dictionaries_Entry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Dictionaries_V1_Dictionaries_Entry.append(obj_)
            obj_.original_tagname_ = "Dictionaries_V1.Dictionaries.Entry"


# end class EntriesType45


class SURFACEType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "BOUNDARY": MemberSpec_(
            "BOUNDARY",
            "BOUNDARYType",
            1,
            0,
            {"maxOccurs": "unbounded", "name": "BOUNDARY", "type": "BOUNDARYType"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, BOUNDARY=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if BOUNDARY is None:
            self.BOUNDARY = []
        else:
            self.BOUNDARY = BOUNDARY
        self.BOUNDARY_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, SURFACEType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SURFACEType.subclass:
            return SURFACEType.subclass(*args_, **kwargs_)
        else:
            return SURFACEType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_BOUNDARY(self):
        return self.BOUNDARY

    def set_BOUNDARY(self, BOUNDARY):
        self.BOUNDARY = BOUNDARY

    def add_BOUNDARY(self, value):
        self.BOUNDARY.append(value)

    def insert_BOUNDARY_at(self, index, value):
        self.BOUNDARY.insert(index, value)

    def replace_BOUNDARY_at(self, index, value):
        self.BOUNDARY[index] = value

    def _hasContent(self):
        if self.BOUNDARY:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="SURFACEType",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("SURFACEType")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "SURFACEType":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="SURFACEType")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="SURFACEType",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="SURFACEType",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="SURFACEType",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for BOUNDARY_ in self.BOUNDARY:
            namespaceprefix_ = (
                self.BOUNDARY_nsprefix_ + ":" if (UseCapturedNS_ and self.BOUNDARY_nsprefix_) else ""
            )
            BOUNDARY_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="BOUNDARY",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "BOUNDARY":
            obj_ = BOUNDARYType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BOUNDARY.append(obj_)
            obj_.original_tagname_ = "BOUNDARY"


# end class SURFACEType


class BOUNDARYType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "POLYLINE": MemberSpec_(
            "POLYLINE",
            "POLYLINEType",
            1,
            0,
            {"maxOccurs": "unbounded", "name": "POLYLINE", "type": "POLYLINEType"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, POLYLINE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if POLYLINE is None:
            self.POLYLINE = []
        else:
            self.POLYLINE = POLYLINE
        self.POLYLINE_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, BOUNDARYType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BOUNDARYType.subclass:
            return BOUNDARYType.subclass(*args_, **kwargs_)
        else:
            return BOUNDARYType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_POLYLINE(self):
        return self.POLYLINE

    def set_POLYLINE(self, POLYLINE):
        self.POLYLINE = POLYLINE

    def add_POLYLINE(self, value):
        self.POLYLINE.append(value)

    def insert_POLYLINE_at(self, index, value):
        self.POLYLINE.insert(index, value)

    def replace_POLYLINE_at(self, index, value):
        self.POLYLINE[index] = value

    def _hasContent(self):
        if self.POLYLINE:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="BOUNDARYType",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("BOUNDARYType")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "BOUNDARYType":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="BOUNDARYType")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="BOUNDARYType",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="BOUNDARYType",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="BOUNDARYType",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for POLYLINE_ in self.POLYLINE:
            namespaceprefix_ = (
                self.POLYLINE_nsprefix_ + ":" if (UseCapturedNS_ and self.POLYLINE_nsprefix_) else ""
            )
            POLYLINE_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="POLYLINE",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "POLYLINE":
            obj_ = POLYLINEType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.POLYLINE.append(obj_)
            obj_.original_tagname_ = "POLYLINE"


# end class BOUNDARYType


class POLYLINEType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "COORD": MemberSpec_("COORD", "CoordValue", 1, 0, {"name": "COORD", "type": "CoordValue"}, 19),
        "ARC": MemberSpec_("ARC", "ArcPoint", 1, 0, {"name": "ARC", "type": "ArcPoint"}, 19),
    }
    subclass = None
    superclass = None

    def __init__(self, COORD=None, ARC=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if COORD is None:
            self.COORD = []
        else:
            self.COORD = COORD
        self.COORD_nsprefix_ = None
        if ARC is None:
            self.ARC = []
        else:
            self.ARC = ARC
        self.ARC_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, POLYLINEType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POLYLINEType.subclass:
            return POLYLINEType.subclass(*args_, **kwargs_)
        else:
            return POLYLINEType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_COORD(self):
        return self.COORD

    def set_COORD(self, COORD):
        self.COORD = COORD

    def add_COORD(self, value):
        self.COORD.append(value)

    def insert_COORD_at(self, index, value):
        self.COORD.insert(index, value)

    def replace_COORD_at(self, index, value):
        self.COORD[index] = value

    def get_ARC(self):
        return self.ARC

    def set_ARC(self, ARC):
        self.ARC = ARC

    def add_ARC(self, value):
        self.ARC.append(value)

    def insert_ARC_at(self, index, value):
        self.ARC.insert(index, value)

    def replace_ARC_at(self, index, value):
        self.ARC[index] = value

    def _hasContent(self):
        if self.COORD or self.ARC:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="POLYLINEType",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("POLYLINEType")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "POLYLINEType":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="POLYLINEType")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="POLYLINEType",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="POLYLINEType",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="POLYLINEType",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for COORD_ in self.COORD:
            namespaceprefix_ = self.COORD_nsprefix_ + ":" if (UseCapturedNS_ and self.COORD_nsprefix_) else ""
            COORD_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="COORD",
                pretty_print=pretty_print,
            )
        for ARC_ in self.ARC:
            namespaceprefix_ = self.ARC_nsprefix_ + ":" if (UseCapturedNS_ and self.ARC_nsprefix_) else ""
            ARC_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="ARC",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "COORD":
            obj_ = CoordValue.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.COORD.append(obj_)
            obj_.original_tagname_ = "COORD"
        elif nodeName_ == "ARC":
            obj_ = ArcPoint.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ARC.append(obj_)
            obj_.original_tagname_ = "ARC"


# end class POLYLINEType


class SURFACEType46(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "BOUNDARY": MemberSpec_(
            "BOUNDARY",
            "BOUNDARYType47",
            1,
            0,
            {"maxOccurs": "unbounded", "name": "BOUNDARY", "type": "BOUNDARYType47"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, BOUNDARY=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if BOUNDARY is None:
            self.BOUNDARY = []
        else:
            self.BOUNDARY = BOUNDARY
        self.BOUNDARY_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, SURFACEType46)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SURFACEType46.subclass:
            return SURFACEType46.subclass(*args_, **kwargs_)
        else:
            return SURFACEType46(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_BOUNDARY(self):
        return self.BOUNDARY

    def set_BOUNDARY(self, BOUNDARY):
        self.BOUNDARY = BOUNDARY

    def add_BOUNDARY(self, value):
        self.BOUNDARY.append(value)

    def insert_BOUNDARY_at(self, index, value):
        self.BOUNDARY.insert(index, value)

    def replace_BOUNDARY_at(self, index, value):
        self.BOUNDARY[index] = value

    def _hasContent(self):
        if self.BOUNDARY:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="SURFACEType46",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("SURFACEType46")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "SURFACEType46":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="SURFACEType46")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="SURFACEType46",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="SURFACEType46",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="SURFACEType46",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for BOUNDARY_ in self.BOUNDARY:
            namespaceprefix_ = (
                self.BOUNDARY_nsprefix_ + ":" if (UseCapturedNS_ and self.BOUNDARY_nsprefix_) else ""
            )
            BOUNDARY_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="BOUNDARY",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "BOUNDARY":
            obj_ = BOUNDARYType47.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BOUNDARY.append(obj_)
            obj_.original_tagname_ = "BOUNDARY"


# end class SURFACEType46


class BOUNDARYType47(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "POLYLINE": MemberSpec_(
            "POLYLINE",
            "POLYLINEType48",
            1,
            0,
            {"maxOccurs": "unbounded", "name": "POLYLINE", "type": "POLYLINEType48"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, POLYLINE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if POLYLINE is None:
            self.POLYLINE = []
        else:
            self.POLYLINE = POLYLINE
        self.POLYLINE_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, BOUNDARYType47)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BOUNDARYType47.subclass:
            return BOUNDARYType47.subclass(*args_, **kwargs_)
        else:
            return BOUNDARYType47(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_POLYLINE(self):
        return self.POLYLINE

    def set_POLYLINE(self, POLYLINE):
        self.POLYLINE = POLYLINE

    def add_POLYLINE(self, value):
        self.POLYLINE.append(value)

    def insert_POLYLINE_at(self, index, value):
        self.POLYLINE.insert(index, value)

    def replace_POLYLINE_at(self, index, value):
        self.POLYLINE[index] = value

    def _hasContent(self):
        if self.POLYLINE:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="BOUNDARYType47",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("BOUNDARYType47")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "BOUNDARYType47":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="BOUNDARYType47")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="BOUNDARYType47",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="BOUNDARYType47",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="BOUNDARYType47",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for POLYLINE_ in self.POLYLINE:
            namespaceprefix_ = (
                self.POLYLINE_nsprefix_ + ":" if (UseCapturedNS_ and self.POLYLINE_nsprefix_) else ""
            )
            POLYLINE_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="POLYLINE",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "POLYLINE":
            obj_ = POLYLINEType48.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.POLYLINE.append(obj_)
            obj_.original_tagname_ = "POLYLINE"


# end class BOUNDARYType47


class POLYLINEType48(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "COORD": MemberSpec_("COORD", "CoordValue", 1, 0, {"name": "COORD", "type": "CoordValue"}, 20),
        "ARC": MemberSpec_("ARC", "ArcPoint", 1, 0, {"name": "ARC", "type": "ArcPoint"}, 20),
    }
    subclass = None
    superclass = None

    def __init__(self, COORD=None, ARC=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if COORD is None:
            self.COORD = []
        else:
            self.COORD = COORD
        self.COORD_nsprefix_ = None
        if ARC is None:
            self.ARC = []
        else:
            self.ARC = ARC
        self.ARC_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, POLYLINEType48)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POLYLINEType48.subclass:
            return POLYLINEType48.subclass(*args_, **kwargs_)
        else:
            return POLYLINEType48(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_COORD(self):
        return self.COORD

    def set_COORD(self, COORD):
        self.COORD = COORD

    def add_COORD(self, value):
        self.COORD.append(value)

    def insert_COORD_at(self, index, value):
        self.COORD.insert(index, value)

    def replace_COORD_at(self, index, value):
        self.COORD[index] = value

    def get_ARC(self):
        return self.ARC

    def set_ARC(self, ARC):
        self.ARC = ARC

    def add_ARC(self, value):
        self.ARC.append(value)

    def insert_ARC_at(self, index, value):
        self.ARC.insert(index, value)

    def replace_ARC_at(self, index, value):
        self.ARC[index] = value

    def _hasContent(self):
        if self.COORD or self.ARC:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="POLYLINEType48",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("POLYLINEType48")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "POLYLINEType48":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="POLYLINEType48")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="POLYLINEType48",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="POLYLINEType48",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="POLYLINEType48",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for COORD_ in self.COORD:
            namespaceprefix_ = self.COORD_nsprefix_ + ":" if (UseCapturedNS_ and self.COORD_nsprefix_) else ""
            COORD_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="COORD",
                pretty_print=pretty_print,
            )
        for ARC_ in self.ARC:
            namespaceprefix_ = self.ARC_nsprefix_ + ":" if (UseCapturedNS_ and self.ARC_nsprefix_) else ""
            ARC_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="ARC",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "COORD":
            obj_ = CoordValue.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.COORD.append(obj_)
            obj_.original_tagname_ = "COORD"
        elif nodeName_ == "ARC":
            obj_ = ArcPoint.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ARC.append(obj_)
            obj_.original_tagname_ = "ARC"


# end class POLYLINEType48


class POLYLINEType49(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "COORD": MemberSpec_("COORD", "CoordValue", 1, 0, {"name": "COORD", "type": "CoordValue"}, 21),
        "ARC": MemberSpec_("ARC", "ArcPoint", 1, 0, {"name": "ARC", "type": "ArcPoint"}, 21),
    }
    subclass = None
    superclass = None

    def __init__(self, COORD=None, ARC=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if COORD is None:
            self.COORD = []
        else:
            self.COORD = COORD
        self.COORD_nsprefix_ = None
        if ARC is None:
            self.ARC = []
        else:
            self.ARC = ARC
        self.ARC_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, POLYLINEType49)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POLYLINEType49.subclass:
            return POLYLINEType49.subclass(*args_, **kwargs_)
        else:
            return POLYLINEType49(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_COORD(self):
        return self.COORD

    def set_COORD(self, COORD):
        self.COORD = COORD

    def add_COORD(self, value):
        self.COORD.append(value)

    def insert_COORD_at(self, index, value):
        self.COORD.insert(index, value)

    def replace_COORD_at(self, index, value):
        self.COORD[index] = value

    def get_ARC(self):
        return self.ARC

    def set_ARC(self, ARC):
        self.ARC = ARC

    def add_ARC(self, value):
        self.ARC.append(value)

    def insert_ARC_at(self, index, value):
        self.ARC.insert(index, value)

    def replace_ARC_at(self, index, value):
        self.ARC[index] = value

    def _hasContent(self):
        if self.COORD or self.ARC:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="POLYLINEType49",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("POLYLINEType49")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "POLYLINEType49":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="POLYLINEType49")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="POLYLINEType49",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="POLYLINEType49",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="POLYLINEType49",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for COORD_ in self.COORD:
            namespaceprefix_ = self.COORD_nsprefix_ + ":" if (UseCapturedNS_ and self.COORD_nsprefix_) else ""
            COORD_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="COORD",
                pretty_print=pretty_print,
            )
        for ARC_ in self.ARC:
            namespaceprefix_ = self.ARC_nsprefix_ + ":" if (UseCapturedNS_ and self.ARC_nsprefix_) else ""
            ARC_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="ARC",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "COORD":
            obj_ = CoordValue.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.COORD.append(obj_)
            obj_.original_tagname_ = "COORD"
        elif nodeName_ == "ARC":
            obj_ = ArcPoint.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ARC.append(obj_)
            obj_.original_tagname_ = "ARC"


# end class POLYLINEType49


class POLYLINEType50(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "COORD": MemberSpec_("COORD", "CoordValue", 1, 0, {"name": "COORD", "type": "CoordValue"}, 22),
        "ARC": MemberSpec_("ARC", "ArcPoint", 1, 0, {"name": "ARC", "type": "ArcPoint"}, 22),
    }
    subclass = None
    superclass = None

    def __init__(self, COORD=None, ARC=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if COORD is None:
            self.COORD = []
        else:
            self.COORD = COORD
        self.COORD_nsprefix_ = None
        if ARC is None:
            self.ARC = []
        else:
            self.ARC = ARC
        self.ARC_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, POLYLINEType50)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POLYLINEType50.subclass:
            return POLYLINEType50.subclass(*args_, **kwargs_)
        else:
            return POLYLINEType50(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_COORD(self):
        return self.COORD

    def set_COORD(self, COORD):
        self.COORD = COORD

    def add_COORD(self, value):
        self.COORD.append(value)

    def insert_COORD_at(self, index, value):
        self.COORD.insert(index, value)

    def replace_COORD_at(self, index, value):
        self.COORD[index] = value

    def get_ARC(self):
        return self.ARC

    def set_ARC(self, ARC):
        self.ARC = ARC

    def add_ARC(self, value):
        self.ARC.append(value)

    def insert_ARC_at(self, index, value):
        self.ARC.insert(index, value)

    def replace_ARC_at(self, index, value):
        self.ARC[index] = value

    def _hasContent(self):
        if self.COORD or self.ARC:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="POLYLINEType50",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("POLYLINEType50")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "POLYLINEType50":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="POLYLINEType50")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="POLYLINEType50",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="POLYLINEType50",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="POLYLINEType50",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for COORD_ in self.COORD:
            namespaceprefix_ = self.COORD_nsprefix_ + ":" if (UseCapturedNS_ and self.COORD_nsprefix_) else ""
            COORD_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="COORD",
                pretty_print=pretty_print,
            )
        for ARC_ in self.ARC:
            namespaceprefix_ = self.ARC_nsprefix_ + ":" if (UseCapturedNS_ and self.ARC_nsprefix_) else ""
            ARC_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="ARC",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "COORD":
            obj_ = CoordValue.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.COORD.append(obj_)
            obj_.original_tagname_ = "COORD"
        elif nodeName_ == "ARC":
            obj_ = ArcPoint.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ARC.append(obj_)
            obj_.original_tagname_ = "ARC"


# end class POLYLINEType50


class POLYLINEType51(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "COORD": MemberSpec_("COORD", "CoordValue", 1, 0, {"name": "COORD", "type": "CoordValue"}, 23),
        "ARC": MemberSpec_("ARC", "ArcPoint", 1, 0, {"name": "ARC", "type": "ArcPoint"}, 23),
    }
    subclass = None
    superclass = None

    def __init__(self, COORD=None, ARC=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if COORD is None:
            self.COORD = []
        else:
            self.COORD = COORD
        self.COORD_nsprefix_ = None
        if ARC is None:
            self.ARC = []
        else:
            self.ARC = ARC
        self.ARC_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, POLYLINEType51)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POLYLINEType51.subclass:
            return POLYLINEType51.subclass(*args_, **kwargs_)
        else:
            return POLYLINEType51(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_COORD(self):
        return self.COORD

    def set_COORD(self, COORD):
        self.COORD = COORD

    def add_COORD(self, value):
        self.COORD.append(value)

    def insert_COORD_at(self, index, value):
        self.COORD.insert(index, value)

    def replace_COORD_at(self, index, value):
        self.COORD[index] = value

    def get_ARC(self):
        return self.ARC

    def set_ARC(self, ARC):
        self.ARC = ARC

    def add_ARC(self, value):
        self.ARC.append(value)

    def insert_ARC_at(self, index, value):
        self.ARC.insert(index, value)

    def replace_ARC_at(self, index, value):
        self.ARC[index] = value

    def _hasContent(self):
        if self.COORD or self.ARC:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="POLYLINEType51",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("POLYLINEType51")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "POLYLINEType51":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="POLYLINEType51")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="POLYLINEType51",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="POLYLINEType51",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="POLYLINEType51",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for COORD_ in self.COORD:
            namespaceprefix_ = self.COORD_nsprefix_ + ":" if (UseCapturedNS_ and self.COORD_nsprefix_) else ""
            COORD_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="COORD",
                pretty_print=pretty_print,
            )
        for ARC_ in self.ARC:
            namespaceprefix_ = self.ARC_nsprefix_ + ":" if (UseCapturedNS_ and self.ARC_nsprefix_) else ""
            ARC_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="ARC",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "COORD":
            obj_ = CoordValue.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.COORD.append(obj_)
            obj_.original_tagname_ = "COORD"
        elif nodeName_ == "ARC":
            obj_ = ArcPoint.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ARC.append(obj_)
            obj_.original_tagname_ = "ARC"


# end class POLYLINEType51


class POLYLINEType52(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "COORD": MemberSpec_("COORD", "CoordValue", 1, 0, {"name": "COORD", "type": "CoordValue"}, 24),
        "ARC": MemberSpec_("ARC", "ArcPoint", 1, 0, {"name": "ARC", "type": "ArcPoint"}, 24),
    }
    subclass = None
    superclass = None

    def __init__(self, COORD=None, ARC=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if COORD is None:
            self.COORD = []
        else:
            self.COORD = COORD
        self.COORD_nsprefix_ = None
        if ARC is None:
            self.ARC = []
        else:
            self.ARC = ARC
        self.ARC_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, POLYLINEType52)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POLYLINEType52.subclass:
            return POLYLINEType52.subclass(*args_, **kwargs_)
        else:
            return POLYLINEType52(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_COORD(self):
        return self.COORD

    def set_COORD(self, COORD):
        self.COORD = COORD

    def add_COORD(self, value):
        self.COORD.append(value)

    def insert_COORD_at(self, index, value):
        self.COORD.insert(index, value)

    def replace_COORD_at(self, index, value):
        self.COORD[index] = value

    def get_ARC(self):
        return self.ARC

    def set_ARC(self, ARC):
        self.ARC = ARC

    def add_ARC(self, value):
        self.ARC.append(value)

    def insert_ARC_at(self, index, value):
        self.ARC.insert(index, value)

    def replace_ARC_at(self, index, value):
        self.ARC[index] = value

    def _hasContent(self):
        if self.COORD or self.ARC:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="POLYLINEType52",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("POLYLINEType52")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "POLYLINEType52":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="POLYLINEType52")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="POLYLINEType52",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="POLYLINEType52",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="POLYLINEType52",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for COORD_ in self.COORD:
            namespaceprefix_ = self.COORD_nsprefix_ + ":" if (UseCapturedNS_ and self.COORD_nsprefix_) else ""
            COORD_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="COORD",
                pretty_print=pretty_print,
            )
        for ARC_ in self.ARC:
            namespaceprefix_ = self.ARC_nsprefix_ + ":" if (UseCapturedNS_ and self.ARC_nsprefix_) else ""
            ARC_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="ARC",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "COORD":
            obj_ = CoordValue.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.COORD.append(obj_)
            obj_.original_tagname_ = "COORD"
        elif nodeName_ == "ARC":
            obj_ = ArcPoint.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ARC.append(obj_)
            obj_.original_tagname_ = "ARC"


# end class POLYLINEType52


class SURFACEType53(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "BOUNDARY": MemberSpec_(
            "BOUNDARY",
            "BOUNDARYType54",
            1,
            0,
            {"maxOccurs": "unbounded", "name": "BOUNDARY", "type": "BOUNDARYType54"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, BOUNDARY=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if BOUNDARY is None:
            self.BOUNDARY = []
        else:
            self.BOUNDARY = BOUNDARY
        self.BOUNDARY_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, SURFACEType53)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SURFACEType53.subclass:
            return SURFACEType53.subclass(*args_, **kwargs_)
        else:
            return SURFACEType53(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_BOUNDARY(self):
        return self.BOUNDARY

    def set_BOUNDARY(self, BOUNDARY):
        self.BOUNDARY = BOUNDARY

    def add_BOUNDARY(self, value):
        self.BOUNDARY.append(value)

    def insert_BOUNDARY_at(self, index, value):
        self.BOUNDARY.insert(index, value)

    def replace_BOUNDARY_at(self, index, value):
        self.BOUNDARY[index] = value

    def _hasContent(self):
        if self.BOUNDARY:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="SURFACEType53",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("SURFACEType53")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "SURFACEType53":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="SURFACEType53")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="SURFACEType53",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="SURFACEType53",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="SURFACEType53",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for BOUNDARY_ in self.BOUNDARY:
            namespaceprefix_ = (
                self.BOUNDARY_nsprefix_ + ":" if (UseCapturedNS_ and self.BOUNDARY_nsprefix_) else ""
            )
            BOUNDARY_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="BOUNDARY",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "BOUNDARY":
            obj_ = BOUNDARYType54.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BOUNDARY.append(obj_)
            obj_.original_tagname_ = "BOUNDARY"


# end class SURFACEType53


class BOUNDARYType54(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "POLYLINE": MemberSpec_(
            "POLYLINE",
            "POLYLINEType55",
            1,
            0,
            {"maxOccurs": "unbounded", "name": "POLYLINE", "type": "POLYLINEType55"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, POLYLINE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if POLYLINE is None:
            self.POLYLINE = []
        else:
            self.POLYLINE = POLYLINE
        self.POLYLINE_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, BOUNDARYType54)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BOUNDARYType54.subclass:
            return BOUNDARYType54.subclass(*args_, **kwargs_)
        else:
            return BOUNDARYType54(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_POLYLINE(self):
        return self.POLYLINE

    def set_POLYLINE(self, POLYLINE):
        self.POLYLINE = POLYLINE

    def add_POLYLINE(self, value):
        self.POLYLINE.append(value)

    def insert_POLYLINE_at(self, index, value):
        self.POLYLINE.insert(index, value)

    def replace_POLYLINE_at(self, index, value):
        self.POLYLINE[index] = value

    def _hasContent(self):
        if self.POLYLINE:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="BOUNDARYType54",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("BOUNDARYType54")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "BOUNDARYType54":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="BOUNDARYType54")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="BOUNDARYType54",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="BOUNDARYType54",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="BOUNDARYType54",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for POLYLINE_ in self.POLYLINE:
            namespaceprefix_ = (
                self.POLYLINE_nsprefix_ + ":" if (UseCapturedNS_ and self.POLYLINE_nsprefix_) else ""
            )
            POLYLINE_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="POLYLINE",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "POLYLINE":
            obj_ = POLYLINEType55.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.POLYLINE.append(obj_)
            obj_.original_tagname_ = "POLYLINE"


# end class BOUNDARYType54


class POLYLINEType55(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "COORD": MemberSpec_("COORD", "CoordValue", 1, 0, {"name": "COORD", "type": "CoordValue"}, 25),
        "ARC": MemberSpec_("ARC", "ArcPoint", 1, 0, {"name": "ARC", "type": "ArcPoint"}, 25),
    }
    subclass = None
    superclass = None

    def __init__(self, COORD=None, ARC=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if COORD is None:
            self.COORD = []
        else:
            self.COORD = COORD
        self.COORD_nsprefix_ = None
        if ARC is None:
            self.ARC = []
        else:
            self.ARC = ARC
        self.ARC_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, POLYLINEType55)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POLYLINEType55.subclass:
            return POLYLINEType55.subclass(*args_, **kwargs_)
        else:
            return POLYLINEType55(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_COORD(self):
        return self.COORD

    def set_COORD(self, COORD):
        self.COORD = COORD

    def add_COORD(self, value):
        self.COORD.append(value)

    def insert_COORD_at(self, index, value):
        self.COORD.insert(index, value)

    def replace_COORD_at(self, index, value):
        self.COORD[index] = value

    def get_ARC(self):
        return self.ARC

    def set_ARC(self, ARC):
        self.ARC = ARC

    def add_ARC(self, value):
        self.ARC.append(value)

    def insert_ARC_at(self, index, value):
        self.ARC.insert(index, value)

    def replace_ARC_at(self, index, value):
        self.ARC[index] = value

    def _hasContent(self):
        if self.COORD or self.ARC:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="POLYLINEType55",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("POLYLINEType55")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "POLYLINEType55":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="POLYLINEType55")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="POLYLINEType55",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="POLYLINEType55",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="POLYLINEType55",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for COORD_ in self.COORD:
            namespaceprefix_ = self.COORD_nsprefix_ + ":" if (UseCapturedNS_ and self.COORD_nsprefix_) else ""
            COORD_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="COORD",
                pretty_print=pretty_print,
            )
        for ARC_ in self.ARC:
            namespaceprefix_ = self.ARC_nsprefix_ + ":" if (UseCapturedNS_ and self.ARC_nsprefix_) else ""
            ARC_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="ARC",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "COORD":
            obj_ = CoordValue.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.COORD.append(obj_)
            obj_.original_tagname_ = "COORD"
        elif nodeName_ == "ARC":
            obj_ = ArcPoint.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ARC.append(obj_)
            obj_.original_tagname_ = "ARC"


# end class POLYLINEType55


class SURFACEType56(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "BOUNDARY": MemberSpec_(
            "BOUNDARY",
            "BOUNDARYType57",
            1,
            0,
            {"maxOccurs": "unbounded", "name": "BOUNDARY", "type": "BOUNDARYType57"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, BOUNDARY=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if BOUNDARY is None:
            self.BOUNDARY = []
        else:
            self.BOUNDARY = BOUNDARY
        self.BOUNDARY_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, SURFACEType56)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SURFACEType56.subclass:
            return SURFACEType56.subclass(*args_, **kwargs_)
        else:
            return SURFACEType56(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_BOUNDARY(self):
        return self.BOUNDARY

    def set_BOUNDARY(self, BOUNDARY):
        self.BOUNDARY = BOUNDARY

    def add_BOUNDARY(self, value):
        self.BOUNDARY.append(value)

    def insert_BOUNDARY_at(self, index, value):
        self.BOUNDARY.insert(index, value)

    def replace_BOUNDARY_at(self, index, value):
        self.BOUNDARY[index] = value

    def _hasContent(self):
        if self.BOUNDARY:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="SURFACEType56",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("SURFACEType56")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "SURFACEType56":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="SURFACEType56")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="SURFACEType56",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="SURFACEType56",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="SURFACEType56",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for BOUNDARY_ in self.BOUNDARY:
            namespaceprefix_ = (
                self.BOUNDARY_nsprefix_ + ":" if (UseCapturedNS_ and self.BOUNDARY_nsprefix_) else ""
            )
            BOUNDARY_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="BOUNDARY",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "BOUNDARY":
            obj_ = BOUNDARYType57.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BOUNDARY.append(obj_)
            obj_.original_tagname_ = "BOUNDARY"


# end class SURFACEType56


class BOUNDARYType57(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "POLYLINE": MemberSpec_(
            "POLYLINE",
            "POLYLINEType58",
            1,
            0,
            {"maxOccurs": "unbounded", "name": "POLYLINE", "type": "POLYLINEType58"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, POLYLINE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if POLYLINE is None:
            self.POLYLINE = []
        else:
            self.POLYLINE = POLYLINE
        self.POLYLINE_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, BOUNDARYType57)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BOUNDARYType57.subclass:
            return BOUNDARYType57.subclass(*args_, **kwargs_)
        else:
            return BOUNDARYType57(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_POLYLINE(self):
        return self.POLYLINE

    def set_POLYLINE(self, POLYLINE):
        self.POLYLINE = POLYLINE

    def add_POLYLINE(self, value):
        self.POLYLINE.append(value)

    def insert_POLYLINE_at(self, index, value):
        self.POLYLINE.insert(index, value)

    def replace_POLYLINE_at(self, index, value):
        self.POLYLINE[index] = value

    def _hasContent(self):
        if self.POLYLINE:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="BOUNDARYType57",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("BOUNDARYType57")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "BOUNDARYType57":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="BOUNDARYType57")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="BOUNDARYType57",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="BOUNDARYType57",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="BOUNDARYType57",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for POLYLINE_ in self.POLYLINE:
            namespaceprefix_ = (
                self.POLYLINE_nsprefix_ + ":" if (UseCapturedNS_ and self.POLYLINE_nsprefix_) else ""
            )
            POLYLINE_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="POLYLINE",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "POLYLINE":
            obj_ = POLYLINEType58.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.POLYLINE.append(obj_)
            obj_.original_tagname_ = "POLYLINE"


# end class BOUNDARYType57


class POLYLINEType58(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "COORD": MemberSpec_("COORD", "CoordValue", 1, 0, {"name": "COORD", "type": "CoordValue"}, 26),
        "ARC": MemberSpec_("ARC", "ArcPoint", 1, 0, {"name": "ARC", "type": "ArcPoint"}, 26),
    }
    subclass = None
    superclass = None

    def __init__(self, COORD=None, ARC=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if COORD is None:
            self.COORD = []
        else:
            self.COORD = COORD
        self.COORD_nsprefix_ = None
        if ARC is None:
            self.ARC = []
        else:
            self.ARC = ARC
        self.ARC_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, POLYLINEType58)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POLYLINEType58.subclass:
            return POLYLINEType58.subclass(*args_, **kwargs_)
        else:
            return POLYLINEType58(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_COORD(self):
        return self.COORD

    def set_COORD(self, COORD):
        self.COORD = COORD

    def add_COORD(self, value):
        self.COORD.append(value)

    def insert_COORD_at(self, index, value):
        self.COORD.insert(index, value)

    def replace_COORD_at(self, index, value):
        self.COORD[index] = value

    def get_ARC(self):
        return self.ARC

    def set_ARC(self, ARC):
        self.ARC = ARC

    def add_ARC(self, value):
        self.ARC.append(value)

    def insert_ARC_at(self, index, value):
        self.ARC.insert(index, value)

    def replace_ARC_at(self, index, value):
        self.ARC[index] = value

    def _hasContent(self):
        if self.COORD or self.ARC:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="POLYLINEType58",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("POLYLINEType58")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "POLYLINEType58":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="POLYLINEType58")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="POLYLINEType58",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="POLYLINEType58",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="POLYLINEType58",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for COORD_ in self.COORD:
            namespaceprefix_ = self.COORD_nsprefix_ + ":" if (UseCapturedNS_ and self.COORD_nsprefix_) else ""
            COORD_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="COORD",
                pretty_print=pretty_print,
            )
        for ARC_ in self.ARC:
            namespaceprefix_ = self.ARC_nsprefix_ + ":" if (UseCapturedNS_ and self.ARC_nsprefix_) else ""
            ARC_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="ARC",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "COORD":
            obj_ = CoordValue.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.COORD.append(obj_)
            obj_.original_tagname_ = "COORD"
        elif nodeName_ == "ARC":
            obj_ = ArcPoint.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ARC.append(obj_)
            obj_.original_tagname_ = "ARC"


# end class POLYLINEType58


class LinesType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "GeometryCHLV03_V1_LineStructure": MemberSpec_(
            "GeometryCHLV03_V1_LineStructure",
            "GeometryCHLV03_V1.LineStructure",
            1,
            0,
            {
                "maxOccurs": "unbounded",
                "name": "GeometryCHLV03_V1.LineStructure",
                "type": "GeometryCHLV03_V1.LineStructure",
            },
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, GeometryCHLV03_V1_LineStructure=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if GeometryCHLV03_V1_LineStructure is None:
            self.GeometryCHLV03_V1_LineStructure = []
        else:
            self.GeometryCHLV03_V1_LineStructure = GeometryCHLV03_V1_LineStructure
        self.GeometryCHLV03_V1_LineStructure_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, LinesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LinesType.subclass:
            return LinesType.subclass(*args_, **kwargs_)
        else:
            return LinesType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_GeometryCHLV03_V1_LineStructure(self):
        return self.GeometryCHLV03_V1_LineStructure

    def set_GeometryCHLV03_V1_LineStructure(self, GeometryCHLV03_V1_LineStructure):
        self.GeometryCHLV03_V1_LineStructure = GeometryCHLV03_V1_LineStructure

    def add_GeometryCHLV03_V1_LineStructure(self, value):
        self.GeometryCHLV03_V1_LineStructure.append(value)

    def insert_GeometryCHLV03_V1_LineStructure_at(self, index, value):
        self.GeometryCHLV03_V1_LineStructure.insert(index, value)

    def replace_GeometryCHLV03_V1_LineStructure_at(self, index, value):
        self.GeometryCHLV03_V1_LineStructure[index] = value

    def _hasContent(self):
        if self.GeometryCHLV03_V1_LineStructure:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="LinesType",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("LinesType")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "LinesType":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="LinesType")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="LinesType",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_="", name_="LinesType"):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="LinesType",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for GeometryCHLV03_V1_LineStructure_ in self.GeometryCHLV03_V1_LineStructure:
            namespaceprefix_ = (
                self.GeometryCHLV03_V1_LineStructure_nsprefix_ + ":"
                if (UseCapturedNS_ and self.GeometryCHLV03_V1_LineStructure_nsprefix_)
                else ""
            )
            GeometryCHLV03_V1_LineStructure_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="GeometryCHLV03_V1.LineStructure",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "GeometryCHLV03_V1.LineStructure":
            obj_ = GeometryCHLV03_V1_LineStructure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.GeometryCHLV03_V1_LineStructure.append(obj_)
            obj_.original_tagname_ = "GeometryCHLV03_V1.LineStructure"


# end class LinesType


class LinesType59(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "GeometryCHLV03_V1_DirectedLineStructure": MemberSpec_(
            "GeometryCHLV03_V1_DirectedLineStructure",
            "GeometryCHLV03_V1.DirectedLineStructure",
            1,
            0,
            {
                "maxOccurs": "unbounded",
                "name": "GeometryCHLV03_V1.DirectedLineStructure",
                "type": "GeometryCHLV03_V1.DirectedLineStructure",
            },
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, GeometryCHLV03_V1_DirectedLineStructure=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if GeometryCHLV03_V1_DirectedLineStructure is None:
            self.GeometryCHLV03_V1_DirectedLineStructure = []
        else:
            self.GeometryCHLV03_V1_DirectedLineStructure = GeometryCHLV03_V1_DirectedLineStructure
        self.GeometryCHLV03_V1_DirectedLineStructure_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, LinesType59)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LinesType59.subclass:
            return LinesType59.subclass(*args_, **kwargs_)
        else:
            return LinesType59(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_GeometryCHLV03_V1_DirectedLineStructure(self):
        return self.GeometryCHLV03_V1_DirectedLineStructure

    def set_GeometryCHLV03_V1_DirectedLineStructure(self, GeometryCHLV03_V1_DirectedLineStructure):
        self.GeometryCHLV03_V1_DirectedLineStructure = GeometryCHLV03_V1_DirectedLineStructure

    def add_GeometryCHLV03_V1_DirectedLineStructure(self, value):
        self.GeometryCHLV03_V1_DirectedLineStructure.append(value)

    def insert_GeometryCHLV03_V1_DirectedLineStructure_at(self, index, value):
        self.GeometryCHLV03_V1_DirectedLineStructure.insert(index, value)

    def replace_GeometryCHLV03_V1_DirectedLineStructure_at(self, index, value):
        self.GeometryCHLV03_V1_DirectedLineStructure[index] = value

    def _hasContent(self):
        if self.GeometryCHLV03_V1_DirectedLineStructure:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="LinesType59",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("LinesType59")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "LinesType59":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="LinesType59")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="LinesType59",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="LinesType59",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="LinesType59",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for GeometryCHLV03_V1_DirectedLineStructure_ in self.GeometryCHLV03_V1_DirectedLineStructure:
            namespaceprefix_ = (
                self.GeometryCHLV03_V1_DirectedLineStructure_nsprefix_ + ":"
                if (UseCapturedNS_ and self.GeometryCHLV03_V1_DirectedLineStructure_nsprefix_)
                else ""
            )
            GeometryCHLV03_V1_DirectedLineStructure_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="GeometryCHLV03_V1.DirectedLineStructure",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "GeometryCHLV03_V1.DirectedLineStructure":
            obj_ = GeometryCHLV03_V1_DirectedLineStructure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.GeometryCHLV03_V1_DirectedLineStructure.append(obj_)
            obj_.original_tagname_ = "GeometryCHLV03_V1.DirectedLineStructure"


# end class LinesType59


class SurfacesType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "GeometryCHLV03_V1_SurfaceStructure": MemberSpec_(
            "GeometryCHLV03_V1_SurfaceStructure",
            "GeometryCHLV03_V1.SurfaceStructure",
            1,
            0,
            {
                "maxOccurs": "unbounded",
                "name": "GeometryCHLV03_V1.SurfaceStructure",
                "type": "GeometryCHLV03_V1.SurfaceStructure",
            },
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, GeometryCHLV03_V1_SurfaceStructure=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if GeometryCHLV03_V1_SurfaceStructure is None:
            self.GeometryCHLV03_V1_SurfaceStructure = []
        else:
            self.GeometryCHLV03_V1_SurfaceStructure = GeometryCHLV03_V1_SurfaceStructure
        self.GeometryCHLV03_V1_SurfaceStructure_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, SurfacesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SurfacesType.subclass:
            return SurfacesType.subclass(*args_, **kwargs_)
        else:
            return SurfacesType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_GeometryCHLV03_V1_SurfaceStructure(self):
        return self.GeometryCHLV03_V1_SurfaceStructure

    def set_GeometryCHLV03_V1_SurfaceStructure(self, GeometryCHLV03_V1_SurfaceStructure):
        self.GeometryCHLV03_V1_SurfaceStructure = GeometryCHLV03_V1_SurfaceStructure

    def add_GeometryCHLV03_V1_SurfaceStructure(self, value):
        self.GeometryCHLV03_V1_SurfaceStructure.append(value)

    def insert_GeometryCHLV03_V1_SurfaceStructure_at(self, index, value):
        self.GeometryCHLV03_V1_SurfaceStructure.insert(index, value)

    def replace_GeometryCHLV03_V1_SurfaceStructure_at(self, index, value):
        self.GeometryCHLV03_V1_SurfaceStructure[index] = value

    def _hasContent(self):
        if self.GeometryCHLV03_V1_SurfaceStructure:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="SurfacesType",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("SurfacesType")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "SurfacesType":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="SurfacesType")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="SurfacesType",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="SurfacesType",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="SurfacesType",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for GeometryCHLV03_V1_SurfaceStructure_ in self.GeometryCHLV03_V1_SurfaceStructure:
            namespaceprefix_ = (
                self.GeometryCHLV03_V1_SurfaceStructure_nsprefix_ + ":"
                if (UseCapturedNS_ and self.GeometryCHLV03_V1_SurfaceStructure_nsprefix_)
                else ""
            )
            GeometryCHLV03_V1_SurfaceStructure_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="GeometryCHLV03_V1.SurfaceStructure",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "GeometryCHLV03_V1.SurfaceStructure":
            obj_ = GeometryCHLV03_V1_SurfaceStructure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.GeometryCHLV03_V1_SurfaceStructure.append(obj_)
            obj_.original_tagname_ = "GeometryCHLV03_V1.SurfaceStructure"


# end class SurfacesType


class SURFACEType60(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "BOUNDARY": MemberSpec_(
            "BOUNDARY",
            "BOUNDARYType61",
            1,
            0,
            {"maxOccurs": "unbounded", "name": "BOUNDARY", "type": "BOUNDARYType61"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, BOUNDARY=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if BOUNDARY is None:
            self.BOUNDARY = []
        else:
            self.BOUNDARY = BOUNDARY
        self.BOUNDARY_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, SURFACEType60)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SURFACEType60.subclass:
            return SURFACEType60.subclass(*args_, **kwargs_)
        else:
            return SURFACEType60(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_BOUNDARY(self):
        return self.BOUNDARY

    def set_BOUNDARY(self, BOUNDARY):
        self.BOUNDARY = BOUNDARY

    def add_BOUNDARY(self, value):
        self.BOUNDARY.append(value)

    def insert_BOUNDARY_at(self, index, value):
        self.BOUNDARY.insert(index, value)

    def replace_BOUNDARY_at(self, index, value):
        self.BOUNDARY[index] = value

    def _hasContent(self):
        if self.BOUNDARY:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="SURFACEType60",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("SURFACEType60")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "SURFACEType60":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="SURFACEType60")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="SURFACEType60",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="SURFACEType60",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="SURFACEType60",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for BOUNDARY_ in self.BOUNDARY:
            namespaceprefix_ = (
                self.BOUNDARY_nsprefix_ + ":" if (UseCapturedNS_ and self.BOUNDARY_nsprefix_) else ""
            )
            BOUNDARY_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="BOUNDARY",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "BOUNDARY":
            obj_ = BOUNDARYType61.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BOUNDARY.append(obj_)
            obj_.original_tagname_ = "BOUNDARY"


# end class SURFACEType60


class BOUNDARYType61(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "POLYLINE": MemberSpec_(
            "POLYLINE",
            "POLYLINEType62",
            1,
            0,
            {"maxOccurs": "unbounded", "name": "POLYLINE", "type": "POLYLINEType62"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, POLYLINE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if POLYLINE is None:
            self.POLYLINE = []
        else:
            self.POLYLINE = POLYLINE
        self.POLYLINE_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, BOUNDARYType61)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BOUNDARYType61.subclass:
            return BOUNDARYType61.subclass(*args_, **kwargs_)
        else:
            return BOUNDARYType61(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_POLYLINE(self):
        return self.POLYLINE

    def set_POLYLINE(self, POLYLINE):
        self.POLYLINE = POLYLINE

    def add_POLYLINE(self, value):
        self.POLYLINE.append(value)

    def insert_POLYLINE_at(self, index, value):
        self.POLYLINE.insert(index, value)

    def replace_POLYLINE_at(self, index, value):
        self.POLYLINE[index] = value

    def _hasContent(self):
        if self.POLYLINE:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="BOUNDARYType61",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("BOUNDARYType61")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "BOUNDARYType61":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="BOUNDARYType61")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="BOUNDARYType61",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="BOUNDARYType61",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="BOUNDARYType61",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for POLYLINE_ in self.POLYLINE:
            namespaceprefix_ = (
                self.POLYLINE_nsprefix_ + ":" if (UseCapturedNS_ and self.POLYLINE_nsprefix_) else ""
            )
            POLYLINE_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="POLYLINE",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "POLYLINE":
            obj_ = POLYLINEType62.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.POLYLINE.append(obj_)
            obj_.original_tagname_ = "POLYLINE"


# end class BOUNDARYType61


class POLYLINEType62(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "COORD": MemberSpec_("COORD", "CoordValue", 1, 0, {"name": "COORD", "type": "CoordValue"}, 27),
        "ARC": MemberSpec_("ARC", "ArcPoint", 1, 0, {"name": "ARC", "type": "ArcPoint"}, 27),
    }
    subclass = None
    superclass = None

    def __init__(self, COORD=None, ARC=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if COORD is None:
            self.COORD = []
        else:
            self.COORD = COORD
        self.COORD_nsprefix_ = None
        if ARC is None:
            self.ARC = []
        else:
            self.ARC = ARC
        self.ARC_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, POLYLINEType62)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POLYLINEType62.subclass:
            return POLYLINEType62.subclass(*args_, **kwargs_)
        else:
            return POLYLINEType62(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_COORD(self):
        return self.COORD

    def set_COORD(self, COORD):
        self.COORD = COORD

    def add_COORD(self, value):
        self.COORD.append(value)

    def insert_COORD_at(self, index, value):
        self.COORD.insert(index, value)

    def replace_COORD_at(self, index, value):
        self.COORD[index] = value

    def get_ARC(self):
        return self.ARC

    def set_ARC(self, ARC):
        self.ARC = ARC

    def add_ARC(self, value):
        self.ARC.append(value)

    def insert_ARC_at(self, index, value):
        self.ARC.insert(index, value)

    def replace_ARC_at(self, index, value):
        self.ARC[index] = value

    def _hasContent(self):
        if self.COORD or self.ARC:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="POLYLINEType62",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("POLYLINEType62")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "POLYLINEType62":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="POLYLINEType62")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="POLYLINEType62",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="POLYLINEType62",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="POLYLINEType62",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for COORD_ in self.COORD:
            namespaceprefix_ = self.COORD_nsprefix_ + ":" if (UseCapturedNS_ and self.COORD_nsprefix_) else ""
            COORD_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="COORD",
                pretty_print=pretty_print,
            )
        for ARC_ in self.ARC:
            namespaceprefix_ = self.ARC_nsprefix_ + ":" if (UseCapturedNS_ and self.ARC_nsprefix_) else ""
            ARC_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="ARC",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "COORD":
            obj_ = CoordValue.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.COORD.append(obj_)
            obj_.original_tagname_ = "COORD"
        elif nodeName_ == "ARC":
            obj_ = ArcPoint.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ARC.append(obj_)
            obj_.original_tagname_ = "ARC"


# end class POLYLINEType62


class SURFACEType63(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "BOUNDARY": MemberSpec_(
            "BOUNDARY",
            "BOUNDARYType64",
            1,
            0,
            {"maxOccurs": "unbounded", "name": "BOUNDARY", "type": "BOUNDARYType64"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, BOUNDARY=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if BOUNDARY is None:
            self.BOUNDARY = []
        else:
            self.BOUNDARY = BOUNDARY
        self.BOUNDARY_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, SURFACEType63)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SURFACEType63.subclass:
            return SURFACEType63.subclass(*args_, **kwargs_)
        else:
            return SURFACEType63(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_BOUNDARY(self):
        return self.BOUNDARY

    def set_BOUNDARY(self, BOUNDARY):
        self.BOUNDARY = BOUNDARY

    def add_BOUNDARY(self, value):
        self.BOUNDARY.append(value)

    def insert_BOUNDARY_at(self, index, value):
        self.BOUNDARY.insert(index, value)

    def replace_BOUNDARY_at(self, index, value):
        self.BOUNDARY[index] = value

    def _hasContent(self):
        if self.BOUNDARY:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="SURFACEType63",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("SURFACEType63")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "SURFACEType63":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="SURFACEType63")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="SURFACEType63",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="SURFACEType63",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="SURFACEType63",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for BOUNDARY_ in self.BOUNDARY:
            namespaceprefix_ = (
                self.BOUNDARY_nsprefix_ + ":" if (UseCapturedNS_ and self.BOUNDARY_nsprefix_) else ""
            )
            BOUNDARY_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="BOUNDARY",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "BOUNDARY":
            obj_ = BOUNDARYType64.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BOUNDARY.append(obj_)
            obj_.original_tagname_ = "BOUNDARY"


# end class SURFACEType63


class BOUNDARYType64(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "POLYLINE": MemberSpec_(
            "POLYLINE",
            "POLYLINEType65",
            1,
            0,
            {"maxOccurs": "unbounded", "name": "POLYLINE", "type": "POLYLINEType65"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, POLYLINE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if POLYLINE is None:
            self.POLYLINE = []
        else:
            self.POLYLINE = POLYLINE
        self.POLYLINE_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, BOUNDARYType64)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BOUNDARYType64.subclass:
            return BOUNDARYType64.subclass(*args_, **kwargs_)
        else:
            return BOUNDARYType64(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_POLYLINE(self):
        return self.POLYLINE

    def set_POLYLINE(self, POLYLINE):
        self.POLYLINE = POLYLINE

    def add_POLYLINE(self, value):
        self.POLYLINE.append(value)

    def insert_POLYLINE_at(self, index, value):
        self.POLYLINE.insert(index, value)

    def replace_POLYLINE_at(self, index, value):
        self.POLYLINE[index] = value

    def _hasContent(self):
        if self.POLYLINE:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="BOUNDARYType64",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("BOUNDARYType64")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "BOUNDARYType64":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="BOUNDARYType64")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="BOUNDARYType64",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="BOUNDARYType64",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="BOUNDARYType64",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for POLYLINE_ in self.POLYLINE:
            namespaceprefix_ = (
                self.POLYLINE_nsprefix_ + ":" if (UseCapturedNS_ and self.POLYLINE_nsprefix_) else ""
            )
            POLYLINE_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="POLYLINE",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "POLYLINE":
            obj_ = POLYLINEType65.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.POLYLINE.append(obj_)
            obj_.original_tagname_ = "POLYLINE"


# end class BOUNDARYType64


class POLYLINEType65(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "COORD": MemberSpec_("COORD", "CoordValue", 1, 0, {"name": "COORD", "type": "CoordValue"}, 28),
        "ARC": MemberSpec_("ARC", "ArcPoint", 1, 0, {"name": "ARC", "type": "ArcPoint"}, 28),
    }
    subclass = None
    superclass = None

    def __init__(self, COORD=None, ARC=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if COORD is None:
            self.COORD = []
        else:
            self.COORD = COORD
        self.COORD_nsprefix_ = None
        if ARC is None:
            self.ARC = []
        else:
            self.ARC = ARC
        self.ARC_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, POLYLINEType65)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POLYLINEType65.subclass:
            return POLYLINEType65.subclass(*args_, **kwargs_)
        else:
            return POLYLINEType65(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_COORD(self):
        return self.COORD

    def set_COORD(self, COORD):
        self.COORD = COORD

    def add_COORD(self, value):
        self.COORD.append(value)

    def insert_COORD_at(self, index, value):
        self.COORD.insert(index, value)

    def replace_COORD_at(self, index, value):
        self.COORD[index] = value

    def get_ARC(self):
        return self.ARC

    def set_ARC(self, ARC):
        self.ARC = ARC

    def add_ARC(self, value):
        self.ARC.append(value)

    def insert_ARC_at(self, index, value):
        self.ARC.insert(index, value)

    def replace_ARC_at(self, index, value):
        self.ARC[index] = value

    def _hasContent(self):
        if self.COORD or self.ARC:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="POLYLINEType65",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("POLYLINEType65")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "POLYLINEType65":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="POLYLINEType65")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="POLYLINEType65",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="POLYLINEType65",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="POLYLINEType65",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for COORD_ in self.COORD:
            namespaceprefix_ = self.COORD_nsprefix_ + ":" if (UseCapturedNS_ and self.COORD_nsprefix_) else ""
            COORD_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="COORD",
                pretty_print=pretty_print,
            )
        for ARC_ in self.ARC:
            namespaceprefix_ = self.ARC_nsprefix_ + ":" if (UseCapturedNS_ and self.ARC_nsprefix_) else ""
            ARC_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="ARC",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "COORD":
            obj_ = CoordValue.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.COORD.append(obj_)
            obj_.original_tagname_ = "COORD"
        elif nodeName_ == "ARC":
            obj_ = ArcPoint.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ARC.append(obj_)
            obj_.original_tagname_ = "ARC"


# end class POLYLINEType65


class POLYLINEType66(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "COORD": MemberSpec_("COORD", "CoordValue", 1, 0, {"name": "COORD", "type": "CoordValue"}, 29),
        "ARC": MemberSpec_("ARC", "ArcPoint", 1, 0, {"name": "ARC", "type": "ArcPoint"}, 29),
    }
    subclass = None
    superclass = None

    def __init__(self, COORD=None, ARC=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if COORD is None:
            self.COORD = []
        else:
            self.COORD = COORD
        self.COORD_nsprefix_ = None
        if ARC is None:
            self.ARC = []
        else:
            self.ARC = ARC
        self.ARC_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, POLYLINEType66)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POLYLINEType66.subclass:
            return POLYLINEType66.subclass(*args_, **kwargs_)
        else:
            return POLYLINEType66(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_COORD(self):
        return self.COORD

    def set_COORD(self, COORD):
        self.COORD = COORD

    def add_COORD(self, value):
        self.COORD.append(value)

    def insert_COORD_at(self, index, value):
        self.COORD.insert(index, value)

    def replace_COORD_at(self, index, value):
        self.COORD[index] = value

    def get_ARC(self):
        return self.ARC

    def set_ARC(self, ARC):
        self.ARC = ARC

    def add_ARC(self, value):
        self.ARC.append(value)

    def insert_ARC_at(self, index, value):
        self.ARC.insert(index, value)

    def replace_ARC_at(self, index, value):
        self.ARC[index] = value

    def _hasContent(self):
        if self.COORD or self.ARC:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="POLYLINEType66",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("POLYLINEType66")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "POLYLINEType66":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="POLYLINEType66")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="POLYLINEType66",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="POLYLINEType66",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="POLYLINEType66",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for COORD_ in self.COORD:
            namespaceprefix_ = self.COORD_nsprefix_ + ":" if (UseCapturedNS_ and self.COORD_nsprefix_) else ""
            COORD_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="COORD",
                pretty_print=pretty_print,
            )
        for ARC_ in self.ARC:
            namespaceprefix_ = self.ARC_nsprefix_ + ":" if (UseCapturedNS_ and self.ARC_nsprefix_) else ""
            ARC_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="ARC",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "COORD":
            obj_ = CoordValue.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.COORD.append(obj_)
            obj_.original_tagname_ = "COORD"
        elif nodeName_ == "ARC":
            obj_ = ArcPoint.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ARC.append(obj_)
            obj_.original_tagname_ = "ARC"


# end class POLYLINEType66


class POLYLINEType67(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "COORD": MemberSpec_("COORD", "CoordValue", 1, 0, {"name": "COORD", "type": "CoordValue"}, 30),
        "ARC": MemberSpec_("ARC", "ArcPoint", 1, 0, {"name": "ARC", "type": "ArcPoint"}, 30),
    }
    subclass = None
    superclass = None

    def __init__(self, COORD=None, ARC=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if COORD is None:
            self.COORD = []
        else:
            self.COORD = COORD
        self.COORD_nsprefix_ = None
        if ARC is None:
            self.ARC = []
        else:
            self.ARC = ARC
        self.ARC_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, POLYLINEType67)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POLYLINEType67.subclass:
            return POLYLINEType67.subclass(*args_, **kwargs_)
        else:
            return POLYLINEType67(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_COORD(self):
        return self.COORD

    def set_COORD(self, COORD):
        self.COORD = COORD

    def add_COORD(self, value):
        self.COORD.append(value)

    def insert_COORD_at(self, index, value):
        self.COORD.insert(index, value)

    def replace_COORD_at(self, index, value):
        self.COORD[index] = value

    def get_ARC(self):
        return self.ARC

    def set_ARC(self, ARC):
        self.ARC = ARC

    def add_ARC(self, value):
        self.ARC.append(value)

    def insert_ARC_at(self, index, value):
        self.ARC.insert(index, value)

    def replace_ARC_at(self, index, value):
        self.ARC[index] = value

    def _hasContent(self):
        if self.COORD or self.ARC:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="POLYLINEType67",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("POLYLINEType67")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "POLYLINEType67":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="POLYLINEType67")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="POLYLINEType67",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="POLYLINEType67",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="POLYLINEType67",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for COORD_ in self.COORD:
            namespaceprefix_ = self.COORD_nsprefix_ + ":" if (UseCapturedNS_ and self.COORD_nsprefix_) else ""
            COORD_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="COORD",
                pretty_print=pretty_print,
            )
        for ARC_ in self.ARC:
            namespaceprefix_ = self.ARC_nsprefix_ + ":" if (UseCapturedNS_ and self.ARC_nsprefix_) else ""
            ARC_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="ARC",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "COORD":
            obj_ = CoordValue.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.COORD.append(obj_)
            obj_.original_tagname_ = "COORD"
        elif nodeName_ == "ARC":
            obj_ = ArcPoint.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ARC.append(obj_)
            obj_.original_tagname_ = "ARC"


# end class POLYLINEType67


class POLYLINEType68(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "COORD": MemberSpec_("COORD", "CoordValue", 1, 0, {"name": "COORD", "type": "CoordValue"}, 31),
        "ARC": MemberSpec_("ARC", "ArcPoint", 1, 0, {"name": "ARC", "type": "ArcPoint"}, 31),
    }
    subclass = None
    superclass = None

    def __init__(self, COORD=None, ARC=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if COORD is None:
            self.COORD = []
        else:
            self.COORD = COORD
        self.COORD_nsprefix_ = None
        if ARC is None:
            self.ARC = []
        else:
            self.ARC = ARC
        self.ARC_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, POLYLINEType68)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POLYLINEType68.subclass:
            return POLYLINEType68.subclass(*args_, **kwargs_)
        else:
            return POLYLINEType68(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_COORD(self):
        return self.COORD

    def set_COORD(self, COORD):
        self.COORD = COORD

    def add_COORD(self, value):
        self.COORD.append(value)

    def insert_COORD_at(self, index, value):
        self.COORD.insert(index, value)

    def replace_COORD_at(self, index, value):
        self.COORD[index] = value

    def get_ARC(self):
        return self.ARC

    def set_ARC(self, ARC):
        self.ARC = ARC

    def add_ARC(self, value):
        self.ARC.append(value)

    def insert_ARC_at(self, index, value):
        self.ARC.insert(index, value)

    def replace_ARC_at(self, index, value):
        self.ARC[index] = value

    def _hasContent(self):
        if self.COORD or self.ARC:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="POLYLINEType68",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("POLYLINEType68")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "POLYLINEType68":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="POLYLINEType68")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="POLYLINEType68",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="POLYLINEType68",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="POLYLINEType68",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for COORD_ in self.COORD:
            namespaceprefix_ = self.COORD_nsprefix_ + ":" if (UseCapturedNS_ and self.COORD_nsprefix_) else ""
            COORD_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="COORD",
                pretty_print=pretty_print,
            )
        for ARC_ in self.ARC:
            namespaceprefix_ = self.ARC_nsprefix_ + ":" if (UseCapturedNS_ and self.ARC_nsprefix_) else ""
            ARC_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="ARC",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "COORD":
            obj_ = CoordValue.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.COORD.append(obj_)
            obj_.original_tagname_ = "COORD"
        elif nodeName_ == "ARC":
            obj_ = ArcPoint.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ARC.append(obj_)
            obj_.original_tagname_ = "ARC"


# end class POLYLINEType68


class POLYLINEType69(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "COORD": MemberSpec_("COORD", "CoordValue", 1, 0, {"name": "COORD", "type": "CoordValue"}, 32),
        "ARC": MemberSpec_("ARC", "ArcPoint", 1, 0, {"name": "ARC", "type": "ArcPoint"}, 32),
    }
    subclass = None
    superclass = None

    def __init__(self, COORD=None, ARC=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if COORD is None:
            self.COORD = []
        else:
            self.COORD = COORD
        self.COORD_nsprefix_ = None
        if ARC is None:
            self.ARC = []
        else:
            self.ARC = ARC
        self.ARC_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, POLYLINEType69)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POLYLINEType69.subclass:
            return POLYLINEType69.subclass(*args_, **kwargs_)
        else:
            return POLYLINEType69(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_COORD(self):
        return self.COORD

    def set_COORD(self, COORD):
        self.COORD = COORD

    def add_COORD(self, value):
        self.COORD.append(value)

    def insert_COORD_at(self, index, value):
        self.COORD.insert(index, value)

    def replace_COORD_at(self, index, value):
        self.COORD[index] = value

    def get_ARC(self):
        return self.ARC

    def set_ARC(self, ARC):
        self.ARC = ARC

    def add_ARC(self, value):
        self.ARC.append(value)

    def insert_ARC_at(self, index, value):
        self.ARC.insert(index, value)

    def replace_ARC_at(self, index, value):
        self.ARC[index] = value

    def _hasContent(self):
        if self.COORD or self.ARC:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="POLYLINEType69",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("POLYLINEType69")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "POLYLINEType69":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="POLYLINEType69")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="POLYLINEType69",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="POLYLINEType69",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="POLYLINEType69",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for COORD_ in self.COORD:
            namespaceprefix_ = self.COORD_nsprefix_ + ":" if (UseCapturedNS_ and self.COORD_nsprefix_) else ""
            COORD_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="COORD",
                pretty_print=pretty_print,
            )
        for ARC_ in self.ARC:
            namespaceprefix_ = self.ARC_nsprefix_ + ":" if (UseCapturedNS_ and self.ARC_nsprefix_) else ""
            ARC_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="ARC",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "COORD":
            obj_ = CoordValue.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.COORD.append(obj_)
            obj_.original_tagname_ = "COORD"
        elif nodeName_ == "ARC":
            obj_ = ArcPoint.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ARC.append(obj_)
            obj_.original_tagname_ = "ARC"


# end class POLYLINEType69


class SURFACEType70(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "BOUNDARY": MemberSpec_(
            "BOUNDARY",
            "BOUNDARYType71",
            1,
            0,
            {"maxOccurs": "unbounded", "name": "BOUNDARY", "type": "BOUNDARYType71"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, BOUNDARY=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if BOUNDARY is None:
            self.BOUNDARY = []
        else:
            self.BOUNDARY = BOUNDARY
        self.BOUNDARY_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, SURFACEType70)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SURFACEType70.subclass:
            return SURFACEType70.subclass(*args_, **kwargs_)
        else:
            return SURFACEType70(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_BOUNDARY(self):
        return self.BOUNDARY

    def set_BOUNDARY(self, BOUNDARY):
        self.BOUNDARY = BOUNDARY

    def add_BOUNDARY(self, value):
        self.BOUNDARY.append(value)

    def insert_BOUNDARY_at(self, index, value):
        self.BOUNDARY.insert(index, value)

    def replace_BOUNDARY_at(self, index, value):
        self.BOUNDARY[index] = value

    def _hasContent(self):
        if self.BOUNDARY:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="SURFACEType70",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("SURFACEType70")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "SURFACEType70":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="SURFACEType70")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="SURFACEType70",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="SURFACEType70",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="SURFACEType70",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for BOUNDARY_ in self.BOUNDARY:
            namespaceprefix_ = (
                self.BOUNDARY_nsprefix_ + ":" if (UseCapturedNS_ and self.BOUNDARY_nsprefix_) else ""
            )
            BOUNDARY_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="BOUNDARY",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "BOUNDARY":
            obj_ = BOUNDARYType71.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BOUNDARY.append(obj_)
            obj_.original_tagname_ = "BOUNDARY"


# end class SURFACEType70


class BOUNDARYType71(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "POLYLINE": MemberSpec_(
            "POLYLINE",
            "POLYLINEType72",
            1,
            0,
            {"maxOccurs": "unbounded", "name": "POLYLINE", "type": "POLYLINEType72"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, POLYLINE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if POLYLINE is None:
            self.POLYLINE = []
        else:
            self.POLYLINE = POLYLINE
        self.POLYLINE_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, BOUNDARYType71)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BOUNDARYType71.subclass:
            return BOUNDARYType71.subclass(*args_, **kwargs_)
        else:
            return BOUNDARYType71(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_POLYLINE(self):
        return self.POLYLINE

    def set_POLYLINE(self, POLYLINE):
        self.POLYLINE = POLYLINE

    def add_POLYLINE(self, value):
        self.POLYLINE.append(value)

    def insert_POLYLINE_at(self, index, value):
        self.POLYLINE.insert(index, value)

    def replace_POLYLINE_at(self, index, value):
        self.POLYLINE[index] = value

    def _hasContent(self):
        if self.POLYLINE:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="BOUNDARYType71",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("BOUNDARYType71")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "BOUNDARYType71":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="BOUNDARYType71")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="BOUNDARYType71",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="BOUNDARYType71",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="BOUNDARYType71",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for POLYLINE_ in self.POLYLINE:
            namespaceprefix_ = (
                self.POLYLINE_nsprefix_ + ":" if (UseCapturedNS_ and self.POLYLINE_nsprefix_) else ""
            )
            POLYLINE_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="POLYLINE",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "POLYLINE":
            obj_ = POLYLINEType72.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.POLYLINE.append(obj_)
            obj_.original_tagname_ = "POLYLINE"


# end class BOUNDARYType71


class POLYLINEType72(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "COORD": MemberSpec_("COORD", "CoordValue", 1, 0, {"name": "COORD", "type": "CoordValue"}, 33),
        "ARC": MemberSpec_("ARC", "ArcPoint", 1, 0, {"name": "ARC", "type": "ArcPoint"}, 33),
    }
    subclass = None
    superclass = None

    def __init__(self, COORD=None, ARC=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if COORD is None:
            self.COORD = []
        else:
            self.COORD = COORD
        self.COORD_nsprefix_ = None
        if ARC is None:
            self.ARC = []
        else:
            self.ARC = ARC
        self.ARC_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, POLYLINEType72)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POLYLINEType72.subclass:
            return POLYLINEType72.subclass(*args_, **kwargs_)
        else:
            return POLYLINEType72(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_COORD(self):
        return self.COORD

    def set_COORD(self, COORD):
        self.COORD = COORD

    def add_COORD(self, value):
        self.COORD.append(value)

    def insert_COORD_at(self, index, value):
        self.COORD.insert(index, value)

    def replace_COORD_at(self, index, value):
        self.COORD[index] = value

    def get_ARC(self):
        return self.ARC

    def set_ARC(self, ARC):
        self.ARC = ARC

    def add_ARC(self, value):
        self.ARC.append(value)

    def insert_ARC_at(self, index, value):
        self.ARC.insert(index, value)

    def replace_ARC_at(self, index, value):
        self.ARC[index] = value

    def _hasContent(self):
        if self.COORD or self.ARC:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="POLYLINEType72",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("POLYLINEType72")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "POLYLINEType72":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="POLYLINEType72")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="POLYLINEType72",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="POLYLINEType72",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="POLYLINEType72",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for COORD_ in self.COORD:
            namespaceprefix_ = self.COORD_nsprefix_ + ":" if (UseCapturedNS_ and self.COORD_nsprefix_) else ""
            COORD_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="COORD",
                pretty_print=pretty_print,
            )
        for ARC_ in self.ARC:
            namespaceprefix_ = self.ARC_nsprefix_ + ":" if (UseCapturedNS_ and self.ARC_nsprefix_) else ""
            ARC_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="ARC",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "COORD":
            obj_ = CoordValue.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.COORD.append(obj_)
            obj_.original_tagname_ = "COORD"
        elif nodeName_ == "ARC":
            obj_ = ArcPoint.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ARC.append(obj_)
            obj_.original_tagname_ = "ARC"


# end class POLYLINEType72


class SURFACEType73(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "BOUNDARY": MemberSpec_(
            "BOUNDARY",
            "BOUNDARYType74",
            1,
            0,
            {"maxOccurs": "unbounded", "name": "BOUNDARY", "type": "BOUNDARYType74"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, BOUNDARY=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if BOUNDARY is None:
            self.BOUNDARY = []
        else:
            self.BOUNDARY = BOUNDARY
        self.BOUNDARY_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, SURFACEType73)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SURFACEType73.subclass:
            return SURFACEType73.subclass(*args_, **kwargs_)
        else:
            return SURFACEType73(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_BOUNDARY(self):
        return self.BOUNDARY

    def set_BOUNDARY(self, BOUNDARY):
        self.BOUNDARY = BOUNDARY

    def add_BOUNDARY(self, value):
        self.BOUNDARY.append(value)

    def insert_BOUNDARY_at(self, index, value):
        self.BOUNDARY.insert(index, value)

    def replace_BOUNDARY_at(self, index, value):
        self.BOUNDARY[index] = value

    def _hasContent(self):
        if self.BOUNDARY:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="SURFACEType73",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("SURFACEType73")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "SURFACEType73":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="SURFACEType73")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="SURFACEType73",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="SURFACEType73",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="SURFACEType73",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for BOUNDARY_ in self.BOUNDARY:
            namespaceprefix_ = (
                self.BOUNDARY_nsprefix_ + ":" if (UseCapturedNS_ and self.BOUNDARY_nsprefix_) else ""
            )
            BOUNDARY_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="BOUNDARY",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "BOUNDARY":
            obj_ = BOUNDARYType74.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BOUNDARY.append(obj_)
            obj_.original_tagname_ = "BOUNDARY"


# end class SURFACEType73


class BOUNDARYType74(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "POLYLINE": MemberSpec_(
            "POLYLINE",
            "POLYLINEType75",
            1,
            0,
            {"maxOccurs": "unbounded", "name": "POLYLINE", "type": "POLYLINEType75"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, POLYLINE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if POLYLINE is None:
            self.POLYLINE = []
        else:
            self.POLYLINE = POLYLINE
        self.POLYLINE_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, BOUNDARYType74)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BOUNDARYType74.subclass:
            return BOUNDARYType74.subclass(*args_, **kwargs_)
        else:
            return BOUNDARYType74(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_POLYLINE(self):
        return self.POLYLINE

    def set_POLYLINE(self, POLYLINE):
        self.POLYLINE = POLYLINE

    def add_POLYLINE(self, value):
        self.POLYLINE.append(value)

    def insert_POLYLINE_at(self, index, value):
        self.POLYLINE.insert(index, value)

    def replace_POLYLINE_at(self, index, value):
        self.POLYLINE[index] = value

    def _hasContent(self):
        if self.POLYLINE:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="BOUNDARYType74",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("BOUNDARYType74")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "BOUNDARYType74":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="BOUNDARYType74")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="BOUNDARYType74",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="BOUNDARYType74",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="BOUNDARYType74",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for POLYLINE_ in self.POLYLINE:
            namespaceprefix_ = (
                self.POLYLINE_nsprefix_ + ":" if (UseCapturedNS_ and self.POLYLINE_nsprefix_) else ""
            )
            POLYLINE_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="POLYLINE",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "POLYLINE":
            obj_ = POLYLINEType75.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.POLYLINE.append(obj_)
            obj_.original_tagname_ = "POLYLINE"


# end class BOUNDARYType74


class POLYLINEType75(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "COORD": MemberSpec_("COORD", "CoordValue", 1, 0, {"name": "COORD", "type": "CoordValue"}, 34),
        "ARC": MemberSpec_("ARC", "ArcPoint", 1, 0, {"name": "ARC", "type": "ArcPoint"}, 34),
    }
    subclass = None
    superclass = None

    def __init__(self, COORD=None, ARC=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if COORD is None:
            self.COORD = []
        else:
            self.COORD = COORD
        self.COORD_nsprefix_ = None
        if ARC is None:
            self.ARC = []
        else:
            self.ARC = ARC
        self.ARC_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, POLYLINEType75)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POLYLINEType75.subclass:
            return POLYLINEType75.subclass(*args_, **kwargs_)
        else:
            return POLYLINEType75(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_COORD(self):
        return self.COORD

    def set_COORD(self, COORD):
        self.COORD = COORD

    def add_COORD(self, value):
        self.COORD.append(value)

    def insert_COORD_at(self, index, value):
        self.COORD.insert(index, value)

    def replace_COORD_at(self, index, value):
        self.COORD[index] = value

    def get_ARC(self):
        return self.ARC

    def set_ARC(self, ARC):
        self.ARC = ARC

    def add_ARC(self, value):
        self.ARC.append(value)

    def insert_ARC_at(self, index, value):
        self.ARC.insert(index, value)

    def replace_ARC_at(self, index, value):
        self.ARC[index] = value

    def _hasContent(self):
        if self.COORD or self.ARC:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="POLYLINEType75",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("POLYLINEType75")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "POLYLINEType75":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="POLYLINEType75")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="POLYLINEType75",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="POLYLINEType75",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="POLYLINEType75",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for COORD_ in self.COORD:
            namespaceprefix_ = self.COORD_nsprefix_ + ":" if (UseCapturedNS_ and self.COORD_nsprefix_) else ""
            COORD_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="COORD",
                pretty_print=pretty_print,
            )
        for ARC_ in self.ARC:
            namespaceprefix_ = self.ARC_nsprefix_ + ":" if (UseCapturedNS_ and self.ARC_nsprefix_) else ""
            ARC_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="ARC",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "COORD":
            obj_ = CoordValue.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.COORD.append(obj_)
            obj_.original_tagname_ = "COORD"
        elif nodeName_ == "ARC":
            obj_ = ArcPoint.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ARC.append(obj_)
            obj_.original_tagname_ = "ARC"


# end class POLYLINEType75


class LinesType76(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "GeometryCHLV95_V1_LineStructure": MemberSpec_(
            "GeometryCHLV95_V1_LineStructure",
            "GeometryCHLV95_V1.LineStructure",
            1,
            0,
            {
                "maxOccurs": "unbounded",
                "name": "GeometryCHLV95_V1.LineStructure",
                "type": "GeometryCHLV95_V1.LineStructure",
            },
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, GeometryCHLV95_V1_LineStructure=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if GeometryCHLV95_V1_LineStructure is None:
            self.GeometryCHLV95_V1_LineStructure = []
        else:
            self.GeometryCHLV95_V1_LineStructure = GeometryCHLV95_V1_LineStructure
        self.GeometryCHLV95_V1_LineStructure_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, LinesType76)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LinesType76.subclass:
            return LinesType76.subclass(*args_, **kwargs_)
        else:
            return LinesType76(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_GeometryCHLV95_V1_LineStructure(self):
        return self.GeometryCHLV95_V1_LineStructure

    def set_GeometryCHLV95_V1_LineStructure(self, GeometryCHLV95_V1_LineStructure):
        self.GeometryCHLV95_V1_LineStructure = GeometryCHLV95_V1_LineStructure

    def add_GeometryCHLV95_V1_LineStructure(self, value):
        self.GeometryCHLV95_V1_LineStructure.append(value)

    def insert_GeometryCHLV95_V1_LineStructure_at(self, index, value):
        self.GeometryCHLV95_V1_LineStructure.insert(index, value)

    def replace_GeometryCHLV95_V1_LineStructure_at(self, index, value):
        self.GeometryCHLV95_V1_LineStructure[index] = value

    def _hasContent(self):
        if self.GeometryCHLV95_V1_LineStructure:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="LinesType76",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("LinesType76")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "LinesType76":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="LinesType76")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="LinesType76",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="LinesType76",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="LinesType76",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for GeometryCHLV95_V1_LineStructure_ in self.GeometryCHLV95_V1_LineStructure:
            namespaceprefix_ = (
                self.GeometryCHLV95_V1_LineStructure_nsprefix_ + ":"
                if (UseCapturedNS_ and self.GeometryCHLV95_V1_LineStructure_nsprefix_)
                else ""
            )
            GeometryCHLV95_V1_LineStructure_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="GeometryCHLV95_V1.LineStructure",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "GeometryCHLV95_V1.LineStructure":
            obj_ = GeometryCHLV95_V1_LineStructure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.GeometryCHLV95_V1_LineStructure.append(obj_)
            obj_.original_tagname_ = "GeometryCHLV95_V1.LineStructure"


# end class LinesType76


class LinesType77(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "GeometryCHLV95_V1_DirectedLineStructure": MemberSpec_(
            "GeometryCHLV95_V1_DirectedLineStructure",
            "GeometryCHLV95_V1.DirectedLineStructure",
            1,
            0,
            {
                "maxOccurs": "unbounded",
                "name": "GeometryCHLV95_V1.DirectedLineStructure",
                "type": "GeometryCHLV95_V1.DirectedLineStructure",
            },
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, GeometryCHLV95_V1_DirectedLineStructure=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if GeometryCHLV95_V1_DirectedLineStructure is None:
            self.GeometryCHLV95_V1_DirectedLineStructure = []
        else:
            self.GeometryCHLV95_V1_DirectedLineStructure = GeometryCHLV95_V1_DirectedLineStructure
        self.GeometryCHLV95_V1_DirectedLineStructure_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, LinesType77)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LinesType77.subclass:
            return LinesType77.subclass(*args_, **kwargs_)
        else:
            return LinesType77(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_GeometryCHLV95_V1_DirectedLineStructure(self):
        return self.GeometryCHLV95_V1_DirectedLineStructure

    def set_GeometryCHLV95_V1_DirectedLineStructure(self, GeometryCHLV95_V1_DirectedLineStructure):
        self.GeometryCHLV95_V1_DirectedLineStructure = GeometryCHLV95_V1_DirectedLineStructure

    def add_GeometryCHLV95_V1_DirectedLineStructure(self, value):
        self.GeometryCHLV95_V1_DirectedLineStructure.append(value)

    def insert_GeometryCHLV95_V1_DirectedLineStructure_at(self, index, value):
        self.GeometryCHLV95_V1_DirectedLineStructure.insert(index, value)

    def replace_GeometryCHLV95_V1_DirectedLineStructure_at(self, index, value):
        self.GeometryCHLV95_V1_DirectedLineStructure[index] = value

    def _hasContent(self):
        if self.GeometryCHLV95_V1_DirectedLineStructure:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="LinesType77",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("LinesType77")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "LinesType77":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="LinesType77")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="LinesType77",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="LinesType77",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="LinesType77",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for GeometryCHLV95_V1_DirectedLineStructure_ in self.GeometryCHLV95_V1_DirectedLineStructure:
            namespaceprefix_ = (
                self.GeometryCHLV95_V1_DirectedLineStructure_nsprefix_ + ":"
                if (UseCapturedNS_ and self.GeometryCHLV95_V1_DirectedLineStructure_nsprefix_)
                else ""
            )
            GeometryCHLV95_V1_DirectedLineStructure_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="GeometryCHLV95_V1.DirectedLineStructure",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "GeometryCHLV95_V1.DirectedLineStructure":
            obj_ = GeometryCHLV95_V1_DirectedLineStructure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.GeometryCHLV95_V1_DirectedLineStructure.append(obj_)
            obj_.original_tagname_ = "GeometryCHLV95_V1.DirectedLineStructure"


# end class LinesType77


class SurfacesType78(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "GeometryCHLV95_V1_SurfaceStructure": MemberSpec_(
            "GeometryCHLV95_V1_SurfaceStructure",
            "GeometryCHLV95_V1.SurfaceStructure",
            1,
            0,
            {
                "maxOccurs": "unbounded",
                "name": "GeometryCHLV95_V1.SurfaceStructure",
                "type": "GeometryCHLV95_V1.SurfaceStructure",
            },
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, GeometryCHLV95_V1_SurfaceStructure=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if GeometryCHLV95_V1_SurfaceStructure is None:
            self.GeometryCHLV95_V1_SurfaceStructure = []
        else:
            self.GeometryCHLV95_V1_SurfaceStructure = GeometryCHLV95_V1_SurfaceStructure
        self.GeometryCHLV95_V1_SurfaceStructure_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, SurfacesType78)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SurfacesType78.subclass:
            return SurfacesType78.subclass(*args_, **kwargs_)
        else:
            return SurfacesType78(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_GeometryCHLV95_V1_SurfaceStructure(self):
        return self.GeometryCHLV95_V1_SurfaceStructure

    def set_GeometryCHLV95_V1_SurfaceStructure(self, GeometryCHLV95_V1_SurfaceStructure):
        self.GeometryCHLV95_V1_SurfaceStructure = GeometryCHLV95_V1_SurfaceStructure

    def add_GeometryCHLV95_V1_SurfaceStructure(self, value):
        self.GeometryCHLV95_V1_SurfaceStructure.append(value)

    def insert_GeometryCHLV95_V1_SurfaceStructure_at(self, index, value):
        self.GeometryCHLV95_V1_SurfaceStructure.insert(index, value)

    def replace_GeometryCHLV95_V1_SurfaceStructure_at(self, index, value):
        self.GeometryCHLV95_V1_SurfaceStructure[index] = value

    def _hasContent(self):
        if self.GeometryCHLV95_V1_SurfaceStructure:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="SurfacesType78",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("SurfacesType78")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "SurfacesType78":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="SurfacesType78")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="SurfacesType78",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="SurfacesType78",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="SurfacesType78",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for GeometryCHLV95_V1_SurfaceStructure_ in self.GeometryCHLV95_V1_SurfaceStructure:
            namespaceprefix_ = (
                self.GeometryCHLV95_V1_SurfaceStructure_nsprefix_ + ":"
                if (UseCapturedNS_ and self.GeometryCHLV95_V1_SurfaceStructure_nsprefix_)
                else ""
            )
            GeometryCHLV95_V1_SurfaceStructure_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="GeometryCHLV95_V1.SurfaceStructure",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "GeometryCHLV95_V1.SurfaceStructure":
            obj_ = GeometryCHLV95_V1_SurfaceStructure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.GeometryCHLV95_V1_SurfaceStructure.append(obj_)
            obj_.original_tagname_ = "GeometryCHLV95_V1.SurfaceStructure"


# end class SurfacesType78


class LocalisedTextType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "LocalisationCH_V1_LocalisedText": MemberSpec_(
            "LocalisationCH_V1_LocalisedText",
            "LocalisationCH_V1.LocalisedText",
            1,
            0,
            {
                "maxOccurs": "unbounded",
                "name": "LocalisationCH_V1.LocalisedText",
                "type": "LocalisationCH_V1.LocalisedText",
            },
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, LocalisationCH_V1_LocalisedText=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if LocalisationCH_V1_LocalisedText is None:
            self.LocalisationCH_V1_LocalisedText = []
        else:
            self.LocalisationCH_V1_LocalisedText = LocalisationCH_V1_LocalisedText
        self.LocalisationCH_V1_LocalisedText_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, LocalisedTextType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LocalisedTextType.subclass:
            return LocalisedTextType.subclass(*args_, **kwargs_)
        else:
            return LocalisedTextType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_LocalisationCH_V1_LocalisedText(self):
        return self.LocalisationCH_V1_LocalisedText

    def set_LocalisationCH_V1_LocalisedText(self, LocalisationCH_V1_LocalisedText):
        self.LocalisationCH_V1_LocalisedText = LocalisationCH_V1_LocalisedText

    def add_LocalisationCH_V1_LocalisedText(self, value):
        self.LocalisationCH_V1_LocalisedText.append(value)

    def insert_LocalisationCH_V1_LocalisedText_at(self, index, value):
        self.LocalisationCH_V1_LocalisedText.insert(index, value)

    def replace_LocalisationCH_V1_LocalisedText_at(self, index, value):
        self.LocalisationCH_V1_LocalisedText[index] = value

    def _hasContent(self):
        if self.LocalisationCH_V1_LocalisedText:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="LocalisedTextType",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("LocalisedTextType")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "LocalisedTextType":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="LocalisedTextType",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="LocalisedTextType",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="LocalisedTextType",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="LocalisedTextType",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for LocalisationCH_V1_LocalisedText_ in self.LocalisationCH_V1_LocalisedText:
            namespaceprefix_ = (
                self.LocalisationCH_V1_LocalisedText_nsprefix_ + ":"
                if (UseCapturedNS_ and self.LocalisationCH_V1_LocalisedText_nsprefix_)
                else ""
            )
            LocalisationCH_V1_LocalisedText_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="LocalisationCH_V1.LocalisedText",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "LocalisationCH_V1.LocalisedText":
            obj_ = LocalisationCH_V1_LocalisedText.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LocalisationCH_V1_LocalisedText.append(obj_)
            obj_.original_tagname_ = "LocalisationCH_V1.LocalisedText"


# end class LocalisedTextType


class LocalisedTextType81(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "LocalisationCH_V1_LocalisedMText": MemberSpec_(
            "LocalisationCH_V1_LocalisedMText",
            "LocalisationCH_V1.LocalisedMText",
            1,
            0,
            {
                "maxOccurs": "unbounded",
                "name": "LocalisationCH_V1.LocalisedMText",
                "type": "LocalisationCH_V1.LocalisedMText",
            },
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, LocalisationCH_V1_LocalisedMText=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if LocalisationCH_V1_LocalisedMText is None:
            self.LocalisationCH_V1_LocalisedMText = []
        else:
            self.LocalisationCH_V1_LocalisedMText = LocalisationCH_V1_LocalisedMText
        self.LocalisationCH_V1_LocalisedMText_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, LocalisedTextType81)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LocalisedTextType81.subclass:
            return LocalisedTextType81.subclass(*args_, **kwargs_)
        else:
            return LocalisedTextType81(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_LocalisationCH_V1_LocalisedMText(self):
        return self.LocalisationCH_V1_LocalisedMText

    def set_LocalisationCH_V1_LocalisedMText(self, LocalisationCH_V1_LocalisedMText):
        self.LocalisationCH_V1_LocalisedMText = LocalisationCH_V1_LocalisedMText

    def add_LocalisationCH_V1_LocalisedMText(self, value):
        self.LocalisationCH_V1_LocalisedMText.append(value)

    def insert_LocalisationCH_V1_LocalisedMText_at(self, index, value):
        self.LocalisationCH_V1_LocalisedMText.insert(index, value)

    def replace_LocalisationCH_V1_LocalisedMText_at(self, index, value):
        self.LocalisationCH_V1_LocalisedMText[index] = value

    def _hasContent(self):
        if self.LocalisationCH_V1_LocalisedMText:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="LocalisedTextType81",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("LocalisedTextType81")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "LocalisedTextType81":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="LocalisedTextType81",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="LocalisedTextType81",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="LocalisedTextType81",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="LocalisedTextType81",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for LocalisationCH_V1_LocalisedMText_ in self.LocalisationCH_V1_LocalisedMText:
            namespaceprefix_ = (
                self.LocalisationCH_V1_LocalisedMText_nsprefix_ + ":"
                if (UseCapturedNS_ and self.LocalisationCH_V1_LocalisedMText_nsprefix_)
                else ""
            )
            LocalisationCH_V1_LocalisedMText_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="LocalisationCH_V1.LocalisedMText",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "LocalisationCH_V1.LocalisedMText":
            obj_ = LocalisationCH_V1_LocalisedMText.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LocalisationCH_V1_LocalisedMText.append(obj_)
            obj_.original_tagname_ = "LocalisationCH_V1.LocalisedMText"


# end class LocalisedTextType81


class LocalisedTextType84(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "LocalisationCH_V1_LocalisedText": MemberSpec_(
            "LocalisationCH_V1_LocalisedText",
            "LocalisationCH_V1.LocalisedText",
            1,
            0,
            {
                "name": "LocalisationCH_V1.LocalisedText",
                "type": "LocalisationCH_V1.LocalisedText",
            },
            35,
        ),
        "Localisation_V1_LocalisedText": MemberSpec_(
            "Localisation_V1_LocalisedText",
            "Localisation_V1.LocalisedText",
            1,
            0,
            {
                "name": "Localisation_V1.LocalisedText",
                "type": "Localisation_V1.LocalisedText",
            },
            35,
        ),
    }
    subclass = None
    superclass = None

    def __init__(
        self,
        LocalisationCH_V1_LocalisedText=None,
        Localisation_V1_LocalisedText=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if LocalisationCH_V1_LocalisedText is None:
            self.LocalisationCH_V1_LocalisedText = []
        else:
            self.LocalisationCH_V1_LocalisedText = LocalisationCH_V1_LocalisedText
        self.LocalisationCH_V1_LocalisedText_nsprefix_ = None
        if Localisation_V1_LocalisedText is None:
            self.Localisation_V1_LocalisedText = []
        else:
            self.Localisation_V1_LocalisedText = Localisation_V1_LocalisedText
        self.Localisation_V1_LocalisedText_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, LocalisedTextType84)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LocalisedTextType84.subclass:
            return LocalisedTextType84.subclass(*args_, **kwargs_)
        else:
            return LocalisedTextType84(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_LocalisationCH_V1_LocalisedText(self):
        return self.LocalisationCH_V1_LocalisedText

    def set_LocalisationCH_V1_LocalisedText(self, LocalisationCH_V1_LocalisedText):
        self.LocalisationCH_V1_LocalisedText = LocalisationCH_V1_LocalisedText

    def add_LocalisationCH_V1_LocalisedText(self, value):
        self.LocalisationCH_V1_LocalisedText.append(value)

    def insert_LocalisationCH_V1_LocalisedText_at(self, index, value):
        self.LocalisationCH_V1_LocalisedText.insert(index, value)

    def replace_LocalisationCH_V1_LocalisedText_at(self, index, value):
        self.LocalisationCH_V1_LocalisedText[index] = value

    def get_Localisation_V1_LocalisedText(self):
        return self.Localisation_V1_LocalisedText

    def set_Localisation_V1_LocalisedText(self, Localisation_V1_LocalisedText):
        self.Localisation_V1_LocalisedText = Localisation_V1_LocalisedText

    def add_Localisation_V1_LocalisedText(self, value):
        self.Localisation_V1_LocalisedText.append(value)

    def insert_Localisation_V1_LocalisedText_at(self, index, value):
        self.Localisation_V1_LocalisedText.insert(index, value)

    def replace_Localisation_V1_LocalisedText_at(self, index, value):
        self.Localisation_V1_LocalisedText[index] = value

    def _hasContent(self):
        if self.LocalisationCH_V1_LocalisedText or self.Localisation_V1_LocalisedText:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="LocalisedTextType84",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("LocalisedTextType84")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "LocalisedTextType84":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="LocalisedTextType84",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="LocalisedTextType84",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="LocalisedTextType84",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="LocalisedTextType84",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for LocalisationCH_V1_LocalisedText_ in self.LocalisationCH_V1_LocalisedText:
            namespaceprefix_ = (
                self.LocalisationCH_V1_LocalisedText_nsprefix_ + ":"
                if (UseCapturedNS_ and self.LocalisationCH_V1_LocalisedText_nsprefix_)
                else ""
            )
            LocalisationCH_V1_LocalisedText_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="LocalisationCH_V1.LocalisedText",
                pretty_print=pretty_print,
            )
        for Localisation_V1_LocalisedText_ in self.Localisation_V1_LocalisedText:
            namespaceprefix_ = (
                self.Localisation_V1_LocalisedText_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Localisation_V1_LocalisedText_nsprefix_)
                else ""
            )
            Localisation_V1_LocalisedText_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Localisation_V1.LocalisedText",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "LocalisationCH_V1.LocalisedText":
            obj_ = LocalisationCH_V1_LocalisedText.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LocalisationCH_V1_LocalisedText.append(obj_)
            obj_.original_tagname_ = "LocalisationCH_V1.LocalisedText"
        elif nodeName_ == "Localisation_V1.LocalisedText":
            obj_ = Localisation_V1_LocalisedText.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Localisation_V1_LocalisedText.append(obj_)
            obj_.original_tagname_ = "Localisation_V1.LocalisedText"


# end class LocalisedTextType84


class LocalisedTextType85(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "LocalisationCH_V1_LocalisedMText": MemberSpec_(
            "LocalisationCH_V1_LocalisedMText",
            "LocalisationCH_V1.LocalisedMText",
            1,
            0,
            {
                "name": "LocalisationCH_V1.LocalisedMText",
                "type": "LocalisationCH_V1.LocalisedMText",
            },
            36,
        ),
        "Localisation_V1_LocalisedMText": MemberSpec_(
            "Localisation_V1_LocalisedMText",
            "Localisation_V1.LocalisedMText",
            1,
            0,
            {
                "name": "Localisation_V1.LocalisedMText",
                "type": "Localisation_V1.LocalisedMText",
            },
            36,
        ),
    }
    subclass = None
    superclass = None

    def __init__(
        self,
        LocalisationCH_V1_LocalisedMText=None,
        Localisation_V1_LocalisedMText=None,
        gds_collector_=None,
        **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if LocalisationCH_V1_LocalisedMText is None:
            self.LocalisationCH_V1_LocalisedMText = []
        else:
            self.LocalisationCH_V1_LocalisedMText = LocalisationCH_V1_LocalisedMText
        self.LocalisationCH_V1_LocalisedMText_nsprefix_ = None
        if Localisation_V1_LocalisedMText is None:
            self.Localisation_V1_LocalisedMText = []
        else:
            self.Localisation_V1_LocalisedMText = Localisation_V1_LocalisedMText
        self.Localisation_V1_LocalisedMText_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, LocalisedTextType85)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LocalisedTextType85.subclass:
            return LocalisedTextType85.subclass(*args_, **kwargs_)
        else:
            return LocalisedTextType85(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_LocalisationCH_V1_LocalisedMText(self):
        return self.LocalisationCH_V1_LocalisedMText

    def set_LocalisationCH_V1_LocalisedMText(self, LocalisationCH_V1_LocalisedMText):
        self.LocalisationCH_V1_LocalisedMText = LocalisationCH_V1_LocalisedMText

    def add_LocalisationCH_V1_LocalisedMText(self, value):
        self.LocalisationCH_V1_LocalisedMText.append(value)

    def insert_LocalisationCH_V1_LocalisedMText_at(self, index, value):
        self.LocalisationCH_V1_LocalisedMText.insert(index, value)

    def replace_LocalisationCH_V1_LocalisedMText_at(self, index, value):
        self.LocalisationCH_V1_LocalisedMText[index] = value

    def get_Localisation_V1_LocalisedMText(self):
        return self.Localisation_V1_LocalisedMText

    def set_Localisation_V1_LocalisedMText(self, Localisation_V1_LocalisedMText):
        self.Localisation_V1_LocalisedMText = Localisation_V1_LocalisedMText

    def add_Localisation_V1_LocalisedMText(self, value):
        self.Localisation_V1_LocalisedMText.append(value)

    def insert_Localisation_V1_LocalisedMText_at(self, index, value):
        self.Localisation_V1_LocalisedMText.insert(index, value)

    def replace_Localisation_V1_LocalisedMText_at(self, index, value):
        self.Localisation_V1_LocalisedMText[index] = value

    def _hasContent(self):
        if self.LocalisationCH_V1_LocalisedMText or self.Localisation_V1_LocalisedMText:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="LocalisedTextType85",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("LocalisedTextType85")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "LocalisedTextType85":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="LocalisedTextType85",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="LocalisedTextType85",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="LocalisedTextType85",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="LocalisedTextType85",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for LocalisationCH_V1_LocalisedMText_ in self.LocalisationCH_V1_LocalisedMText:
            namespaceprefix_ = (
                self.LocalisationCH_V1_LocalisedMText_nsprefix_ + ":"
                if (UseCapturedNS_ and self.LocalisationCH_V1_LocalisedMText_nsprefix_)
                else ""
            )
            LocalisationCH_V1_LocalisedMText_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="LocalisationCH_V1.LocalisedMText",
                pretty_print=pretty_print,
            )
        for Localisation_V1_LocalisedMText_ in self.Localisation_V1_LocalisedMText:
            namespaceprefix_ = (
                self.Localisation_V1_LocalisedMText_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Localisation_V1_LocalisedMText_nsprefix_)
                else ""
            )
            Localisation_V1_LocalisedMText_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Localisation_V1.LocalisedMText",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "LocalisationCH_V1.LocalisedMText":
            obj_ = LocalisationCH_V1_LocalisedMText.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LocalisationCH_V1_LocalisedMText.append(obj_)
            obj_.original_tagname_ = "LocalisationCH_V1.LocalisedMText"
        elif nodeName_ == "Localisation_V1.LocalisedMText":
            obj_ = Localisation_V1_LocalisedMText.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Localisation_V1_LocalisedMText.append(obj_)
            obj_.original_tagname_ = "Localisation_V1.LocalisedMText"


# end class LocalisedTextType85


class BlobType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "BINBLBOX": MemberSpec_(
            "BINBLBOX",
            "BINBLBOXType",
            0,
            0,
            {"name": "BINBLBOX", "type": "BINBLBOXType"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, BINBLBOX=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.BINBLBOX = BINBLBOX
        self.BINBLBOX_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, BlobType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BlobType.subclass:
            return BlobType.subclass(*args_, **kwargs_)
        else:
            return BlobType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_BINBLBOX(self):
        return self.BINBLBOX

    def set_BINBLBOX(self, BINBLBOX):
        self.BINBLBOX = BINBLBOX

    def _hasContent(self):
        if self.BINBLBOX is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="BlobType",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("BlobType")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "BlobType":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="BlobType")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="BlobType",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_="", name_="BlobType"):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="BlobType",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.BINBLBOX is not None:
            namespaceprefix_ = (
                self.BINBLBOX_nsprefix_ + ":" if (UseCapturedNS_ and self.BINBLBOX_nsprefix_) else ""
            )
            self.BINBLBOX.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="BINBLBOX",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "BINBLBOX":
            obj_ = BINBLBOXType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BINBLBOX = obj_
            obj_.original_tagname_ = "BINBLBOX"


# end class BlobType


class BINBLBOXType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "valueOf_": MemberSpec_("valueOf_", "xsd:base64Binary", 0),
    }
    subclass = None
    superclass = None

    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, BINBLBOXType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BINBLBOXType.subclass:
            return BINBLBOXType.subclass(*args_, **kwargs_)
        else:
            return BINBLBOXType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def _hasContent(self):
        if 1 if type(self.valueOf_) in [int, float] else self.valueOf_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="BINBLBOXType",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("BINBLBOXType")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "BINBLBOXType":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="BINBLBOXType")
        outfile.write(">")
        self._exportChildren(
            outfile,
            level + 1,
            namespaceprefix_,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="BINBLBOXType",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="BINBLBOXType",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class BINBLBOXType


class LocalisedBlobType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "OeREBKRM_V2_0_LocalisedBlob": MemberSpec_(
            "OeREBKRM_V2_0_LocalisedBlob",
            "OeREBKRM_V2_0.LocalisedBlob",
            1,
            0,
            {
                "maxOccurs": "unbounded",
                "name": "OeREBKRM_V2_0.LocalisedBlob",
                "type": "OeREBKRM_V2_0.LocalisedBlob",
            },
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, OeREBKRM_V2_0_LocalisedBlob=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if OeREBKRM_V2_0_LocalisedBlob is None:
            self.OeREBKRM_V2_0_LocalisedBlob = []
        else:
            self.OeREBKRM_V2_0_LocalisedBlob = OeREBKRM_V2_0_LocalisedBlob
        self.OeREBKRM_V2_0_LocalisedBlob_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, LocalisedBlobType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LocalisedBlobType.subclass:
            return LocalisedBlobType.subclass(*args_, **kwargs_)
        else:
            return LocalisedBlobType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_OeREBKRM_V2_0_LocalisedBlob(self):
        return self.OeREBKRM_V2_0_LocalisedBlob

    def set_OeREBKRM_V2_0_LocalisedBlob(self, OeREBKRM_V2_0_LocalisedBlob):
        self.OeREBKRM_V2_0_LocalisedBlob = OeREBKRM_V2_0_LocalisedBlob

    def add_OeREBKRM_V2_0_LocalisedBlob(self, value):
        self.OeREBKRM_V2_0_LocalisedBlob.append(value)

    def insert_OeREBKRM_V2_0_LocalisedBlob_at(self, index, value):
        self.OeREBKRM_V2_0_LocalisedBlob.insert(index, value)

    def replace_OeREBKRM_V2_0_LocalisedBlob_at(self, index, value):
        self.OeREBKRM_V2_0_LocalisedBlob[index] = value

    def _hasContent(self):
        if self.OeREBKRM_V2_0_LocalisedBlob:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="LocalisedBlobType",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("LocalisedBlobType")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "LocalisedBlobType":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="LocalisedBlobType",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="LocalisedBlobType",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="LocalisedBlobType",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="LocalisedBlobType",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for OeREBKRM_V2_0_LocalisedBlob_ in self.OeREBKRM_V2_0_LocalisedBlob:
            namespaceprefix_ = (
                self.OeREBKRM_V2_0_LocalisedBlob_nsprefix_ + ":"
                if (UseCapturedNS_ and self.OeREBKRM_V2_0_LocalisedBlob_nsprefix_)
                else ""
            )
            OeREBKRM_V2_0_LocalisedBlob_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="OeREBKRM_V2_0.LocalisedBlob",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "OeREBKRM_V2_0.LocalisedBlob":
            obj_ = OeREBKRM_V2_0_LocalisedBlob.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OeREBKRM_V2_0_LocalisedBlob.append(obj_)
            obj_.original_tagname_ = "OeREBKRM_V2_0.LocalisedBlob"


# end class LocalisedBlobType


class LocalisedTextType86(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "OeREBKRM_V2_0_LocalisedUri": MemberSpec_(
            "OeREBKRM_V2_0_LocalisedUri",
            "OeREBKRM_V2_0.LocalisedUri",
            1,
            0,
            {
                "maxOccurs": "unbounded",
                "name": "OeREBKRM_V2_0.LocalisedUri",
                "type": "OeREBKRM_V2_0.LocalisedUri",
            },
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, OeREBKRM_V2_0_LocalisedUri=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if OeREBKRM_V2_0_LocalisedUri is None:
            self.OeREBKRM_V2_0_LocalisedUri = []
        else:
            self.OeREBKRM_V2_0_LocalisedUri = OeREBKRM_V2_0_LocalisedUri
        self.OeREBKRM_V2_0_LocalisedUri_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, LocalisedTextType86)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LocalisedTextType86.subclass:
            return LocalisedTextType86.subclass(*args_, **kwargs_)
        else:
            return LocalisedTextType86(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_OeREBKRM_V2_0_LocalisedUri(self):
        return self.OeREBKRM_V2_0_LocalisedUri

    def set_OeREBKRM_V2_0_LocalisedUri(self, OeREBKRM_V2_0_LocalisedUri):
        self.OeREBKRM_V2_0_LocalisedUri = OeREBKRM_V2_0_LocalisedUri

    def add_OeREBKRM_V2_0_LocalisedUri(self, value):
        self.OeREBKRM_V2_0_LocalisedUri.append(value)

    def insert_OeREBKRM_V2_0_LocalisedUri_at(self, index, value):
        self.OeREBKRM_V2_0_LocalisedUri.insert(index, value)

    def replace_OeREBKRM_V2_0_LocalisedUri_at(self, index, value):
        self.OeREBKRM_V2_0_LocalisedUri[index] = value

    def _hasContent(self):
        if self.OeREBKRM_V2_0_LocalisedUri:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="LocalisedTextType86",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("LocalisedTextType86")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "LocalisedTextType86":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="LocalisedTextType86",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="LocalisedTextType86",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="LocalisedTextType86",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="LocalisedTextType86",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for OeREBKRM_V2_0_LocalisedUri_ in self.OeREBKRM_V2_0_LocalisedUri:
            namespaceprefix_ = (
                self.OeREBKRM_V2_0_LocalisedUri_nsprefix_ + ":"
                if (UseCapturedNS_ and self.OeREBKRM_V2_0_LocalisedUri_nsprefix_)
                else ""
            )
            OeREBKRM_V2_0_LocalisedUri_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="OeREBKRM_V2_0.LocalisedUri",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "OeREBKRM_V2_0.LocalisedUri":
            obj_ = OeREBKRM_V2_0_LocalisedUri.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OeREBKRM_V2_0_LocalisedUri.append(obj_)
            obj_.original_tagname_ = "OeREBKRM_V2_0.LocalisedUri"


# end class LocalisedTextType86


class NameType87(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "LocalisationCH_V1_MultilingualText": MemberSpec_(
            "LocalisationCH_V1_MultilingualText",
            "LocalisationCH_V1.MultilingualText",
            0,
            0,
            {
                "name": "LocalisationCH_V1.MultilingualText",
                "type": "LocalisationCH_V1.MultilingualText",
            },
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, LocalisationCH_V1_MultilingualText=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if LocalisationCH_V1_MultilingualText is None:
            self.LocalisationCH_V1_MultilingualText = globals()["LocalisationCH_V1_MultilingualText"]()
        else:
            self.LocalisationCH_V1_MultilingualText = LocalisationCH_V1_MultilingualText
        self.LocalisationCH_V1_MultilingualText_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, NameType87)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NameType87.subclass:
            return NameType87.subclass(*args_, **kwargs_)
        else:
            return NameType87(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_LocalisationCH_V1_MultilingualText(self):
        return self.LocalisationCH_V1_MultilingualText

    def set_LocalisationCH_V1_MultilingualText(self, LocalisationCH_V1_MultilingualText):
        self.LocalisationCH_V1_MultilingualText = LocalisationCH_V1_MultilingualText

    def _hasContent(self):
        if self.LocalisationCH_V1_MultilingualText is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="NameType87",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("NameType87")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "NameType87":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="NameType87")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="NameType87",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_="", name_="NameType87"):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="NameType87",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.LocalisationCH_V1_MultilingualText is not None:
            namespaceprefix_ = (
                self.LocalisationCH_V1_MultilingualText_nsprefix_ + ":"
                if (UseCapturedNS_ and self.LocalisationCH_V1_MultilingualText_nsprefix_)
                else ""
            )
            self.LocalisationCH_V1_MultilingualText.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="LocalisationCH_V1.MultilingualText",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "LocalisationCH_V1.MultilingualText":
            obj_ = LocalisationCH_V1_MultilingualText.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LocalisationCH_V1_MultilingualText = obj_
            obj_.original_tagname_ = "LocalisationCH_V1.MultilingualText"


# end class NameType87


class AmtImWebType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "OeREBKRM_V2_0_MultilingualUri": MemberSpec_(
            "OeREBKRM_V2_0_MultilingualUri",
            "OeREBKRM_V2_0.MultilingualUri",
            0,
            0,
            {
                "name": "OeREBKRM_V2_0.MultilingualUri",
                "type": "OeREBKRM_V2_0.MultilingualUri",
            },
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, OeREBKRM_V2_0_MultilingualUri=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if OeREBKRM_V2_0_MultilingualUri is None:
            self.OeREBKRM_V2_0_MultilingualUri = globals()["OeREBKRM_V2_0_MultilingualUri"]()
        else:
            self.OeREBKRM_V2_0_MultilingualUri = OeREBKRM_V2_0_MultilingualUri
        self.OeREBKRM_V2_0_MultilingualUri_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, AmtImWebType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AmtImWebType.subclass:
            return AmtImWebType.subclass(*args_, **kwargs_)
        else:
            return AmtImWebType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_OeREBKRM_V2_0_MultilingualUri(self):
        return self.OeREBKRM_V2_0_MultilingualUri

    def set_OeREBKRM_V2_0_MultilingualUri(self, OeREBKRM_V2_0_MultilingualUri):
        self.OeREBKRM_V2_0_MultilingualUri = OeREBKRM_V2_0_MultilingualUri

    def _hasContent(self):
        if self.OeREBKRM_V2_0_MultilingualUri is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AmtImWebType",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("AmtImWebType")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "AmtImWebType":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="AmtImWebType")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="AmtImWebType",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="AmtImWebType",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AmtImWebType",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.OeREBKRM_V2_0_MultilingualUri is not None:
            namespaceprefix_ = (
                self.OeREBKRM_V2_0_MultilingualUri_nsprefix_ + ":"
                if (UseCapturedNS_ and self.OeREBKRM_V2_0_MultilingualUri_nsprefix_)
                else ""
            )
            self.OeREBKRM_V2_0_MultilingualUri.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="OeREBKRM_V2_0.MultilingualUri",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "OeREBKRM_V2_0.MultilingualUri":
            obj_ = OeREBKRM_V2_0_MultilingualUri.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OeREBKRM_V2_0_MultilingualUri = obj_
            obj_.original_tagname_ = "OeREBKRM_V2_0.MultilingualUri"


# end class AmtImWebType


class TitelType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "LocalisationCH_V1_MultilingualText": MemberSpec_(
            "LocalisationCH_V1_MultilingualText",
            "LocalisationCH_V1.MultilingualText",
            0,
            0,
            {
                "name": "LocalisationCH_V1.MultilingualText",
                "type": "LocalisationCH_V1.MultilingualText",
            },
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, LocalisationCH_V1_MultilingualText=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if LocalisationCH_V1_MultilingualText is None:
            self.LocalisationCH_V1_MultilingualText = globals()["LocalisationCH_V1_MultilingualText"]()
        else:
            self.LocalisationCH_V1_MultilingualText = LocalisationCH_V1_MultilingualText
        self.LocalisationCH_V1_MultilingualText_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, TitelType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TitelType.subclass:
            return TitelType.subclass(*args_, **kwargs_)
        else:
            return TitelType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_LocalisationCH_V1_MultilingualText(self):
        return self.LocalisationCH_V1_MultilingualText

    def set_LocalisationCH_V1_MultilingualText(self, LocalisationCH_V1_MultilingualText):
        self.LocalisationCH_V1_MultilingualText = LocalisationCH_V1_MultilingualText

    def _hasContent(self):
        if self.LocalisationCH_V1_MultilingualText is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="TitelType",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("TitelType")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "TitelType":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="TitelType")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="TitelType",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_="", name_="TitelType"):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="TitelType",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.LocalisationCH_V1_MultilingualText is not None:
            namespaceprefix_ = (
                self.LocalisationCH_V1_MultilingualText_nsprefix_ + ":"
                if (UseCapturedNS_ and self.LocalisationCH_V1_MultilingualText_nsprefix_)
                else ""
            )
            self.LocalisationCH_V1_MultilingualText.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="LocalisationCH_V1.MultilingualText",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "LocalisationCH_V1.MultilingualText":
            obj_ = LocalisationCH_V1_MultilingualText.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LocalisationCH_V1_MultilingualText = obj_
            obj_.original_tagname_ = "LocalisationCH_V1.MultilingualText"


# end class TitelType


class AbkuerzungType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "LocalisationCH_V1_MultilingualText": MemberSpec_(
            "LocalisationCH_V1_MultilingualText",
            "LocalisationCH_V1.MultilingualText",
            0,
            0,
            {
                "name": "LocalisationCH_V1.MultilingualText",
                "type": "LocalisationCH_V1.MultilingualText",
            },
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, LocalisationCH_V1_MultilingualText=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if LocalisationCH_V1_MultilingualText is None:
            self.LocalisationCH_V1_MultilingualText = globals()["LocalisationCH_V1_MultilingualText"]()
        else:
            self.LocalisationCH_V1_MultilingualText = LocalisationCH_V1_MultilingualText
        self.LocalisationCH_V1_MultilingualText_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, AbkuerzungType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbkuerzungType.subclass:
            return AbkuerzungType.subclass(*args_, **kwargs_)
        else:
            return AbkuerzungType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_LocalisationCH_V1_MultilingualText(self):
        return self.LocalisationCH_V1_MultilingualText

    def set_LocalisationCH_V1_MultilingualText(self, LocalisationCH_V1_MultilingualText):
        self.LocalisationCH_V1_MultilingualText = LocalisationCH_V1_MultilingualText

    def _hasContent(self):
        if self.LocalisationCH_V1_MultilingualText is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AbkuerzungType",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("AbkuerzungType")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "AbkuerzungType":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="AbkuerzungType")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="AbkuerzungType",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="AbkuerzungType",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="AbkuerzungType",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.LocalisationCH_V1_MultilingualText is not None:
            namespaceprefix_ = (
                self.LocalisationCH_V1_MultilingualText_nsprefix_ + ":"
                if (UseCapturedNS_ and self.LocalisationCH_V1_MultilingualText_nsprefix_)
                else ""
            )
            self.LocalisationCH_V1_MultilingualText.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="LocalisationCH_V1.MultilingualText",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "LocalisationCH_V1.MultilingualText":
            obj_ = LocalisationCH_V1_MultilingualText.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LocalisationCH_V1_MultilingualText = obj_
            obj_.original_tagname_ = "LocalisationCH_V1.MultilingualText"


# end class AbkuerzungType


class OffizielleNrType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "LocalisationCH_V1_MultilingualText": MemberSpec_(
            "LocalisationCH_V1_MultilingualText",
            "LocalisationCH_V1.MultilingualText",
            0,
            0,
            {
                "name": "LocalisationCH_V1.MultilingualText",
                "type": "LocalisationCH_V1.MultilingualText",
            },
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, LocalisationCH_V1_MultilingualText=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if LocalisationCH_V1_MultilingualText is None:
            self.LocalisationCH_V1_MultilingualText = globals()["LocalisationCH_V1_MultilingualText"]()
        else:
            self.LocalisationCH_V1_MultilingualText = LocalisationCH_V1_MultilingualText
        self.LocalisationCH_V1_MultilingualText_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, OffizielleNrType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OffizielleNrType.subclass:
            return OffizielleNrType.subclass(*args_, **kwargs_)
        else:
            return OffizielleNrType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_LocalisationCH_V1_MultilingualText(self):
        return self.LocalisationCH_V1_MultilingualText

    def set_LocalisationCH_V1_MultilingualText(self, LocalisationCH_V1_MultilingualText):
        self.LocalisationCH_V1_MultilingualText = LocalisationCH_V1_MultilingualText

    def _hasContent(self):
        if self.LocalisationCH_V1_MultilingualText is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="OffizielleNrType",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("OffizielleNrType")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "OffizielleNrType":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="OffizielleNrType",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="OffizielleNrType",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="OffizielleNrType",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="OffizielleNrType",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.LocalisationCH_V1_MultilingualText is not None:
            namespaceprefix_ = (
                self.LocalisationCH_V1_MultilingualText_nsprefix_ + ":"
                if (UseCapturedNS_ and self.LocalisationCH_V1_MultilingualText_nsprefix_)
                else ""
            )
            self.LocalisationCH_V1_MultilingualText.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="LocalisationCH_V1.MultilingualText",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "LocalisationCH_V1.MultilingualText":
            obj_ = LocalisationCH_V1_MultilingualText.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LocalisationCH_V1_MultilingualText = obj_
            obj_.original_tagname_ = "LocalisationCH_V1.MultilingualText"


# end class OffizielleNrType


class TextImWebType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "OeREBKRM_V2_0_MultilingualUri": MemberSpec_(
            "OeREBKRM_V2_0_MultilingualUri",
            "OeREBKRM_V2_0.MultilingualUri",
            0,
            0,
            {
                "name": "OeREBKRM_V2_0.MultilingualUri",
                "type": "OeREBKRM_V2_0.MultilingualUri",
            },
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, OeREBKRM_V2_0_MultilingualUri=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if OeREBKRM_V2_0_MultilingualUri is None:
            self.OeREBKRM_V2_0_MultilingualUri = globals()["OeREBKRM_V2_0_MultilingualUri"]()
        else:
            self.OeREBKRM_V2_0_MultilingualUri = OeREBKRM_V2_0_MultilingualUri
        self.OeREBKRM_V2_0_MultilingualUri_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, TextImWebType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TextImWebType.subclass:
            return TextImWebType.subclass(*args_, **kwargs_)
        else:
            return TextImWebType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_OeREBKRM_V2_0_MultilingualUri(self):
        return self.OeREBKRM_V2_0_MultilingualUri

    def set_OeREBKRM_V2_0_MultilingualUri(self, OeREBKRM_V2_0_MultilingualUri):
        self.OeREBKRM_V2_0_MultilingualUri = OeREBKRM_V2_0_MultilingualUri

    def _hasContent(self):
        if self.OeREBKRM_V2_0_MultilingualUri is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="TextImWebType",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("TextImWebType")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "TextImWebType":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="TextImWebType")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="TextImWebType",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="TextImWebType",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="TextImWebType",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.OeREBKRM_V2_0_MultilingualUri is not None:
            namespaceprefix_ = (
                self.OeREBKRM_V2_0_MultilingualUri_nsprefix_ + ":"
                if (UseCapturedNS_ and self.OeREBKRM_V2_0_MultilingualUri_nsprefix_)
                else ""
            )
            self.OeREBKRM_V2_0_MultilingualUri.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="OeREBKRM_V2_0.MultilingualUri",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "OeREBKRM_V2_0.MultilingualUri":
            obj_ = OeREBKRM_V2_0_MultilingualUri.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OeREBKRM_V2_0_MultilingualUri = obj_
            obj_.original_tagname_ = "OeREBKRM_V2_0.MultilingualUri"


# end class TextImWebType


class DokumentType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "OeREBKRM_V2_0_MultilingualBlob": MemberSpec_(
            "OeREBKRM_V2_0_MultilingualBlob",
            "OeREBKRM_V2_0.MultilingualBlob",
            0,
            0,
            {
                "name": "OeREBKRM_V2_0.MultilingualBlob",
                "type": "OeREBKRM_V2_0.MultilingualBlob",
            },
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, OeREBKRM_V2_0_MultilingualBlob=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if OeREBKRM_V2_0_MultilingualBlob is None:
            self.OeREBKRM_V2_0_MultilingualBlob = globals()["OeREBKRM_V2_0_MultilingualBlob"]()
        else:
            self.OeREBKRM_V2_0_MultilingualBlob = OeREBKRM_V2_0_MultilingualBlob
        self.OeREBKRM_V2_0_MultilingualBlob_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, DokumentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DokumentType.subclass:
            return DokumentType.subclass(*args_, **kwargs_)
        else:
            return DokumentType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_OeREBKRM_V2_0_MultilingualBlob(self):
        return self.OeREBKRM_V2_0_MultilingualBlob

    def set_OeREBKRM_V2_0_MultilingualBlob(self, OeREBKRM_V2_0_MultilingualBlob):
        self.OeREBKRM_V2_0_MultilingualBlob = OeREBKRM_V2_0_MultilingualBlob

    def _hasContent(self):
        if self.OeREBKRM_V2_0_MultilingualBlob is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="DokumentType",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("DokumentType")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "DokumentType":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="DokumentType")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="DokumentType",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="DokumentType",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="DokumentType",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.OeREBKRM_V2_0_MultilingualBlob is not None:
            namespaceprefix_ = (
                self.OeREBKRM_V2_0_MultilingualBlob_nsprefix_ + ":"
                if (UseCapturedNS_ and self.OeREBKRM_V2_0_MultilingualBlob_nsprefix_)
                else ""
            )
            self.OeREBKRM_V2_0_MultilingualBlob.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="OeREBKRM_V2_0.MultilingualBlob",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "OeREBKRM_V2_0.MultilingualBlob":
            obj_ = OeREBKRM_V2_0_MultilingualBlob.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OeREBKRM_V2_0_MultilingualBlob = obj_
            obj_.original_tagname_ = "OeREBKRM_V2_0.MultilingualBlob"


# end class DokumentType


class ZustaendigeStelleType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "REF": MemberSpec_("REF", "IliID", 0, 0, {"use": "required", "name": "REF"}),
        "BID": MemberSpec_("BID", "IliID", 0, 1, {"use": "optional", "name": "BID"}),
        "ORDER_POS": MemberSpec_(
            "ORDER_POS",
            "xsd:positiveInteger",
            0,
            1,
            {"use": "optional", "name": "ORDER_POS"},
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, REF=None, BID=None, ORDER_POS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.REF = _cast(None, REF)
        self.REF_nsprefix_ = None
        self.BID = _cast(None, BID)
        self.BID_nsprefix_ = None
        self.ORDER_POS = _cast(int, ORDER_POS)
        self.ORDER_POS_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, ZustaendigeStelleType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ZustaendigeStelleType.subclass:
            return ZustaendigeStelleType.subclass(*args_, **kwargs_)
        else:
            return ZustaendigeStelleType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_REF(self):
        return self.REF

    def set_REF(self, REF):
        self.REF = REF

    def get_BID(self):
        return self.BID

    def set_BID(self, BID):
        self.BID = BID

    def get_ORDER_POS(self):
        return self.ORDER_POS

    def set_ORDER_POS(self, ORDER_POS):
        self.ORDER_POS = ORDER_POS

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if ():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="ZustaendigeStelleType",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("ZustaendigeStelleType")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "ZustaendigeStelleType":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="ZustaendigeStelleType",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="ZustaendigeStelleType",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="ZustaendigeStelleType",
    ):
        if self.REF is not None and "REF" not in already_processed:
            already_processed.add("REF")
            outfile.write(
                " REF=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.REF), input_name="REF")),)
            )
        if self.BID is not None and "BID" not in already_processed:
            already_processed.add("BID")
            outfile.write(
                " BID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.BID), input_name="BID")),)
            )
        if self.ORDER_POS is not None and "ORDER_POS" not in already_processed:
            already_processed.add("ORDER_POS")
            outfile.write(' ORDER_POS="%s"' % self.gds_format_integer(self.ORDER_POS, input_name="ORDER_POS"))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="ZustaendigeStelleType",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("REF", node)
        if value is not None and "REF" not in already_processed:
            already_processed.add("REF")
            self.REF = value
            self.validate_IliID(self.REF)  # validate type IliID
        value = find_attr_value_("BID", node)
        if value is not None and "BID" not in already_processed:
            already_processed.add("BID")
            self.BID = value
            self.validate_IliID(self.BID)  # validate type IliID
        value = find_attr_value_("ORDER_POS", node)
        if value is not None and "ORDER_POS" not in already_processed:
            already_processed.add("ORDER_POS")
            self.ORDER_POS = self.gds_parse_integer(value, node, "ORDER_POS")
            if self.ORDER_POS <= 0:
                raise_parse_error(node, "Invalid PositiveInteger")

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class ZustaendigeStelleType


class VerweisWMSType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "OeREBKRM_V2_0_MultilingualUri": MemberSpec_(
            "OeREBKRM_V2_0_MultilingualUri",
            "OeREBKRM_V2_0.MultilingualUri",
            0,
            0,
            {
                "name": "OeREBKRM_V2_0.MultilingualUri",
                "type": "OeREBKRM_V2_0.MultilingualUri",
            },
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, OeREBKRM_V2_0_MultilingualUri=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if OeREBKRM_V2_0_MultilingualUri is None:
            self.OeREBKRM_V2_0_MultilingualUri = globals()["OeREBKRM_V2_0_MultilingualUri"]()
        else:
            self.OeREBKRM_V2_0_MultilingualUri = OeREBKRM_V2_0_MultilingualUri
        self.OeREBKRM_V2_0_MultilingualUri_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, VerweisWMSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VerweisWMSType.subclass:
            return VerweisWMSType.subclass(*args_, **kwargs_)
        else:
            return VerweisWMSType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_OeREBKRM_V2_0_MultilingualUri(self):
        return self.OeREBKRM_V2_0_MultilingualUri

    def set_OeREBKRM_V2_0_MultilingualUri(self, OeREBKRM_V2_0_MultilingualUri):
        self.OeREBKRM_V2_0_MultilingualUri = OeREBKRM_V2_0_MultilingualUri

    def _hasContent(self):
        if self.OeREBKRM_V2_0_MultilingualUri is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="VerweisWMSType",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("VerweisWMSType")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "VerweisWMSType":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="VerweisWMSType")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="VerweisWMSType",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="VerweisWMSType",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="VerweisWMSType",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.OeREBKRM_V2_0_MultilingualUri is not None:
            namespaceprefix_ = (
                self.OeREBKRM_V2_0_MultilingualUri_nsprefix_ + ":"
                if (UseCapturedNS_ and self.OeREBKRM_V2_0_MultilingualUri_nsprefix_)
                else ""
            )
            self.OeREBKRM_V2_0_MultilingualUri.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="OeREBKRM_V2_0.MultilingualUri",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "OeREBKRM_V2_0.MultilingualUri":
            obj_ = OeREBKRM_V2_0_MultilingualUri.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OeREBKRM_V2_0_MultilingualUri = obj_
            obj_.original_tagname_ = "OeREBKRM_V2_0.MultilingualUri"


# end class VerweisWMSType


class DarstellungsDienstType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "REF": MemberSpec_("REF", "IliID", 0, 0, {"use": "required", "name": "REF"}),
        "BID": MemberSpec_("BID", "IliID", 0, 1, {"use": "optional", "name": "BID"}),
        "ORDER_POS": MemberSpec_(
            "ORDER_POS",
            "xsd:positiveInteger",
            0,
            1,
            {"use": "optional", "name": "ORDER_POS"},
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, REF=None, BID=None, ORDER_POS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.REF = _cast(None, REF)
        self.REF_nsprefix_ = None
        self.BID = _cast(None, BID)
        self.BID_nsprefix_ = None
        self.ORDER_POS = _cast(int, ORDER_POS)
        self.ORDER_POS_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, DarstellungsDienstType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DarstellungsDienstType.subclass:
            return DarstellungsDienstType.subclass(*args_, **kwargs_)
        else:
            return DarstellungsDienstType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_REF(self):
        return self.REF

    def set_REF(self, REF):
        self.REF = REF

    def get_BID(self):
        return self.BID

    def set_BID(self, BID):
        self.BID = BID

    def get_ORDER_POS(self):
        return self.ORDER_POS

    def set_ORDER_POS(self, ORDER_POS):
        self.ORDER_POS = ORDER_POS

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if ():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="DarstellungsDienstType",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("DarstellungsDienstType")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "DarstellungsDienstType":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="DarstellungsDienstType",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="DarstellungsDienstType",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="DarstellungsDienstType",
    ):
        if self.REF is not None and "REF" not in already_processed:
            already_processed.add("REF")
            outfile.write(
                " REF=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.REF), input_name="REF")),)
            )
        if self.BID is not None and "BID" not in already_processed:
            already_processed.add("BID")
            outfile.write(
                " BID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.BID), input_name="BID")),)
            )
        if self.ORDER_POS is not None and "ORDER_POS" not in already_processed:
            already_processed.add("ORDER_POS")
            outfile.write(' ORDER_POS="%s"' % self.gds_format_integer(self.ORDER_POS, input_name="ORDER_POS"))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="DarstellungsDienstType",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("REF", node)
        if value is not None and "REF" not in already_processed:
            already_processed.add("REF")
            self.REF = value
            self.validate_IliID(self.REF)  # validate type IliID
        value = find_attr_value_("BID", node)
        if value is not None and "BID" not in already_processed:
            already_processed.add("BID")
            self.BID = value
            self.validate_IliID(self.BID)  # validate type IliID
        value = find_attr_value_("ORDER_POS", node)
        if value is not None and "ORDER_POS" not in already_processed:
            already_processed.add("ORDER_POS")
            self.ORDER_POS = self.gds_parse_integer(value, node, "ORDER_POS")
            if self.ORDER_POS <= 0:
                raise_parse_error(node, "Invalid PositiveInteger")

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class DarstellungsDienstType


class LegendeType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "REF": MemberSpec_("REF", "IliID", 0, 0, {"use": "required", "name": "REF"}),
        "BID": MemberSpec_("BID", "IliID", 0, 1, {"use": "optional", "name": "BID"}),
        "ORDER_POS": MemberSpec_(
            "ORDER_POS",
            "xsd:positiveInteger",
            0,
            1,
            {"use": "optional", "name": "ORDER_POS"},
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, REF=None, BID=None, ORDER_POS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.REF = _cast(None, REF)
        self.REF_nsprefix_ = None
        self.BID = _cast(None, BID)
        self.BID_nsprefix_ = None
        self.ORDER_POS = _cast(int, ORDER_POS)
        self.ORDER_POS_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, LegendeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LegendeType.subclass:
            return LegendeType.subclass(*args_, **kwargs_)
        else:
            return LegendeType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_REF(self):
        return self.REF

    def set_REF(self, REF):
        self.REF = REF

    def get_BID(self):
        return self.BID

    def set_BID(self, BID):
        self.BID = BID

    def get_ORDER_POS(self):
        return self.ORDER_POS

    def set_ORDER_POS(self, ORDER_POS):
        self.ORDER_POS = ORDER_POS

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if ():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="LegendeType",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("LegendeType")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "LegendeType":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="LegendeType")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="LegendeType",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="LegendeType",
    ):
        if self.REF is not None and "REF" not in already_processed:
            already_processed.add("REF")
            outfile.write(
                " REF=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.REF), input_name="REF")),)
            )
        if self.BID is not None and "BID" not in already_processed:
            already_processed.add("BID")
            outfile.write(
                " BID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.BID), input_name="BID")),)
            )
        if self.ORDER_POS is not None and "ORDER_POS" not in already_processed:
            already_processed.add("ORDER_POS")
            outfile.write(' ORDER_POS="%s"' % self.gds_format_integer(self.ORDER_POS, input_name="ORDER_POS"))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="LegendeType",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("REF", node)
        if value is not None and "REF" not in already_processed:
            already_processed.add("REF")
            self.REF = value
            self.validate_IliID(self.REF)  # validate type IliID
        value = find_attr_value_("BID", node)
        if value is not None and "BID" not in already_processed:
            already_processed.add("BID")
            self.BID = value
            self.validate_IliID(self.BID)  # validate type IliID
        value = find_attr_value_("ORDER_POS", node)
        if value is not None and "ORDER_POS" not in already_processed:
            already_processed.add("ORDER_POS")
            self.ORDER_POS = self.gds_parse_integer(value, node, "ORDER_POS")
            if self.ORDER_POS <= 0:
                raise_parse_error(node, "Invalid PositiveInteger")

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class LegendeType


class ZustaendigeStelleType88(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "REF": MemberSpec_("REF", "IliID", 0, 0, {"use": "required", "name": "REF"}),
        "BID": MemberSpec_("BID", "IliID", 0, 1, {"use": "optional", "name": "BID"}),
        "ORDER_POS": MemberSpec_(
            "ORDER_POS",
            "xsd:positiveInteger",
            0,
            1,
            {"use": "optional", "name": "ORDER_POS"},
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, REF=None, BID=None, ORDER_POS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.REF = _cast(None, REF)
        self.REF_nsprefix_ = None
        self.BID = _cast(None, BID)
        self.BID_nsprefix_ = None
        self.ORDER_POS = _cast(int, ORDER_POS)
        self.ORDER_POS_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, ZustaendigeStelleType88)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ZustaendigeStelleType88.subclass:
            return ZustaendigeStelleType88.subclass(*args_, **kwargs_)
        else:
            return ZustaendigeStelleType88(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_REF(self):
        return self.REF

    def set_REF(self, REF):
        self.REF = REF

    def get_BID(self):
        return self.BID

    def set_BID(self, BID):
        self.BID = BID

    def get_ORDER_POS(self):
        return self.ORDER_POS

    def set_ORDER_POS(self, ORDER_POS):
        self.ORDER_POS = ORDER_POS

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if ():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="ZustaendigeStelleType88",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("ZustaendigeStelleType88")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "ZustaendigeStelleType88":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="ZustaendigeStelleType88",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="ZustaendigeStelleType88",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="ZustaendigeStelleType88",
    ):
        if self.REF is not None and "REF" not in already_processed:
            already_processed.add("REF")
            outfile.write(
                " REF=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.REF), input_name="REF")),)
            )
        if self.BID is not None and "BID" not in already_processed:
            already_processed.add("BID")
            outfile.write(
                " BID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.BID), input_name="BID")),)
            )
        if self.ORDER_POS is not None and "ORDER_POS" not in already_processed:
            already_processed.add("ORDER_POS")
            outfile.write(' ORDER_POS="%s"' % self.gds_format_integer(self.ORDER_POS, input_name="ORDER_POS"))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="ZustaendigeStelleType88",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("REF", node)
        if value is not None and "REF" not in already_processed:
            already_processed.add("REF")
            self.REF = value
            self.validate_IliID(self.REF)  # validate type IliID
        value = find_attr_value_("BID", node)
        if value is not None and "BID" not in already_processed:
            already_processed.add("BID")
            self.BID = value
            self.validate_IliID(self.BID)  # validate type IliID
        value = find_attr_value_("ORDER_POS", node)
        if value is not None and "ORDER_POS" not in already_processed:
            already_processed.add("ORDER_POS")
            self.ORDER_POS = self.gds_parse_integer(value, node, "ORDER_POS")
            if self.ORDER_POS <= 0:
                raise_parse_error(node, "Invalid PositiveInteger")

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class ZustaendigeStelleType88


class EigentumsbeschraenkungType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "REF": MemberSpec_("REF", "IliID", 0, 0, {"use": "required", "name": "REF"}),
        "BID": MemberSpec_("BID", "IliID", 0, 1, {"use": "optional", "name": "BID"}),
        "ORDER_POS": MemberSpec_(
            "ORDER_POS",
            "xsd:positiveInteger",
            0,
            1,
            {"use": "optional", "name": "ORDER_POS"},
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, REF=None, BID=None, ORDER_POS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.REF = _cast(None, REF)
        self.REF_nsprefix_ = None
        self.BID = _cast(None, BID)
        self.BID_nsprefix_ = None
        self.ORDER_POS = _cast(int, ORDER_POS)
        self.ORDER_POS_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, EigentumsbeschraenkungType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EigentumsbeschraenkungType.subclass:
            return EigentumsbeschraenkungType.subclass(*args_, **kwargs_)
        else:
            return EigentumsbeschraenkungType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_REF(self):
        return self.REF

    def set_REF(self, REF):
        self.REF = REF

    def get_BID(self):
        return self.BID

    def set_BID(self, BID):
        self.BID = BID

    def get_ORDER_POS(self):
        return self.ORDER_POS

    def set_ORDER_POS(self, ORDER_POS):
        self.ORDER_POS = ORDER_POS

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if ():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="EigentumsbeschraenkungType",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("EigentumsbeschraenkungType")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "EigentumsbeschraenkungType":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="EigentumsbeschraenkungType",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="EigentumsbeschraenkungType",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="EigentumsbeschraenkungType",
    ):
        if self.REF is not None and "REF" not in already_processed:
            already_processed.add("REF")
            outfile.write(
                " REF=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.REF), input_name="REF")),)
            )
        if self.BID is not None and "BID" not in already_processed:
            already_processed.add("BID")
            outfile.write(
                " BID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.BID), input_name="BID")),)
            )
        if self.ORDER_POS is not None and "ORDER_POS" not in already_processed:
            already_processed.add("ORDER_POS")
            outfile.write(' ORDER_POS="%s"' % self.gds_format_integer(self.ORDER_POS, input_name="ORDER_POS"))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="EigentumsbeschraenkungType",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("REF", node)
        if value is not None and "REF" not in already_processed:
            already_processed.add("REF")
            self.REF = value
            self.validate_IliID(self.REF)  # validate type IliID
        value = find_attr_value_("BID", node)
        if value is not None and "BID" not in already_processed:
            already_processed.add("BID")
            self.BID = value
            self.validate_IliID(self.BID)  # validate type IliID
        value = find_attr_value_("ORDER_POS", node)
        if value is not None and "ORDER_POS" not in already_processed:
            already_processed.add("ORDER_POS")
            self.ORDER_POS = self.gds_parse_integer(value, node, "ORDER_POS")
            if self.ORDER_POS <= 0:
                raise_parse_error(node, "Invalid PositiveInteger")

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class EigentumsbeschraenkungType


class SymbolType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "BINBLBOX": MemberSpec_(
            "BINBLBOX",
            "BINBLBOXType89",
            0,
            0,
            {"name": "BINBLBOX", "type": "BINBLBOXType89"},
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, BINBLBOX=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.BINBLBOX = BINBLBOX
        self.BINBLBOX_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, SymbolType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SymbolType.subclass:
            return SymbolType.subclass(*args_, **kwargs_)
        else:
            return SymbolType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_BINBLBOX(self):
        return self.BINBLBOX

    def set_BINBLBOX(self, BINBLBOX):
        self.BINBLBOX = BINBLBOX

    def _hasContent(self):
        if self.BINBLBOX is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="SymbolType",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("SymbolType")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "SymbolType":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="SymbolType")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="SymbolType",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_="", name_="SymbolType"):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="SymbolType",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.BINBLBOX is not None:
            namespaceprefix_ = (
                self.BINBLBOX_nsprefix_ + ":" if (UseCapturedNS_ and self.BINBLBOX_nsprefix_) else ""
            )
            self.BINBLBOX.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="BINBLBOX",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "BINBLBOX":
            obj_ = BINBLBOXType89.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BINBLBOX = obj_
            obj_.original_tagname_ = "BINBLBOX"


# end class SymbolType


class BINBLBOXType89(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "valueOf_": MemberSpec_("valueOf_", "xsd:base64Binary", 0),
    }
    subclass = None
    superclass = None

    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, BINBLBOXType89)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BINBLBOXType89.subclass:
            return BINBLBOXType89.subclass(*args_, **kwargs_)
        else:
            return BINBLBOXType89(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def _hasContent(self):
        if 1 if type(self.valueOf_) in [int, float] else self.valueOf_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="BINBLBOXType89",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("BINBLBOXType89")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "BINBLBOXType89":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="BINBLBOXType89")
        outfile.write(">")
        self._exportChildren(
            outfile,
            level + 1,
            namespaceprefix_,
            namespacedef_,
            name_,
            pretty_print=pretty_print,
        )
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="BINBLBOXType89",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="BINBLBOXType89",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class BINBLBOXType89


class LegendeTextType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "LocalisationCH_V1_MultilingualText": MemberSpec_(
            "LocalisationCH_V1_MultilingualText",
            "LocalisationCH_V1.MultilingualText",
            0,
            0,
            {
                "name": "LocalisationCH_V1.MultilingualText",
                "type": "LocalisationCH_V1.MultilingualText",
            },
            None,
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, LocalisationCH_V1_MultilingualText=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if LocalisationCH_V1_MultilingualText is None:
            self.LocalisationCH_V1_MultilingualText = globals()["LocalisationCH_V1_MultilingualText"]()
        else:
            self.LocalisationCH_V1_MultilingualText = LocalisationCH_V1_MultilingualText
        self.LocalisationCH_V1_MultilingualText_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, LegendeTextType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LegendeTextType.subclass:
            return LegendeTextType.subclass(*args_, **kwargs_)
        else:
            return LegendeTextType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_LocalisationCH_V1_MultilingualText(self):
        return self.LocalisationCH_V1_MultilingualText

    def set_LocalisationCH_V1_MultilingualText(self, LocalisationCH_V1_MultilingualText):
        self.LocalisationCH_V1_MultilingualText = LocalisationCH_V1_MultilingualText

    def _hasContent(self):
        if self.LocalisationCH_V1_MultilingualText is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="LegendeTextType",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("LegendeTextType")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "LegendeTextType":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_="LegendeTextType")
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="LegendeTextType",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="LegendeTextType",
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.interlis.ch/INTERLIS2.3" ',
        name_="LegendeTextType",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.LocalisationCH_V1_MultilingualText is not None:
            namespaceprefix_ = (
                self.LocalisationCH_V1_MultilingualText_nsprefix_ + ":"
                if (UseCapturedNS_ and self.LocalisationCH_V1_MultilingualText_nsprefix_)
                else ""
            )
            self.LocalisationCH_V1_MultilingualText.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="LocalisationCH_V1.MultilingualText",
                pretty_print=pretty_print,
            )

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == "LocalisationCH_V1.MultilingualText":
            obj_ = LocalisationCH_V1_MultilingualText.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LocalisationCH_V1_MultilingualText = obj_
            obj_.original_tagname_ = "LocalisationCH_V1.MultilingualText"


# end class LegendeTextType


class DarstellungsDienstType90(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = {
        "REF": MemberSpec_("REF", "IliID", 0, 0, {"use": "required", "name": "REF"}),
        "BID": MemberSpec_("BID", "IliID", 0, 1, {"use": "optional", "name": "BID"}),
        "ORDER_POS": MemberSpec_(
            "ORDER_POS",
            "xsd:positiveInteger",
            0,
            1,
            {"use": "optional", "name": "ORDER_POS"},
        ),
    }
    subclass = None
    superclass = None

    def __init__(self, REF=None, BID=None, ORDER_POS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.REF = _cast(None, REF)
        self.REF_nsprefix_ = None
        self.BID = _cast(None, BID)
        self.BID_nsprefix_ = None
        self.ORDER_POS = _cast(int, ORDER_POS)
        self.ORDER_POS_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, DarstellungsDienstType90)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DarstellungsDienstType90.subclass:
            return DarstellungsDienstType90.subclass(*args_, **kwargs_)
        else:
            return DarstellungsDienstType90(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_REF(self):
        return self.REF

    def set_REF(self, REF):
        self.REF = REF

    def get_BID(self):
        return self.BID

    def set_BID(self, BID):
        self.BID = BID

    def get_ORDER_POS(self):
        return self.ORDER_POS

    def set_ORDER_POS(self, ORDER_POS):
        self.ORDER_POS = ORDER_POS

    def validate_IliID(self, value):
        # Validate type IliID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(self.validate_IliID_patterns_, value):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_IliID_patterns_,
                    )
                )

    validate_IliID_patterns_ = [["^(([a-zA-Z_][0-9a-zA-Z_\\-\\.]*:)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.]*)$"]]

    def _hasContent(self):
        if ():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="DarstellungsDienstType90",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("DarstellungsDienstType90")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "DarstellungsDienstType90":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="DarstellungsDienstType90",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="DarstellungsDienstType90",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="DarstellungsDienstType90",
    ):
        if self.REF is not None and "REF" not in already_processed:
            already_processed.add("REF")
            outfile.write(
                " REF=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.REF), input_name="REF")),)
            )
        if self.BID is not None and "BID" not in already_processed:
            already_processed.add("BID")
            outfile.write(
                " BID=%s"
                % (self.gds_encode(self.gds_format_string(quote_attrib(self.BID), input_name="BID")),)
            )
        if self.ORDER_POS is not None and "ORDER_POS" not in already_processed:
            already_processed.add("ORDER_POS")
            outfile.write(' ORDER_POS="%s"' % self.gds_format_integer(self.ORDER_POS, input_name="ORDER_POS"))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="DarstellungsDienstType90",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("REF", node)
        if value is not None and "REF" not in already_processed:
            already_processed.add("REF")
            self.REF = value
            self.validate_IliID(self.REF)  # validate type IliID
        value = find_attr_value_("BID", node)
        if value is not None and "BID" not in already_processed:
            already_processed.add("BID")
            self.BID = value
            self.validate_IliID(self.BID)  # validate type IliID
        value = find_attr_value_("ORDER_POS", node)
        if value is not None and "ORDER_POS" not in already_processed:
            already_processed.add("ORDER_POS")
            self.ORDER_POS = self.gds_parse_integer(value, node, "ORDER_POS")
            if self.ORDER_POS <= 0:
                raise_parse_error(node, "Invalid PositiveInteger")

    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class DarstellungsDienstType90


GDSClassesMapping = {}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    prefix_tag = TagNamePrefix + tag
    rootClass = GDSClassesMapping.get(prefix_tag)
    if rootClass is None:
        rootClass = globals().get(prefix_tag)
    return tag, rootClass


def get_required_ns_prefix_defs(rootNode):
    """Get all name space prefix definitions required in this XML doc.
    Return a dictionary of definitions and a char string of definitions.
    """
    nsmap = {
        prefix: uri for node in rootNode.iter() for (prefix, uri) in node.nsmap.items() if prefix is not None
    }
    namespacedefs = " ".join(['xmlns:{}="{}"'.format(prefix, uri) for prefix, uri in nsmap.items()])
    return nsmap, namespacedefs


def parse(inFileName, silence=False, print_warnings=True):
    global CapturedNsmap_
    gds_collector = GdsCollector_()
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = "Transfer"
        rootClass = Transfer
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    CapturedNsmap_, namespacedefs = get_required_ns_prefix_defs(rootNode)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(sys.stdout, 0, name_=rootTag, namespacedef_=namespacedefs, pretty_print=True)
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ("-" * 50) + "\n"
        sys.stderr.write(separator)
        sys.stderr.write(
            "----- Warnings -- count: {} -----\n".format(
                len(gds_collector.get_messages()),
            )
        )
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseEtree(
    inFileName,
    silence=False,
    print_warnings=True,
    mapping=None,
    reverse_mapping=None,
    nsmap=None,
):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = "Transfer"
        rootClass = Transfer
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if mapping is None:
        mapping = {}
    if reverse_mapping is None:
        reverse_mapping = {}
    rootElement = rootObj.to_etree(
        None,
        name_=rootTag,
        mapping_=mapping,
        reverse_mapping_=reverse_mapping,
        nsmap_=nsmap,
    )
    reverse_node_mapping = rootObj.gds_reverse_node_mapping(mapping)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        content = etree_.tostring(rootElement, pretty_print=True, xml_declaration=True, encoding="utf-8")
        sys.stdout.write(str(content))
        sys.stdout.write("\n")
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ("-" * 50) + "\n"
        sys.stderr.write(separator)
        sys.stderr.write(
            "----- Warnings -- count: {} -----\n".format(
                len(gds_collector.get_messages()),
            )
        )
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj, rootElement, mapping, reverse_node_mapping


def parseString(inString, silence=False, print_warnings=True):
    """Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    """
    parser = None
    rootNode = parsexmlstring_(inString, parser)
    gds_collector = GdsCollector_()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = "Transfer"
        rootClass = Transfer
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if not SaveElementTreeNode:
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(sys.stdout, 0, name_=rootTag, namespacedef_="")
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ("-" * 50) + "\n"
        sys.stderr.write(separator)
        sys.stderr.write(
            "----- Warnings -- count: {} -----\n".format(
                len(gds_collector.get_messages()),
            )
        )
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseLiteral(inFileName, silence=False, print_warnings=True):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = "Transfer"
        rootClass = Transfer
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write("#from classes import *\n\n")
        sys.stdout.write("import classes as model_\n\n")
        sys.stdout.write("rootObj = model_.rootClass(\n")
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(")\n")
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ("-" * 50) + "\n"
        sys.stderr.write(separator)
        sys.stderr.write(
            "----- Warnings -- count: {} -----\n".format(
                len(gds_collector.get_messages()),
            )
        )
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == "__main__":
    # import pdb; pdb.set_trace()
    main()

RenameMappings_ = {}

#
# Mapping of namespaces to types defined in them
# and the file in which each is defined.
# simpleTypes are marked "ST" and complexTypes "CT".
NamespaceToDefMappings_ = {
    "http://www.interlis.ch/INTERLIS2.3": [
        (
            "IliID",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "ST",
        ),
        (
            "CHAdminCodes_V1.CHCantonCode",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "ST",
        ),
        (
            "CHAdminCodes_V1.CHMunicipalityCode",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "ST",
        ),
        (
            "CoordSys.Angle_DMS",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "ST",
        ),
        (
            "CoordSys.Angle_DMS_90",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "ST",
        ),
        (
            "GeometryCHLV03_V1.Orientation",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "ST",
        ),
        (
            "GeometryCHLV03_V1.Accuracy",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "ST",
        ),
        (
            "GeometryCHLV03_V1.Method",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "ST",
        ),
        (
            "GeometryCHLV95_V1.Orientation",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "ST",
        ),
        (
            "GeometryCHLV95_V1.Accuracy",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "ST",
        ),
        (
            "GeometryCHLV95_V1.Method",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "ST",
        ),
        (
            "InternationalCodes_V1.LanguageCode_ISO639_1",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "ST",
        ),
        (
            "InternationalCodes_V1.CountryCode_ISO3166_1",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "ST",
        ),
        (
            "OeREBKRM_V2_0.ArtEigentumsbeschraenkung",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "ST",
        ),
        (
            "OeREBKRM_V2_0.ArtikelNummer",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "ST",
        ),
        (
            "OeREBKRM_V2_0.Datum",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "ST",
        ),
        (
            "OeREBKRM_V2_0.DokumentTyp",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "ST",
        ),
        (
            "OeREBKRM_V2_0.GrundstuecksArt",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "ST",
        ),
        (
            "OeREBKRM_V2_0.RechtsStatus",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "ST",
        ),
        (
            "OeREBKRM_V2_0.Thema",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "ST",
        ),
        (
            "OeREBKRM_V2_0.UID",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "ST",
        ),
        (
            "INTERLIS.NAME",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "ST",
        ),
        (
            "INTERLIS.URI",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "ST",
        ),
        (
            "Transfer",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "Models",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "Model",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "RoleType",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "DataSection",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "AdministrativeUnitsCH_V1_CHCantons_CHCanton",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "AdministrativeUnitsCH_V1_CHCantons",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "AdministrativeUnitsCH_V1_CHDistricts_CHDistrict",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "AdministrativeUnitsCH_V1_CHDistricts",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "AdministrativeUnitsCH_V1_CHMunicipalities_CHMunicipality",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "AdministrativeUnitsCH_V1_CHMunicipalities",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "AdministrativeUnitsCH_V1_CHAdministrativeUnions_AdministrativeUnion",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "AdministrativeUnitsCH_V1_CHAdministrativeUnions",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "AdministrativeUnitsCH_V1_CHAgencies_Agency",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "AdministrativeUnitsCH_V1_CHAgencies",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "AdministrativeUnits_V1_AdministrativeUnits_AdministrativeElement",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "AdministrativeUnits_V1_AdministrativeUnits_UnionMembers",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "AdministrativeUnits_V1_AdministrativeUnits",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "AdministrativeUnits_V1_Countries_Country",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "AdministrativeUnits_V1_Countries",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "AdministrativeUnits_V1_CountryNames_CountryName",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "AdministrativeUnits_V1_CountryNames_CountryNamesTranslation",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "AdministrativeUnits_V1_CountryNames",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "AdministrativeUnits_V1_Agencies_Agency",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "AdministrativeUnits_V1_Agencies_Organisation",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "AdministrativeUnits_V1_Agencies",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "CoordSys_Angle_DMS_S",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "CoordSys_CoordsysTopic_Ellipsoid",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "CoordSys_CoordsysTopic_GravityModel",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "CoordSys_CoordsysTopic_GeoidModel",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "CoordSys_CoordsysTopic_LengthAXIS",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "CoordSys_CoordsysTopic_AngleAXIS",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "CoordSys_CoordsysTopic_GeoCartesian1D",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "CoordSys_CoordsysTopic_GeoHeight",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "CoordSys_CoordsysTopic_GeoCartesian2D",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "CoordSys_CoordsysTopic_GeoCartesian3D",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "CoordSys_CoordsysTopic_GeoEllipsoidal",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "CoordSys_CoordsysTopic_ToGeoEllipsoidal",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "CoordSys_CoordsysTopic_ToGeoCartesian3D",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "CoordSys_CoordsysTopic_BidirectGeoCartesian2D",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "CoordSys_CoordsysTopic_BidirectGeoCartesian3D",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "CoordSys_CoordsysTopic_BidirectGeoEllipsoidal",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "CoordSys_CoordsysTopic_MapProjection",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "CoordSys_CoordsysTopic_TransverseMercator",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "CoordSys_CoordsysTopic_SwissProjection",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "CoordSys_CoordsysTopic_Mercator",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "CoordSys_CoordsysTopic_ObliqueMercator",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "CoordSys_CoordsysTopic_Lambert",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "CoordSys_CoordsysTopic_Polyconic",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "CoordSys_CoordsysTopic_Albus",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "CoordSys_CoordsysTopic_Azimutal",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "CoordSys_CoordsysTopic_Stereographic",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "CoordSys_CoordsysTopic_HeightConversion",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "CoordSys_CoordsysTopic",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "DictionariesCH_V1_Dictionaries_Dictionary",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "DictionariesCH_V1_Dictionaries",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "Dictionaries_V1_Dictionaries_Entry",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "Dictionaries_V1_Dictionaries_Dictionary",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "Dictionaries_V1_Dictionaries",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "GeometryCHLV03_V1_Coord2",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "GeometryCHLV03_V1_Coord3",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "GeometryCHLV03_V1_Surface",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "GeometryCHLV03_V1_Area",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "GeometryCHLV03_V1_Line",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "GeometryCHLV03_V1_DirectedLine",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "GeometryCHLV03_V1_LineWithAltitude",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "GeometryCHLV03_V1_DirectedLineWithAltitude",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "GeometryCHLV03_V1_SurfaceWithOverlaps2mm",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "GeometryCHLV03_V1_AreaWithOverlaps2mm",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "GeometryCHLV03_V1_LineStructure",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "GeometryCHLV03_V1_DirectedLineStructure",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "GeometryCHLV03_V1_MultiLine",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "GeometryCHLV03_V1_MultiDirectedLine",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "GeometryCHLV03_V1_SurfaceStructure",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "GeometryCHLV03_V1_MultiSurface",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "GeometryCHLV95_V1_Coord2",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "GeometryCHLV95_V1_Coord3",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "GeometryCHLV95_V1_Surface",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "GeometryCHLV95_V1_Area",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "GeometryCHLV95_V1_Line",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "GeometryCHLV95_V1_DirectedLine",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "GeometryCHLV95_V1_LineWithAltitude",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "GeometryCHLV95_V1_DirectedLineWithAltitude",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "GeometryCHLV95_V1_SurfaceWithOverlaps2mm",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "GeometryCHLV95_V1_AreaWithOverlaps2mm",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "GeometryCHLV95_V1_LineStructure",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "GeometryCHLV95_V1_DirectedLineStructure",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "GeometryCHLV95_V1_MultiLine",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "GeometryCHLV95_V1_MultiDirectedLine",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "GeometryCHLV95_V1_SurfaceStructure",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "GeometryCHLV95_V1_MultiSurface",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "LocalisationCH_V1_LocalisedText",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "LocalisationCH_V1_LocalisedMText",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "LocalisationCH_V1_MultilingualText",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "LocalisationCH_V1_MultilingualMText",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "Localisation_V1_LocalisedText",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "Localisation_V1_LocalisedMText",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "Localisation_V1_MultilingualText",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "Localisation_V1_MultilingualMText",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "OeREBKRM_V2_0_OEREBOID",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "OeREBKRM_V2_0_ArtikelNummer_",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "OeREBKRM_V2_0_Datum_",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "OeREBKRM_V2_0_Thema_",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "OeREBKRM_V2_0_LocalisedBlob",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "OeREBKRM_V2_0_LocalisedUri",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "OeREBKRM_V2_0_MultilingualBlob",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "OeREBKRM_V2_0_MultilingualUri",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "OeREBKRM_V2_0_ThemaRef",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "OeREBKRM_V2_0_Amt_Amt",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "OeREBKRM_V2_0_Amt",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "OeREBKRM_V2_0_Dokumente_Dokument",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "OeREBKRM_V2_0_Dokumente",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "OeREBKRMtrsfr_V2_0_Transferstruktur_DarstellungsDienst",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "OeREBKRMtrsfr_V2_0_Transferstruktur_Eigentumsbeschraenkung",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "OeREBKRMtrsfr_V2_0_Transferstruktur_Geometrie",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "OeREBKRMtrsfr_V2_0_Transferstruktur_LegendeEintrag",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "OeREBKRMtrsfr_V2_0_Transferstruktur_HinweisVorschrift",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "OeREBKRMtrsfr_V2_0_Transferstruktur",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "CoordValue",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "ArcPoint",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "HeaderSection",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "OidSpaces",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
        (
            "OidSpace",
            "../../../../../../../../mgdm2oereb/mgdm2oereb_pavel/doc/fed/OeREBKRMtrsfr_V2_0.xsd",
            "CT",
        ),
    ]
}

__all__ = [
    "AbkuerzungType",
    "AdministrativeUnitsCH_V1_CHAdministrativeUnions",
    "AdministrativeUnitsCH_V1_CHAdministrativeUnions_AdministrativeUnion",
    "AdministrativeUnitsCH_V1_CHAgencies",
    "AdministrativeUnitsCH_V1_CHAgencies_Agency",
    "AdministrativeUnitsCH_V1_CHCantons",
    "AdministrativeUnitsCH_V1_CHCantons_CHCanton",
    "AdministrativeUnitsCH_V1_CHDistricts",
    "AdministrativeUnitsCH_V1_CHDistricts_CHDistrict",
    "AdministrativeUnitsCH_V1_CHMunicipalities",
    "AdministrativeUnitsCH_V1_CHMunicipalities_CHMunicipality",
    "AdministrativeUnits_V1_AdministrativeUnits",
    "AdministrativeUnits_V1_AdministrativeUnits_AdministrativeElement",
    "AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnion",
    "AdministrativeUnits_V1_AdministrativeUnits_AdministrativeUnit",
    "AdministrativeUnits_V1_AdministrativeUnits_UnionMembers",
    "AdministrativeUnits_V1_Agencies",
    "AdministrativeUnits_V1_Agencies_Agency",
    "AdministrativeUnits_V1_Agencies_Organisation",
    "AdministrativeUnits_V1_Countries",
    "AdministrativeUnits_V1_Countries_Country",
    "AdministrativeUnits_V1_CountryNames",
    "AdministrativeUnits_V1_CountryNames_CountryName",
    "AdministrativeUnits_V1_CountryNames_CountryNamesTranslation",
    "AmtImWebType",
    "ArcPoint",
    "AxisType",
    "AxisType16",
    "AxisType17",
    "AxisType19",
    "AxisType21",
    "BINBLBOXType",
    "BINBLBOXType89",
    "BOUNDARYType",
    "BOUNDARYType47",
    "BOUNDARYType54",
    "BOUNDARYType57",
    "BOUNDARYType61",
    "BOUNDARYType64",
    "BOUNDARYType71",
    "BOUNDARYType74",
    "BlobType",
    "CoordSys_Angle_DMS_S",
    "CoordSys_CoordsysTopic",
    "CoordSys_CoordsysTopic_Albus",
    "CoordSys_CoordsysTopic_AngleAXIS",
    "CoordSys_CoordsysTopic_Azimutal",
    "CoordSys_CoordsysTopic_BidirectGeoCartesian2D",
    "CoordSys_CoordsysTopic_BidirectGeoCartesian3D",
    "CoordSys_CoordsysTopic_BidirectGeoEllipsoidal",
    "CoordSys_CoordsysTopic_Ellipsoid",
    "CoordSys_CoordsysTopic_GeoCartesian1D",
    "CoordSys_CoordsysTopic_GeoCartesian2D",
    "CoordSys_CoordsysTopic_GeoCartesian3D",
    "CoordSys_CoordsysTopic_GeoEllipsoidal",
    "CoordSys_CoordsysTopic_GeoHeight",
    "CoordSys_CoordsysTopic_GeoidModel",
    "CoordSys_CoordsysTopic_GravityModel",
    "CoordSys_CoordsysTopic_HeightConversion",
    "CoordSys_CoordsysTopic_Lambert",
    "CoordSys_CoordsysTopic_LengthAXIS",
    "CoordSys_CoordsysTopic_MapProjection",
    "CoordSys_CoordsysTopic_Mercator",
    "CoordSys_CoordsysTopic_ObliqueMercator",
    "CoordSys_CoordsysTopic_Polyconic",
    "CoordSys_CoordsysTopic_Stereographic",
    "CoordSys_CoordsysTopic_SwissProjection",
    "CoordSys_CoordsysTopic_ToGeoCartesian3D",
    "CoordSys_CoordsysTopic_ToGeoEllipsoidal",
    "CoordSys_CoordsysTopic_TransverseMercator",
    "CoordValue",
    "DarstellungsDienstType",
    "DarstellungsDienstType90",
    "DataSection",
    "DescriptionType",
    "DescriptionType7",
    "DictionariesCH_V1_Dictionaries",
    "DictionariesCH_V1_Dictionaries_Dictionary",
    "Dictionaries_V1_Dictionaries",
    "Dictionaries_V1_Dictionaries_Dictionary",
    "Dictionaries_V1_Dictionaries_Entry",
    "DokumentType",
    "EigentumsbeschraenkungType",
    "EllipsoidRefType",
    "EllipsoidRefType23",
    "EntriesType",
    "EntriesType43",
    "EntriesType45",
    "GeoidRefType",
    "GeometryCHLV03_V1_Area",
    "GeometryCHLV03_V1_AreaWithOverlaps2mm",
    "GeometryCHLV03_V1_Coord2",
    "GeometryCHLV03_V1_Coord3",
    "GeometryCHLV03_V1_DirectedLine",
    "GeometryCHLV03_V1_DirectedLineStructure",
    "GeometryCHLV03_V1_DirectedLineWithAltitude",
    "GeometryCHLV03_V1_Line",
    "GeometryCHLV03_V1_LineStructure",
    "GeometryCHLV03_V1_LineWithAltitude",
    "GeometryCHLV03_V1_MultiDirectedLine",
    "GeometryCHLV03_V1_MultiLine",
    "GeometryCHLV03_V1_MultiSurface",
    "GeometryCHLV03_V1_Surface",
    "GeometryCHLV03_V1_SurfaceStructure",
    "GeometryCHLV03_V1_SurfaceWithOverlaps2mm",
    "GeometryCHLV95_V1_Area",
    "GeometryCHLV95_V1_AreaWithOverlaps2mm",
    "GeometryCHLV95_V1_Coord2",
    "GeometryCHLV95_V1_Coord3",
    "GeometryCHLV95_V1_DirectedLine",
    "GeometryCHLV95_V1_DirectedLineStructure",
    "GeometryCHLV95_V1_DirectedLineWithAltitude",
    "GeometryCHLV95_V1_Line",
    "GeometryCHLV95_V1_LineStructure",
    "GeometryCHLV95_V1_LineWithAltitude",
    "GeometryCHLV95_V1_MultiDirectedLine",
    "GeometryCHLV95_V1_MultiLine",
    "GeometryCHLV95_V1_MultiSurface",
    "GeometryCHLV95_V1_Surface",
    "GeometryCHLV95_V1_SurfaceStructure",
    "GeometryCHLV95_V1_SurfaceWithOverlaps2mm",
    "GravityRefType",
    "HeaderSection",
    "LegendeTextType",
    "LegendeType",
    "LinesType",
    "LinesType59",
    "LinesType76",
    "LinesType77",
    "LocalisationCH_V1_LocalisedMText",
    "LocalisationCH_V1_LocalisedText",
    "LocalisationCH_V1_MultilingualMText",
    "LocalisationCH_V1_MultilingualText",
    "Localisation_V1_LocalisedMText",
    "Localisation_V1_LocalisedText",
    "Localisation_V1_MultilingualMText",
    "Localisation_V1_MultilingualText",
    "LocalisedBlobType",
    "LocalisedTextType",
    "LocalisedTextType81",
    "LocalisedTextType84",
    "LocalisedTextType85",
    "LocalisedTextType86",
    "Model",
    "Models",
    "NameType",
    "NameType2",
    "NameType4",
    "NameType5",
    "NameType6",
    "NameType87",
    "OeREBKRM_V2_0_Amt",
    "OeREBKRM_V2_0_Amt_Amt",
    "OeREBKRM_V2_0_ArtikelNummer_",
    "OeREBKRM_V2_0_Datum_",
    "OeREBKRM_V2_0_Dokumente",
    "OeREBKRM_V2_0_Dokumente_Dokument",
    "OeREBKRM_V2_0_LocalisedBlob",
    "OeREBKRM_V2_0_LocalisedUri",
    "OeREBKRM_V2_0_MultilingualBlob",
    "OeREBKRM_V2_0_MultilingualUri",
    "OeREBKRM_V2_0_OEREBOID",
    "OeREBKRM_V2_0_ThemaRef",
    "OeREBKRM_V2_0_Thema_",
    "OeREBKRMtrsfr_V2_0_Transferstruktur",
    "OeREBKRMtrsfr_V2_0_Transferstruktur_DarstellungsDienst",
    "OeREBKRMtrsfr_V2_0_Transferstruktur_Eigentumsbeschraenkung",
    "OeREBKRMtrsfr_V2_0_Transferstruktur_Geometrie",
    "OeREBKRMtrsfr_V2_0_Transferstruktur_HinweisVorschrift",
    "OeREBKRMtrsfr_V2_0_Transferstruktur_LegendeEintrag",
    "OffizielleNrType",
    "OidSpace",
    "OidSpaces",
    "POLYLINEType",
    "POLYLINEType48",
    "POLYLINEType49",
    "POLYLINEType50",
    "POLYLINEType51",
    "POLYLINEType52",
    "POLYLINEType55",
    "POLYLINEType58",
    "POLYLINEType62",
    "POLYLINEType65",
    "POLYLINEType66",
    "POLYLINEType67",
    "POLYLINEType68",
    "POLYLINEType69",
    "POLYLINEType72",
    "POLYLINEType75",
    "RoleType",
    "SURFACEType",
    "SURFACEType46",
    "SURFACEType53",
    "SURFACEType56",
    "SURFACEType60",
    "SURFACEType63",
    "SURFACEType70",
    "SURFACEType73",
    "SupervisorType",
    "SupervisorType10",
    "SurfacesType",
    "SurfacesType78",
    "SymbolType",
    "TextImWebType",
    "TitelType",
    "Transfer",
    "UpperLevelUnitType",
    "UpperLevelUnitType1",
    "UpperLevelUnitType3",
    "UpperLevelUnitType8",
    "UpperLevelUnitType9",
    "VerweisWMSType",
    "ZustaendigeStelleType",
    "ZustaendigeStelleType88",
]

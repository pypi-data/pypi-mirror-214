# from novalabs.strategies.macd_strategy import StratBacktest
# from datetime import datetime, timedelta
# import time
# import pandas as pd
# import numpy as np
# from novalabs.utils.helpers import (
#     convert_candle_to_timedelta,
# )

# strategy = StratBacktest(
#     exchange='binance',
#     list_pairs=['BTCUSDT', 'ETHUSDT', 'SOLUSDT', 'XRPUSDT', 'LTCUSDT', 'ADAUSDT', 'EOSUSDT', 'MATICUSDT'],
#     start=datetime(2020, 1, 1),
#     end=datetime(2023, 1, 1),
#     candle="1h",
#     max_holding=timedelta(hours=12),
#     max_pos=2,
#     tp_sl_delta=0.01,
# )

# idx_ = 0
# for pair in strategy.list_pairs:
#     idx_ += 1
#     print(
#         f"BACK TESTING {pair} {idx_} / {len(strategy.list_pairs)}",
#         "\U000023F3",
#         end="\r",
#     )

#     df = strategy.get_historical_data(pair)

#     if len(df) == 0:
#         print(f"No data for {pair} before {strategy.end.strftime('%Y-%m-%d')}")
#         continue

#     df = strategy.build_indicators(df)
#     df = strategy.entry_strategy(df)

#     for col in ["entry_signal", "stop_loss", "take_profit", "position_size"]:
#         assert (
#             col in df.columns
#         ), f"Missing {col} column. Please create this column in entry_strategy()"

#     strategy._verify_tp_sl(df)
#     df = strategy._create_entry_prices_times(df)
#     df = strategy._max_stop_loss(df)
#     df = strategy.exit_strategy(df)

#     assert (
#         "exit_signal" in df.columns
#     ), "Missing exit_signal column. Please create this column in entry_strategy()"

#     df = strategy._create_closest_exit(df)
#     df = strategy._create_all_exit_point(df)
#     strategy._create_position_df(df, pair)
#     print(f"BACK TESTING {pair}", "\U00002705")


# """

# Executing _all_pairs_real_positions step by step to vectorize it !

# """


# for pair in strategy.df_all_positions.keys():
#     df_concat = strategy.df_all_positions[pair]
#     df_concat["pair"] = pair
#     strategy.df_all_pairs_positions = pd.concat(
#         [strategy.df_all_pairs_positions, strategy.df_all_positions[pair]]
#     )


# if len(strategy.df_all_pairs_positions) == 0:
#     raise Exception(
#         "No position has been taken during the whole backtest period"
#     )

# strategy.df_all_pairs_positions = strategy.df_all_pairs_positions[
#     strategy.df_all_pairs_positions["entry_time"] > strategy.start
# ]

# strategy.df_all_pairs_positions = strategy.df_all_pairs_positions.sort_values(
#     by=["exit_time"]
# )

# strategy.df_all_pairs_positions["position_size"] = (
#     strategy.positions_size
#     * strategy.start_bk
#     * strategy.df_all_pairs_positions["position_size"]
# )

# strategy.df_all_pairs_positions = strategy.df_all_pairs_positions.dropna(
#     subset=["exit_price", "PL_amt_realized"]
# )

# # Shift all TP or SL exit time bc it is based on the open time
# candle_duration = convert_candle_to_timedelta(candle=strategy.candle)

# strategy.df_all_pairs_positions["exit_time"] = np.where(
#     strategy.df_all_pairs_positions["exit_point"].isin(["TP", "SL"]),
#     strategy.df_all_pairs_positions["exit_time"] + candle_duration,
#     strategy.df_all_pairs_positions["exit_time"],
# )

# strategy.df_all_pairs_positions = strategy.df_all_pairs_positions.reset_index(drop=True)

# """
# At that moment, we have all the positions that have been generated by all the pairs!
# We need to combine them into a list of possible trades
# """

# sample = strategy.df_all_pairs_positions[['entry_time', 'exit_time']]

# sample['nb_minutes_in_position'] = (sample.exit_time - sample.entry_time).astype(
#     "timedelta64[s]"
# ).astype(int) // 60


# df_count_entry_time = (sample.reset_index()
#                              .groupby('entry_time')
#                              .agg(count_same_entry_time=('entry_time', 'size'),
#                                   original_indexes=('index', list))
#                              .reset_index())

# df_count_exit_time = (sample.reset_index()
#                              .groupby('exit_time')
#                              .agg(count_same_entry_time=('exit_time', 'size'),
#                                   original_indexes=('index', list))
#                              .reset_index())


# frequency = (
#     strategy.candle.replace("m", "min") if "m" in strategy.candle else strategy.candle
# )


# complete = pd.DataFrame()
# complete["open_time"] = pd.date_range(start=strategy.start, end=strategy.end, freq=frequency)

# complete = complete.merge(df_count_entry_time, how='left', left_on='open_time', right_on='entry_time')
# complete = complete.merge(df_count_exit_time, how='left', left_on='open_time', right_on='exit_time')


# complete['count_entry_time'] =complete['count_entry_time'].fillna(0)
# complete['count_exit_time'] =complete['count_exit_time'].fillna(0)

# complete['cum_entry'] =complete['count_entry_time'].cumsum()
# complete['cum_exit'] =complete['count_entry_time'].cumsum()


# complete['all_pos_any_time'] = complete['cum_entry'] - complete['cum_exit']


# # Attempt with Apply
# # sample['prior_exit_times'] = sample.apply(lambda row: sample[
# #     (sample['entry_time'] <= row['entry_time']) &
# #     (sample['exit_time'] > row['entry_time'])
# #     ]['exit_time'].tolist(), axis=1)

# # sample['prior_exit_times_count'] = sample['prior_exit_times'].apply(len)


# # Delete impossible trades
# t = strategy.start
# actual_nb_pos = 0
# exit_times = []
# all_rows_to_delete = pd.DataFrame(columns=strategy.df_all_pairs_positions.columns)
# current_bk = strategy.start_bk

# while t <= strategy.end:

#     if t in exit_times:
#         if strategy.geometric_sizes:
#             # actualize current bankroll
#             current_bk += strategy.df_all_pairs_positions[
#                 strategy.df_all_pairs_positions["exit_time"] == t
#             ]["PL_amt_realized"].sum()

#         # quit positions
#         actual_nb_pos -= exit_times.count(t)
#         exit_times = list(filter(t.__ne__, exit_times))

#     entry_t = strategy.df_all_pairs_positions[
#         strategy.df_all_pairs_positions["entry_time"] == t
#     ]

#     nb_signals = entry_t.shape[0]

#     # Delete rows if actual_nb_pos is over maximum pos
#     if nb_signals + actual_nb_pos > strategy.max_pos:
#         nb_to_delete = nb_signals - (strategy.max_pos - actual_nb_pos)

#         # Select nb_to_delete random positions
#         rows_to_delete = entry_t.sample(n=nb_to_delete)

#         # Delete these positions
#         strategy.df_all_pairs_positions = pd.concat(
#             [strategy.df_all_pairs_positions, rows_to_delete]
#         )
#         strategy.df_all_pairs_positions = (
#             strategy.df_all_pairs_positions.drop_duplicates(keep=False)
#         )

#         all_rows_to_delete = pd.concat([all_rows_to_delete, rows_to_delete])
#         actual_nb_pos = strategy.max_pos

#         # Append exit times
#         real_entry_t = strategy.df_all_pairs_positions[
#             strategy.df_all_pairs_positions["entry_time"] == t
#         ]
#         exit_times += real_entry_t["exit_time"].tolist()

#     elif nb_signals != 0:
#         actual_nb_pos += nb_signals

#         # Append exit times
#         exit_times += entry_t["exit_time"].tolist()

#     # If TP or SL hit during the opening candle
#     if t in exit_times:
#         if strategy.geometric_sizes:
#             # actualize current bankroll
#             current_bk += strategy.df_all_pairs_positions[
#                 strategy.df_all_pairs_positions["exit_time"] == t
#             ]["PL_amt_realized"].sum()

#         # quit positions
#         actual_nb_pos -= exit_times.count(t)
#         exit_times = list(filter(t.__ne__, exit_times))

#     # Compute position size
#     if strategy.geometric_sizes and (nb_signals > 0):
#         strategy.df_all_pairs_positions["position_size"] = np.where(
#             strategy.df_all_pairs_positions["entry_time"] == t,
#             min(current_bk * strategy.positions_size, 50_000),
#             strategy.df_all_pairs_positions["position_size"],
#         )

#         strategy.df_all_pairs_positions["PL_amt_realized"] = np.where(
#             strategy.df_all_pairs_positions["entry_time"] == t,
#             strategy.df_all_pairs_positions["PL_prc_realized"]
#             * strategy.df_all_pairs_positions["position_size"],
#             strategy.df_all_pairs_positions["PL_amt_realized"],
#         )

#     t = t + candle_duration


# # strategy._all_pairs_real_positions()

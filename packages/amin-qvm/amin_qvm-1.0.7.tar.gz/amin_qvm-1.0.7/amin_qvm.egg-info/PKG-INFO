Metadata-Version: 2.1
Name: amin-qvm
Version: 1.0.7
Summary: Amin-QVM: Quantum Computing Library
Home-page: https://github.com/amin1029384756/QVM
Author: Amin Alogaili
Author-email: aminalogai@gmail.com
Keywords: quantum computing library simulation amin alogaili QVM aminalogaili
Classifier: Development Status :: 5 - Production/Stable
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: OS Independent
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.6
Classifier: Programming Language :: Python :: 3.7
Classifier: Programming Language :: Python :: 3.8
Requires-Python: >=3.8
License-File: LICENSE.ttxt

This awesome code allows you to run some mind-boggling quantum stuff that you get from the Quantum Composer. It's all about playing with qubits, gates, and measurements, just like the pros do. You can do cool things like checking out the available qubits, applying gates, and even measuring the results.

You won't believe it, but this code supports 100% of the examples from the IBM tutorial. Yep, every single one. And it's not just limited to that. There are tons of additional tests and examples that you can explore. The whole implementation is pretty compact too, with only 675 lines of code for the 5-qubit quantum computer simulator. Plus, there are twice as many lines dedicated to test programs and examples.

To give you a taste of what you can do, check out this example. You can create a quantum computer object, write some mind-bending code in the Quantum Composer style, and execute it. In this case, we're creating a super cool GHZ state:

.. code-block:: python

   from amin_qvm.QuantumComputer import *

   ghz_example_code = """
   h q[0];
   h q[1];
   x q[2];
   cx q[1], q[2];
   cx q[0], q[2];
   h q[0];
   h q[1];
   h q[2];
   """

   qc = QuantumComputer()
   qc.execute(ghz_example_code)
   Probability.pretty_print_probabilities(qc.qubits.get_quantum_register_containing("q0").get_state())

And voila! It will print out the probabilities of different states. Mind-blowing, right?

You can also dive deeper into the quantum realm by working with individual states and gates directly in pure Python. It's like being a quantum wizard! You can create states, apply gates, and see the magic unfold. Here's an example based on the "Swap Qubits" tutorial from IBM:

.. code-block:: python
   
   # Swap Qubits example IBM tutorial Section IV, Page 2
   qc = QuantumComputer()
   qc.apply_gate(Gate.X, "q2")
   qc.apply_two_qubit_gate_CNOT("q1", "q2")
   qc.apply_gate(Gate.H, "q1")
   qc.apply_gate(Gate.H, "q2")
   qc.apply_two_qubit_gate_CNOT("q1", "q2")
   qc.apply_gate(Gate.H, "q1")
   qc.apply_gate(Gate.H, "q2")
   qc.apply_two_qubit_gate_CNOT("q1", "q2")
   qc.measure("q1")
   qc.measure("q2")
   Probability.pretty_print_probabilities(qc.qubits.get_quantum_register_containing("q1").get_state())

Boom! You'll witness the power of quantum computation as it prints out probabilities and states.

If you're a math nerd and want to explore the mathematical side of things, you can manipulate individual states and gates using the Kronecker product. It's like playing with Lego blocks to create mind-blowing structures. Here's an example based on the same "Swap Qubits" tutorial:

.. code-block:: python

   # Swap Qubits example IBM tutorial Section IV, Page 2
   q1 = State.zero_state
   q2 = State.zero_state
   q2 = Gate.X * q2
   new_state = Gate.CNOT2_01 * np.kron(q1, q2)
   H2_0 = np.kron(Gate.H, Gate.eye)
   H2_1 = np.kron(Gate.eye, Gate.H)
   new_state = H2_0 * new_state
   new_state = H2_1 * new_state
   new_state = Gate.CNOT2_01 * new_state
   new_state = H2_0 * new_state
   new_state = H2_1 * new_state
   new_state = Gate.CNOT2_01 * new_state
   Probability.pretty_print_probabilities(new_state)

Prepare to have your mind blown once again as it displays probabilities and states.

So, whether you're a quantum prodigy or just a curious mind, this code is perfect for unraveling the mysteries of quantum computing. Give it a whirl and explore the wonders of the quantum realm. Have fun!
amin_qvm.functions Module
=========================

This module provides functions for quantum machine learning using Pennylane.

Examples
--------

Training and Testing a Quantum Model
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: python

   import numpy as np
   from amin_qvm.functions import train, test
   
   # Generate training and testing data
   X_train = np.random.rand(100, 2)
   Y_train = np.random.choice([-1, 1], 100)
   X_test = np.random.rand(20, 2)
   Y_test = np.random.choice([-1, 1], 20)
   
   # Train the quantum model
   num_qubits = 2
   num_layers = 4
   num_steps = 100
   params = train(X_train, Y_train, num_qubits, num_layers, num_steps)
   
   # Test the quantum model
   accuracy = test(X_test, Y_test, params, num_qubits)
   print("Accuracy:", accuracy)

Custom Quantum Machine Learning
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: python

   import numpy as np
   from amin_qvm.functions import custom_quantum_machine_learning
   
   # Generate custom training and testing data
   X_train = np.random.rand(100, 2)
   Y_train = np.random.choice([-1, 1], 100)
   X_test = np.random.rand(20, 2)
   Y_test = np.random.choice([-1, 1], 20)
   
   # Perform custom quantum machine learning
   num_qubits = 2
   num_layers = 4
   num_steps = 100
   accuracy = custom_quantum_machine_learning(X_train, Y_train, X_test, Y_test, num_qubits, num_layers, num_steps)
   print("Accuracy (custom):", accuracy)

Grover's Search Algorithm
~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: python

   from amin_qvm.functions import grover_search
   
   # Perform Grover's search
   secret_bitstring = "1010"
   guessed_bitstring = grover_search(secret_bitstring)
   print("Guessed bitstring:", guessed_bitstring)

Deutsch's Algorithm
~~~~~~~~~~~~~~~~~~~
.. code-block:: python

   # Define your own function
   def my_function(x):
       # Modify this function according to your requirements
       return x % 2 == 0

   # Example usage
   result = deutsch(my_function)
   print("The function is:", result)

WARNING: NERDS ONLY
~~~~~~~~~~~~~~~~~~~~~~~~~
Normalizing Quantum States
--------------------------
.. image:: images/equation.png
    :alt: an unnormalized quantum state

Suppose we are given an unnormalized quantum state like the one above.
We can turn this into an equivalent, valid quantum state by normalizing it. This function, given alpha
and beta, normalizes this state to

.. image:: images/equation2.png
   :alt: a normalized quantum state

Suppose we are given the inputs

  alpha = 2.0 + 1.0j
  beta = -0.3 + 0.4j 

The function should return the vector

  np.array([ 0.87287156+0.43643578j, -0.13093073+0.17457431j]) 

which represents the qubit state

.. image:: images/equation3.png
   :alt: The qubit state representation

Here is the code example

.. code-block:: python

   from amin-qvm.functions import normalize_state
   import numpy as np

   ket_0 = np.array([1, 0])
   ket_1 = np.array([0, 1])
   print(normalize_state(ket_0, ket_1))


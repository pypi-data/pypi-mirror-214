import pyperclip


def n0():
    print(r'''
1.Концепция класса и объекта. Принципы и механизмы ООП.
2.Объявление класса, конструктор, создание объектов и одиночное наследование в Python. Управление доступом к атрибутам класса в Python. Полиморфизм и утиная типизация и проверка принадлежности объекта к классу в языке Python.
3.Методы классов и статические переменные и методы в Python. Специальные методы для использования пользовательских классов со стандартными операторами и функциями. Функциональное программирование
4.Основные возможности, поддерживаемые функциональными языками программирования. Поддержка элементов функционального программирования в Python.
5.Концепция «функции – граждане первого класса» в языке программирования, поддержка этой концепции в Python. Специфика лямбда- функций в Python их возможности и ограничения. Типичные сценарии использования лямбда-функций в Python.
6.Глобальные и локальные переменные в функциях на примере Python. Побочные эффекты вызова функций и их последствия.
7.Вложенные функции и замыкания, специфика реализации в Python.
8.Функции высшего порядка и декораторы в Python.
9.Концепция map/filter/reduce. Реализация map/filter/reduce в Python и пример их использования.
10.Итераторы в Python: встроенные итераторы, создание собственных итераторов, типичные способы обхода итераторов и принцип их работы. Встроенные функции для работы с итераторами и возможности модуля itertools. Функции генераторы и выражения генераторы: создание и применение в Python. Оценка сложности. Массивы, стеки, очереди, списки
11.Специфика массивов, как структур данных. Динамические массивы – специфика работы, сложность операций. Специфика работа с array в Python.
12.Абстрактная структура данных стек и очередь: базовые и расширенные операции, их сложность.
13.Специфика реализации и скорости основных операций в очереди на базе массива и связанного списка.
14.Связанные списки: однонаправленные и двунаправленные – принцип реализации. Сравнение скорости выполнения основных операций в связанных списках и в динамическом массиве. Сортировки
15.Алгоритм обменной сортировки, сложность сортировки и возможности по ее улучшению.
16.Алгоритм сортировки выбором, сложность сортировки и возможности по ее улучшению.
17.Алгоритм сортировки вставками, его сложность. Алгоритм быстрого поиска в отсортированном массиве. Сложность поиска в отсортированном и не отсортированном массиве.
18.Алгоритм сортировки Шелла, сложность сортировки и возможности по ее улучшению.
19.Алгоритм быстрой сортировки, сложность сортировки и возможности по ее улучшению.
20.Алгоритм сортировки слиянием, сложность сортировки. Деревья
21.Реализация двоичных деревьев в виде связанных объектов. Различные реализации рекурсивного обхода двоичных деревьев.
22.Двоичное дерево поиска – принципы реализации и логика реализации основных операций.
23.Двоичная куча – принципы реализации и логика реализации основных операций. Хэш-таблицы
24.Абстрактный тип данных - ассоциативный массив и принцип его реализации на основе хэш-таблиц и хэш-функций.
25.Общая схема построения хэш-функции и возможная роль в этой схеме хэш-функции multiply-add-and-divide. Принцип работы хэш-функции multiply-add-and-divide.
26.Полиномиальная хэш-функция – принцип работы, специфика эффективной реализации и специфика применения хэш-функции.
27.Различные методы разрешения коллизий в хэш-таблицах.
''')
    return 0



def n1():
    s=r'''
Класс — в объектно-ориентированном программировании, представляет собой шаблон для создания объектов, обеспечивающий начальные значения состояний: инициализация полей-переменных и реализация поведения функций или методов.
Объект — некоторая сущность в цифровом пространстве, обладающая определённым состоянием и поведением, имеющая определенные свойства (атрибуты) и операции над ними (методы). Как правило, при рассмотрении объектов выделяется то, что объекты принадлежат одному или нескольким классам, которые определяют поведение (являются моделью) объекта. Термины «экземпляр класса» и «объект» взаимозаменяемы.
Парадигма ООП построена на 3 основных принципах:
Инкапсуляция – сокрытие данных, т. е. классы не имеют прямого доступа к полям друг друга, а взаимодействие между ними осуществляется через публичные методы.
Наследование – название говорит само за себя. Дочерний класс наследует свойства и методы родительского, тем самым реализуя повторное использование.
Полиморфизм – это способность одного и того же объекта вести себя по-разному в зависимости от того, в контексте какого класса он используется. Полиморфизм связан с созданием перегружаемых виртуальных методов.

'''
    return pyperclip.copy(s)



def n2():
    s=r'''
Объявление класса
Создание класса в Python начинается с инструкции class. Вот так будет выглядеть минимальный класс.
class C: 
    pass

Класс состоит из объявления (инструкция class), имени класса (нашем случае это имя C) и тела класса, которое содержит атрибуты и методы (в нашем минимальном классе есть только одна инструкция pass).
Конструктор:
•	Конструктор — уникальный метод класса, который называется __init__.
•	Первый параметр конструктора во всех случаях self (ключевое слово, которое ссылается на сам класс).
•	Конструктор нужен для создания объекта.
•	Конструктор передает значения аргументов свойствам создаваемого объекта.
•	В одном классе всегда только один конструктор.
•	Если класс определяется не конструктором, Python предположит, что он наследует конструктор родительского класса.
Создание объектов
Создание объектов в Python довольно простое. Сначала вы указываете имя нового объекта, за которым следует оператор присваивания и имя класса с параметрами (как определено в конструкторе). 
Помните, что количество и тип параметров должны быть совместимы с параметрами, полученными в функции-конструкторе. 
Когда объект создан, могут быть вызваны методы-члены и доступны атрибуты-члены (при условии, что они доступны).

Одиночное наследование 
Одноуровневое наследование позволяет производному классу наследовать характеристики от одного родительского класса.
Управления доступом к атрибутам класса в Python
Управления доступом к атрибутам в Python может осуществляться несколькими способами:
__getattr__  __set__  __getattribute__  __delete__
property
дескриптор
property и дескрипторы применяются к отдельным атрибутам.
Свойства
attribute = property(fget, fset, fdel, doc)
Все аргументы по умолчанию None, при обращение приводят к исключению
Дескрипторы
Протокол дескрипторов позволяет передавать выполнение операций чтения и записи для определенного атрибута методам отдельного обьекта класса.
В отличии от свойств в дескрипторе при отсутствии метода не возникает исключение.
Если не реализован __set__, то атрибут будет просто переопределен
__getattr__ и __getattribute__
__getattr__ -вызывается при обращение к несуществующим атрибутам
__set__ -при присваивании значений
__getattribute__ -вызывается при обращение к любым атрибутам

Делегирования - управление доступом ко всем атрибутам встроенного объекта
функция getattr(self, item) эквивалентна self.item

Полиморфизм и утиная типизация
Полиморфизм - это поддержка нескольких реализаций на основе общего интерфейса.
Другими словами, полиморфизм позволяет перегружать одноименные методы родительского класса в классах-потомках.
Утиная типизация
Утиная типизация – это концепция, характерная для языков программирования с динамической типизацией, согласно которой конкретный тип или класс объекта не важен, а важны лишь свойства и методы, которыми этот объект обладает. Другими словами, при работе с объектом его тип не проверяется, вместо этого проверяются свойства и методы этого объекта. Такой подход добавляет гибкости коду, позволяет полиморфно работать с объектами, которые никак не связаны друг с другом и могут быть объектами разных классов. Единственное условие, чтобы все эти объекты поддерживали необходимый набор свойств и методов.
Проверка принадлежности объекта к классу в языке Python.
Описание:
Функция isinstance() вернет True, если проверяемый объект object является экземпляром указанного класса (классов) или его подкласса (прямого, косвенного или виртуального).
Если объект object не является экземпляром данного типа, то функция всегда возвращает False.
Функцией isinstance() можно проверить класс, кортеж с классами, либо рекурсивный кортеж кортежей. Другие типы последовательностей аргументом classinfo не поддерживаются.
Синтаксис:
isinstance(object, classinfo)
Параметры:
•	object - объект, требующий проверки,
•	classinfo - класс, кортеж с классами или рекурсивный кортеж кортежей или с версии Python 3.10 может быть объединением нескольких типов (например int | str).
Возвращаемое значение:
bool.

'''
    return pyperclip.copy(s)

def n3():
    s=r'''
Методы классов
Методы класса вместо параметра self принимают параметр cls. Этот параметр при вызове метода указывает не на экземпляр объекта, а на класс.
Поскольку метод класса имеет доступ только к аргументу cls, он не может изменять состояние экземпляра объекта. Для этого нужен доступ к self. Но, тем не менее, методы класса могут изменять состояние класса в целом, что затронет и все экземпляры этого класса.
V2:
Метод класса получает первым аргументом ссылку на класс, которую принято называть cls. Такие методы относятся к классам, а значит, могут оперировать статическими атрибутами, но не имеют доступа к объектам.  Они объявляются в теле класса при помощи декораторов @staticmethod и @classmethod соответственно
Статические переменные и методы в Python
Статическая переменная в Python - это переменная, которая объявлена внутри определенного класса, но не в методе. Эту переменную можно вызвать через класс, внутри которого она определена, но не напрямую. Статическая переменная также называется переменной класса. Эти переменные ограничены классом, поэтому они не могут изменить состояние объекта.
Статические методы в python
В Python, статические методы класса отмечаются декоратором @staticmethod, 
Этот тип метода не принимает ни параметра self как метод экземпляра класса, ни параметра cls как метод класса. При этом, конечно, статический метод может принимать произвольное количество других параметров.
Поэтому статический метод не может изменять ни состояние объекта, ни состояние класса. Статические методы ограничены в том, к каким данным они могут получить доступ.

Специальные методы для использования пользовательских классов со стандартными операторами и функциями.
Специальные методы
Методы, имена которых обрамляются __, Python трактует как специальные, например, __init__ (инициализация) или __str__ (строковое представление). Специальные методы, как правило, идут первыми при объявлении класса.

'''
    return pyperclip.copy(s)


def n4():
    s=r'''
Основные возможности, поддерживаемые функциональными языками программирования

•	Чистые функции — функциональное программирование использует чистые функции. Это функции, которые не изменяются, дают надёжные результаты и всегда дают одинаковый результат для одного и того же ввода. Они не вызывают неожиданных результатов или побочных эффектов и абсолютно предсказуемы независимо от внешнего кода.
•	Неизменяемость — это принцип, согласно которому после того, как вы установили значение для чего-либо, это значение не изменится. Это устраняет побочные эффекты или неожиданные результаты, поскольку программа не зависит от состояния. Таким образом, функции всегда работают одинаково при каждом запуске; это чистые функции.
•	Дисциплинированное состояние — новые ценности могут быть созданы, поэтому есть некоторые состояния, которые могут измениться в этом смысле, но это глубоко контролируемый процесс. Функциональное программирование стремится избежать общего состояния и изменчивости. Если состояние жёстко контролируется, его легче масштабировать и отлаживать, и вы получаете менее неожиданные результаты.
•	Ссылочная прозрачность — этот принцип основан на сочетании чистых функций и неизменности. Поскольку наши функции чисты и предсказуемы, мы можем использовать их для замены переменных и, следовательно, уменьшить количество выполняемых назначений. Если результат функции будет равен переменной, поскольку наши результаты предсказуемы, мы можем просто заменить переменную этой функцией.
•	Функции первого класса — этот принцип прост. Функциональное программирование очень высоко ценит определённые функции, функции первого класса. Следовательно, он поддерживает передачу целых функций между собой так же легко, как другие языки с переменными. Эти функции можно рассматривать как значения или данные в функциональном программировании.
•	Системы типов — поскольку функциональное программирование так сосредоточено на точности и предотвращении ошибок. Наличие статически типизированной системы имеет смысл. Это необходимо для того, чтобы убедиться, что каждый тип данных назначен правильно, строки — это строки, а числа с плавающей запятой — это числа с плавающей запятой, и предотвращает использование непредсказуемых переменных.

Поддержка элементов функционального программирования в Python
Lamda функция
Встроенные функции высших порядков(функции первого класса):
map()
Принимает функцию-аргумент и применяет её ко всем элементам входящей последовательности.
filter()
Как следует из названия, filter() фильтрует последовательность по заданному условию.
apply()
Применяет входящую функцию к позиционным и именованным аргументам. Эти аргументы задаются списком и словарём соответственно.
zip()
Упаковывает итерируемые объекты в один список кортежей. При работе ориентируется на объект меньшей длины:
Модуль functools
Functools — это библиотека, которая содержит дополнительные функции высших порядков.
reduce()
Принимает функцию и последовательность. Запускает цепь вычислений, применяя функцию ко всем элементам последовательности. Сводит набор к единственному значению.
partial()
Функция служит для частичного назначения аргументов. На входе и на выходе — тоже функции.
cmp_to_key()
Возвращает ключевую функцию для компарации объектов.
update_wrapper()
Используется для обновления метаданных функции-обертки, данными из некоторых атрибутов оборачиваемой функции. Обеспечивает лучшую читаемость и возможность повторного использования кода.
@lru_cache
lru_cache — это декоратор. То есть "обёртка", которая может изменить поведение функции, не меняя её код. Lru_cache даёт выбранной функции кэширование, чтобы фиксировать результаты тяжеловесных вычислений, запросов или других операций.


'''
    return pyperclip.copy(s)


def n5():
    s=r'''
Концепция «функции – граждане первого класса» в языке программирования, поддержка этой концепции в Python
   Концепция «функции – граждане первого класса» в языке программирования
Функции в языке программирования считаются гражданами первого класса, если они демонстрируют следующие характеристики.
•	Их можно хранить в переменных.
•	Их можно хранить в структурах данных.
•	Их можно пропустить как аргумент к функции.
•	Они могут быть возвращены как значения из другой функции.

поддержка этой концепции в Python
Это означает, что функции можно динамически создвать и уничтожать, передвать их в другие функции, возвращать их как значения и так далее.
Python поддерживает все эти функции, чтобы функции рассматривались как граждане первого класса.
def logger(msg):
    def message():
        print('Log:', msg)
    return message
logWarning = logger('Warning')
logWarning()

Специфика лямбда-функций в Python их возможности и ограничения.
Лямбда-функция — это небольшая анонимная функция, которая принимает любое количество аргументов, но имеет только одно выражение. Лямбда-функции возвращают объект, который назначен переменной или используется как часть других функций.
Лямбда-выражения отличаются от обычных определений функций по нескольким причинам. В частности, лямбда-функции ограничены одним выражением, поэтому они не могут использовать операторы или аннотации.
Когда дело доходит до значений, возвращаемых из лямбда-выражений, всегда есть неявный оператор возврата. Лямбда-функции оценивают выражение и автоматически возвращают результат.

Типичные сценарии использования лямбда-функций в Python.
Когда функция имеет только одно выражение. 
Для повторяющихся задач, носящих временный характер.


'''
    return pyperclip.copy(s)



def n6():
    s=r'''
Глобальные переменные
В Python переменная, объявленная вне функции или в глобальной области видимости, называется глобальной переменной. К глобальной переменной можно получить доступ как внутри, так и вне функции.
x = "глобальная переменная"
def foo():
    print("x внутри функции:", x)
foo()
print("x вне функции:", x)
Вывод: 
x внутри функции: глобальная переменная
x вне функции: глобальная переменная
Локальные переменные
Переменная, объявленная внутри тела функции или в локальной области видимости, называется локальной переменной.

def foo():
    y = "локальная переменная"
    print(y)
foo()
Вывод:
локальная переменная

Побочные эффекты вызова функций и их последствия
побочные эффекты — это наблюдаемые последствия вызова функции, не относящиеся к возвращаемому результату.
Есть такие функции, которые при вызове меняют файлы и таблицы баз данных, отправляют данные на сервер или модифицируют глобальные переменные. Всё это — побочные эффекты.

'''
    return pyperclip.copy(s)



def n7():
    s=r'''
Вложенные (или внутренние, англ. inner, nested) функции – это функции, которые мы определяем внутри других функций. В Python такая функция имеет прямой доступ к переменным и именам, определенным во включающей её функции. Вложенные функции имеют множество применений, в первую очередь для создания замыканий и декораторов.
Замыкание — это комбинация функции и множества ссылок на переменные в области видимости функции. Последнее иногда называют ссылочной средой. Замыкание позволяет выполнять функцию за пределами области видимости. В Python ссылочная среда хранится в виде набора ячеек. Доступ к ним можно получить с помощью атрибутов func_closure или __closure__. В Python 3 используется только __closure__

в Python вложенные функции имеют прямой доступ к переменным и именам, которые вы определяете во включающей функции. Это предоставляет механизм для инкапсуляции функций, создания вспомогательных решений, реализации замыканий и декораторов.

'''
    return pyperclip.copy(s)



def n8():
    s=r'''
Функция высшего порядка – это функция, которая может принимать в качестве аргумента другую функцию и/или возвращать функцию как результат работы. Так как в Python функции – это объекты первого класса, то они являются HOF, это свойство активно используется при разработке программного обеспечения. 

К встроенным функциям высшего порядка, которые можно использовать без импорта каких-либо библиотек, относятся map и filter.
Функция map принимает функцию и итератор, возвращает итератор, элементами которого являются результаты применения функции к элементам входного итератора.
Функция filter принимает функцию предикат и итератор, возвращает итератор, элементами которого являются данные из исходного итератора, для которых предикат возвращает True.

Модуль functools
Модуль functools предоставляет набор декораторов и HOF функций, которые либо принимают другие функции в качестве аргумента, либо возвращают функции как результат работы.

HOF функции

Partial
Функция partial создает частично примененные функции (см. “Функция как возвращаемое значение. Каррирование, замыкание, частичное применение”). Суть идеи в том, что если у функции есть несколько аргументов, то можно создать на базе нее другую, у которой часть аргументов будут иметь заранее заданные значения.

Прототип:

partial(func, /, *args, **keywords)
Параметры:
func - Функция, для которой нужно построить частично примененный вариант.
args - Позиционные аргументы функции.
keywords - Именованные аргументы функции.
partialmethod - Инструмент, аналогичный по своему назначению функции partial(), применяется для методов классов.

Прототип:
class partialmethod(func, /, *args, **keywords)

Параметры:

func
Метод класса, для которого нужно построить частично примененный вариант.
args
Позиционные аргументы метода.
keywords
Именованные аргументы метода.

Reduce - Сворачивает переданную последовательность с помощью заданной функции. Прототип функции:
reduce(function, iterable[, initializer])

Параметры:
function - Функция для свертки исходной последовательности, должна принимать два аргумента.
iterable - Последовательность для свертки (итератор).
initializer - Начальное значение, которое будет использоваться для сверки. Если значение не задано, то в качестве начального будет выбран первый элемент из итератора.

Декоратор — это функция, которая позволяет обернуть другую функцию для расширения её функциональности без непосредственного изменения её кода. 
def param_transfer(fn):
   def wrapper(arg):
       print("Run function: " + str(fn.__name__) + "(), with param: " + str(arg))
       fn(arg)
   return wrapper
@param_transfer
def print_sqrt(num):
   print(num**0.5)


'''
    return pyperclip.copy(s)



def n9():
    s=r'''
В Python функция map принимает два аргумента: функцию и аргумент составного типа данных, например, список. map применяет к каждому элементу списка переданную функцию. Например, вы прочитали из файла список чисел, изначально все эти числа имеют строковый тип данных, чтобы работать с ними - нужно превратить их в целое число:
old_list = ['1', '2', '3', '4', '5', '6', '7']
new_list = list(map(int, old_list))
print (new_list)
[1, 2, 3, 4, 5, 6, 7]

Функция filter() в Python:
Функция filter предлагает элегантный вариант фильтрации элементов последовательности. Принимает в качестве аргументов функцию и последовательность, которую необходимо отфильтровать:

mixed = ['мак', 'просо', 'мак', 'мак', 'просо', 'мак', 'просо', 'просо', 'просо', 'мак']
zolushka = list(filter(lambda x: x == 'мак', mixed))
print (zolushka)
['мак', 'мак', 'мак', 'мак', 'мак']

Функция reduce() в Python:
Функция reduce принимает 2 аргумента: функцию и последовательность. reduce() последовательно применяет функцию-аргумент к элементам списка, возвращает единичное значение.  «в Python 2.x функция reduce доступна как встроенная, в то время, как в Python 3 она была перемещена в модуль functools.»

Вычисление суммы всех элементов списка при помощи reduce:
from functools import reduce
items = [1,2,3,4,5]
sum_all = reduce(lambda x,y: x + y, items)
print (sum_all) 
15

'''
    return pyperclip.copy(s)



def n10():
    s=r'''
Итерируемый тип данных - это такой тип, который может возвращать свои элементы по одному. Любой объект, имеющий метод __iter__() , или любая последовательность (то есть объект, имеющий метод__getitem__() , принимающий целочисленный аргумент со значением от 0 и выше), является итерируемым и может предоставлять итератор.
Итератор - это объект, имеющий метод __next__() , который при каждом вызове возвращает очередной элемент и возбуждает исключение StopIteration после исчерпания всех элементов.

создания собственных итераторов
Самый простой способ создания собственных итераторов в Python — это создание генератора.
squares = (n**2 for n in favorite_numbers)

обойти итератор
Самый простой способ обойти итератор – использовать цикл for. Мы можем получить доступ к каждому элементу в итераторе, используя цикл for следующим образом.
myList = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
myIter = iter(myList)
print("list is:", myList)
print("Elements in the iterator are:")
for element in myIter:
    print(element)

Другой способ получить доступ к элементам итератора – использовать функцию next (). Функция next () принимает итератор в качестве входных данных и возвращает следующий элемент, который еще не был пройден, как и метод __next __ ().

myList = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
myIter = iter(myList)
print("list is:", myList)
print("Elements in the iterator are:")
try:
    print(next(myIter))
    print(next(myIter))
    print(next(myIter))
    print(next(myIter))
except StopIteration as e:
    print("All elements in the iterator already traversed. Raised exception", e)

Встроенные функции для работы с итераторами
Две встроенные функции Python, map() и filter(), дублируют функциональность выражения-генератора:

Встроенной функцией map(f, iterA, iterB, ...) можно заменить цикл for/in, так как она применяет функцию f() ко всем переданным итераторам (по сути, в цикле, тоже выполняются какие-то действия с каждым элементом), и следовательно возвращает итератор значений f(iterA[0], iterB[0]), f(iterA[1], iterB[1]), f(iterA[2], iterB[2]),

Встроенная функция filter(predicate, iter) возвращает итератор по всем элементам последовательности, которые удовлетворяют определенному условию, и аналогичным образом дублируется при составлении списков. Аргумент predicate - это функция, которая принимает одно значение итерации iter, что-то с ним делать, и в итоге должна возвращать значение bool. Возвращаемое значение True будет говорить функции filter() пропустить значение, False - отбросить.

возможности модуля itertools
Бесконечные итераторы.
Модуль itertools поставляется с тремя итераторами, которые могут повторяться бесконечно. Это означает, что при их использовании необходимо понимать, что в конце концов нужно будет как то выходить из этих итераторов, иначе будет бесконечный цикл..
Итератор itertools.count() будет возвращать равномерно распределенные значения, начиная с числа, которое передается в качестве начального параметра start; этот итератор также принимает параметр шага step.
Итератор itertools.cycle() позволяет создать итератор, который будет бесконечно циклически перебирать серию значений.
Итератор itertools.repeat() будет возвращать переданный объект (например словарь, список и т.д. ) снова и снова (бесконечно), если НЕ установить аргумент times, который отвечает за количество повторений.

Конечные итераторы.
Итератор itertools.accumulate() возвращает накопленные суммы (по умолчанию) или накопленные результаты функции, которую можно передать в качестве второго аргумента. По умолчанию для накопления используется сложение:
Итератор itertools.chain() берет серию итераций и, по сути, "сглаживает" их в одну общую итерацию.

Комбинаторные итераторы.
Модуль itertools содержит четыре итератора, которые можно использовать для создания комбинаций и перестановок данных.
Функция itertools.combinations() позволяет создать итератор со всеми возможными комбинациями элементов входной последовательности.
Итератор itertools.combinations_with_replacement() похож на itertools.combinations(). Единственное отличие заключается в том, что он фактически будет создавать комбинации, в которых элементы действительно повторяются.
Функция itertools.product() предназначена для создания декартовых произведений из серии входных итераций.
Функция itertools.permutations() будет возвращать последовательные перестановки элементов указанной длины из итерации, которая передается в качестве аргумента. Подобно функции itertools.combinations(), перестановки выдаются в лексикографическом порядке сортировки.

Функции генераторы и выражения генераторы: создание и применение в Python.
Функции-генераторы
Функции-генераторы отличаются от обычных функций тем, что в них есть один или несколько операторов yield.
Создать генератор на Python довольно просто. Он похож на обычную функцию, определяемую ключевым словом def, и использует ключевое слово yield вместо return. Или мы можем сказать, что если тело любой функции содержит оператор yield, он автоматически становится функцией-генератором. Рассмотрим следующий пример:
def simple(): 
for i in range(10): 
    if(i%2==0): 
         yield i 
for i in simple(): 
    print(i) 

Генератор выражения
Мы можем легко создать выражение генератора без использования пользовательской функции. Это то же самое, что и лямбда-функция, которая создает анонимную функцию; выражения генератора создают анонимную функцию генератора.

Представление выражения генератора похоже на понимание списка Python. Единственное отличие состоит в том, что квадратные скобки заменены круглыми скобками. Понимание списка вычисляет весь список, тогда как выражение генератора вычисляет один элемент за раз.
# Generator expression 
a =(x**3 for x in list) 

'''
    return pyperclip.copy(s)



def n11():
    s=r'''
В классических языках, требуется указывать размер массива и тип данных. 
В Питоне нет структуры данных, полностью соответствующей массиву. Однако, есть списки, которые являются их надмножеством, то есть это те же массивы, но с расширенным функционалом. Эти структуры удобнее в использовании, но цена такого удобства, как всегда, производительность и потребляемые ресурсы. И массив, и список – это упорядоченные коллекции, но разница между ними заключается в том, что классический массив должен содержать элементы только одного типа, а список Python может содержать любые элементы.

Динамический массив похож на массив, но с той разницей, что его размер можно динамически изменять во время выполнения. Не нужно заранее указывать размер массива. Элементы массива занимают непрерывный блок памяти, и после создания его размер не может быть изменен. После заполнения динамический массив может выделить больший кусок памяти, скопировать содержимое из исходного массива в это новое пространство и продолжить заполнять доступные слоты.

Модуль array. Массивы в python
Модуль array определяет массивы в python. Массивы очень похожи на списки, но с ограничением на тип данных и размер каждого элемента.
Размер и тип элемента в массиве определяется при его создании 
Класс array.array(TypeCode [, инициализатор]) — новый массив, элементы которого ограничены TypeCode, и инициализатор, который должен быть списком, объектом, который поддерживает интерфейс буфера, или итерируемый объект.
array.typecodes — строка, содержащая все возможные типы в массиве.
Массивы изменяемы. Массивы поддерживают все списковые методы (индексация, срезы, умножения, итерации), и другие методы

'''
    return pyperclip.copy(s)


def n12():
    s=r'''
Стек в Python – это линейная структура данных, в которой данные расположены объектами друг над другом. Он хранит данные в режиме LIFO (Last in First Out). Данные хранятся в том же порядке, в каком на кухне тарелки располагаются одна над другой. Мы всегда выбираем последнюю тарелку из стопки тарелок. В стеке новый элемент вставляется с одного конца, и элемент может быть удален только с этого конца.
empty() – возвращает истину, если стек пуст. Временная сложность O (1).
size() – возвращает длину. Временная сложность O (1).
top() – этот метод возвращает адрес последнего элемента. Временная сложность O (1).
push(g) – метод добавляет элемент ‘g’ в конец стека – временная сложность составляет O (1).
pop() – удаляет самый верхний элемент. Временная сложность O (1).

Очередь в Python – это линейный тип структуры данных, используемый для последовательного хранения данных. Ее концепция основана на FIFO (“First in First Out”), что означает «первым пришел – первым обслужен». Или так: «первым пришел – первый вышел». Очередь имеет два конца – спереди и сзади. Следующий элемент вставляется с заднего конца и снимается с переднего конца.

Enqueue – постановка в очередь – операция, которая добавляет элементы. Является условием, если очередь заполнена. Временная сложность постановки составляет O (1).
Dequeue – это операция, при которой мы удаляем элемент из очереди. Он удаляется в том же порядке, в котором был вставлен. Если очередь пуста, это является условием потери значимости. Временная сложность составляет O (1).
Front – элемент вставлен в переднюю часть. Временная сложность – O (1).
Rear – элемент удален из задней части. Временная сложность задней части O (1).

'''
    return pyperclip.copy(s)



def n13():
    s=r'''
Очередь - это структура данных, которая обеспечивает выполнение операций вставки (enqueue) и удаления (dequeue) элементов в определенном порядке. Существуют различные способы реализации очереди, включая массив и связанный список.

Реализация очереди на базе массива:

Вставка (enqueue): При вставке элемента в очередь на базе массива необходимо увеличить размер массива, если текущий массив полностью заполнен. Затем новый элемент помещается в конец очереди. В среднем, операция вставки в очередь на базе массива занимает O(1) времени, но если массив полностью заполнен и требуется изменение его размера, операция может занять O(n) времени, где n - текущий размер массива.

Удаление (dequeue): При удалении элемента из очереди на базе массива, элемент из начала очереди удаляется, а все остальные элементы сдвигаются влево, чтобы заполнить пустое место. Это также может потребовать O(n) времени в худшем случае, где n - текущий размер очереди, так как все элементы могут потребоваться для сдвига.

Реализация очереди на базе связанного списка:

Вставка (enqueue): При вставке элемента в очередь на базе связанного списка создается новый узел, содержащий элемент, и этот узел добавляется в конец списка. Вставка элемента в связанный список занимает O(1) времени, поскольку нет необходимости в перемещении других элементов.

Удаление (dequeue): При удалении элемента из очереди на базе связанного списка, ссылка на первый узел обновляется, чтобы указывать на следующий узел в списке, и первый узел удаляется. Операция удаления также занимает O(1) времени, поскольку нет необходимости в перемещении других элементов.

Скорость операций в очереди на базе массива и связанного списка зависит от контекста и специфических условий использования. В общем случае, операции вставки и удаления в очереди на базе связанного списка выполняются быстрее, чем в очереди на базе массива, особенно если требуется изменение размера массива. Однако, для небольших очередей, где изменение размера массива не является проблемой, использование массива может быть эффективным.
'''
    return pyperclip.copy(s)


def n14():
    s=r'''
Связанный список - это структура данных, состоящая из узлов, каждый из которых содержит элемент данных и ссылку на следующий узел (или предыдущий и следующий узлы для двунаправленного списка). Однонаправленный связанный список имеет ссылку только на следующий узел, а двунаправленный связанный список имеет ссылку на предыдущий и следующий узлы.

Принцип реализации однонаправленного связанного списка:
- Каждый узел состоит из двух частей: элемента данных и ссылки на следующий узел.
- Узлы связываются между собой с помощью ссылок, где последний узел имеет ссылку на NULL (или на пустое значение).
- Для вставки элемента в список нужно создать новый узел, установить ссылку предыдущего узла на новый узел и ссылку нового узла на следующий узел.
- Для удаления узла необходимо перенаправить ссылку предыдущего узла на следующий узел, игнорируя удаляемый узел.

Принцип реализации двунаправленного связанного списка:
- Каждый узел содержит элемент данных и ссылки на предыдущий и следующий узлы.
- Узлы связываются между собой с помощью ссылок в обоих направлениях.
- Для вставки элемента создается новый узел, устанавливаются ссылки предыдущего и следующего узлов на новый узел, а также ссылки нового узла на предыдущий и следующий узлы.
- Для удаления узла нужно обновить ссылки соседних узлов, чтобы обойти удаляемый узел.

Сравнение скорости выполнения основных операций в связанных списках и динамическом массиве:
- Вставка элемента: В однонаправленном и двунаправленном связанных списках вставка элемента требует создания нового узла и переустановки ссылок, что занимает O(1) времени. В динамическом массиве вставка элемента в конец массива также занимает O(1) времени. Однако, если требуется вставка в середину массива, все элементы, следующие за вставляемым элементом, должны быть сдвинуты, что занимает O(n) времени, где n - количество элементов в массиве.
- Удаление элемента: В связанных списках удаление элемента требует обновления ссылок на узлы, что занимает O(1) времени. В дин

амическом массиве удаление элемента также занимает O(n) времени, так как все элементы, следующие за удаляемым элементом, должны быть сдвинуты, чтобы заполнить пустое место.
- Доступ к элементу: В связанных списках доступ к элементу требует последовательного перехода по узлам, что занимает O(n) времени в худшем случае, где n - позиция элемента в списке. В динамическом массиве доступ к элементу выполняется за O(1) времени, так как элементы массива расположены последовательно в памяти и доступ осуществляется по индексу.

В целом, связанные списки обеспечивают быстрое выполнение операций вставки и удаления, особенно в начале списка, но требуют последовательного прохода по узлам для доступа к элементам. Динамические массивы обеспечивают быстрый доступ к элементам, но могут быть неэффективными при частых операциях вставки и удаления в середине массива. Выбор между ними зависит от конкретных требований и характеристик использования структуры данных.
'''
    return pyperclip.copy(s)



def n15():
    s=r'''
Алгоритм обменной сортировки, также известный как сортировка пузырьком (Bubble Sort), является простым алгоритмом сортировки, который работает путем последовательного сравнения и обмена соседних элементов, пока массив не будет полностью отсортирован. Вот основные шаги алгоритма:

1. Проход по массиву от начала до конца.
2. Сравнение каждой пары соседних элементов.
3. Если порядок пары элементов неправильный (больший элемент перед меньшим), то происходит обмен этих элементов.
4. Повторение шагов 1-3 до тех пор, пока массив не будет полностью отсортирован (в каждой итерации самый большой элемент "всплывает" в конец массива).

Сложность сортировки пузырьком:
- В лучшем случае, когда массив уже отсортирован, алгоритм требует только одного прохода по массиву для проверки, что элементы находятся в правильном порядке. В таком случае сложность составляет O(n), где n - количество элементов в массиве.
- В худшем случае, когда массив отсортирован в обратном порядке, алгоритм выполняет n итераций, где n - количество элементов в массиве. Каждая итерация требует сравнения и, при необходимости, обмена соседних элементов. Таким образом, сложность составляет O(n^2).
- В среднем случае алгоритм также имеет сложность O(n^2).

Улучшение алгоритма обменной сортировки:
- Одним из способов улучшения сортировки пузырьком является введение флага, который указывает, были ли обмены элементов на текущей итерации. Если в ходе прохода по массиву не было обменов, то можно считать, что массив уже отсортирован, и алгоритм может быть прекращен. Это позволяет уменьшить количество операций в лучшем случае, когда массив уже отсортирован, и в случаях, когда массив частично отсортирован.
- Другим способом улучшения является оптимизация алгоритма путем добавления переменной, которая хранит индекс последнего обмена на каждой итерации. Это позволяет сократить количество сравнений в следующей итерации, поскольку элементы после последнего обмена уже находятся в правильном порядке.

Важно от

метить, что сортировка пузырьком не является эффективным алгоритмом для больших массивов или в случае, когда требуется высокая производительность. В таких случаях следует рассмотреть использование более эффективных алгоритмов сортировки, таких как быстрая сортировка (QuickSort) или сортировка слиянием (Merge Sort).
'''
    return pyperclip.copy(s)



def n16():
    s=r'''
Алгоритм сортировки выбором (Selection Sort) - это простой алгоритм сортировки, который работает путем нахождения наименьшего элемента в неотсортированной части массива и обмена его с первым элементом неотсортированной части. Затем граница между отсортированной и неотсортированной частью сдвигается, и процесс повторяется до полной сортировки массива. Вот основные шаги алгоритма:

1. Ищем наименьший элемент в неотсортированной части массива.
2. Обмениваем найденный наименьший элемент с первым элементом неотсортированной части.
3. Сдвигаем границу между отсортированной и неотсортированной частью массива.
4. Повторяем шаги 1-3 до тех пор, пока весь массив не будет отсортирован.

Сложность сортировки выбором:
- В худшем, лучшем и среднем случаях сложность сортировки выбором составляет O(n^2), где n - количество элементов в массиве. Это потому, что на каждой итерации необходимо просмотреть оставшуюся неотсортированную часть массива для поиска наименьшего элемента.
- Алгоритм сортировки выбором не является адаптивным и не учитывает изначальный порядок элементов или частичную отсортированность массива.

Улучшение алгоритма сортировки выбором:
- В некоторых случаях можно улучшить алгоритм сортировки выбором путем оптимизации процесса обмена элементов. Вместо обмена элементов на каждой итерации можно сохранять индекс наименьшего элемента и выполнять обмен только после прохода по всей неотсортированной части массива. Это позволяет сократить количество операций обмена и улучшить производительность алгоритма.
- Также можно рассмотреть использование других более эффективных алгоритмов сортировки, таких как быстрая сортировка (QuickSort) или сортировка слиянием (Merge Sort), для достижения лучшей производительности при сортировке больших массивов.
'''
    return pyperclip.copy(s)



def n17():
    s=r'''
Алгоритм сортировки вставками (Insertion Sort) - это простой алгоритм сортировки, который работает путем вставки каждого элемента на правильное место в уже отсортированной части массива. Вот основные шаги алгоритма:

1. Начинаем с предположения, что первый элемент массива уже отсортирован.
2. Берем следующий элемент из неотсортированной части массива и вставляем его на правильное место в отсортированной части массива.
3. Повторяем шаг 2 для всех оставшихся элементов, расширяя отсортированную часть массива на каждой итерации.

Сложность сортировки вставками:
- В худшем, лучшем и среднем случаях сложность сортировки вставками составляет O(n^2), где n - количество элементов в массиве. Это потому, что для каждого элемента нужно просмотреть все предыдущие элементы в отсортированной части массива, чтобы найти правильное место для вставки.

Алгоритм быстрого поиска в отсортированном массиве (Binary Search) - это эффективный алгоритм поиска, который работает на основе принципа "разделяй и властвуй". Он ищет заданное значение путем последовательного деления отсортированного массива на две части и сравнения значения с серединным элементом. Вот основные шаги алгоритма:

1. Задаем левую и правую границы для поиска (обычно начало и конец массива).
2. Находим середину массива путем деления суммы левой и правой границы на 2.
3. Сравниваем искомое значение с элементом, находящимся в середине.
4. Если искомое значение равно серединному элементу, поиск завершен.
5. Если искомое значение меньше серединного элемента, повторяем шаги 1-4 для левой половины массива.
6. Если искомое значение больше серединного элемента, повторяем шаги 1-4 для правой половины массива.
7. Повторяем шаги 1-6 до тех пор, пока не будет найден искомый элемент или границы поиска не сойдутся.

Сложность поиска в отсортированном и неотсортированном массиве:
- В отсортированном массиве сложность бинарного поиска составляет O(log n), где n - количество элементов в массиве. Это потому, что на каждой итерации размер поискового пространства у

меньшается вдвое.
- В неотсортированном массиве применение бинарного поиска неэффективно, так как требуется отсортированное поисковое пространство. В таком случае использование линейного поиска имеет сложность O(n), где n - количество элементов в массиве, так как может потребоваться проверка всех элементов для нахождения искомого значения.
'''
    return pyperclip.copy(s)



def n18():
    s=r'''
Алгоритм сортировки Шелла (Shell Sort) является усовершенствованным вариантом сортировки вставками. Он использует идею сортировки вставками, но вместо сравнения и перестановки соседних элементов, сортировка Шелла сравнивает и переставляет элементы, находящиеся на определенном расстоянии друг от друга. Постепенно уменьшая это расстояние, алгоритм перемещает элементы к их окончательным позициям и, наконец, выполняет обычную сортировку вставками. Вот основные шаги алгоритма:

1. Определяем интервалы сортировки, начиная с большого значения и постепенно уменьшая его.
2. Для каждого интервала выполняем сортировку вставками, где элементы сравниваются и переставляются на заданное расстояние.
3. Повторяем шаг 2 до тех пор, пока не достигнем интервала 1, то есть выполним обычную сортировку вставками.

Сложность сортировки Шелла:
Сложность сортировки Шелла зависит от выбора последовательности интервалов. Лучшая известная последовательность интервалов для сортировки Шелла имеет сложность n log^2(n), где n - количество элементов в массиве. Хотя это хуже, чем некоторые более эффективные алгоритмы сортировки, такие как быстрая сортировка или сортировка слиянием, сортировка Шелла все же является улучшением по сравнению с сортировкой вставками.

Улучшение сортировки Шелла:
Сортировка Шелла может быть улучшена путем выбора более эффективной последовательности интервалов. Существует множество различных последовательностей интервалов, которые могут быть использованы, и некоторые из них обеспечивают лучшую производительность. Некоторые известные последовательности интервалов, такие как последовательность Седжвика или последовательность Пратта, могут обеспечить лучшую сложность сортировки Шелла. Экспериментирование с различными последовательностями интервалов может привести к улучшению производительности алгоритма.
'''
    return pyperclip.copy(s)



def n19():
    s=r'''
Алгоритм быстрой сортировки (QuickSort) является одним из наиболее эффективных алгоритмов сортировки. Он использует принцип "разделяй и властвуй" для сортировки массива путем выбора опорного элемента, разделения массива на две части: элементы, меньшие опорного, и элементы, большие опорного, и рекурсивной сортировки этих двух подмассивов. Вот основные шаги алгоритма:

1. Выбираем опорный элемент из массива. Обычно в качестве опорного выбирают первый, последний или случайный элемент.
2. Разделяем массив на две части: элементы, меньшие опорного, и элементы, большие опорного.
3. Рекурсивно применяем быструю сортировку к обеим частям массива.
4. Объединяем отсортированные подмассивы в один отсортированный массив.

Сложность быстрой сортировки:
- В худшем случае сложность быстрой сортировки составляет O(n^2), где n - количество элементов в массиве. Это происходит, когда на каждом шаге выбирается опорный элемент, являющийся крайним минимальным или максимальным элементом, и массив делится на две части неравных размеров.
- В среднем случае быстрая сортировка имеет сложность O(n log n), что делает ее очень эффективной. В этом случае массив разделяется на две примерно равные части на каждом шаге.

Улучшение быстрой сортировки:
- Выбор опорного элемента: Выбор опорного элемента влияет на эффективность алгоритма. Хорошим подходом является выбор случайного опорного элемента, чтобы снизить вероятность попадания на крайние значения и обеспечить более равномерное разделение массива.
- Оптимизация разделения: Можно использовать различные методы разделения, такие как схема "три элемента" (median-of-three), которая выбирает медиану из первого, среднего и последнего элементов в качестве опорного элемента. Это может помочь избежать худшего случая сортировки и повысить производительность.
- Оптимизация для малых подмассивов: При достаточно малых подмассивах использование других алгоритмов сортировки, таких как сортировка вставками или сортировка пузы

рьком, может быть более эффективным, чем рекурсивное применение быстрой сортировки. Это помогает избежать излишних рекурсивных вызовов.
- Оптимизация стека вызовов: Вместо рекурсивной реализации можно использовать итеративный алгоритм, использующий стек или очередь для хранения информации о подмассивах. Это может уменьшить потребление памяти и улучшить производительность.
'''
    return pyperclip.copy(s)



def n20():
    s=r'''
Алгоритм сортировки слиянием (Merge Sort) является эффективным алгоритмом сортировки, который использует принцип "разделяй и властвуй". Он разбивает массив на две половины, рекурсивно сортирует каждую половину, а затем объединяет отсортированные половины в один отсортированный массив. Вот основные шаги алгоритма:

1. Разделяем исходный массив на две равные части.
2. Рекурсивно сортируем каждую половину массива, применяя сортировку слиянием.
3. Объединяем отсортированные половины, сравнивая элементы в каждой половине и помещая их в правильный порядок в новый массив.
4. Повторяем шаги 2-3 до тех пор, пока не получим полностью отсортированный массив.

Сложность сортировки слиянием:
Сложность сортировки слиянием во всех случаях (лучший, худший, средний) составляет O(n log n), где n - количество элементов в массиве. Это делает его одним из самых эффективных алгоритмов сортировки. Независимо от размера массива, сортировка слиянием всегда выполняется за время, пропорциональное n*log n. Это позволяет ей хорошо масштабироваться при больших объемах данных.

Сортировка слиянием обеспечивает стабильную сортировку, что означает, что элементы с одинаковыми значениями сохраняют относительный порядок после сортировки.

Однако сортировка слиянием требует дополнительной памяти для временного массива при слиянии отсортированных половин. В худшем случае требуется дополнительное O(n) памяти. Поэтому, если доступ к дополнительной памяти ограничен, это может быть недостатком алгоритма.
'''
    return pyperclip.copy(s)


def n21():
    s=r'''
Двоичное дерево можно реализовать в виде связанных объектов, где каждый узел представляет собой объект, содержащий значение и ссылки на его левого и правого потомков. Вот пример реализации двоичного дерева в виде связанных объектов на языке Python:

```python
class BinaryTreeNode:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None
```

Для обхода двоичного дерева существуют различные реализации рекурсивного алгоритма. Вот несколько примеров:

1. Рекурсивный обход в прямом порядке (Preorder traversal):
   - Посетить текущий узел.
   - Рекурсивно обойти левое поддерево.
   - Рекурсивно обойти правое поддерево.

```python
def preorder_traversal(node):
    if node is not None:
        print(node.value)  # Посетить текущий узел
        preorder_traversal(node.left)  # Рекурсивно обойти левое поддерево
        preorder_traversal(node.right)  # Рекурсивно обойти правое поддерево
```

2. Рекурсивный обход в симметричном порядке (Inorder traversal):
   - Рекурсивно обойти левое поддерево.
   - Посетить текущий узел.
   - Рекурсивно обойти правое поддерево.

```python
def inorder_traversal(node):
    if node is not None:
        inorder_traversal(node.left)  # Рекурсивно обойти левое поддерево
        print(node.value)  # Посетить текущий узел
        inorder_traversal(node.right)  # Рекурсивно обойти правое поддерево
```

3. Рекурсивный обход в обратном порядке (Postorder traversal):
   - Рекурсивно обойти левое поддерево.
   - Рекурсивно обойти правое поддерево.
   - Посетить текущий узел.

```python
def postorder_traversal(node):
    if node is not None:
        postorder_traversal(node.left)  # Рекурсивно обойти левое поддерево
        postorder_traversal(node.right)  # Рекурсивно обойти правое поддерево
        print(node.value)  # Посетить текущий узел
```

Это примеры рекурсивной реализации обхода двоичных деревьев, где каждая функция принимает корень дерева в качестве параметра и выполняет необходимые действия для каждого узла. Вы можете вызывать эти функции, передавая им корневой узел вашего двоичного дерева.
'''
    return pyperclip.copy(s)



def n22():
    s=r'''
Двоичное дерево поиска (Binary Search Tree, BST) - это структура данных, которая обеспечивает эффективный поиск, вставку и удаление элементов. Основная идея состоит в том, что для каждого узла значения в левом поддереве меньше значения в узле, а значения в правом поддереве больше значения в узле. Это позволяет быстро находить элементы, сравнивая их значения с значениями узлов и двигаясь в соответствующем направлении.

Принципы реализации двоичного дерева поиска:
1. Каждый узел содержит значение и ссылки на его левого и правого потомков (другие узлы).
2. Значения в левом поддереве меньше значения текущего узла, а значения в правом поддереве больше значения текущего узла.
3. Все значения в дереве должны быть уникальными (в зависимости от конкретной реализации это может быть необязательным требованием).

Основные операции в двоичном дереве поиска:
1. Поиск элемента:
   - Начиная с корня, сравниваем значение искомого элемента с значением текущего узла.
   - Если значения совпадают, элемент найден. Если значение искомого элемента меньше значения текущего узла, переходим к левому поддереву. Если значение искомого элемента больше значения текущего узла, переходим к правому поддереву.
   - Продолжаем этот процесс до тех пор, пока не найдем искомый элемент или не достигнем конца дерева (узел становится None).

2. Вставка элемента:
   - Начиная с корня, сравниваем значение вставляемого элемента с значением текущего узла.
   - Если значение меньше значения текущего узла и у текущего узла есть левый потомок, переходим к левому поддереву и повторяем процесс.
   - Если значение больше значения текущего узла и у текущего узла есть правый потомок, переходим к правому поддереву и повторяем процесс.
   - Когда мы достигаем узла, у которого нет подходящего потомка, создаем новый узел с вставляемым значением и делаем его левым или правым потомком, в зависимости от значения.

3. Удаление элемента:
   - Найдите элемент, который нужно удалить, следуя процессу поиска.
   - Если у удаляемого элемента нет потомков, просто удаляем его, изменив ссылку на него у его родительского узла на None

.
   - Если у удаляемого элемента есть только один потомок, просто перенаправляем ссылку от родительского узла на этого потомка.
   - Если у удаляемого элемента есть оба потомка, есть несколько подходов к удалению, включая замену удаляемого элемента его преемником (следующим по значению элементом в дереве) или его предшественником (предыдущим по значению элементом в дереве).

Логика реализации операций в двоичном дереве поиска зависит от конкретной реализации и используемого языка программирования, но принципы остаются теми же. Операции поиска, вставки и удаления требуют рекурсивного или итеративного обхода дерева с использованием сравнения значений.
'''
    return pyperclip.copy(s)



def n23():
    s=r'''
Двоичная куча (Binary Heap) - это структура данных, представляющая собой полное двоичное дерево, в котором каждый узел имеет значение, большее или равное значению его потомков. Это означает, что на вершине кучи (корне) находится наименьший элемент (мин-куча) или наибольший элемент (макс-куча).

Принципы реализации двоичной кучи:
1. Двоичная куча обычно реализуется в виде массива. Потому что при полном двоичном дереве можно легко вычислить индексы потомков и родителей элемента, используя арифметику индексов массива.
2. В мин-куче каждый узел имеет значение, меньшее или равное значению его потомков, в то время как в макс-куче каждый узел имеет значение, большее или равное значению его потомков.
3. Все уровни, кроме, возможно, последнего уровня заполняются слева направо.

Логика реализации основных операций в двоичной куче:
1. Вставка элемента:
   - Новый элемент вставляется в первое свободное место в куче (обычно это следующий элемент в массиве).
   - Затем он сравнивается с его родительским элементом и, если необходимо, происходит перестановка, чтобы сохранить свойство кучи.
   - Этот процесс повторяется, пока новый элемент не будет находиться в правильной позиции в куче.

2. Удаление минимального (максимального) элемента:
   - Корень кучи содержит минимальный (максимальный) элемент.
   - При удалении минимального (максимального) элемента, он заменяется последним элементом кучи.
   - Затем происходит процесс "просеивания вниз", где элемент сравнивается со своими потомками, и, если необходимо, происходит перестановка, чтобы сохранить свойство кучи.
   - Этот процесс повторяется, пока удаленный элемент не будет находиться в правильной позиции в куче.

3. Доступ к минимальному (максимальному) элементу:
   - Корень кучи содержит минимальный (максимальный) элемент, поэтому доступ к нему происходит непосредственно из корня.

4. Построение кучи:
   - Можно построить кучу из неупорядоченного массива элементов.
   - Процесс построения нач

инается с последнего уровня и движется вверх по дереву.
   - Каждый элемент просеивается вниз, чтобы быть в правильной позиции для своего поддерева.
   - Этот процесс повторяется для каждого элемента, пока не будет построена корректная куча.

Операции в двоичной куче выполняются с использованием сравнения значений элементов и перестановок элементов в массиве для обеспечения правильного порядка элементов. Сложность операций в двоичной куче зависит от высоты дерева и составляет O(log n), где n - количество элементов в куче.
'''
    return pyperclip.copy(s)



def n24():
    s=r'''
Абстрактный тип данных (АТД) - ассоциативный массив, также известный как словарь или хеш-таблица, представляет собой структуру данных, которая хранит пары ключ-значение, где каждый ключ уникален и используется для доступа к соответствующему значению. Основная идея состоит в том, чтобы эффективно находить значение по ключу без необходимости перебора всех элементов.

Принципы реализации ассоциативного массива на основе хеш-таблиц и хеш-функций:
1. Хеш-таблица: Это массив, где каждый элемент называется ячейкой или корзиной. Количество ячеек в хеш-таблице обычно больше, чем количество ключей, чтобы уменьшить вероятность коллизий (когда разным ключам соответствует одна и та же ячейка).
2. Хеш-функция: Это функция, которая принимает ключ и вычисляет целочисленное значение (хеш-код). Хеш-функция должна быть быстрой и равномерно распределять ключи по ячейкам хеш-таблицы, чтобы минимизировать количество коллизий.
3. Хранение значений: Значения связываются с соответствующими ключами в хеш-таблице. Когда происходит вставка, ключ пропускается через хеш-функцию, чтобы определить индекс ячейки, в которой будет храниться значение.
4. Разрешение коллизий: Коллизии возникают, когда разным ключам соответствует один и тот же индекс ячейки. Существуют различные методы разрешения коллизий, такие как метод цепочек (в каждой ячейке хранится связанный список ключей и значений), метод открытой адресации (попытка найти другую доступную ячейку) и другие.

Основная идея при работе с ассоциативным массивом на основе хеш-таблицы и хеш-функций заключается в использовании хеш-кода ключа для быстрого поиска соответствующего значения. При вставке, обновлении или удалении элемента ключ пропускается через хеш-функцию для определения индекса ячейки, где будет храниться значение. При поиске значения по ключу процесс повторяется, и значение возвращается из соответствующей ячейки.

Эффективность ассоциативного массива на основе хеш-таблиц зависит от качества хеш-функции и

 уровня коллизий. Хорошо спроектированная хеш-функция и эффективное разрешение коллизий позволяют достичь почти константного времени выполнения операций вставки, поиска и удаления, в среднем O(1). Однако, в худшем случае (когда все ключи попадают в одну ячейку), время выполнения может быть O(n), где n - количество элементов в хеш-таблице.
'''
    return pyperclip.copy(s)



def n25():
    s=r'''
Общая схема построения хэш-функции включает несколько шагов:

1. Инициализация: Выбирается начальное значение хэша, которое может быть некоторым заданным константным числом.

2. Цикл обработки: Ключ разбивается на отдельные части (например, байты или биты), и каждая часть обрабатывается в цикле. В каждой итерации цикла выполняется комбинация текущего значения хэша с текущей частью ключа.

3. Финализация: После обработки всех частей ключа выполняются завершающие операции для получения окончательного значения хэша. В этом шаге могут применяться дополнительные операции, такие как побитовые сдвиги, применение масок и пр.

Хэш-функция multiply-add-and-divide (умножение-сложение-деление) является одним из примеров хэш-функций, которые могут использоваться в этой схеме. Принцип работы хэш-функции multiply-add-and-divide следующий:

1. Инициализация: Начальное значение хэша выбирается в качестве исходного значения.

2. Цикл обработки: Каждая часть ключа умножается на некоторую константу, затем к результату прибавляется текущее значение хэша. Это создает новое значение хэша для каждой части ключа.

3. Финализация: После обработки всех частей ключа выполняется деление полученного значения хэша на размер хэш-таблицы, чтобы привести значение в нужный диапазон индексов ячеек хэш-таблицы.

Преимуществом хэш-функции multiply-add-and-divide является ее простота и высокая производительность. Она обеспечивает хорошее равномерное распределение значений хэша и эффективно разрешает коллизии. Однако, эта хэш-функция не является универсальной и может показывать некоторую зависимость от особенностей данных, поэтому в некоторых случаях может потребоваться выбрать другую хэш-функцию для оптимальной производительности.
'''
    return pyperclip.copy(s)



def n26():
    s=r'''
Полиномиальная хэш-функция - это тип хэш-функции, которая использует полиномиальную комбинацию значений ключа для вычисления хэш-кода. Принцип работы полиномиальной хэш-функции заключается в следующем:

1. Каждый символ ключа (например, буква, цифра или байт) рассматривается как коэффициент в полиноме.
2. Каждый символ умножается на степень основания полинома, которое обычно является простым числом.
3. Полученные произведения складываются вместе, чтобы получить хэш-код ключа.

Таким образом, полиномиальная хэш-функция создает уникальный хэш-код для каждого ключа на основе его символов и их положения в ключе.

Эффективная реализация полиномиальной хэш-функции включает несколько аспектов:

1. Выбор основания полинома: Основание полинома должно быть простым числом, предпочтительно близким к размеру используемого алфавита (например, количество возможных символов). Это помогает распределить хэш-коды равномерно.
2. Избегайте переполнения: При вычислении полиномиального значения для каждого символа следует использовать арифметику с большой точностью, чтобы избежать переполнения и потери информации.
3. Масштабирование хэш-кода: Полученный хэш-код может быть слишком большим для использования в конкретной хэш-таблице. Поэтому может потребоваться применить операцию модуля, чтобы ограничить хэш-код в нужном диапазоне.

Специфика применения полиномиальной хэш-функции включает следующее:

1. Хэш-таблицы: Полиномиальная хэш-функция часто используется в хэш-таблицах для быстрого поиска и доступа к значениям по ключу.
2. Цифровые отпечатки: Полиномиальные хэш-функции также могут быть применены для создания уникальных идентификаторов (хэшей) для цифровых данных, таких как строки, файлы или блоки данных. Это используется в цифровых отпечатках, проверке целостности данных и других алгоритмах.

Основными преимуществами полиномиальных хэш-

функций являются их простота, хорошее равномерное распределение хэш-кодов и эффективность в большинстве случаев. Однако, при неправильном выборе основания полинома или неоптимальной реализации они могут страдать от коллизий и плохой производительности, особенно при работе с большими объемами данных. Поэтому важно тщательно выбирать параметры полиномиальной хэш-функции в зависимости от конкретных требований и характеристик данных.
'''
    return pyperclip.copy(s)



def n27():
    s=r'''
При использовании хэш-таблицы возникает возможность коллизий, когда два или более ключа хэшируются в одну и ту же ячейку или слот хэш-таблицы. Для разрешения коллизий существуют различные методы. Некоторые из них включают:

1. Открытое адресование (Open Addressing): При коллизии новый элемент помещается в следующую свободную ячейку хэш-таблицы. Это может быть реализовано различными способами, такими как линейное пробирование (Linear Probing), квадратичное пробирование (Quadratic Probing) или двойное хэширование (Double Hashing).

2. Цепочки (Chaining): Каждая ячейка хэш-таблицы содержит связанный список или другую структуру данных, в которой хранятся все элементы, которые хэшируются в эту ячейку. При коллизии новый элемент добавляется в связанный список в соответствующей ячейке.

3. Коэффициент загрузки (Load Factor) и перехэширование (Rehashing): При достижении определенного коэффициента загрузки хэш-таблицы (например, определенного числа заполненных ячеек) может быть выполнено перехэширование. При перехэшировании создается новая хэш-таблица с большей емкостью, и все элементы перераспределяются на основе новых хэш-функций.

4. Совершенное хэширование (Perfect Hashing): Это метод, который гарантирует отсутствие коллизий для заданного набора ключей. Он требует предварительного анализа ключей для построения оптимальной хэш-функции.

5. Коэффициенты проб (Probing Constants): При использовании метода открытого адресования можно изменять значения коэффициентов пробирования (например, при линейном пробировании) для более равномерного распределения элементов и уменьшения коллизий.

Выбор метода разрешения коллизий зависит от характеристик данных, требований к производительности, ожидаемого объема данных и ограничений реализации. Каждый метод имеет свои преимущества и недостатки, и выбор оптимального метода является важной задачей при проектировании хэш-таблицы.
'''
    return pyperclip.copy(s)


import datetime
import logging
import re
import tarfile
import typing
import urllib.parse

from functools import partial
from pathlib import Path

import license_expression

from pycargoebuild import __version__
from pycargoebuild.cargo import Crate, PackageMetadata, get_package_metadata
from pycargoebuild.format import format_license_var
from pycargoebuild.license import spdx_to_ebuild


EBUILD_TEMPLATE_START = """\
# Copyright {year} Gentoo Authors
# Distributed under the terms of the GNU General Public License v2

# Autogenerated by pycargoebuild {prog_version}

EAPI=8

CRATES="{crates}"

inherit cargo

DESCRIPTION="{description}"
HOMEPAGE="{homepage}"
SRC_URI="
\t${{CARGO_CRATE_URIS}}
"

LICENSE="{pkg_license}"
"""

EBUILD_TEMPLATE_CRATE_LICENSE = """\
# Dependent crate licenses
LICENSE+="{crate_licenses}"
"""

EBUILD_TEMPLATE_END = """\
SLOT="0"
KEYWORDS="~amd64"
"""


def get_CRATES(crates: typing.Iterable[Crate]) -> str:
    """
    Return the value of CRATES for the given crate list
    """
    if not crates:
        return ""
    return ("\n" +
            "\n".join(sorted(f"\t{c.crate_entry}" for c in crates)) +
            "\n")


def get_package_LICENSE(pkg_meta: PackageMetadata) -> str:
    """
    Get the value of package's LICENSE string
    """

    spdx = license_expression.get_spdx_licensing()
    if pkg_meta.license is not None:
        parsed_pkg_license = spdx.parse(pkg_meta.license,
                                        strict=True)
        return format_license_var(spdx_to_ebuild(parsed_pkg_license),
                                  prefix='LICENSE="')
    return ""


def get_license_from_crate(path: Path) -> typing.Optional[str]:
    """
    Read the metadata from specified crate and return its license string
    """

    assert path.name.endswith(".crate")
    with tarfile.open(path, "r:gz") as crate:
        tarf = crate.extractfile(f"{path.name[:-6]}/Cargo.toml")
        if tarf is None:
            raise RuntimeError(f"Cargo.toml not found in {path}")
        with tarf:
            # tarfile.ExFileObject() is IO[bytes] while tomli/tomllib
            # expects BinaryIO -- but it actually is compatible
            # https://github.com/hukkin/tomli/issues/214
            crate_metadata = get_package_metadata(tarf)  # type: ignore
            if crate_metadata.license_file is not None:
                logging.warning(
                    f"Crate {path.name} uses license-file="
                    f"{crate_metadata.license_file!r}, please inspect "
                    "the license manually and add it *separately* from crate "
                    "licenses")
            elif crate_metadata.license is None:
                raise RuntimeError(
                    f"Crate {path.name} does not specify a license!")
            return crate_metadata.license


def get_crate_LICENSE(crate_files: typing.Iterable[Path]) -> str:
    """
    Get the value of LICENSE string for crates
    """

    spdx = license_expression.get_spdx_licensing()
    crate_licenses = set(map(get_license_from_crate, crate_files))
    crate_licenses.discard(None)

    # combine crate licenses and simplify the result
    combined_license = " AND ".join(f"( {x} )" for x in crate_licenses)
    parsed_license = spdx.parse(combined_license, strict=True)
    if parsed_license is None:
        return ""
    final_license = parsed_license.simplify()
    crate_licenses_str = format_license_var(spdx_to_ebuild(final_license),
                                            prefix='LICENSE+=" ')
    # if it's not a multiline string, we need to prepend " "
    if not crate_licenses_str.startswith("\n"):
        crate_licenses_str = " " + crate_licenses_str
    return crate_licenses_str


DQUOTE_SPECIAL_RE = re.compile(r'([$`"\\])')
DQUOTE_SPECIAL_PLUS_WS_RE = re.compile(r'[$`"\\\s]')


def collapse_whitespace(value: str) -> str:
    """Collapse sequences of whitespace into a single space"""
    return " ".join(value.split())


def bash_dquote_escape(value: str) -> str:
    """Escape all characters with special meaning in bash double-quotes"""
    return DQUOTE_SPECIAL_RE.sub(r"\\\1", value)


def url_dquote_escape(value: str) -> str:
    """URL-encode whitespace and special chars to use in bash double-quotes"""
    return DQUOTE_SPECIAL_PLUS_WS_RE.sub(
        lambda x: urllib.parse.quote_plus(x.group(0)), value)


def get_ebuild(pkg_meta: PackageMetadata,
               crates: typing.Iterable[Crate],
               distdir: Path,
               *,
               crate_license: bool = True,
               ) -> str:
    """
    Get ebuild contents for passed contents of Cargo.toml and Cargo.lock.
    """

    template = EBUILD_TEMPLATE_START
    if crate_license:
        template += EBUILD_TEMPLATE_CRATE_LICENSE
    template += EBUILD_TEMPLATE_END

    crate_files = [distdir / crate.filename for crate in crates]
    return template.format(
        crates=get_CRATES(crates),
        crate_licenses=get_crate_LICENSE(crate_files),
        description=bash_dquote_escape(collapse_whitespace(
            pkg_meta.description or "")),
        homepage=url_dquote_escape(pkg_meta.homepage or ""),
        pkg_license=get_package_LICENSE(pkg_meta),
        prog_version=__version__,
        year=datetime.date.today().year)


CRATES_RE = re.compile(
    r"^(?P<start>CRATES=(?P<delim>['\"])).*?(?P=delim)$",
    re.DOTALL | re.MULTILINE)

CRATE_LICENSE_RE = re.compile(
    r"^(?P<start># Dependent crate licenses\n"
    r"LICENSE[+]=(?P<delim>['\"])).*?(?P=delim)$",
    re.DOTALL | re.MULTILINE)


class CountingSubst:
    def __init__(self, repl: typing.Callable[[], str]
                 ) -> None:
        self.count = 0
        self.repl = repl

    def __call__(self, match: re.Match) -> str:
        self.count += 1
        return match.group("start") + self.repl() + match.group("delim")

    def assert_count(self, desc: str, expected: int) -> None:
        if self.count != expected:
            raise RuntimeError(
                f"{desc} matched {self.count} times, {expected} expected")


def update_ebuild(ebuild: str,
                  pkg_meta: PackageMetadata,
                  crates: typing.Iterable[Crate],
                  distdir: Path,
                  *,
                  crate_license: bool = True,
                  ) -> str:
    """
    Update the CRATES and LICENSE in an existing ebuild
    """

    crate_files = [distdir / crate.filename for crate in crates]
    crates_repl = CountingSubst(partial(get_CRATES, crates))
    crate_license_repl = CountingSubst(partial(get_crate_LICENSE, crate_files))

    ebuild = CRATE_LICENSE_RE.sub(crate_license_repl,
                                  CRATES_RE.sub(crates_repl, ebuild))

    crates_repl.assert_count("CRATES=", 1)
    crate_license_repl.assert_count(
        "Crate LICENSE+= (with marker comment)", 1 if crate_license else 0)

    return ebuild

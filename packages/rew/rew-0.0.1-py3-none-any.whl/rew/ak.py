from typing import Any, Dict, Optional
from pydantic import BaseModel, Field
from jinja2 import Template

# How to create virtual DOM: google for examples how they are created (top several selections have instructions how thats done).
# https://svelte.dev/blog/virtual-dom-is-pure-overhead

# The issue is how to render dome component (component class name could be dom element - problem is that its an instance: the difference between instances is only the state, so in the template you can specify the component class name and its state).
#  The component should be rerendered on state change. Emit the event to rerender the component.
#  Component or event state methods should be attached easily.



class Compo(BaseModel):
    template: str
    name: str = "" # Name could be autogenerated from the class name 
    model: Optional[type[BaseModel]] = None
    state: Optional[Dict[str, Any]] = None

    def __init__(self, template: str, **kwargs):
        kwargs["name"] = kwargs.get("name") or self.__class__.__name__
        return super().__init__(template=template, **kwargs)

    def __call__(self, state: Optional[Dict[str, Any]] = None) -> "Compo":
        return Compo(
            name=self.name,
            template=self.template,
            model=self.model,
            state=state,
        )

    def __setattr__(self, key, value):
        if key == "state" and self.model:
            self.model.validate(value)
        return super().__setattr__(key, value)

    def render(self) -> str:
        return Template(self.template).render(self.state)

    def render_to_dom(self, dom: str) -> str:
        rendered_compo = Template(self.template).render(self.state)
        return dom.replace(f"<{self.name}/>", rendered_compo)

# class Profile(Compo):
#     name: str
#         

# class Skill(Compo):
#     skill_title: list[str]
#     profile: Profile
#     

# skill = Skill(profile=Profile(name="labas"), skill_title=["vienas", "du"])


# skill2 = Skill.parse_obj({'skill_title': ['vienas', 'du', "trys"], 'profile': {'name': 'namas'}})


## Lets create a Pydantic class.



## This should be Python package.


## Latest consideration: should JSON be typed using Pydantic.
# Lets create a single served page, which would have Pydantic installed.
# A way to print the state.
# Component: Each Pydantic type should have a place to attach and its template.
# Pydantic should be able to output as JSON.



# ## Consider writing a plugin for an app:
# # https://docs.pyscript.net/unstable/guides/custom-plugins.html
# ## Consider writing a virtual DOM library:
# # https://dev.to/ycmjason/building-a-simple-virtual-dom-from-scratch-3d05
# # https://medium.com/@deathmood/how-to-write-your-own-virtual-dom-ee74acc13060


# class Element:
#     innerHtml = "<div>{ name } and { surname }</div>"

#     def __init__(self, name):
#         pass

#     def write(self, value, append=False):
#         print(value)
#         return value


# # How to handle 

# # GET_LIST
# # GET
# # POST
# # PUT
# # DELETE

# # Pagination.

# # Rerendering.
#     # Template could be written as jinja tempalte, which would be initailly loaded and than updated on changes.

# # Whole tree has to be rendered.
#     # Template in Jinja?


# class dom_dict(dict):

#     # id is added on initialization
#     def __init__(self, template_id: str):
#         pass


# class dom_list(list):
#     """
#     Works like a simple list, except each element is rendered to template and stored in the container.
#     Also an API call can be made.
#     """

#     def __init__(self, container_id: str, template_id: str, url: str, jwt_token: str, *args, **kwargs):
#         self.container_id = container_id
#         self.template_id = template_id
#         result = super().__init__(*args, **kwargs)
#         return result

#     def _render(self, values: dict):
#         # Renders values into an element
#         return Element(self.template_id).innerHtml.format(values)

#     def append(self, value) -> None:
#         result = super().append(value)
#         Element(self.container_id).write(self._render(value), append=True)
#         return result

#     def insert(self, index, value) -> None:
#         result = super().insert(index, value)
#         return result

#     def pop(self, index: int, **kwargs):
#         result = super().pop(index, **kwargs)
#         return result

#     def remove(self, value) -> None:
#         result = super().remove(value)
#         return result


# my_list = dom_list("container-id", "template-id")
# my_list.append({"name": "hello-world", })

